<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最短路径 Shortest Path</title>
    <link href="/posts/45583/"/>
    <url>/posts/45583/</url>
    
    <content type="html"><![CDATA[<h2 id="最短路径-shortest-path">最短路径 Shortest Path</h2><p>加权有向图中每条路径都有值，其值是该路径上所有边的权值之和。最短路径（Shortest Path）问题就是指求出两个给定顶点间权值最小的路径。</p><h3 id="定义">定义</h3><p>两个顶点s和t之间的一条最短路径 是从s到t的一条有向简单路径，而且此路径具有以下的性质：不存在另一条这样的路径且有更小的权值。</p><h3 id="最短路径树shortest-path-trees-简称spt">最短路径树（Shortest-pathtrees， 简称SPT）</h3><p>给定一个图和一个指定的顶点s，则s的最短路径树是一个包含s以及由s可达的所有顶点的子图，它构成以s为根的一棵有向树，其中每条树路径都是图中的一条最短路径。最短路径树定义了从根到其它顶点的最短路径。</p><h3 id="分类">分类</h3><p>图中最短路径问题主要是以下三类:</p><ol type="1"><li>源点－汇点最短路径</li><li>单源最短路径</li><li>全源最短路径</li></ol><h3 id="算法">算法</h3><p>求图中最短路径的算法常用的有：</p><ol type="1"><li>Dijkstra算法</li><li>Floyd-Warshall算法</li><li>Bellman-Ford算法</li></ol><p>###　基本操作</p><h4 id="边松弛edge-relaxation">边松弛（edge relaxation）</h4><p>检查一条给定的边，是否可以通过该边，对到其所指顶点的最短路径进行更新。</p><p>不妨设有条边<code>e=(u,v)</code>，它的长度是<code>e.dist</code>，<code>d[i]</code>表示源点到顶点i的最短距离，则松弛操作如下：<code>if (d[v] &gt; d[u] + e.dist) d[v] = d[u] + e.dist</code>上式的意思就是：如果从源点到u的最短距离加上u到v的长度小于当前源点到v的最短距离，那么更新源点到v的最短距离。边松弛体现在Dijkstra算法和Bellman-Ford算法中</p><h4 id="路径松弛path-relaxation">路径松弛（path relaxation）</h4><p>检查一个给定顶点，是否可以使得连接另外两个给定顶点的最短路径进行更新。</p><p>不妨设现在有一个顶点x，还有另外两个顶点s和t。考虑能否通过x，使得s到t的最短距离变的更小，能的话，就进行路径松弛：<code>if (d[s][t] &gt; d[s][x] + d[x][t]) d[s][t] = d[s][x] + d[x][t]</code>上式的意思是：如果s到x的最短距离加上x到t的最短距离小于s到t的最短距离，那么更新s到t的最短距离。路径松弛体现在Floyd-Warshall算法中。</p><h2 id="dijkstra算法">Dijkstra算法</h2><p>Dijkstra算法计算单源最短路径，它的基本思想：开始把源点放在SPT中，然后，每次增加一条边来构造SPT，所取的边总是可以给出从源点到尚未在SPT中的一个顶点的最短路径。也就是说，按照顶点与起始顶点的距离（通过SPT）为顺序来加入顶点。即：每次选不在SPT中距离源点最近的点加入SPT。</p><h3 id="具体步骤">具体步骤</h3><ol type="1"><li>初始化：顶点集S只包含源点，即S={v}，顶点集U包含除v外的其他顶点。</li><li>从U中选取一个顶点u，它是源点v到U中最短路径长度最小的顶点，然后把顶点u加入S中（此时求出了源点v到顶点u的最短路径长度）。</li><li>以顶点u为新考虑的中间点，修改顶点u的出边邻接点j的最短路径长度，此时源点v到顶点j的最短路径有两条，即一条经过顶点u，一条不经过顶点u。</li><li>重复步骤2和3，直到S包含所有的顶点即U为空。</li></ol><h3 id="基于堆的dijkstra算法代码">基于堆的Dijkstra算法代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> from, to, dist;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> d) : <span class="hljs-built_in">from</span>(u), <span class="hljs-built_in">to</span>(v), <span class="hljs-built_in">dist</span>(d) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HeapNode</span> &#123; <br>    <span class="hljs-type">int</span> d, u; <span class="hljs-comment">// d表示该点到源点的距离，u是该点的编号</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> HeapNode&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> d &gt; rhs.d; <br>    &#125; <span class="hljs-comment">// 小根堆</span><br>&#125;;<br>vector&lt;Edge&gt; edges; <span class="hljs-comment">// edges存所有的边的信息</span><br>vector&lt;<span class="hljs-type">int</span>&gt; G[MAXN]; <span class="hljs-comment">// G[i]是顶点i发出的所有边</span><br><span class="hljs-type">bool</span> done[MAXN]; <span class="hljs-comment">// 是否已经加入SPT</span><br><span class="hljs-type">int</span> d[MAXN]; <span class="hljs-comment">// 每个点到源点的最短路径</span><br><span class="hljs-type">int</span> p[MAXN]; <span class="hljs-comment">// 记录到顶点i的是哪条边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> V)</span> </span>&#123; <span class="hljs-comment">// 计算所有顶点到顶点s的最短路径</span><br>    priority_queue&lt;HeapNode&gt; Q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) d[i] = INF;<br>    d[s] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 顶点s做源点</span><br>    <span class="hljs-built_in">memset</span>(done, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(done));<br>    Q.<span class="hljs-built_in">push</span>((HeapNode)&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123; <br>        HeapNode x = Q.<span class="hljs-built_in">top</span>(); Q.pop;<br>        <span class="hljs-type">int</span> u = x.u; <span class="hljs-comment">// 把出队的队头元素的标号给u</span><br>        <span class="hljs-keyword">if</span> (done[u]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 已经在SPT中就跳过</span><br>        done[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记u在SPT中了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].<span class="hljs-built_in">size</span>(); ++i) &#123; <br>            Edge&amp; e = edges[G[u][i]];<br>            <span class="hljs-keyword">if</span> (d[e.to] &gt; d[u] + e.dist) &#123; <br>                d[e.to] = d[u] + e.dist;<br>                p[e.to] = G[u][i];<br>                Q.<span class="hljs-built_in">push</span>((HeapNode)&#123;d[e.to], e.to&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="注意">注意</h3><p>Dijkstra算法可以解决带有<strong>非负权值</strong>的<strong>单源最短路径</strong>问题，如果图中有负权值，则该算法不成立，因为它的前提是增加更多边时，路径的长度不会递减。</p><h3 id="分析">分析</h3><p>利用优先队列实现的Dijkstra算法的时间复杂度是<spanclass="math inline">\(O(ElogV)\)</span>，因为它是在一个规模最大是V的优先队列中进行V个插入，V个删除最小值，以及E个减少键值的操作。</p><h2 id="floyd-warshall算法">Floyd-Warshall算法</h2><p>Floyd-Warshall算法计算全源最短路径，它的本质是动态规划，用<code>d[i][j][k]</code>表示i到j的最短距离，而且该路径上的顶点的标号都小于等于k(除了源点和汇点)，那么下面的式子明显成立：<code>d[i][j][k] = min(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1])</code></p><p>i到j中间标号最大是k的路径肯定是这样得到的：</p><ol type="1"><li>i到j，而且中间标号最大是k-1的最短路径，或者</li><li>i到k，中间标号最大是k-1的最短路径加上了k到j，中间最大标号是k-1的最短路径。这两种情况里的小的就是要求的。</li></ol><p>这样就有了<span class="math inline">\(O(V^3)\)</span>的算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> d[MAXN][MAXN]; <span class="hljs-comment">// 距离矩阵</span><br><span class="hljs-type">int</span> p[MAXN][MAXN]; <span class="hljs-comment">// 路径数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FloydWarshall</span><span class="hljs-params">(<span class="hljs-type">int</span> V)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化距离矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) &#123;<br>                d[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 同一顶点的距离为0</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                d[i][j] = INF; <span class="hljs-comment">// 不直接相连的顶点的距离设为无穷大</span><br>            &#125;<br>            p[i][j] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化路径数组</span><br>        &#125;<br>    &#125;<br><br>     <span class="hljs-comment">// 根据边的信息更新距离矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        Edge&amp; e = edges[i];<br>        <span class="hljs-keyword">if</span> (d[e.from][e.to] &gt; e.dist) &#123;<br>            d[e.from][e.to] = e.dist;<br>            p[e.from][e.to] = e.from;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算最短路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; V; ++k) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (d[i][k] != INF &amp;&amp; d[k][j] != INF &amp;&amp; d[i][j] &gt; d[i][k] + d[k][j]) &#123;<br>                    d[i][j] = d[i][k] + d[k][j]; <span class="hljs-comment">// 更新最短路径</span><br>                    p[i][j] = p[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="bellman-ford算法">Bellman-Ford算法</h2><p>Bellman-Ford算法计算<strong>单源的最短路径</strong>。</p><h3 id="基本思路">基本思路</h3><p>为了计算一个从顶点s出发的最短路径，用<code>d[i]</code>表示源点s到i的最短路径，开始<code>d[s] = 0</code>，其它都是<strong>极大值</strong>，然后以任何顺序对每条边进行边松弛操作，完成V-1遍这样的操作，就可以得到各点到s的最短距离。</p><p>我们可以用一个FIFO队列来保存这些顶点，每一遍处理的时候只检查这些顶点发出的边，对于沿着一条发出边进行松弛时可能有效的所有顶点都放在一个队列中，每次从队列中取一个顶点，并沿着它的所有边进行松弛。如果其中任何一条边导致到达某个顶点的一条更短的路径，那么将该点放入队列中。</p><h3id="基于fifo队列的bellman-ford算法">基于FIFO队列的Bellman-Ford算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123; <br>    queue&lt;<span class="hljs-type">int</span>&gt; Q; <span class="hljs-comment">// FIFO队列</span><br>    <span class="hljs-built_in">memset</span>(inq, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(inq));<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) d[i] = INF;<br>    d[s] = <span class="hljs-number">0</span>;<br>    inq[s] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// inq[i] = true，表示顶点i在队列里</span><br>    Q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123; <br>        <span class="hljs-type">int</span> u = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br>        inq[u] = <span class="hljs-literal">false</span>; <span class="hljs-comment">//u出队了，就不在队列里了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            Edge&amp; e = edges[G[u][i]];<br>            <span class="hljs-keyword">if</span> (d[u] &lt; INF &amp;&amp; d[e.to] &gt; d[u] + e.dist) &#123;<br>                d[e.to] = d[u] + e.dist;<br>                p[e.to] = G[u][i];<br>                <span class="hljs-keyword">if</span> (!inq[e.to]) &#123; <span class="hljs-comment">// 如果e.to不在队列里才入队，否则，不用再入队 </span><br>                    Q.<span class="hljs-built_in">push</span>(e.to); <br>                    inq[e.to] = <span class="hljs-literal">true</span>;<br>                 <span class="hljs-keyword">if</span> (++cnt[e.to] &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>                &#125;<br>            &#125; <br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="负环">负环</h2><p>利用Bellman-Ford算法很容易来检查一个图是否存在负环。因为最多进行V-1遍所有边的松弛操作，所以V-1遍后看，是否有新的元素入队？有，就存在负环；否则，则没有。上述代码最后返回true就是无负环，返回false就是有负环。用FIFO队列不好判断哪些是一遍的操作，所以用了<code>cnt</code>数组，<code>cnt[i]</code>表示顶点i入队几次了，反正如果无负环，<code>cnt[i]</code>不会超过n，否则，最后必超过（可能是超过V-1遍操作后）。</p><p>Floyd_Warshall算法也能判断图中是否有负环，只要最后检查是否有d[i][i]是负的。上面程序最坏情况下运行时间仍和VE成正比，对于稠密图，运行时间可能不比Floyd好，对于稀疏图则最快可能快V倍。注意Floyd只能求所有的最短路径，不会因为你是求某点出发的最短路径而可以减少运行时间。实战中利用FIFO队列实现的Bellman-Ford算法效果相当好。</p><p>目前对于求有负环的最短路径是NP困难的。</p>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>data structure</tag>
      
      <tag>algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树 Minimum Spanning Tree</title>
    <link href="/posts/45419/"/>
    <url>/posts/45419/</url>
    
    <content type="html"><![CDATA[<h2 id="最小生成树-minimum-spanning-tree">最小生成树 Minimum SpanningTree</h2><p>加权无向图的最小生成树（Minimum SpanningTree，简称MST）是一棵生成树，其权（所有边的权值之和）不会大于其它任何生成树的权。</p><p>一个带权连通图G（假定每条边上的权值均大于零）可能有多棵生成树.每棵生成树中所有边上的权值之和可能不同。其中边上的权值之和最小的生成树称为图的最小生成树。</p><p>MST算法有很多，但其中最知名的是Prim算法和Kruskal算法</p><h2 id="prim算法">Prim算法</h2><h3 id="基本思路">基本思路</h3><p>从任何一个顶点开始作一棵单顶点MST，再为之增加V-1条边，每次增加的边都是将MST上的一个顶点和尚未在此MST上的一个顶点相连接的最小边。</p><p>假设G=(V，E)是一个具有n个顶点的带权连通图，T=(U，TE)是G的最小生成树，其中U是T的顶点集，TE是T的边集，则由G构造从起始点v出发的最小生成树T的步骤如下：</p><ol type="1"><li>初始化U={v}。以v到其他顶点的所有边为候选边。</li><li>重复以下步骤n-1次，使得其他n-1个顶点被加入到U中：<ol type="1"><li>从候选边中挑选<strong>权值最小</strong>的边加入TE（所有候选边一定是连接两个顶点集U和V-U的边），设该边在V-U中的顶点是k，将顶点k加入U中。</li><li>考察当前V-U中的所有顶点j，修改候选边：<strong>若(k，j)的权值小于原来和顶点j关联的候选边，则用(k，j)取代后者作为候选边</strong>。</li></ol></li></ol><p>寻找最小边在这里使用小根堆</p><h3 id="基于堆的prim算法代码">基于堆的Prim算法代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> from, to, cost;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w):<span class="hljs-built_in">from</span>(u), <span class="hljs-built_in">to</span>(v), <span class="hljs-built_in">cost</span>(w) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HeapNode</span> &#123;<br>    <span class="hljs-type">int</span> d, u; <span class="hljs-comment">// d表示点u到MST的距离</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> HeapNode&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> d &gt; rhs.d; <span class="hljs-comment">// 小根堆</span><br>    &#125;<br>&#125;;<br>vector&lt;Edge&gt; edges; <span class="hljs-comment">// edges存所有边</span><br>vector&lt;<span class="hljs-type">int</span>&gt; G[MAXN]; <span class="hljs-comment">// G[i]是顶点i发出的所有边</span><br><span class="hljs-type">bool</span> done[MAXN]; <span class="hljs-comment">// i是否已经加入了MST</span><br><span class="hljs-type">int</span> d[MAXN]; <span class="hljs-comment">// 每个点到MST的最小距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Prim</span><span class="hljs-params">()</span> </span>&#123;<br>    priority_queue&lt;HeapNode&gt; Q;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总权值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) d[i] = INF; <span class="hljs-comment">// V是图的节点数</span><br>    d[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从点0开始</span><br>    <span class="hljs-built_in">memset</span>(done, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(done));<br>    Q.<span class="hljs-built_in">push</span>((HeapNode)&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>        HeapNode x = Q.<span class="hljs-built_in">top</span>(); Q.pop;<br>        <span class="hljs-type">int</span> u = x.u; <span class="hljs-comment">// u为队头元素的序号</span><br>        <span class="hljs-keyword">if</span> (done[u]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 已经在MST中就跳过</span><br>        ans += x.d; <span class="hljs-comment">// 加上出队的队头元素到MST的距离</span><br>        done[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].size; ++i) &#123; <span class="hljs-comment">// 更新最小生成树的权值</span><br>            Edge&amp; e = edges[G[u][i]]; <span class="hljs-comment">// 顶点to能修改最小距离</span><br>            <span class="hljs-keyword">if</span> (d[e.to] &gt; e.cost) &#123;<br>                d[e.to] = e.cost;<br>                Q.<span class="hljs-built_in">push</span>((HeapNode)&#123;d[e.to], e.to&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意">注意</h4><p>本段代码用邻接表来存图，输入可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; ++i) &#123; <span class="hljs-comment">// E是边数 </span><br>    <span class="hljs-type">int</span> u, v, cost;<br>    cin &gt;&gt; u &gt;&gt; v &gt;&gt; cost;  <span class="hljs-comment">// 输入边的起点、终点和权值</span><br>    G[u].<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">// 存储边的索引</span><br>    edges.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(u, v, cost));<br>    G[v].<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">// 存储边的索引</span><br>    edges.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(v, u, cost));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析">分析</h3><p>Prim时间复杂度为<span class="math inline">\(O(VlogV +ElogV)\)</span>。在稀疏图的情况下，E的数量通常远小于<spanclass="math inline">\(V^2\)</span>，因此可以将时间复杂度近似为<spanclass="math inline">\(O(ElogV)\)</span>。而在稠密图的情况下，E的数量接近<spanclass="math inline">\(V^2\)</span>，时间复杂度会接近<spanclass="math inline">\(O(V^2logV)\)</span>。</p><h2 id="kruskal算法">Kruskal算法</h2><h3 id="基本思路-1">基本思路</h3><p>以边的长度（从小到大）为顺序来处理，若一条边与前面加入到MST中的边未形成环，则将这样的边加入到MST中，增加了V-1条边后停止。也就是说开始是一个森林，每个顶点就是一棵独立的树，然后逐渐把这些树合并（通过一条最小边），最后形成的一棵树就是MST。</p><p>假设G=(V，E)是一个具有n个顶点的带权连通图，T=(U，TE)是G的最小生成树，则构造最小生成树的步骤如下：</p><ol type="1"><li>置U的初值等于V（即包含有G中的全部顶点），TE的初值为空集（即图T中每一个顶点都构成一个分量）。</li><li>将图G中的边按权值从小到大的顺序依次选取：若选取的边未使生成树T形成回路，则加入TE；否则舍弃，直到TE中包含n-1条边为止。</li></ol><p>如果把一棵树看成一个集合，那么对于新加入的边，要判断它的两个顶点是否已经在同一个集合了？是的话就跳过，处理下一条边；不是的话就把这条边加入到MST，同时把该边两顶点所处的两个集合合并。这个实际就是不相交集合（DisjointSet）的并查(Union-Find)操作。</p><h3 id="kruskal算法代码">Kruskal算法代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <br>    <span class="hljs-type">int</span> u, v, cost; <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> edge&amp; e1, <span class="hljs-type">const</span> edge&amp; e2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> e1.cost &lt; e2.cost;<br>&#125;<br><br>edge es[MAX_E]; <span class="hljs-comment">// 存储边的信息</span><br><span class="hljs-type">int</span> par[MAX_V]; <span class="hljs-comment">// 存储父节点</span><br><br><span class="hljs-comment">// 初始化并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_union_find</span><span class="hljs-params">(<span class="hljs-type">int</span> V)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) &#123;<br>        par[i] = i; <span class="hljs-comment">// 初始时每个节点的父节点是自身</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查找根节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (par[x] == x) &#123;<br>        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// 根节点的父节点是自身</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> par[x] = <span class="hljs-built_in">find</span>(par[x]); <span class="hljs-comment">// 路径压缩，将x的父节点设为根节点，加速后续查找</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 合并集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    x = <span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 查找x的根节点</span><br>    y = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// 查找y的根节点</span><br>    <span class="hljs-keyword">if</span> (x != y) &#123;<br>        par[x] = y; <span class="hljs-comment">// 将x的根节点设为y，合并两个集合</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断两个节点是否属于同一个集合</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// 若两个节点的根节点相同，则属于同一个集合</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> V, <span class="hljs-type">int</span> E)</span> </span>&#123; <br>    <span class="hljs-built_in">sort</span>(es, es + E, cmp); <span class="hljs-comment">// 按权值从小到大排序</span><br>    <span class="hljs-built_in">init_union_find</span>(V); <span class="hljs-comment">// 并查集初始化 </span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; ++i) &#123; <br>        edge e = es[i];<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">same</span>(e.u, e.v)) &#123; <span class="hljs-comment">// u和v不属于一个集合</span><br>        <span class="hljs-built_in">unite</span>(e.u, e.v); <span class="hljs-comment">// 合并u和v集合的元素</span><br>        res += e.cost;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析-1">分析</h3><p>Kruskal算法的时间复杂度为<span class="math inline">\(O(ElogE +Eα(V))\)</span>。在稀疏图的情况下，E的数量通常远小于<spanclass="math inline">\(V^2\)</span>，因此可以将时间复杂度近似为<spanclass="math inline">\(O(ElogE)\)</span>。而在稠密图的情况下，E的数量接近<spanclass="math inline">\(V^2\)</span>，时间复杂度会接近<spanclass="math inline">\(O(Eα(V))\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>data structure</tag>
      
      <tag>algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人王国里的路径长度</title>
    <link href="/posts/36820/"/>
    <url>/posts/36820/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述">题目描述</h4><p>在一个机器人王国里，围绕首都分N层构建卫星城市。以首都为圆心，以路相连分出两个卫星城在第一个层，然后每个卫星城又有路相连分出两个卫星城在下一层，但每条路的长度不同。第N层的卫星城不再分出新的卫星城。现在人类只探知到所有直接相连的城市间的路程，你能计算某个卫星城到达首都的路程吗？</p><h4 id="输入">输入</h4><p>第一行为N，表示机器人王国里有N层卫星城，N最大为10。从第二行开始，共<spanclass="math inline">\(2^{N+1}-2\)</span>行，每行分别是城市的代号到其分出的卫星城的代号和它们间的路程。代号用若干个字母表示，直连路程最大为100。最后一行是某卫星城的代号。</p><h4 id="输出">输出</h4><p>根据最后一行的卫星城代号，求该卫星城到首都的路程。</p><h4 id="样例输入">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>A F 20<br>B D 100<br>G A 5<br>G B 10<br>A C 6<br>B E 30<br>D<br></code></pre></td></tr></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">110<br></code></pre></td></tr></table></figure><h4 id="题解">题解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">City</span> &#123;<br>    string parent;<br>    <span class="hljs-type">int</span> distance;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-type">int</span> num_cities = (<span class="hljs-number">1</span> &lt;&lt; (N + <span class="hljs-number">1</span>)) - <span class="hljs-number">2</span>;<br>    unordered_map&lt;string, City&gt; cities;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_cities; i++) &#123;<br>        string from, to;<br>        <span class="hljs-type">int</span> distance;<br>        cin &gt;&gt; from &gt;&gt; to &gt;&gt; distance;<br>        cities[to] = &#123;from, distance&#125;;<br>    &#125;<br><br>    string target;<br>    cin &gt;&gt; target;<br><br>    <span class="hljs-type">int</span> total_distance = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//反向追踪它的父键值，并累加它们的距离值，直到找不到目标键值为止</span><br>    <span class="hljs-keyword">while</span> (cities.<span class="hljs-built_in">find</span>(target) != cities.<span class="hljs-built_in">end</span>()) &#123;<br>        total_distance += cities[target].distance;<br>        target = cities[target].parent;<br>    &#125;<br><br>    cout &lt;&lt; total_distance &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>data structure</tag>
      
      <tag>tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Power of Robert Capa&#39;s The Falling Soldier</title>
    <link href="/posts/40417/"/>
    <url>/posts/40417/</url>
    
    <content type="html"><![CDATA[<p>Today, I would like to talk about one of the most famous andcontroversial war photographs ever taken: "The Falling Soldier" byRobert Capa.</p><figure><img src="the_falling_soldier.jpg"alt="The Falling Soldier - Robert Capa" /><figcaption aria-hidden="true">The Falling Soldier - RobertCapa</figcaption></figure><p>Robert Capa, born Endre Friedmann in 1913, was a Hungarian-bornAmerican photojournalist known for his courage and his motto: "If yourpictures aren't good enough, you're not close enough." He co-foundedMagnum Photos, the first cooperative agency for freelance photographers.During his career, he covered several wars including the Spanish CivilWar, World War II, and the First Indochina War. Tragically, he died in1954 when he stepped on a landmine in Vietnam.</p><p>"The Falling Soldier" is a black and white photograph taken on 1936,during the Spanish Civil War. It captures the exact moment a Republicansoldier is shot in the head and falls backward, seemingly lifeless. Thephotograph became a symbol of the Republican cause and the horrors ofwar.</p><p>"The Falling Soldier" is a powerful image that evokes various themes.The theme of death is prominent, as the photograph captures the instantof death, a rare and shocking occurrence in photography. It raisesethical questions about the role of photography in depicting death. Thetheme of war is also evident, as the image represents the brutality andviolence of war and how it affects ordinary people caught in itscrossfire. Finally, the theme of heroism is present, portraying thesoldier as a hero who sacrificed his life for his cause.</p><p>When I look at this photograph, I feel a mix of emotions. I feelsadness and anger, thinking about the unfairness of this soldier's deathand the many others who perished in war. I also feel amazed and curious,appreciating Capa's incredible ability to capture such a momentous eventwith his camera.</p><p>In conclusion, Robert Capa's "The Falling Soldier" is an iconicphotograph that has left an indelible mark on the history ofphotojournalism. It is a powerful reminder of the horrors of war and theprice paid by those who fight for their beliefs. The photograph'sauthenticity may remain a point of debate, but its impact on the worldcannot be denied. Thank you for listening.</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Why Students Should Be Encouraged To Lead A Healthy Lifestyle</title>
    <link href="/posts/16273/"/>
    <url>/posts/16273/</url>
    
    <content type="html"><![CDATA[<p>According to the World Health Organization, more than 80% of theworld’s adolescents are insufficiently physically active. This alarmingstatistic shows that many students neglect their health in pursuit ofacademic excellence or other goals. However, health is not somethingthat can be sacrificed or ignored. I believe that students should beencouraged to lead a healthy lifestyle by schools, families and society.While the physical benefits of doing so are widely recognized, I want toemphasize its positive effects on our mental health.</p><p>Health is the foundation of happiness. By engaging in regularexercise, eating a balanced diet, and getting sufficient sleep, one cannot only prevent illnesses and boost the immune system, but also lowerstress levels and anxiety. Moreover, a healthy lifestyle can enhancestudents’ academic performance, which is of utmost importance for usstudents. For instance, I used to sleep only 5 hours a day and rarelyexercise when I was in high school. Soon I suffered from a severeheadache and lost concentration on my studies. As a result, my gradesplummeted and this in turn made me more anxious and even harder to fallasleep. One day I decided to change the unhealthy lifestyle. I startedto go to bed earlier and keep jogging. It really worked! I felt moreenergetic and confident than ever before.</p><p>In conclusion, leading a healthy lifestyle is not only beneficial forstudents’ physical health, but also for their mental well-being andacademic performance. As far as I am concerned, at no time should weunderestimate the benefits of leading a healthy lifestyle.</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理复习</title>
    <link href="/posts/51544/"/>
    <url>/posts/51544/</url>
    
    <content type="html"><![CDATA[<blockquote><p><ahref="https://ivansnow02.github.io/assets/Physics.html">思维导图</a></p></blockquote><h2 id="运动和力">运动和力</h2><ul><li>角加速度: <span class="math inline">\(\beta = \frac{d \omega}{dt}=\frac{d^2 \theta}{d t^2}\)</span></li><li>切向加速度:<ul><li><span class="math inline">\(\vec{a_t}=\frac{dv}{dt}\vec{e_t}\)</span></li><li><spanclass="math inline">\(a_t=\frac{dv}{dt}=R\frac{d\omega}{dt}=R\beta\)</span></li></ul></li><li>法向加速度:<ul><li><span class="math inline">\(\vec{a_n}=\frac{dv^2}{R}\vec{e_n}\)</span></li><li><span class="math inline">\(a_n=\frac{v^2}{R}=\omega v=\omega ^2R\)</span></li></ul></li><li>牛顿第二定律: <spanclass="math inline">\(\vec{F_{合}}=m\vec{a}=\frac{d\vec{p}}{dt}\)</span></li></ul><h2 id="运动的守恒量和守恒定律">运动的守恒量和守恒定律</h2><ul><li>动量定理: <span class="math inline">\(I = \int _{t_1}^{t_2} \vec{F}dt = \vec {p_2}-\vec{p_1}\)</span></li><li>平均冲力: <span class="math inline">\(\bar{\vec{F}}=\frac{\int_{t_1}^{t_2} \vec{F}dt}{t_2-t_1}=\frac{m\vec{v_2}-m\vec{v_1}}{t_2-t_1}\)</span></li><li>角动量: <span class="math inline">\(\vec{L}=\vec{r}\times\vec{p}\)</span></li><li>力矩: <span class="math inline">\(\vec{M}=\vec{r}\times\vec{F}\)</span></li><li>质点（系）角动量定理: <span class="math inline">\(\vec{M}=\frac{d\vec{L}}{dt}\)</span></li><li>角动量守恒定律: <spanclass="math inline">\(\vec{L}=常量(\vec{M}=0)\)</span></li><li>功: <span class="math inline">\(A=\int_a^b \vec{F} \cdotd\vec{r}\)</span></li><li>质点系的动能定理: <span class="math inline">\(A_外+A_内=\DeltaE_k\)</span></li><li>质点系的功能原理: <span class="math inline">\(A_外+A_{非保内}=\DeltaE\)</span></li><li>机械能守恒定律（条件: <spanclass="math inline">\(A_外+A_{非保内}=0\)</span>）: <spanclass="math inline">\(E=E_k+E_p=常量\)</span></li></ul><h2 id="刚体的运动">刚体的运动</h2><ul><li>对定轴的力矩: <span class="math inline">\(M_Z=rF_\perpsin\varphi\)</span></li><li>定轴转动定律: <spanclass="math inline">\(M_Z=J\alpha=J\frac{d\omega}{dt}\)</span></li><li>转动惯量:<ul><li><span class="math inline">\(J=\sum\limits_{i} \Delta m_ir_i^2\)</span></li><li><span class="math inline">\(J=\int r^2 dm\)</span></li></ul></li><li>力矩的功: <span class="math inline">\(A=\int_{\theta_0}^\thetaMd\theta\)</span></li><li>刚体的转动动能: <spanclass="math inline">\(E_k=\frac{1}{2}J\omega^2\)</span></li><li>刚体的重力势能: <span class="math inline">\(E_p=mgh_c\)</span></li><li>定轴转动的机械能: <spanclass="math inline">\(E=E_k+E_p=\frac{1}{2}J\omega^2+mgh_c\)</span></li><li>绕定轴的角动量: <spanclass="math inline">\(L_Z=J\omega\)</span></li><li>角动量定理: <span class="math inline">\(\int_{t_1}^{t_2}M_Zdt=J\omega_2-J\omega_1\)</span></li><li>角动量守恒定律: <spanclass="math inline">\(M_Z=0,L_Z=J\omega=J\omega_0=常量\)</span></li></ul><h2 id="相对论基础">相对论基础</h2><ul><li>洛伦兹变换: <spanclass="math inline">\(\begin{cases}x&#39;=\frac{x-ut}{\sqrt{1-\frac{u^2}{c^2}}}\\y&#39;=y\\ z&#39;=z\\t&#39;=\frac{t-\frac{ux}{c^2}}{\sqrt{1-\frac{u^2}{c^2}}}\end{cases}\)</span></li><li>相对论速度变换关系: <spanclass="math inline">\(\begin{cases}v&#39;_x=\frac{v_x-u}{1-\frac{uv_x}{c^2}}\\v&#39;_y=\frac{v_y\sqrt{1-\frac{u^2}{c^2}}}{1-\frac{uv_x}{c^2}}\\v&#39;_z=\frac{v_z\sqrt{1-\frac{u^2}{c^2}}}{1-\frac{uv_x}{c^2}}\end{cases}\)</span></li><li>时间延缓（运动时大于固有时）: <spanclass="math inline">\(t=\frac{t_0}{\sqrt{1-\beta^2}}\)</span></li><li>长度收缩（运动长度小于固有长度）: <spanclass="math inline">\(l=l_0\sqrt{1-\beta^2}\)</span></li><li>质速关系: <spanclass="math inline">\(m=\frac{m_0}{\sqrt{1-\frac{v^2}{c^2}}}\)</span></li><li>相对论动量: <spanclass="math inline">\(\vec{p}=m\vec{v}=\frac{m_0\vec{v}}{\sqrt{1-(\frac{v}{c})^2}}\)</span></li><li>动力学方程: <spanclass="math inline">\(\vec{F}=\frac{d\vec{p}}{dt}=\frac{d(m\vec{v})}{dt}=\frac{d}{dt}(\frac{m_0\vec{v}}{\sqrt{1-(\frac{v}{c})^2}})\)</span></li><li>质量和能量的关系: <spanclass="math inline">\(E_0=m_0c^2,E=mc^2\)</span></li><li>动能: <spanclass="math inline">\(E_k=mc^2-m_0c^2=m_0c^2(\frac{1}{\sqrt{1-\frac{v^2}{c^2}}}-1)\)</span></li><li>动量和能量的关系: <spanclass="math inline">\(E^2=c^2p^2+E_0^2=c^2p^2+m_0^2c^4\)</span></li></ul><h2 id="机械振动">机械振动</h2><ul><li>表达式: <span class="math inline">\(x=Acos(\omegax+\varphi_0),\space\omega=\sqrt{\frac{k}{m}}\)</span></li><li>单摆: <spanclass="math inline">\(T=2\pi\sqrt{\frac{g}{l}}\)</span></li><li>复摆: <spanclass="math inline">\(T=2\pi\sqrt{\frac{J}{mgh}}\)</span></li><li>机械能守恒: <spanclass="math inline">\(E=\frac{1}{2}kA^2\)</span></li></ul><h2 id="机械波">机械波</h2><ul><li>角频率: <spanclass="math inline">\(\omega=2\pi\nu=\frac{2\pi}{T}\)</span></li><li>波速: <spanclass="math inline">\(u=\frac{\lambda}{T}=\nu\lambda\)</span></li><li>波函数建立方法:<ol type="1"><li>建立坐标系，写出已知点O的振动方程: <spanclass="math inline">\(y_O=Acos(\omega t+\varphi)\)</span></li><li>求出波线上任一点P的振动方程: <spanclass="math inline">\(y_P=Acos[\omega (t\pm\Deltat)+\varphi]\)</span></li><li>写出平面简谐波的波函数: <spanclass="math inline">\(y(x,t)=Acos[\omega(t\pm\frac{x}{u})+\varphi_0]\)</span></li></ol></li><li>波动表达式: <span class="math inline">\(y(x,t)=Acos(\omega t \pm\frac{2\pi}{\lambda}x+\varphi)\)</span></li><li>线元的动能: <span class="math inline">\(\DeltaE_k=\frac{1}{2}\rho_l\Deltax\omega^2A^2sin^2[\omega(t-\frac{x}{u})+\varphi]\)</span></li><li>线元的势能: <span class="math inline">\(\DeltaE_p=\frac{1}{2}\rho_l\Deltax\omega^2A^2sin^2[\omega(t-\frac{x}{u})+\varphi]\)</span></li><li>波的能量: <span class="math inline">\(\Delta E=\Delta E_k+\DeltaE_p=\rho_l\Deltax\omega^2A^2sin^2[\omega(t-\frac{x}{u})+\varphi]\)</span></li><li>平均能量密度: <spanclass="math inline">\(\bar{w}=\frac{1}{2}\rho\omega^2A^2\)</span></li><li>能流强度: <spanclass="math inline">\(\vec{I}=\frac{1}{2}\rho\omega^2A^2\vec{u}\)</span></li><li>波的干涉:<ul><li>P点的相位差: <spanclass="math inline">\(\Delta\varphi=\varphi_2-\varphi_1-2\pi(\frac{r_2-r_1}{\lambda})=\begin{cases}2k\pi &amp;A_{max}=A_1+A_2(加强)\\其它&amp;A_{min}&lt;A&lt;A_{max}\\(2k+1)\pi &amp;A_{min}=|A_1-A_2|(减弱)\end{cases}\ (k=0,\pm1,\pm2,\ldots)\)</span></li><li>同向相干波源(<span class="math inline">\(\varphi_2=\varphi_1,\\Delta\varphi=\frac{2\pi(r_1-r_2)}{\lambda}=\frac{2\pi}{\lambda}\delta\)</span>):<span class="math inline">\(\delta=r_1-r_2=\begin{cases} k\lambda&amp;合振幅最大\\(2k+1)\frac{\lambda}{2} &amp;合振幅最小 \end{cases}\(k=0,\pm1,\pm2,\ldots)\)</span></li></ul></li><li>驻波方程: <span class="math inline">\(y=(2A_0cos\frac{2\pix}{\lambda})cos(\omega t)\)</span><ul><li>波腹: <span class="math inline">\(x=k\frac{\lambda}{2}\quadk=0,\pm1,\ldots\)</span></li><li>波节: <span class="math inline">\(x=(2k+1)\frac{\lambda}{4}\quadk=0,\pm1,\ldots\)</span></li></ul></li><li>半波损失: 垂直疏到密</li></ul><h2 id="光学">光学</h2><ul><li>双缝干涉明暗条纹: <span class="math inline">\(\begin{cases} x=\pmk\frac{D\lambda}{d} &amp;(k=0,1,2,\ldots) \ 明纹 \\x=\pm(2k+1)\frac{D\lambda}{2d} &amp;(k=0,1,2,\ldots)\ 暗纹\end{cases}\)</span><ul><li>相邻明纹暗纹间距: <span class="math inline">\(\Deltax=\frac{D}{d}\lambda\)</span></li><li>光强: <spanclass="math inline">\(I=I_1+I_2+2\sqrt{I_1I_2}cos\Delta\varphi\quad\Delta\varphi = \frac{2\pi\delta}{\lambda}\)</span></li></ul></li><li>等倾干涉条纹: <spanclass="math inline">\(\delta=2d\sqrt{n^2-n_1^2sin^2i}+\frac{\lambda}{2}=\begin{cases}k\lambda &amp;k=1,2,3,\ldots \ 明纹\\(2k+1)\frac{\lambda}{2}&amp;k=0,1,2,\ldots \  暗纹\end{cases}\)</span><ul><li>增透膜: <span class="math inline">\(2nd=(2k+1)\frac{\lambda}{2}\quadk=0,1,2,\ldots\)</span></li></ul></li><li>等厚干涉条纹: <spanclass="math inline">\(\delta=2d+\frac{\lambda}{2}=\begin{cases} k\lambda&amp;k=1,2,3,\ldots \ 明纹\\(2k+1)\frac{\lambda}{2} &amp;k=0,1,2,\ldots\  暗纹\end{cases}\)</span><ul><li>相邻明纹/暗纹间距: <spanclass="math inline">\(l=\frac{\lambda}{2sin\theta}\approx\frac{\lambda}{2\theta}\)</span></li><li>牛顿环半径: <spanclass="math inline">\(r=\begin{cases}\sqrt{\frac{(2k-1)R\lambda}{2}}&amp;k=1,2,3,\ldots \ 明纹\\ \sqrt{kR\lambda} &amp;k=0,1,2,\ldots \ 暗纹\end{cases}\)</span></li></ul></li><li>单缝的夫琅禾费衍射:<ul><li>条纹: <span class="math inline">\(\delta=asin\theta=\begin{cases}\pm k\lambda &amp; 暗纹\\0 &amp;中央明纹\\\pm(2k+1)\frac{\lambda}{2}&amp; 明纹\end{cases}\quad k=1,2,3,\ldots\)</span></li><li>半角宽度: <span class="math inline">\(\theta_k\approxsin\theta_k=\begin{cases}\pm 2k \frac{\lambda}{2a}&amp; 暗纹\\\frac{\lambda}{a}&amp; 中央明纹的半角宽度\\\pm(2k+1)\frac{\lambda}{2a}&amp; 明纹\end{cases}\quadk=1,2,3,\ldots\)</span></li><li>半宽度: <span class="math inline">\(x=D\theta_k\)</span></li></ul></li><li>圆孔的夫琅禾费衍射:<ul><li>第一级暗环衍射角: <span class="math inline">\(\theta_1\approxsin\theta_1=0.61\frac{\lambda}{r}=1.22\frac{\lambda}{d}\)</span></li><li>艾里斑线半径: <spanclass="math inline">\(R=1.22\frac{\lambda}{d}f\)</span></li><li>分辨率: <spanclass="math inline">\(R=\frac{1}{\theta_R}=\frac{d}{1.22\lambda}\)</span><ul><li>显微镜: <span class="math inline">\(R=\frac{1}{\Deltay}=\frac{nsinu}{0.61\lambda}\)</span></li></ul></li></ul></li><li>光栅衍射:<ul><li>光栅方程: <span class="math inline">\((a+b)sin\theta=\pm k\lambda \明纹 \  (k=0,1,2,\ldots)\)</span></li><li>缺级: <span class="math inline">\(k=\frac{a+b}{a}k&#39;\quadk&#39;=\pm1,\pm2,\pm3,\ldots\)</span></li><li>最大级数: <spanclass="math inline">\(k_{max}=\frac{a+b}{\lambda}\)</span></li></ul></li><li>X射线的衍射:<ul><li>布拉格公式: <span class="math inline">\(2dsin\theta=k\lambda\quadk=1,2,3,\ldots\)</span></li></ul></li><li>偏振:<ul><li>马吕斯定律: <spanclass="math inline">\(I_2=I_1cos^2\alpha\)</span></li><li>布儒斯特定律(起偏角<spanclass="math inline">\(i_B\)</span>叫布儒斯特角): <spanclass="math inline">\(tan i_B=\frac{n_2}{n_1}\)</span></li><li>入射角等于布儒斯特角时: <spanclass="math inline">\(i_B+r=90^\circ\)</span>，反射光只有垂直于入射面的振动，折射光仍为部分偏振光</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构题目02</title>
    <link href="/posts/45666/"/>
    <url>/posts/45666/</url>
    
    <content type="html"><![CDATA[<h2 id="section">1</h2><h4 id="题目描述">题目描述</h4><p>给你若干个字符串，请编程输出每个字符串的子串个数。</p><h4 id="输入">输入</h4><p>若干个字符串，每个字符串占一行，字符串中不含空格，长度最大为1000。</p><h4 id="输出">输出</h4><p>对应每一行的字符串，输出该字符串子串的个数。</p><h4 id="样例输入">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">abc<br>apple<br>software<br></code></pre></td></tr></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">7<br>16<br>37<br></code></pre></td></tr></table></figure><h4 id="题解">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; s)&#123;<br>        cout &lt;&lt; s.<span class="hljs-built_in">length</span>() * (s.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-1">2</h2><h4 id="题目描述-1">题目描述</h4><p>给你一个目标串，请查找在给目标串中是否存在模式串，存在就输出第一个模式串在目标串中出现的位置。</p><h4 id="输入-1">输入</h4><p>占两行，第一行是目标串（长度小于1000），第二行为模式串（长度小于100）。</p><h4 id="输出-1">输出</h4><p>输出模式串在目标串中出现的位置，即模式串匹配到目标串时第一个字符在目标串的位置（注意从1开始描述字符开始位置），不能匹配时输出0</p><h4 id="样例输入-1">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">appleorange<br>orange<br></code></pre></td></tr></table></figure><h4 id="样例输出-1">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br></code></pre></td></tr></table></figure><h4 id="题解-1">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s, a;<br>    cin &gt;&gt; s &gt;&gt; a;<br>    cout &lt;&lt; s.<span class="hljs-built_in">find</span>(a) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-2">3</h2><h4 id="题目描述-2">题目描述</h4><p>在一个N行N列的方阵(或称N阶方阵)中，从左上角到右下角这一斜线上有N个数据元素，这个斜线称为方阵的主对角线。给你一个方阵，请求方阵主对角线上数据的和。</p><h4 id="输入-2">输入</h4><p>第一行是N（N&lt;100），表示下边是一个N阶方阵。接下来N行N列用空格间隔放置正整数（int型）。</p><h4 id="输出-2">输出</h4><p>N阶方阵主对角线上数据的和。</p><h4 id="样例输入-2">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br>1 2 3<br>1 2 3<br>1 2 3<br></code></pre></td></tr></table></figure><h4 id="样例输出-2">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br></code></pre></td></tr></table></figure><h4 id="题解-2">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, sum = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> a;<br>            cin &gt;&gt; a;<br>            <span class="hljs-keyword">if</span> (i == j)&#123;<br>                sum += a;<br>            &#125;<br>        &#125;<br>    cout &lt;&lt; sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-3">4</h2><h4 id="题目描述-3">题目描述</h4><p>给你一个N行N列的方格矩阵，从外圈按顺时针依次填写自然数，这会构成一个螺旋阵，你能编程实现吗？比如5行5列的情况如下：</p><p>1 2 3 4 5</p><p>16 17 18 19 6</p><p>15 24 25 20 7</p><p>14 23 22 21 8</p><p>13 12 11 10 9</p><h4 id="输入-3">输入</h4><p>输入一个正整数数N（N&lt;100）。</p><h4 id="输出-3">输出</h4><p>输出符合题意的螺旋阵。</p><h4 id="样例输入-3">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><h4 id="样例输出-3">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9<br></code></pre></td></tr></table></figure><h4 id="题解-3">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, c = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (cnt &lt;= n * n) &#123;<br>        <span class="hljs-comment">//上方</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = c; i &lt; n - c; i++) &#123;<br>            a[c][i] = cnt++;<br>        &#125;<br>        <span class="hljs-comment">//右方</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = c + <span class="hljs-number">1</span>; i &lt; n - c; i++) &#123;<br>            a[i][n - c - <span class="hljs-number">1</span>] = cnt++;<br>        &#125;<br>        <span class="hljs-comment">//下方</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - c - <span class="hljs-number">2</span>; i &gt;= c; i--) &#123;<br>            a[n - c - <span class="hljs-number">1</span>][i] = cnt++;<br>        &#125;<br>        <span class="hljs-comment">//左方</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - c - <span class="hljs-number">2</span>; i &gt;= c + <span class="hljs-number">1</span>; i--) &#123;<br>            a[i][c] = cnt++;<br>        &#125;<br>        c++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            cout &lt;&lt; a[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-4">5</h2><h4 id="题目描述-4">题目描述</h4><p>有三根标为A,B,C的柱子，A柱子上从上到下按金字塔状依次叠放着n个半径从1厘米到n厘米的的圆盘，要把A上的所有盘子移动到柱子C上，中间可以临时放在B上，但每次移动每一根柱子上都不能出现大盘子在小盘子上方的情况，要求用最少的移动次数完成，请编程模拟每次移动。</p><h4 id="输入-4">输入</h4><p>占一行，为整数n（n&lt;64），表示盘子数。</p><h4 id="输出-4">输出</h4><p>把A上的所有盘子移动到柱子C上，每次只能移动一个盘子，输出移动每一次过程。每次移动占一行，第一个数表示第几步移动，第二个数是移动的盘子的半径，然后是从哪个柱子移动到哪个柱子。</p><h4 id="样例输入-4">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><h4 id="样例输出-4">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">1 1 A-&gt;B<br>2 2 A-&gt;C<br>3 1 B-&gt;C<br></code></pre></td></tr></table></figure><h4 id="题解-4">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hanoi</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %c-&gt;%c\n&quot;</span>,cnt++,n,x,z);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">Hanoi</span>(n - <span class="hljs-number">1</span>, x, z, y);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %c-&gt;%c\n&quot;</span>,cnt++,n,x,z);<br>        <span class="hljs-built_in">Hanoi</span>(n - <span class="hljs-number">1</span>, y, x, z);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">Hanoi</span>(n, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-5">6</h2><h4 id="题目描述-5">题目描述</h4><p>已知一颗树的节点间关系，请编程实现该树的先根遍历。</p><h4 id="输入-5">输入</h4><p>若干行，每行描述了一组双亲节点和孩子节点的关系序偶对（每个节点用不同的大写字母表示，节点小于26个）。且数的度小于5。</p><h4 id="输出-5">输出</h4><p>该树的先根遍历序列，序列中每个字母用空格隔开。</p><h4 id="样例输入-5">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">B E<br>B F<br>A B<br>A C<br></code></pre></td></tr></table></figure><h4 id="样例输出-5">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">A B E F C<br></code></pre></td></tr></table></figure><h4 id="题解-5">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; sons;<br>    <span class="hljs-built_in">Node</span>()&#123;&#125;<br>&#125;node[<span class="hljs-number">26</span>];<br><span class="hljs-type">int</span> root = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">char</span>(root + <span class="hljs-string">&#x27;A&#x27;</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node[root].sons.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-built_in">preOrder</span>(node[root].sons[i]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> p, c;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; p &gt;&gt; c) &#123;<br>        <span class="hljs-keyword">if</span> (p == EOF || c == EOF) <span class="hljs-keyword">break</span>;<br>        node[p - <span class="hljs-string">&#x27;A&#x27;</span>].sons.<span class="hljs-built_in">push_back</span>(c - <span class="hljs-string">&#x27;A&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (root == c - <span class="hljs-string">&#x27;A&#x27;</span> || root == <span class="hljs-number">-1</span>) &#123;<br>            root = p - <span class="hljs-string">&#x27;A&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">preOrder</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-6">7</h2><h4 id="题目描述-6">题目描述</h4><p>已知一颗树的节点间关系，请编程实现该树的后根遍历序列。</p><h4 id="输入-6">输入</h4><p>若干行，每行描述了一组双亲节点和孩子节点的关系序偶对（每个节点用不同的大写字母表示，节点小于26个）。且数的度小于5。</p><h4 id="输出-6">输出</h4><p>该树的后根遍历序列，序列中每个字母用空格隔开。</p><h4 id="样例输入-6">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">B E<br>B F<br>A B<br>A C<br></code></pre></td></tr></table></figure><h4 id="样例输出-6">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">E F B C A<br></code></pre></td></tr></table></figure><h4 id="题解-6">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; sons;<br>    <span class="hljs-built_in">Node</span>()&#123;&#125;<br>&#125;node[<span class="hljs-number">26</span>];<br><span class="hljs-type">int</span> root = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node[root].sons.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-built_in">postOrder</span>(node[root].sons[i]);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">char</span>(root + <span class="hljs-string">&#x27;A&#x27;</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> p, c;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; p &gt;&gt; c) &#123;<br>        <span class="hljs-keyword">if</span> (p == EOF || c == EOF) <span class="hljs-keyword">break</span>;<br>        node[p - <span class="hljs-string">&#x27;A&#x27;</span>].sons.<span class="hljs-built_in">push_back</span>(c - <span class="hljs-string">&#x27;A&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (root == c - <span class="hljs-string">&#x27;A&#x27;</span> || root == <span class="hljs-number">-1</span>) &#123;<br>            root = p - <span class="hljs-string">&#x27;A&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">postOrder</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思政复习</title>
    <link href="/posts/56431/"/>
    <url>/posts/56431/</url>
    
    <content type="html"><![CDATA[<ul class="task-list"><li><inputtype="checkbox" />道德的（<em>相对独立性</em>）既表现为道德的历史继承性,也表现为道德对社会发展具有能动的反作用。</li><li><inputtype="checkbox" />（<em>奉献社会</em>）要求从业人员在工作岗位上兢兢业业地为社会和他人作贡献,是社会主义职业道德中最高层次的要求,体现了社会主义职业道德的最高目标指向。</li><li><inputtype="checkbox" />加强道德修养,提升个人品德,应借鉴历史上思想家们所提出的学思并重、（<em>省察克治、慎独自律、知行合一、积善成德</em>）等各种积极有效的方法,并结合当今社会发展的需要身体力行,不断提高自己的道德素质和精神境界。</li><li><inputtype="checkbox" />自觉把集体利益放在个人利益之上,在维护集体利益的前提下,实现个人的正当利益。这是已经具有较高社会主义道德觉悟的人能够达到的要求。</li><li><inputtype="checkbox" />（<em>国务院</em>）有权根据宪法和法律制定行政法规。</li><li><inputtype="checkbox" />推进全面依法治国,法治社会建设是（<em>基础工程</em>）。</li><li><inputtype="checkbox" />2020年11月,习近平在中央全面依法治国工作会议上的重要讲话中,用“（<em>十一个坚持</em>）”对全面依法治国进行了系统阐释、部署。</li><li><inputtype="checkbox" />有力的法治保障体系,是全面依法治国的（<em>重要依托</em>）。</li><li><inputtype="checkbox" />公正司法是全面依法治国的（<em>重点</em>）。</li><li><inputtype="checkbox" />习近平总书记指出:“对新时代的中国青年来说,热爱祖国是立身之本、成才之基。”作为实现中国梦的见证者和参与者,当代大学生应以（国家富强、民族振兴、人民幸福）为己任。</li></ul>]]></content>
    
    
    <categories>
      
      <category>trash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>trash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>习近平复习</title>
    <link href="/posts/49742/"/>
    <url>/posts/49742/</url>
    
    <content type="html"><![CDATA[<ul><li>中国特色社会主义的战略布局是（ <strong>四个全面</strong> ）</li><li>我国社会主要矛盾的变化<ul><li>没有改变我们对我国社会主义所处历史阶段的判断</li><li>我国仍处于并将长期处于社会主义初级阶段的基本国情没有变</li><li>我国是世界最大发展中国家的国际地位没有变</li></ul></li><li>坚持把马克思主义基本原理同（<strong>中国具体实际相结合、中华优秀传统文化</strong>）相结合，用马克思主义观察时代、把握时代、引领时代，继续发展当代中国马克思主义、21世纪马克思主义</li><li>社会主义政治发展的必然要求是坚持（ 党的领导、人民当家作主、依法治国）的有机统一</li><li>习近平新时代中国特色社会主义思想坚持以社会主义现代化建设进程中的实际问题、以我们正在做的事情为中心，着眼统揽（<strong>伟大斗争、伟大工程、伟大梦想</strong>），大智慧谋划大格局，大手笔续写大文章，是实践探索、经验总结、理论升华凝结而成的思想结晶</li><li>世界百年未有之大变局表现在哪些方面？<ul><li>当前国际格局和国际体系正在发生深刻调整；</li><li>全球治理体系正在发生深刻变革 ；</li><li>国际力量对比正在发生近代以来最具革命性的变化 ；</li><li>世界范围呈现出影响人类历史进程和趋向的重大态势</li></ul></li><li>2012年11月29日，习近平在参观《复兴之路》展览时首次提出中国梦，并引用三句诗诠释了近代以来中国人民寻梦、追梦、圆梦的历史进程。中华民族的明天，“（<strong>长风破浪会有时</strong> ）”</li><li>“两个一百年”的奋斗目标中第一个百年目标是（<strong>建成更高水平的小康社会</strong> ）</li><li>综合分析国际国内形势和我国发展条件，党的十九大提出我们要全面建成小康社会，实现第一个百年奋斗目标，然后再乘势而上开启（<strong>全面建设社会主义现代化国家</strong> ）新征程。</li><li>( <strong>党的十二大</strong>)首次把“小康”作为经济建设总的奋斗目标</li><li>习近平指出：“全面建设社会主义现代化国家、基本实现社会主义现代化，既是（<strong>社会主义初级阶段</strong>）我国发展的要求，也是我国社会主义从初级阶段向更高阶段迈进的要求</li><li>（ <strong>党的十九届五中全会</strong>）作出“全面建成小康社会胜利在望”的重要判断，将“全面建成小康社会”目标提升为“全面建设社会主义现代化国家”，确立全面建设社会主义现代化国家在“四个全面”战略布局中的引领地位</li><li>坚持和发展中国特色社会主义的总任务是<ul><li>实现社会主义现代化和中华民族伟大复兴</li><li>在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国</li><li>中国梦是中华民族伟大复兴的形象表达</li></ul></li><li>中国梦的科学内涵是<ul><li>国家富强</li><li>民族振兴</li><li>人民幸福</li></ul></li><li>2020年，“十三五”规划目标任务胜利完成，（<strong>决战脱贫攻坚取得全面胜利、全面建成小康社会取得决定性成就</strong>），我国经济实力、科技实力、综合国力和人民生活水平跃上新的大台阶</li><li>新时代坚持和发展中国特色社会主义的前进定力是什么？<ul><li>第一，坚持党的全面领导是坚持和发展中国特色社会主义的必由之路。</li><li>第二，中国特色社会主义是实现中华民族伟大复兴的必由之路。</li><li>第三，团结奋斗是中国人民创造历史伟业的必由之路。</li><li>第四，贯彻新发展理念是新时代我国发展壮大的必由之路。</li><li>第五，全面从严治党是党永葆生机活力、走好新的赶考之路的必由之路</li></ul></li><li>中国式现代化国家的重要特征是什么？<ul><li>第一，中国式现代化是人口规模巨大的现代化。</li><li>第二，中国式现代化是全体人民共同富裕的现代化。</li><li>第三，中国式现代化是物质文明和精神文明相协调的现代化。</li><li>第四，中国式现代化是人与自然和谐共生的现代化。</li><li>第五，中国式现代化是走和平发展道路的现代化。</li></ul></li><li>始终把群众作为智慧和力量的源泉，始终把（<strong>政治智慧的增长、政治素质的提升、群众基础的广泛</strong>）深深扎根于人民的创造性实践中</li><li>党依靠人民，推进（<strong>改革开放、社会主义现代化建设</strong>）走出一条中国特色社会主义道路。</li><li>以人民为中心是我们党（ <strong>立党为公、执政为民</strong>）的生动体现，是全心全意为人民服务的时代彰显。</li><li>不忘初心、牢记使命，说到底是为什么人、靠什么人的问题。以百姓心为心，与人民（<strong>同呼吸、共命运、心连心</strong>），是党的初心，也是党的恒心。</li><li>扎实推动共同富裕的重大举措<ul><li>第一，提高发展的平衡性、协调性、包容性。</li><li>第二，着力扩大中等收入群体规模。</li><li>第三，促进基本公共服务均等化。</li><li>第四， 加强对高收入的规范和调节。</li><li>第五，促进人民精神生活共同富裕。</li><li>第六，促进农民农村共同富裕。</li></ul></li><li>（ <strong>新发展格局</strong>）是根据我国发展阶段、环境、条件变化提出来的，是重塑我国国际合作和竞争新优势的战略抉择，是把握未来发展主动权的战略性布局和先手棋。</li><li>经济改革的方向是要让（ <strong>市场</strong>）在资源配置中发挥决定性作用</li><li>经济进入新常态后，伴随着经济增长速度的下降，推动（<strong>供给侧改革</strong> ）成为经济生活中的主旋律</li><li>建设彰显优势、协调联动的（ <strong>城乡区域</strong> ）发展体系</li><li>我国经济已由高速增长阶段转向（<strong>高质量发展阶段</strong>），正处在转变发展方式、优化经济结构、转换增长动力的攻关期。</li><li>我国经济发展处于（ <strong>增长速度换挡期、结构调整阵痛期、前期刺激政策消化期</strong>）阶段，我国发展进入新常态。</li><li>我国现代化经济体系的内容是什么？<ol type="1"><li>创新引领、协同发展的产业体系。</li><li>统一开放、竞争有序的市场体系。</li><li>体现效率、促进公平的收入分配体系。</li><li>彰显优势、协调联动的城乡区域发展体系。</li><li>资源节约、环境友好的绿色发展体系。</li><li>多元平衡、安全高效的全面开放体系。</li></ol></li><li>供给侧结构性改革的必要性是什么?<ol type="1"><li>适应把握引领经济发展新常态的重大创新。</li><li>适应国际金融危机发生后综合国力竞争新形势的主动选择。</li><li>推动我国经济实现高质量发展的必然要求。</li></ol></li><li>（ <strong>2013 年 9 月和 10 月</strong>），习近平先后提出共建“丝绸之路经济带”和“21世纪海上丝绸之路”的重大倡议。</li><li>（ <strong>引进来和走出去</strong>）是“一带一路”国际合作的重要内容，如同车之两轮、鸟之两翼。</li><li>全面深化改革的总目标是<ul><li>完善和发展中国特色社会主义制度</li><li>推进国家治理体系和治理能力现代化</li></ul></li><li>治理能力是运用国家制度管理国家各方面事务的能力，它包括（<strong>改革发展稳定、内政外交国防、治党治国治军</strong>）等各个方面各个领域的治理能力。</li><li>绿水青山就是金山银山，阐述了（<strong>经济发展、生态环境保护</strong>）的关系</li><li>要加快推进（ <strong>绿色发展、循环发展、低碳发展</strong>），开创美丽中国建设新局面。</li><li>党的二十大报告指出：“（<strong>尊重自然、顺应自然、保护自然</strong>），是全面建设社会主义现代化国家的内在要求。”</li><li>全面深化改革的重点是（<strong>经济体制改革</strong>）</li><li>全面建设社会主义国家的首要任务是（<strong>高质量发展</strong>）</li><li>社会主义民主不是超越阶级的民主</li><li>法治的保障作用（<strong>固根本、稳预期、利长远</strong>）</li><li>体现社会主义民主政治的本质和核心的是：<ul><li>保障人民依法参加国家和社会事务管理</li><li>国家法律制定必须体现人民意志</li><li>国家一切权利属于人民</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>trash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>trash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构题目01</title>
    <link href="/posts/53823/"/>
    <url>/posts/53823/</url>
    
    <content type="html"><![CDATA[<h2 id="section">1</h2><h4 id="题目描述">题目描述</h4><p>新年快到了，天勤准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。</p><h4 id="输入">输入</h4><p>第一行是测试数据的组数<span class="math inline">\(CN(Casenumber，1&lt;CN&lt;10000)\)</span>，接着有<spanclass="math inline">\(CN\)</span>行正整数<spanclass="math inline">\(N(1&lt;n&lt;32768)\)</span>，表示会员人数。</p><h4 id="输出">输出</h4><p>对于每一个<spanclass="math inline">\(N\)</span>，输出一行新朋友的人数，这样共有<spanclass="math inline">\(CN\)</span>行输出。</p><h4 id="样例输入">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br>25608<br>24027<br></code></pre></td></tr></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">7680<br>16016<br></code></pre></td></tr></table></figure><h4 id="题解">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eular</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> ( n % i == <span class="hljs-number">0</span>) &#123;<br>            n /= i;<br>            r *= i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>                r *= i;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) r *= n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> CN;<br>    cin &gt;&gt; CN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CN; i++) &#123;<br>        <span class="hljs-type">int</span> N; <br>        cin &gt;&gt; N;<br>        cout &lt;&lt; <span class="hljs-built_in">eular</span>(N) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-1">2</h2><h4 id="题目描述-1">题目描述</h4><p>给你一个正整数<spanclass="math inline">\(n\)</span>，请问有多少个比<spanclass="math inline">\(n\)</span>小的且与<spanclass="math inline">\(n\)</span>互质的正整数？两个整数互质的意思是，这两个整数没有比<spanclass="math inline">\(1\)</span>大的公约数。</p><h4 id="输入-1">输入</h4><p>输入包含多组测试数据。每组输入是一个正整数<spanclass="math inline">\(n(n \leq 1000000000)\)</span>。当<spanclass="math inline">\(n=0\)</span>时，输入结束。</p><h4 id="输出-1">输出</h4><p>对于每组输入，输出比<spanclass="math inline">\(n\)</span>小的且与<spanclass="math inline">\(n\)</span>互质的正整数个数。</p><h4 id="样例输入-1">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">7<br>12<br>0<br></code></pre></td></tr></table></figure><h4 id="样例输出-1">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br>4<br></code></pre></td></tr></table></figure><h4 id="题解-1">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eular</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> ( n % i == <span class="hljs-number">0</span>) &#123;<br>            n /= i;<br>            r *= i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>)&#123;<br>                n /= i;<br>                r *= i;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) r *= n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n)&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">eular</span>(n)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-2">3</h2><h4 id="题目描述-2">题目描述</h4><p><span class="math inline">\(n\)</span>个人围成一圈，按<spanclass="math inline">\(1\)</span>到<spanclass="math inline">\(n\)</span>的顺序编号。从第一个人开始报数（从<spanclass="math inline">\(1\)</span>到<spanclass="math inline">\(m\)</span>报数），凡报到<spanclass="math inline">\(m\)</span>的人退出圈子，问最后留下的是原来的第几号。</p><h4 id="输入-2">输入</h4><p>首先输入两个正整数<span class="math inline">\(n\)</span>和<spanclass="math inline">\(m\)</span>，<spanclass="math inline">\(n\)</span>表示<spanclass="math inline">\(n\)</span>个人围一个圈子<spanclass="math inline">\((n \geq 2)\)</span>，<spanclass="math inline">\(m\)</span>表示从<spanclass="math inline">\(1\)</span>报数到<spanclass="math inline">\(m\)</span>的人退出圈子<spanclass="math inline">\((1 \leq m)\)</span>。</p><h4 id="输出-2">输出</h4><p>最后剩下的人的编号。</p><h4 id="样例输入-2">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2 3<br></code></pre></td></tr></table></figure><h4 id="样例输出-2">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><h4 id="题解-2">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>list &lt;<span class="hljs-type">int</span>&gt; l;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        l.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doJ</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span>&#123;<br>    <span class="hljs-built_in">init</span>(n);<br>    list&lt;<span class="hljs-type">int</span>&gt; :: iterator it = l.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span>(l.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; m; j++)&#123;<br>            it ++;<br>            <span class="hljs-keyword">if</span>(it == l.<span class="hljs-built_in">end</span>())&#123;<br>                it = l.<span class="hljs-built_in">begin</span>();<br>            &#125;<br>        &#125;<br>        it = l.<span class="hljs-built_in">erase</span>(it);<br>        <span class="hljs-keyword">if</span>(it == l.<span class="hljs-built_in">end</span>())&#123;<br>            it = l.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">doJ</span>(n, m);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-3">4</h2><h4 id="题目描述-3">题目描述</h4><p>编写程序演示把一个<spanclass="math inline">\(10\)</span>进制整数转换为<spanclass="math inline">\(R\)</span>进制的转换结果。</p><h4 id="输入-3">输入</h4><p>正整数<span class="math inline">\(N\)</span>和<spanclass="math inline">\(R\)</span>，空格分隔 <spanclass="math inline">\(N\)</span>是输入的十进制数，<spanclass="math inline">\(R\)</span>需要转换的进制数，<spanclass="math inline">\(2 \leq R \leq 20\)</span></p><h4 id="输出-3">输出</h4><p>将<span class="math inline">\(10\)</span>进制整数转换为<spanclass="math inline">\(R\)</span>进制的转换结果，超过<spanclass="math inline">\(9\)</span>的数字符号显示为A、B、C……Z等字母。</p><h4 id="样例输入-3">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">10 16<br></code></pre></td></tr></table></figure><h4 id="样例输出-3">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">A<br></code></pre></td></tr></table></figure><h4 id="题解-3">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">string <span class="hljs-title">decToR</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    string ans;<br>    string digits = <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> m = n % r;<br>        ans = digits[m] + ans;<br>        n /= r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, r;<br>    cin &gt;&gt; n &gt;&gt; r;<br>    cout &lt;&lt; <span class="hljs-built_in">decToR</span>(n, r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-4">5</h2><h4 id="题目描述-4">题目描述</h4><p>输入两个整数的求和式，比如<code>1+2=</code>，输出求和式和对应结果。请编程实现。</p><h4 id="输入-4">输入</h4><p>一个求和式，形如<code>a+b=</code>。</p><h4 id="输出-4">输出</h4><p>求和式及对应结果。</p><h4 id="样例输入-4">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1+2=<br></code></pre></td></tr></table></figure><h4 id="样例输出-4">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1+2=3<br></code></pre></td></tr></table></figure><h4 id="题解-4">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stoD</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(s[i] != <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>        a = <span class="hljs-number">10</span> * a + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        i ++;<br>    &#125;<br>    i ++;<br>    <span class="hljs-keyword">while</span>(s[i] != <span class="hljs-string">&#x27;=&#x27;</span>)&#123;<br>        b = <span class="hljs-number">10</span> * b + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        i ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    cout &lt;&lt; s &lt;&lt; <span class="hljs-built_in">stoD</span>(s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-5">6</h2><h4 id="题目描述-5">题目描述</h4><p>波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式<code>2 + 3</code>的波兰表示法为<code>+ 2 3</code>。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如<code>(2 + 3) * 4</code>的波兰表示法为<code>* + 2 3 4</code>。本题求解波兰表达式的值，其中运算符包括<code>+</code><code>-</code> <code>*</code> <code>/</code>四个。</p><h4 id="输入-5">输入</h4><p>输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。</p><h4 id="输出-5">输出</h4><p>输出为一行，表达式的值(保留6位小数)。</p><h4 id="样例输入-5">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">* + 11.0 12.0 + 24.0 35.0<br></code></pre></td></tr></table></figure><h4 id="样例输出-5">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1357.000000<br></code></pre></td></tr></table></figure><h4 id="题解-5">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">operate</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-keyword">switch</span> (s[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">operate</span>() + <span class="hljs-built_in">operate</span>();<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">operate</span>() - <span class="hljs-built_in">operate</span>();<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">operate</span>() * <span class="hljs-built_in">operate</span>();<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">operate</span>() / <span class="hljs-built_in">operate</span>();<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">stold</span>(s);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>,<span class="hljs-built_in">operate</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-6">7</h2><h4 id="题目描述-6">题目描述</h4><p>上体育课的时候，老师已经把班级同学排成了两个队列，而且每个队列都是按照从底到高排好队，现在需要把两个队列合并，合并后需要保证还是从低到高排列。合并队列，你能编程实现吗？</p><h4 id="输入-6">输入</h4><p>第1行为<spanclass="math inline">\(n\)</span>，表示开始排成的每个队列的长度。第2、3行是代表从小到大的<spanclass="math inline">\(n\)</span>个整数，每行的整数间有一个空格间隔。</p><h4 id="输出-6">输出</h4><p>输出占一行，为从小到大的整数，每个整数间间隔一个空格。</p><h4 id="样例输入-6">样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br>1 3 5 8 15<br>2 3 4 6 9<br></code></pre></td></tr></table></figure><h4 id="样例输出-6">样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1 2 3 3 4 5 6 8 9 15<br></code></pre></td></tr></table></figure><h4 id="题解-6">题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>queue&lt;<span class="hljs-type">int</span>&gt; a,b;<br><span class="hljs-function">queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">merge</span><span class="hljs-params">(queue&lt;<span class="hljs-type">int</span>&gt; a,queue&lt;<span class="hljs-type">int</span>&gt; b)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-keyword">while</span> (!a.<span class="hljs-built_in">empty</span>() &amp;&amp; !b.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">front</span>() &lt; b.<span class="hljs-built_in">front</span>()) &#123;<br>            c.<span class="hljs-built_in">push</span>(a.<span class="hljs-built_in">front</span>());<br>            a.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            c.<span class="hljs-built_in">push</span>(b.<span class="hljs-built_in">front</span>());<br>            b.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!a.<span class="hljs-built_in">empty</span>()) &#123;<br>        c.<span class="hljs-built_in">push</span>(a.<span class="hljs-built_in">front</span>());<br>        a.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!b.<span class="hljs-built_in">empty</span>()) &#123;<br>        c.<span class="hljs-built_in">push</span>(b.<span class="hljs-built_in">front</span>());<br>        b.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        a.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        b.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; c = <span class="hljs-built_in">merge</span>(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++)&#123;<br>        cout &lt;&lt; c.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        c.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/posts/16574/"/>
    <url>/posts/16574/</url>
    
    <content type="html"><![CDATA[<blockquote><p>栈和队列可以说是最基本的数据结构了，它们都是在两端进行操作，其中栈在栈顶进行操作，被称为先进后出（LIFO），队列在队头和队尾进行操作，被称为先进先出（FIFO）</p></blockquote><img src="/posts/16574/image-20230530103359493.png" class=""><h2 id="栈">栈</h2><p>直接来看看API吧：</p><h3 id="api">API</h3><table><thead><tr class="header"><th>public class Stack</th><th></th></tr></thead><tbody><tr class="odd"><td>Stack()</td><td>构造一个空栈</td></tr><tr class="even"><td>void push(Item item)</td><td>入栈</td></tr><tr class="odd"><td>Item pop()</td><td>出栈</td></tr><tr class="even"><td>boolean isEmpty()</td><td>判空</td></tr><tr class="odd"><td>int size()</td><td>大小</td></tr></tbody></table><h3 id="链栈">链栈</h3><p>顾名思义，基于链表实现的栈</p><p>其中的一个结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    Item item;<br>    Node next;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Item item;<br>        Node next;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">return</span> first == <span class="hljs-literal">null</span>; <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Item item)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">oldfirst</span> <span class="hljs-operator">=</span> first;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        first.item = item;<br>        first.next = oldfirst;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> first.item;<br>        first = first.next;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序栈">顺序栈</h3><p>基于数组（顺序表）实现的栈是顺序栈</p><p>简单实现一个定长的栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedCapacityStack</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">private</span> Item[] s;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FixedCapacityStack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123; <br>        s = (Item[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity]; <br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">return</span> N == <span class="hljs-number">0</span>; <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Item item)</span> &#123; <br>        s[N++] = item; <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">return</span> s[--N]; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是定长的栈需要获取<code>capacity</code>，而这又需要客户端提供，然而大部分时间客户端是不知道所需的容量的。</p><p>于是就有了动态长度的栈：</p><h4 id="resizingarraystack">ResizingArrayStack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResizingArrayStack</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">private</span> Item[] s;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResizingArrayStack</span><span class="hljs-params">()</span> &#123; <br>        s = (Item[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">1</span>]; <br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Item item)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N == s.length) resize(<span class="hljs-number">2</span> * s.length);<br>        s[N++] = item;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">return</span> s[--N]; <br>        s[N] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (N &gt; <span class="hljs-number">0</span> &amp;&amp; N == s.length/<span class="hljs-number">4</span>) resize(s.length/<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        Item[] copy = (Item[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)<br>            copy[i] = s[i];<br>        s = copy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时<code>pop</code>和<code>push</code>操作的最坏时间复杂度也是<spanclass="math inline">\(O(N)\)</span>。</p><h4 id="迭代器">迭代器</h4><p>我们可以为栈写一个迭代器：</p><p>需要实现<code>Iterator&lt;&gt;</code>接口的<code>hasNext</code>和<code>next</code>方法，栈类也需要实现<code>Iterable&lt;&gt;</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;Item&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListIterator</span>();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> first;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> current != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!hasNext()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        &#125;<br>        <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> current.item;<br>        current = current.next;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;Item&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> N;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!hasNext()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s[--N];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列">队列</h2><p>队列是一种基于<strong>先进先出</strong>（FIFO）策略的集合类型</p><h3 id="api-1">API</h3><table><thead><tr class="header"><th>public class Queue</th><th></th></tr></thead><tbody><tr class="odd"><td>Queue()</td><td>构造一个空队列</td></tr><tr class="even"><td>void enqueue(Item item)</td><td>入队</td></tr><tr class="odd"><td>Item dequeue()</td><td>出队</td></tr><tr class="even"><td>boolean isEmpty()</td><td>判空</td></tr><tr class="odd"><td>int size()</td><td>大小</td></tr></tbody></table><h3 id="链队">链队</h3><p>直接贴代码，没什么好说的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedQueue</span>&lt;Item&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;Item&gt;&#123;<br>    <span class="hljs-keyword">private</span> Node first, last;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        Item item;<br>        Node next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">return</span> first == <span class="hljs-literal">null</span>;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Item item)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">oldlast</span> <span class="hljs-operator">=</span> last;<br>        last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        last.item = item;<br>        last.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (isEmpty()) first = last;<br>        <span class="hljs-keyword">else</span> oldlast.next = last;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> first.item;<br>        first = first.next;<br>        <span class="hljs-keyword">if</span> (isEmpty()) last = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> item;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Iterator&lt;Item&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListIterator</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Item&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> first;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> current != <span class="hljs-literal">null</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!hasNext()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            &#125;<br>            <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> current.item;<br>            current = current.next;<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="顺序队列">顺序队列</h3><p>顺序队列是基于顺序表的队列，其实一般都是循环队列，就是栈顶、栈底两个指针，<code>front = (front + 1) ％ MaxSize</code>，<code>rear = (rear + 1) ％ MaxSize</code></p><ul><li>队空条件：<code>rear == front</code></li><li>队满条件：<code>(rear + 1) % MaxSize == front</code></li><li>元素进队：<code>rear = (rear + 1) % MaxSize</code></li><li>元素出队：<code>front = (front + 1) % MaxSize</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Item item)</span>&#123; <br>   <span class="hljs-keyword">if</span> ((rear + <span class="hljs-number">1</span>) % MaxSize == front) <span class="hljs-keyword">return</span>;<br>   rear = (rear + <span class="hljs-number">1</span>) % MaxSize;<br>   s[rear] = item;<br>&#125;<br><br><span class="hljs-keyword">public</span> Item <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;  <br>   <span class="hljs-keyword">if</span> (front == rear) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>   front = (front + <span class="hljs-number">1</span>) % MaxSize;<br>   <span class="hljs-keyword">return</span> s[front];<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>coursera</category>
      
      <category>Algorithms, Part I</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>data structure</tag>
      
      <tag>coursera</tag>
      
      <tag>algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/posts/61809/"/>
    <url>/posts/61809/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自Coursera的<ahref="https://www.coursera.org/learn/algorithms-part1/home/welcome">Algorithms,Part I</a>课程</p></blockquote><h2 id="动态连通性">动态连通性</h2><h3id="我们假设相连是一种等价关系这也就意味-着它具有">我们假设“相连”是一种等价关系，这也就意味着它具有：</h3><ul><li>自反性：p 和 p 是相连的</li><li>对称性：如果 p 和 q 是相连的，那么 q 和 p 也是相连的</li><li>传递性：如果 p 和 q 是相连的且 q 和 r 是相连的，那么 p 和 r也是相连的</li></ul><h3 id="连通分量">连通分量</h3><p>连通分量是相连元素组成的最大集合</p><h3 id="查找">查找</h3><p>检查两个元素是否在一个分量中</p><h3 id="归并">归并</h3><p>将两个分量归并到相同的分量中</p><h2 id="并查集算法的api">并查集算法的API</h2><table><thead><tr class="header"><th style="text-align: left;"><code>public class UF</code></th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>UF(int N)</code></td><td>以整数标识（ 0 到 <span class="math inline">\(N-1\)</span> ）初始化<span class="math inline">\(N\)</span> 个触点</td></tr><tr class="even"><td style="text-align: left;"><code>void union(int p, int q)</code></td><td>在 p 和 q 之间添加一条连接</td></tr><tr class="odd"><td style="text-align: left;"><code>int find(int p)</code></td><td>p（0 到 <span class="math inline">\(N-1\)</span>）所在的分量的标识符</td></tr><tr class="even"><tdstyle="text-align: left;"><code>boolean connected(int p, int q)</code></td><td>如果 p 和 q 存在于同一个分量中则返回 <code>true</code></td></tr><tr class="odd"><td style="text-align: left;"><code>int count()</code></td><td>连通分量的数量</td></tr></tbody></table><h2 id="quick-find-算法">quick-find 算法</h2><h3 id="数据结构">数据结构</h3><ul><li>长度为 N 的整型数组 <code>id[]</code></li><li>当且仅当 p 和 q 有相同 <code>id</code> 时 p 和 q 连通</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] id;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">QuickFindUF</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>    id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)<br>        id[i] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="find">find()</h3><p>返回根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">root</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-keyword">return</span> id[p];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="union">union()</h3><p>把要归并的所有连通分量的 <code>id</code> 改为另一个连通分量的<code>id</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> id[p];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">qid</span> <span class="hljs-operator">=</span> id[q];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; id.length; i++)<br>        <span class="hljs-keyword">if</span> (id[i] == pid) id[i] = qid;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析">复杂度分析</h3><table><thead><tr class="header"><th>算法</th><th>构造函数</th><th>union()</th><th>find()</th></tr></thead><tbody><tr class="odd"><td>quick-find</td><td><span class="math inline">\(N\)</span></td><td><span class="math inline">\(N\)</span></td><td><span class="math inline">\(1\)</span></td></tr></tbody></table><p><code>union</code>操作过于复杂，很难运用于大型问题</p><h2 id="quick-union-算法">quick-union 算法</h2><h3 id="数据结构-1">数据结构</h3><p>还是 <code>id[]</code>数组，不过这次不用把所有的分量都改了，一种“偷懒”算法，即<strong>尽量避免计算直到不得不进行计算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] id;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">QuickUnionUF</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>    id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) id[i] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="find-1">find()</h3><p>返回根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i != id[i]) i = id[i];<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="union-1">union()</h3><p>把要归并的连通分量的根节点的 <code>id</code>改为另一个连通分量根节点的 <code>id</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> find(p);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> find(q);<br>    id[i] = j;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1">复杂度分析</h3><table><thead><tr class="header"><th>算法</th><th>构造函数</th><th>union()</th><th>find()</th></tr></thead><tbody><tr class="odd"><td>quick-union</td><td><span class="math inline">\(N\)</span></td><td><spanclass="math inline">\(N\)</span>（包括查找根节点，取决于树的高度）</td><td><span class="math inline">\(N\)</span>（取决于树的高度）</td></tr></tbody></table><p><code>union</code>操作过于复杂，很难运用于大型问题</p><h2 id="改进">改进</h2><h3 id="加权-quick-union-算法">加权 quick-union 算法</h3><p>就是将小树连接到大树来降低高度</p><img src="/posts/61809/image-20230521192309273.png" class="" title="加权"><p>我们需要一个额外的数组 <code>sz[]</code> 来记录以 <code>i</code>为根节点的树的大小，只要在 <code>union</code> 方法中加入三行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> find(p);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> find(q);<br>    id[i] = j;<br>    <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (sz[i] &lt; sz[j]) &#123;<br>        id[i] = j; sz[j] += sz[i];<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        id[j] = i; sz[i] += sz[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析-2">复杂度分析</h4><table><thead><tr class="header"><th>算法</th><th>构造函数</th><th>union()</th><th>find()</th></tr></thead><tbody><tr class="odd"><td>weighted QU</td><td><span class="math inline">\(N\)</span></td><td><span class="math inline">\(\lg N\)</span>（包括查找根节点）</td><td><span class="math inline">\(\lg N\)</span></td></tr></tbody></table><blockquote><p>我们能不能再进一步？</p></blockquote><h3 id="使用路径压缩的加权-quick-union-算法">使用路径压缩的加权quick-union 算法</h3><blockquote><p>顾名思义，就是路径压缩（</p></blockquote><p>为了简化路径压缩，直接加上一行代码就行了，将路径上每个节点指向它在路径上的祖父节点。这种实现不如完全展平好，但在实际应用中两者差不多一样好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i != id[i]) &#123;<br>        id[i] = id[id[i]];<br>        i = id[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析-3">复杂度分析</h4><table><thead><tr class="header"><th>算法</th><th>构造函数</th><th>union()</th><th>find()</th></tr></thead><tbody><tr class="odd"><td>weighted QU</td><td><span class="math inline">\(N\)</span></td><td>非常接近线性</td><td>1（均摊 成本）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>coursera</category>
      
      <category>Algorithms, Part I</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>data structure</tag>
      
      <tag>coursera</tag>
      
      <tag>algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构之线性表</title>
    <link href="/posts/55223/"/>
    <url>/posts/55223/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是一系列关于数据结构的笔记博客，为了练习自己的代码能力，咱将尽可能不使用C++来实现这些数据结构</p></blockquote><h2 id="线性表的简单介绍">线性表的简单介绍</h2><ul><li>线性表是具有相同特性的数据元素的一个有限序列。</li><li>所有数据元素类型相同。</li><li>线性表是有限个数据元素构成的。</li><li>线性表中数据元素与位置相关，即每个数据元素有唯一的序号。</li></ul><p>咱们的线性表需要如下的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs NONE">createList(a[])：由整数数组a中的全部元素建立线性表的相应存储结构。<br>add(e)：将元素e添加到线性表末尾。<br>getLength()：求线性表的长度。<br>getElem(i)：求线性表中序号为i的元素。<br>setElem(i, e)：设置线性表中序号i的元素值为e。<br>getNo(e)：求线性表中第一个值为e的元素的序号。<br>insert(i, e)：在线性表中插入数据元素e作为第i个元素。<br>delete(i)：在线性表中删除第i个数据元素。<br>dispList()：输出线性表的所有元素。<br></code></pre></td></tr></table></figure><h2 id="顺序表">顺序表</h2><p>顺序表是线性表中的顺序存储结构，通常是一段连续的空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> initCap = <span class="hljs-number">5</span><br><span class="hljs-keyword">type</span> SqList <span class="hljs-keyword">struct</span> &#123;<br>data []<span class="hljs-type">int</span><br>capacity <span class="hljs-type">int</span><br>length <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法">方法</h3><h4 id="构造函数伪">构造函数(伪)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSqList</span><span class="hljs-params">()</span></span> SqList &#123;<br>    <span class="hljs-keyword">return</span> SqList&#123;<br>        data:     <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, initCap),<span class="hljs-comment">//用切片将就着吧</span><br>        capacity: initCap,<br>        Length:   <span class="hljs-number">0</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重新调整容量">重新调整容量</h4><p><del>其实是多此一举</del></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *SqList)</span></span> reCap(newCap <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">if</span> newCap &lt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    list.capacity = newCap<br>    <span class="hljs-keyword">var</span> newData = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, newCap)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; list.Length; i++ &#123;<br>        newData[i] = list.data[i]<br>    &#125;<br>    list.data = newData<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="建表">建表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *SqList)</span></span> CreateList(a []<span class="hljs-keyword">interface</span>&#123;&#125;, n <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> list.Length == list.capacity &#123;<br>            list.reCap(<span class="hljs-number">2</span> * list.Length)<br>        &#125;<br>        list.data[list.Length] = a[i]<br>        list.Length++<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="添加元素">添加元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *SqList)</span></span> Add(e <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-keyword">if</span> list.Length == list.capacity &#123;<br>        list.reCap(<span class="hljs-number">2</span> * list.Length)<br>    &#125;<br>    list.data[list.Length] = e<br>    list.Length++<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改元素">修改元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *SqList)</span></span> SetElem(i <span class="hljs-type">int</span>, e <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">0</span> || i &gt;= list.Length &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    list.data[i] = e<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找">查找</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *SqList)</span></span> GetNo(e <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; list.Length; i++ &#123;<br>        <span class="hljs-keyword">if</span> list.data[i] == e &#123;<br>            <span class="hljs-keyword">return</span> i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入">插入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *SqList)</span></span> Insert(i <span class="hljs-type">int</span>, e <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">0</span> || i &gt;= list.Length &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> list.Length == list.capacity &#123;<br>        list.reCap(<span class="hljs-number">2</span> * list.Length)<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := list.Length; j &gt; i; j-- &#123;<br>        list.data[j] = list.data[j<span class="hljs-number">-1</span>]<br>    &#125;<br>    list.data[i] = e<br>    list.Length++<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除">删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *SqList)</span></span> Delete(i <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">0</span> || i &gt;= list.Length &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := i; j &lt; list.Length<span class="hljs-number">-1</span>; j++ &#123;<br>        list.data[j] = list.data[j+<span class="hljs-number">1</span>]<br>    &#125;<br>    list.Length--<br>    <span class="hljs-keyword">if</span> list.capacity &gt; initCap &amp;&amp; list.Length &lt;= list.capacity/<span class="hljs-number">4</span> &#123;<br>        list.reCap(list.capacity / <span class="hljs-number">2</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="打印">打印</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *SqList)</span></span> DispList() &#123;<br>    fmt.Print(<span class="hljs-string">&quot;顺序表内容是:[&quot;</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; list.Length<span class="hljs-number">-1</span>; i++ &#123;<br>        fmt.Print(list.data[i], <span class="hljs-string">&quot;,&quot;</span>)<br>    &#125;<br>    fmt.Print(list.data[list.Length<span class="hljs-number">-1</span>], <span class="hljs-string">&quot;]\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表">链表</h2><p>链表是线性表的链式存储结构，这边就实现一个单链表好了</p><ul><li><p>结点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LinkNode <span class="hljs-keyword">struct</span> &#123;<br>data <span class="hljs-keyword">interface</span>&#123;&#125;<br>next *LinkNode<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>链表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LinkList <span class="hljs-keyword">struct</span> &#123;<br>head   *LinkNode<br>tail   *LinkNode<br>length <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="方法-1">方法</h3><h4 id="构造函数伪-1">构造函数（伪）</h4><ul><li><p>结点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLinkNode</span><span class="hljs-params">()</span></span> *LinkNode &#123;<br><span class="hljs-keyword">return</span> &amp;LinkNode&#123;<br>next: <span class="hljs-literal">nil</span>,<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLinkNodeWithData</span><span class="hljs-params">(d <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> *LinkNode &#123;<br><span class="hljs-keyword">return</span> &amp;LinkNode&#123;<br>data: d,<br>next: <span class="hljs-literal">nil</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>链表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLinkList</span><span class="hljs-params">()</span></span> *LinkList &#123;<br><span class="hljs-keyword">return</span> &amp;LinkList&#123;<br>head:   NewLinkNode(),<br>tail:   NewLinkNode(),<br>length: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="建表-1">建表</h4><ul><li><p>头插法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateListF 头插法建表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> CreateListF(a []<span class="hljs-keyword">interface</span>&#123;&#125;, n <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>l.Insert(<span class="hljs-number">0</span>, a[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>尾插法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateListR 尾插法建表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> CreateListR(a []<span class="hljs-keyword">interface</span>&#123;&#125;, n <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>l.Insert(i, a[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="插入-1">插入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Insert 在第i个位置插入元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> Insert(i <span class="hljs-type">int</span>, e <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>s := NewLinkNodeWithData(e)<br>p := l.GetI(i - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;<br>s.next = p.next<br>p.next = s<br><span class="hljs-keyword">if</span> s.next == <span class="hljs-literal">nil</span> &#123;<br>l.tail = s<br>&#125;<br>l.length++<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回第i个元素">返回第i个元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GetI 返回第i个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> GetI(i <span class="hljs-type">int</span>) *LinkNode &#123;<br>p := l.head<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">-1</span>; j &lt; i &amp;&amp; p != <span class="hljs-literal">nil</span>; j++ &#123;<br>p = p.next<br>&#125;<br><span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="打印-1">打印</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> DispList() &#123;<br>p := l.head.next<br><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>fmt.Print(p.data, <span class="hljs-string">&quot; &quot;</span>)<br>p = p.next<br>&#125;<br>fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除-1">删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Delete 在单链表中删除序号i位置的结点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> Delete(i <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>p := l.GetI(i - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;<br>q := p.next<br><span class="hljs-keyword">if</span> q != <span class="hljs-literal">nil</span> &#123;<br>p.next = q.next<br>q = <span class="hljs-literal">nil</span><br>l.length--<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改元素-1">修改元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SetElem 设置序号i的结点值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> SetElem(i <span class="hljs-type">int</span>, e <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>p := l.GetI(i)<br><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &#123;<br>p.data = e<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找-1">查找</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GetNo 查找第一个为e的元素的序号</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> GetNo(e <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">int</span> &#123;<br>no := <span class="hljs-number">0</span><br>p := l.head.next<br><span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &amp;&amp; p.data != e &#123;<br>no++<br>p = p.next<br>&#125;<br><span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> no<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="添加元素-1">添加元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add 在末尾添加元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LinkList)</span></span> Add(e <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>l.Insert(l.length, e)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>data structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sports Life Lesson</title>
    <link href="/posts/54039/"/>
    <url>/posts/54039/</url>
    
    <content type="html"><![CDATA[<p>As Aristotle said, “Life needs sports.” Sport, in its various forms,is an integral part of human culture that transcends geographical,cultural, and linguistic boundaries. It is not only an avenue tomaintain a better figure or a source of entertainment, but also apowerful means of character development and learning essential lifelessons. Today, we will discuss some of the most important life lessonsthat sport can offer us beyond the playing field or court.</p><p>First and foremost, sport teaches us the value of hard work andperseverance. Higher, Faster, Stronger - the road to the top never comesto an end and being an athlete requires years of training, sweating anddiscipline. These qualities of dedication and hard work are essentialfor success in any endeavor, not just sport. When facing challenges,athletes learn to push themselves through adversity and focus on theirgoals.</p><p>Another lesson sport can teach us is how to work as a team. Mostsports require cooperation as a team to achieve a common goal, such asscoring points or winning a match. Learning to work together,communicate effectively, and trust one another is crucial for success inany team-oriented environment.</p><p>Additionally, sport helps individuals develop a strong sense ofself-confidence and self-awareness. As athletes improve their skills andachieve personal milestones, they gain confidence in their abilities,which can carry over to other areas of life. At the same time, sportrequires individuals to recognize their strengths and weaknesses,promoting self-awareness and personal growth.</p><p>Sport has the power to change the world. The lessons learned on thefield can have a lasting impact on an individual’s life and guide themto success.</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战——黑马点评</title>
    <link href="/posts/63610/"/>
    <url>/posts/63610/</url>
    
    <content type="html"><![CDATA[<p>就是黑马程序员的Redis教程里的黑马点评的项目，前面就不讲了，直接开始正题。</p><h1 id="基于session实现登录流程">基于Session实现登录流程</h1><p>分为三个步骤：</p><ul><li>发送验证码</li><li>短信验证码登录、注册</li><li>校验登录状态</li></ul><h2 id="发送验证码">发送验证码</h2><h3 id="逻辑">逻辑：</h3><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><img src="/posts/63610/1.png" class="" title="发送验证码"><h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//校验手机号，不符合就返回错误，符合就生成验证码</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//保存验证码到session</span><br>    session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>,code);<br>    <span class="hljs-comment">//发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&quot;</span> + code);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="短信验证码登录注册">短信验证码登录、注册</h2><h3 id="逻辑-1">逻辑：</h3><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><img src="/posts/63610/2.png" class="" title="短信验证码登录、注册"><h3 id="代码-1">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//校验手机号和验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-comment">//不一致，报错</span><br>    <span class="hljs-keyword">if</span>(cacheCode == <span class="hljs-literal">null</span> || !cacheCode.toString().equals(code)) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//一致，根据手机号查用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>    <span class="hljs-comment">//判断是否存在</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//不存在，创建用户</span><br>        user = createUserWithPhone(phone);<br>    &#125;<br>    session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="校验登录状态">校验登录状态</h2><p>校验登录状态需要配置拦截器来实现登录拦截功能</p><h3 id="原理">原理</h3><p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应。</p><p>每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的，使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><h3 id="逻辑-2">逻辑</h3><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><img src="/posts/63610/3.png" class="" title="校验登录状态"><h3 id="代码-2">代码</h3><ul><li>首先实现HandlerInterceptor接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//Get session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//Get user from session</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//if user exists</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//not exists, reject, return 401</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//save user in ThreadLocal</span><br>        UserHolder.saveUser((UserDTO) user);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>然后是MvcConfig</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>()).excludePathPatterns(<br>                <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                <span class="hljs-string">&quot;/voucher/**&quot;</span><br>        );<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="session共享问题">session共享问题</h2><p>每个Tomcat中都有一份属于自己的<code>session</code>,假设用户第一次访问第一台Tomcat，并且把自己的信息存放到第一台服务器的<code>session</code>中，但是第二次这个用户访问到了第二台Tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的<code>session</code>，所以此时整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是<code>session</code>拷贝，就是说虽然每个Tomcat上都有不同的<code>session</code>，但是每当任意一台服务器的<code>session</code>修改时，都会同步给其他的Tomcat服务器的<code>session</code>，这样的话，就可以实现<code>session</code>的共享了</p><p>但是这种方案有两个<strong>大</strong>问题</p><ol type="1"><li><p>每台服务器中都有完整的一份<code>session</code>数据，服务器压力过大。</p></li><li><p><code>session</code>拷贝数据时，可能会出现延迟</p></li></ol><p>所以咱们要基于Redis来完成，我们把<code>session</code>换成Redis，Redis数据本身就是共享的，就可以避免<code>session</code>共享的问题了</p><img src="/posts/63610/4.png" class="" title="session共享问题"><h1id="redis代替session的业务流程">Redis代替<code>session</code>的业务流程</h1><h2 id="设计key">设计<code>key</code></h2><p>我们可以生成一个随机字符串<code>token</code>，来存储。这样既可以满足唯一性也可以满足脱敏性。</p><h2 id="整体流程">整体流程</h2><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到Redis，并且生成<code>token</code>作为Redis的<code>key</code>，当我们校验用户是否登录时，会去携带着<code>token</code>进行访问，从Redis中取出<code>token</code>对应的<code>value</code>，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到<code>threadLocal</code>中，并且放行。</p><img src="/posts/63610/5.png" class="" title="整体流程"><h2 id="代码-3">代码</h2><p>直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//校验手机号，不符合就返回错误，符合就生成验证码</span><br>        <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">//保存验证码到Redis</span><br>        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">//发送验证码</span><br>        log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&quot;</span> + code);<br><br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//校验手机号和验证码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>        <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 从redis获取验证码并校验</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>        <span class="hljs-comment">//不一致，报错</span><br>        <span class="hljs-keyword">if</span>(cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//一致，根据手机号查用户</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>        <span class="hljs-comment">//判断是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//不存在，创建用户</span><br>            user = createUserWithPhone(phone);<br>        &#125;<br>        <span class="hljs-comment">// 保存用户信息到 redis中</span><br>        <span class="hljs-comment">// 随机生成token，作为登录令牌</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 将User对象转为HashMap存储</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap<br>                (userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>                CopyOptions.create()<br>                        .setIgnoreNullValue(<span class="hljs-literal">true</span>)<br>                        .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));<br>        <span class="hljs-comment">// 存储</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>        stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br>        <span class="hljs-comment">// 设置token有效期</span><br>        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> Result.ok(token);<br>    &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>(stringRedisTemplate)).excludePathPatterns(<br>                <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                <span class="hljs-string">&quot;/user/login&quot;</span>,<br>                <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                <span class="hljs-string">&quot;/voucher/**&quot;</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoginInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//Get token in Header</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>            <span class="hljs-comment">//not exists, reject, return 401</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.LOGIN_USER_KEY + token;<br>        <span class="hljs-comment">//Get user from Redis</span><br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>        <span class="hljs-comment">//if user exists</span><br>        <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>            <span class="hljs-comment">//not exists, reject, return 401</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//turn Hash to UserDTO</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//save user in ThreadLocal</span><br>        UserHolder.saveUser(userDTO);<br><br>        <span class="hljs-comment">// refresh token TTL</span><br>        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>coding</tag>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringDataRedis</title>
    <link href="/posts/17687/"/>
    <url>/posts/17687/</url>
    
    <content type="html"><![CDATA[<h1 id="redis的java客户端">Redis的Java客户端</h1><p>Redis的客户端可以在<ahref="https://redis.io/docs/clients/">Redis官网</a>找到，推荐的客户端包括：</p><ul><li>Jedis：以Redis命令作为方法名称，学习成本低，简单实用。但是Jedis实例是<strong>线程不安全</strong>的，<strong>多线程环境下需要基于连接池来使用</strong></li><li>Lettuce：Lettuce是基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式和管道模式</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求</li></ul><h2 id="jedis">Jedis</h2><blockquote><p><a href="https://github.com/redis/jedis">Jedis官网</a></p></blockquote><h3 id="jedis快速入门">Jedis快速入门</h3><h4 id="导入依赖">导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="建立连接">建立连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.建立连接</span><br>    jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-comment">// 2.设置密码</span><br>    <span class="hljs-comment">//jedis.auth(&quot;&quot;);</span><br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试">测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 存入</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Snow San&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>    <span class="hljs-comment">// 获取</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 插入</span><br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Snow San&quot;</span>);<br>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;18&quot;</span>);<br>    <span class="hljs-comment">// 获取</span><br>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="释放资源">释放资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jedis连接池">Jedis连接池</h3><p>Jedis本身是<strong>线程不安全</strong>的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <br>                                  <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <br>                                  <span class="hljs-number">6379</span>, <br>                                  <span class="hljs-number">1000</span>, <br>                                  <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//密码在此（</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="springdataredis客户端">SpringDataRedis客户端</h2><p><del>接下来就是本次的主角啦！</del></p><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，<ahref="https://spring.io/projects/spring-data-redis">SpringDataRedis官网</a></p><p>ta的特点如下：</p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中</p><h3 id="springdataredis快速入门">SpringDataRedis快速入门</h3><h4 id="新建一个boot项目">新建一个boot项目</h4><p><del>别说你连boot项目都不会建</del></p><h4 id="引入依赖">引入依赖</h4><p>要引入<code>spring-boot-starter-data-redis</code>,<code>commons-pool2</code>和<code>jackson-databind</code>，不过貌似MVC已经整合了<code>jackson</code>？</p><p><del>懒的话整个<code>lombok</code></del></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--common-pool--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="配置redis">配置Redis</h4><p>说到boot果然就是yaml呢<del>（笑）</del></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">data:</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>      <span class="hljs-attr">lettuce:</span><br>        <span class="hljs-attr">pool:</span><br>          <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>          <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>          <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>          <span class="hljs-attr">max-wait:</span> <span class="hljs-string">1000ms</span><br></code></pre></td></tr></table></figure><h4 id="注入redistemplate">注入RedisTemplate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br></code></pre></td></tr></table></figure><h4 id="测试-1">测试！</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 写入</span><br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Snow San&quot;</span>);<br>    <span class="hljs-comment">// 获取</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义序列化白雪">自定义序列化<del>（白雪）</del></h3><p>RedisTemplate可以接收任意<code>Object</code>作为值写入Redis,但在写入前会把<code>Object</code>序列化为字节形式，默认是采用JDK序列化，缺点是：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>因此可以自定义RedisTemplate的序列化方式，采用JSON序列化来代替默认的JDK序列化方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>&#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JSON序列化在查询时还能自动把JSON反序列化为Java对象，注意<code>@class</code>字段，ta会带来额外的内存开销</p><h3 id="stringredistemplate">StringRedisTemplate</h3><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。</p><p>不过当需要存储Java对象时，必须手动完成对象的序列化和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 写入</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;verify:phone:11111111&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>    <span class="hljs-comment">// 获取</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Snow&quot;</span>, <span class="hljs-number">18</span>);<br>    <span class="hljs-comment">// 手动序列化</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>    <span class="hljs-comment">// 写入</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:1&quot;</span>, json);<br>    <span class="hljs-comment">// 获取</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:1&quot;</span>);<br>    <span class="hljs-comment">// 手动反序列化</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, User.class);<br>    System.out.println(<span class="hljs-string">&quot;user1 = &quot;</span> + user1);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>coding</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>习近平新时代中国特色社会主义思想概论</title>
    <link href="/posts/57769/"/>
    <url>/posts/57769/</url>
    
    <content type="html"><![CDATA[<blockquote><p><ahref="https://ivansnow02.github.io/assets/XJP.html">思维导图</a></p></blockquote><h1 id="第一讲-马克思主义中国化新飞跃">第一讲马克思主义中国化新飞跃</h1><h2id="一习近平新时代中国特色社会主义思想如何创立的">一、习近平新时代中国特色社会主义思想如何创立的</h2><h3 id="时代背景两个大局同步交织">时代背景："两个大局"同步交织</h3><p>两个大局：中华民族伟大复兴的战略全局；世界百年未有之大变局。</p><ul><li>世界百年未有之大变局加速演进，世界百年未有之大变局概括起来说就是 ：<ul><li>当前国际格局和国际体系正在发生深刻调整</li><li>全球治理体系正在发生深刻变革</li><li>国际力量对比正在发生近代以来最具革命性的变化</li><li>世界范围呈现出影响人类历史进程和趋向的</li><li>中华民族伟大复兴正处于关键时期</li><li>中华民族迎来了从站起来、富起来到强起来的伟大飞跃，实现中华民族伟大复兴进入了不可逆转的历史进程。</li><li>中华民族伟大复兴，是造成世界百年未有之大变局的重要原因；世界面临百年未有之大变局给中华民族伟大复兴带来重大机遇。</li></ul></li></ul><h3id="历史方位中国特色社会主义进入新时代">历史方位：中国特色社会主义进入新时代</h3><ul><li><p>社会主要矛盾变化是进入新时代的重要依据</p><ul><li>改革开放后，我国社会主要矛盾是人民日益增长的物质文化需要同落后的社会生产之间的矛盾。进入新时代，人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全和环境等方面的要求日益增长。我国社会生产力水平总体上显著提高，更加突出的问题是发展的不平衡不充分。我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。主要矛盾的变化，虽然没有改变我们对我国社会主义所处历史阶段的判断，但却是关系全局的历史性变化。</li></ul></li><li><p>新时代是什么样的时代？</p><ul><li><p>是承前启后、继往开来、在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代</p></li><li><p>是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代</p></li><li><p>是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代</p></li><li><p>是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代</p></li><li><p>是我国不断为人类作出更大贡献的时代</p></li></ul></li><li><p>进入新时代意味着什么？</p><ul><li><p>意味着中华民族迎来了从站起来、富起来到强起来的伟大飞跃</p></li><li><p>意味着科学社会主义在二十一世纪的中国焕发出强大生机活力</p></li><li><p>意味着拓展了发展中国家走向现代化的途径，为解决人类问题贡献了中国智慧和中国方案</p></li></ul></li></ul><h3id="实践基础历史性成就历时性变革">实践基础：历史性成就、历时性变革</h3><ul><li><p>十三个方面的标志性成果</p><ul><li><img src="image1.png" /></li></ul></li></ul><h3 id="基本方法两个结合">基本方法："两个结合"</h3><ul><li><p>两个结合的内涵</p><ul><li>坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合。</li></ul></li></ul><h2id="二习近平新时代中国特色社会主义思想回答了什么课题">二、习近平新时代中国特色社会主义思想回答了什么课题</h2><ul><li><p>坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义</p></li><li><p>建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国</p></li><li><p>建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党</p></li></ul><h2id="三习近平新时代中国特色社会主义思想主要包含哪些内容">三、习近平新时代中国特色社会主义思想主要包含哪些内容</h2><h3 id="十个明确">"十个明确"</h3><ul><li><p>明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，中国共产党是最高政治领导力量，全党必须增强"四个意识"、坚定"四个自信"、做到"两个维护"。</p></li><li><p>明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国，以中国式现代化推进中华民族伟大复兴。</p></li><li><p>明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，发展全过程人民民主，推动人的全面发展、全体人民共同富裕取得更为明显的实质性进展。</p></li><li><p>明确中国特色社会主义事业总体布局是经济建设、政治建设、文化建设、社会建设、生态文明建设五位一体，战略布局是全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党四个全面。</p></li><li><p>明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。</p></li><li><p>明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家。</p></li><li><p>明确必须坚持和完善社会主义基本经济制度，使市场在资源配置中起决定性作用，更好发挥政府作用，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展，统筹发展和安全。</p></li><li><p>明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队。</p></li><li><p>明确中国特色大国外交要服务民族复兴、促进人类进步，推动建设新型国际关系，推动构建人类命运共同体。</p></li><li><p>明确全面从严治党的战略方针，提出新时代党的建设总要求，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，落实管党治党政治责任，以伟大自我革命引领伟大社会革命。</p></li></ul><h3 id="十四个坚持">"十四个坚持"</h3><ul><li><img src="image2.png" /></li></ul><h2id="四如何理解习近平新时代中国特色社会主义思想的历史地位">四、如何理解习近平新时代中国特色社会主义思想的历史地位</h2><ul><li><p>当代中国马克思主义、二十一世纪马克思主义</p></li><li><p>中华文化和中国精神的时代精华</p></li><li><p>马克思主义中国化的新飞跃</p></li><li><p>深刻领悟"两个确立"的决定性意义</p></li></ul><h1 id="第二讲-坚持和发展中国特色社会主义总任务">第二讲坚持和发展中国特色社会主义总任务</h1><h2id="一为什么说实现中华民族伟大复兴进入了不可逆转的历史进程">一、为什么说实现中华民族伟大复兴进入了不可逆转的历史进程</h2><h3 id="中华民族近代以来最伟大的梦想">中华民族近代以来最伟大的梦想</h3><ul><li><p>中华文明源远流长、博大精深，是中华民族独特的精神标识，是当代中国文化的根基，是维系全世界华人的精神纽带，也是中国文化创新的宝藏；</p></li><li><p>我国从十九世纪四十年代起，到二十世纪四十年代中期，全世界几乎一切大中小帝国主义国家都侵略过我国，没有一次战争不是以我国失败、签订丧权辱国条约而告终。其原因：一是社会制度腐败，二是经济技术落后。</p></li><li><p>中国产生了共产党，这是开天辟地的大事变</p></li><li><p>原因：</p><ul><li>深刻改变了近代以后中华民族发展的方向和进程；</li><li>深刻改变了中国人民和中华民族的前途和命运；</li><li>深刻改变了世界发展的趋势和格局。</li></ul></li><li><p>实现中华民族伟大复兴是党百年奋斗的主题</p><ul><li><p>一百年来，中国共产党团结带领中国人民进行的一切奋斗、一切牺牲、一切创造，归结起来就是一个主题：实现中华民族伟大复兴。</p></li><li><p>新民主主义革命时期，党面临的主要任务是，反对帝国主义、封建主义、官僚资本主义，争取民族独立、人民解放，为实现中华民族伟大复兴创造根本社会条件。</p></li><li><p>社会主义革命和建设时期，党面临的主要任务是，实现从新民主主义到社会主义的转变，进行社会主义革命，推进社会主义建设，为实现中华民族伟大复兴奠定根本政治前提和制度基础。</p></li><li><p>改革开放和社会主义现代化建设新时期，党面临的主要任务是，继续探索中国建设社会主义的正确道路，解放和发展社会生产力，使人民摆脱贫困、尽快富裕起来，为实现中华民族伟大复兴提供充满新的活力的体制保证和快速发展的物质条件。</p></li><li><p>中国特色社会主义新时代，党面临的主要任务是，实现第一个百年奋斗目标，开启实现第二个百年奋斗目标新征程，朝着实现中华民族伟大复兴的宏伟目标继续前进。</p></li></ul></li></ul><h3id="中华民族伟大复兴展现出前所未有的光明前景从站起来到富起来到迎来强起来">中华民族伟大复兴展现出前所未有的光明前景：从站起来到富起来，到迎来强起来</h3><ul><li><p>"中国梦"是中华民族伟大复兴的形象表达；</p></li><li><p>"中国梦"的本质是国家富强、民族振兴、人民幸福；</p></li><li><p>中国梦归根到底是人民的梦，其最深沉的根基在中国人民心中。</p></li><li><p>中国梦同世界人民的梦想息息相通，是追求和平的梦，贡献世界的梦。</p></li><li><p>今天，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴的目标，作为这一判断的底气在于我国发展具有诸多过去难以想象的战略性有利条件：有中国共产党的坚强领导；有中国特色社会主义制度的显著优势；有持续快速发展积累的坚实基础；有长期稳定的社会环境；有自信自强的精神力量。</p></li></ul><h3id="实现中华民族伟大复兴的艰巨性复杂性和长期性">实现中华民族伟大复兴的艰巨性、复杂性和长期性</h3><ul><li><p>中华民族伟大复兴不是轻轻松松、敲锣打鼓就能实现的，必须勇于进行具有许多新的历史特点的伟大斗争。</p></li><li><p>依靠顽强斗争打开事业发展新天地。</p><ul><li>应对重大挑战、抵御重大风险、克服重大阻力、解决重大矛盾，必须进行具有许多新的历史特点的伟大斗争。</li><li>最根本的是要把我们自己的事情做好，包括：<ul><li>实现中国梦必须走中国道路------中国特色社会主义道路；</li><li>实现中国梦必须弘扬中国精神------以爱国主义为核心的民族精神和以改革创新为核心的时代精神；</li><li>实现中国梦必须凝聚中国力量------中国各族人民大团结的力量。</li></ul></li></ul></li></ul><h2id="二如何理解中国特色社会主义是实现中华民族伟大复兴的必由之路">二、如何理解中国特色社会主义是实现中华民族伟大复兴的必由之路</h2><h3id="党和人民长期奋斗取得的根本成就">党和人民长期奋斗取得的根本成就</h3><ul><li><p>方向决定道路、道路决定命运</p><ul><li><p>我们党在革命、建设、改革各个历史时期，坚持从我国国情出发，探索并形成了符合中国实际的新民主主义革命道路、社会主义改造和社会主义建设道路、中国特色社会主义道路。</p></li><li><p>道路问题是关系党的事业兴衰成败第一位的问题，道路就是党的生命</p></li></ul></li><li><p>中国特色社会主义不是从天上掉下来的</p><ul><li><p>从历史纵深中走来：是在改革开放40年的伟大实践中得来的，是在中华人民共和国成立近70年的持续探索中得来的，是在我们党领导人民进行伟大社会革命97年的实践中得来的，是在近代以来中华民族由衰到盛170多年的历史进程中得来的，是对中华文明5000多年的传承发展中得来的。</p></li><li><p>走自己的路，是党百年奋斗得出的历史结论</p></li></ul></li></ul><h4id="思考如何正确认识改革开放前后两个历史时期的关系">思考：如何正确认识改革开放前后两个历史时期的关系？</h4><ul><li><p>如果没有1949年建立新中国并进行社会主义革命和建设，积累了重要的思想、物质、制度条件，积累了正反两方面经验，改革开放也很难顺利推进。</p></li><li><p>两个历史时期虽有很大差别，但决不是彼此割裂的，更不是根本对立的。</p></li><li><p>不能用改革开放后的历史时期否定改革开放前的历史时期，也不能用改革开放前的历史时期否定改革开放后的历史时期。</p></li><li><p>中国特色社会主义道路是创造人民美好生活、实现中华民族伟大复兴的康庄大道。只要我们既不走封闭僵化的老路，也不走改旗易帜的邪路，坚定不移走中国特色社会主义道路，就一定能够实现中华民族伟大复兴。</p></li></ul><h3id="中国特色社会主义是社会主义而不是其他什么主义">中国特色社会主义是社会主义而不是其他什么主义</h3><ul><li><p>廓清对中国特色社会主义的认识迷雾</p><ul><li><p>近些年来，国内外有些舆论提出中国现在搞的究竟还是不是社会主义的疑问，有人说是"资本社会主义"，还有人干脆说是"国家资本主义""新官僚资本主义"，这些都是完全错误的。</p></li><li><p>一些人反复炒作"国家资本主义""资本社会主义""新官僚资本主义"的目的，就是为遏制中国制造舆论，企图通过抹黑中国社会制度，动摇人们对中国特色社会主义的信心，迫使我们放弃被实践所证明的成功道路和制度。</p></li></ul></li><li><p>中国特色社会主义的科学社会主义性质</p><ul><li>科学社会主义基本原则不能丢，丢了就不是社会主义。这些原则包括：<ul><li>无产阶级政党是无产阶级的先锋队，社会主义事业必须坚持无产阶级政党的领导；</li><li>无产阶级革命是无产阶级进行斗争的最高形式，必须以建立无产阶级专政的国家为目的；</li><li>在生产资料公有制基础上组织生产，满足全体社会成员的需要是社会主义生产的根本目的；</li><li>对社会生产进行有计划的指导和调节，实行等量劳动领取等量产品的按劳分配原则；</li><li>通过无产阶级专政和社会主义高度发展最终实现向消灭阶级、消灭剥削、实现人的全面而自由发展的共产主义社会的过渡。</li></ul></li><li>中国特色社会主义坚持了科学社会主义基本原则并赋予其鲜明中国特色，表现在：<ul><li>领导力量------中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，党是最高政治领导力量；</li><li>国体和政体：实行人民民主专政的国体和人民代表大会制度的政体；</li><li>经济制度------坚持公有制为主体、多种所有制经济共同发展，坚持按劳分配为主体、多种分配方式并存，实行社会主义市场经济体制；</li><li>意识形态：坚守马克思主义信仰、共产主义远大理想、中国特色社会主义共同理想；</li><li>根本立场：坚持以人民为中心，不断促进人的全面发展，实现全体人民共同富裕。</li></ul></li></ul></li></ul><h3id="新时代坚持和发展中国特色社会主义要一以贯之">新时代坚持和发展中国特色社会主义要一以贯之</h3><ul><li><p>中国共产党领导的伟大社会革命接续推进、一以贯之；</p><ul><li>新民主主义革命、社会主义革命、改革开放新的伟大革命，<ul><li>都是以解决生产力和生产关系矛盾为根本目的的革命性实践；</li><li>都是建立和建设社会主义、最终实现共产主义的伟大社会革命的不同阶段。</li></ul></li><li>新时代中国特色社会主义是我们党领导人民进行伟大社会革命的成果，也是我们党领导人民进行伟大社会革命的继续，必须一以贯之进行下去。</li></ul></li><li><p>科学把握新时代中国面临的战略机遇和风险挑战</p></li><li><p>新时代坚持和发展中国特色社会主义的前进定力</p></li><li><p>认清五个"必由之路"：</p><ul><li>坚持党的全面领导是坚持和发展中国特色社会主义的必由之路；</li><li>中国特色社会主义是实现中华民族伟大复兴的必由之路；团结奋斗是中国人民创造历史伟业的必由之路；</li><li>贯彻新发展理念是新时代我国发展壮大的必由之路；</li><li>全面从严治党是党永葆生机活力、走好新的赶考之路的必由之路。</li></ul></li></ul><h3id="坚定中国特色社会主义四个自信">坚定中国特色社会主义"四个自信"</h3><ul><li><p>四个自信的内容：道路自信、理论自信、制度自信、文化自信</p></li><li><p>我国改革开放以来实现了两大奇迹：经济快速发展奇迹；社会长期稳定奇迹。</p></li></ul><h2id="三如何建设社会主义现代化强国">三、如何建设社会主义现代化强国</h2><h3 id="全面建成小康社会">全面建成小康社会</h3><ul><li><p>小康是中华民族自古以来不懈追求的梦想</p></li><li><p>实现小康社会是我国现代化建设的重要目标</p><ul><li><p>改革开放之初，邓小平同志首先用"小康"来诠释中国式现代化，明确提出到20世纪末"在中国建立一个小康社会"的奋斗目标。</p></li><li><p>人民生活从温饱不足到总体小康、奔向全面小康的历史性跨越</p></li><li><p>1982年党的十二大首次把"小康"作为经济建设总的奋斗目标，提出到20世纪末力争使人民的物质文化生活达到小康水平；</p></li><li><p>1987年党的十三大制定"三步走"现代化发展战略，把20世纪末人民生活达到小康水平作为第二步奋斗目标。</p></li><li><p>1992年在人民温饱问题基本得到解决的基础上，党的十四大提出到20世纪末人民生活由温饱进入小康。</p></li></ul></li><li><p>全面建成小康社会，是"两个一百年"奋斗目标的第一个百年奋斗目标。党的十八大以来，以习近平同志为核心的党中央顺应我国经济社会新发展和广大人民群众新期盼，提出了全面建成小康社会新的目标要求，赋予了"小康"更高的标准、更丰富的内涵。</p></li><li><p>全面建成小康社会，强调的不仅是"小康"，更重要、更难做到的是"全面"。"小康"讲的是发展水平，"全面"讲的是发展的平衡性、协调性、可持续性。</p></li><li><p>到2020年底，中国如期完成新时代脱贫攻坚目标任务，现行标准下9899万农村贫困人口全部脱贫，832个贫困县全部摘帽。我们实现了第一个百年奋斗目标，在中华大地上全面建成了小康社会，历史性地解决了绝对贫困问题。</p></li><li><p>全面建成小康社会，意味着中华民族实现千百年来的夙愿；表明我国发展和人民生活水平跃上新的大台阶；是全面建设社会主义现代化国家征程中的关键一步。</p></li></ul><h3 id="全面建设社会主义现代化国家">全面建设社会主义现代化国家</h3><ul><li><p>建设社会主义现代化强国是我们党确立的伟大目标；</p></li><li><p>建成社会主义现代化强国的战略安排。</p><ul><li>第一步：2035年，基本实现社会主义现代化；</li><li>第二步：本世纪中叶，建成富强民主文明和谐美丽的社会主义现代化强国。</li></ul></li><li><p>开启全面建设社会主义现代化国家新征程</p></li></ul><h3 id="推进和拓展中国式现代化">推进和拓展中国式现代化</h3><ul><li><p>鞋子合不合脚，只有穿的人才知道</p></li><li><p>我们建设的现代化必须是具有中国特色、符合中国实际的。</p><ul><li>与"串联式"的西方现代化不同，我国发展必然是一个"并联式"的过程，工业化、信息化、城镇化、农业现代化是叠加发展的。</li></ul></li><li><p>中国式现代化的重要特征：</p><ul><li>人口规模巨大的现代化；</li><li>全体人民共同富裕的现代化；</li><li>物质文明和精神文明相协调的现代化；</li><li>人与自然和谐共生的现代化；</li><li>走和平发展道路的现代化。</li></ul></li><li><p>中国式现代化将更好发展自身、造福世界</p></li></ul><p>第三讲 坚持党的全面领导</p><h2 id="一为什么要坚持党的领导">一、为什么要坚持党的领导</h2><h3 id="党是最高政治领导力量">党是最高政治领导力量</h3><ul><li><p>引领政治方向。方向决定道路，道路决定命运。中国共产党始终坚持共产主义理想和社会主义信念。党的十八大以来，以习近平同志为核心的党中央高举中国特色社会主义伟大旗帜，把准把好新时代改革开放的方向盘。这个方向就是中国特色社会主义道路，而不是其他什么道路。</p></li><li><p>统领政治体系。国家政治体系是一个大系统，其构成包括根本政治制度、基本政治制度和国家治理各方面具体的体制机制，涵盖国家机关、政党组织和各种政治主体。在这个大系统中，中国共产党处于统领地位。</p></li><li><p>决断重大事项。中国共产党作为最高政治领导力量，很重要的是就党和国家的重大事项进行决策。离开决策权，所谓领导就是一句空话。中国共产党一路走来，不断从胜利走向胜利，每一步都离不开科学有效的决策及周密部署和有效实施。善于抓问题、想办法、作决策，是党的领导水平和执政本领的集中体现。</p></li><li><p>领导社会治理。社会治理离不开一定的组织形态。中国共产党的组织形态既推进了社会的有序治理，又保证了社会充满活力。首先，中国共产党的政治功能为社会治理提供方向。其次，中国共产党以党的服务功能推进社会有效运转。最后，中国共产党以强大的组织体系确保社会治理和谐有序。</p></li></ul><h3id="中国共产党领导是中国特色社会主义最本质的特征">中国共产党领导是中国特色社会主义最本质的特征</h3><ul><li><p>中国共产党领导是中国特色社会主义最本质的特征，要置于科学社会主义基本原理中去认识，要置于国际共产主义运动历史经验教训中去分析，要置于中国共产党领导中国社会发展中去把握。中国共产党领导是中国特色社会主义最本质的特征，就在于党的领导直接关系着中国特色社会主义的性质、方向和命运。</p></li><li><p>首先，中国共产党的领导是由科学社会主义的理论逻辑决定的。坚持无产阶级政党的领导是无产阶级革命和社会主义建设取得胜利的根本保证。马克思和恩格斯在《共产党宣言》中明确指出："在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。"中国特色社会主义是科学社会主义基本原则同当代中国实际和时代特征相结合的产物，是植根于当代中国的科学社会主义。只有坚持中国共产党的领导，才能保证中国特色社会主义的性质和正确方向。</p></li><li><p>其次，中国共产党的领导是由中国特色社会主义产生与发展的历史逻辑决定的。中国共产党领导中国人民开创的中国特色社会主义不是从天上掉下来的，而是在改革开放40多年的伟大实践中得来的，是在中华人民共和国成立70多年的持续探索中得来的，是在党领导人民进行伟大社会革命100多年的实践中得来的，是在对近代以来180多年中华民族发展历程的深刻总结中走出来的，是在对中华民族5000多年悠久文明的传承中走出来的，是党和人民历经千辛万苦、付出各种代价取得的宝贵成果。中国共产党是中国特色社会主义事业的开创者、推动者、引领者，团结带领人民开辟了中国特色社会主义道路，创立了中国特色社会主义理论，创建了中国特色社会主义制度，发展了中国特色社会主义文化。历史和现实证明，没有中国共产党的领导，就没有中国特色社会主义的产生和发展。</p></li><li><p>最后，中国共产党的领导是由中国特色社会主义迈向新征程的实践逻辑决定的。百余年来，为了实现中华民族伟大复兴的历史使命，中国共产党初心不改、矢志不渝，团结带领人民历经千难万险、付出巨大牺牲，取得了一个又一个伟大斗争的胜利。今天，我们已经全面建成小康社会、踏上了建设社会主义现代化强国的新征程。在实现中华民族伟大复兴征程中，面临着来自国际国内多种多样前所未有的挑战，不知还要爬多少坡、过多少坎，经历多少风风雨雨、克服多少艰难险阻。坚定走中国道路，把14亿多人民凝聚成中国力量，焕发出中国精神，把新时代中国特色社会主义这篇大文章继续写好、写精彩，从根本上要靠党的全面领导，靠党把好方向盘。</p></li></ul><h3id="中国共产党领导是中国特色社会主义制度的最大优势">中国共产党领导是中国特色社会主义制度的最大优势</h3><ul><li><p>中国共产党是中国特色社会主义制度的创建者。没有中国共产党，就没有中国特色社会主义制度的形成、发展和完善，制度优势就无从谈起。中国共产党把科学社会主义原则和中国实际相结合，创建了根本政治制度和基本政治制度，中国特色社会主义法律体系，公有制为主体、多种所有制经济共同发展的基本经济制度。党领导中国人民通过改革不断完善中国特色社会主义制度。</p></li><li><p>中国共产党的领导是充分发挥中国特色社会主义制度优势的根本保障。党的领导作为一项制度安排是中国特色社会主义制度的重要组成部分。作为党的根本组织制度和领导制度的民主集中制，最能体现中国特色社会主义制度的优越性。这项制度把充分发扬党内民主和正确实行集中有机结合起来，既可以最大限度激发全党创造活力，又可以统一全党思想和行动，有效防止和克服议而不决、决而不行的分散主义，是科学合理而又有效率的制度。</p></li><li><p>中国共产党的自身优势是中国特色社会主义制度优势的主要来源。回顾党的历史，我们可以清楚地看到，在长期奋斗中，党形成了自身的理论优势、政治优势、组织优势、制度优势和密切联系群众的优势。正是这些优势使党能够由小到大、由弱到强，团结带领全国各族人民谱写了中国革命、建设、改革的壮丽篇章，根本改变了中国人民和中华民族的前途和命运；也正是这些优势引领和锻造了中国特色社会主义的制度优势，从根本上保证中国特色社会主义不变色、不变质。</p></li></ul><h2id="二怎样理解党的领导是全面的系统的整体的">二、怎样理解党的领导是全面的、系统的、整体的</h2><h3 id="党的领导是全面的">党的领导是全面的</h3><ul><li><p>领导对象要全面覆盖.党领导一切，包括党领导人大、政府、政协、监察机关、审判机关、检察机关、武装力量、人民团体、企事业单位、基层群众性自治组织、社会组织等。</p></li><li><p>领导内容要全面.必须体现到经济建设、政治建设、文化建设、社会建设、生态文明建设和国防军队、祖国统一、外交工作、党的建设等各方面。</p></li><li><p>领导过程要全面.既制定路线方针政策，又协调各方、督促落实，贯穿于治国理政的立法、决策、执行、管理、监督等各项工作之中。</p></li><li><p>领导方法要全面.通过制定大政方针，提出立法建议，推荐重要干部，进行思想宣传，发挥党组织和党员的作用等，坚持依法执政，实施党对国家和社会的领导。</p></li><li><p>党、政、军、民、学在党中央的集中统一领导下，既各司其职、各负其责又相互配合，这样治国理政才有方向、有章法、有力量。否则就会出现各自为政、一盘散沙的局面，不仅我们确定的目标不能实现，而且必定会产生灾难性后果。</p></li></ul><h4id="坚持党的全面领导与过去党的一元化领导有什么不同">坚持党的全面领导与过去党的一元化领导有什么不同？</h4><ul><li><p>在坚持和加强党的全面领导问题上，一些人把它与过去党的一元化领导简单等同起来，这种认识是错误的。</p><ul><li><p>党的一元化领导。党的一元化领导是抗战时期开始形成的领导制度，当时各根据地长期被分割，为了适应严酷的战争环境，需要党对军、政、民实施统一领导，这对于统一全党的思想意志、有效集中各种资源、推动革命根据地发展，最终取得中国革命的胜利发挥了重要作用。但后来计划经济时期，在"左"的错误思想影响下，加之民主与法制不健全，导致权力过分集中、政企不分、政事不分、政社不分，出现"家长制""一言堂"，党的一元化领导被极端化和教条化，给党和国家事业带来严重破坏。</p></li><li><p>党的全面领导。改革开放以来，我们不断深化对共产党执政规律的认识，特别是党的十八大以后，针对一段时期党的领导被忽视、淡化、弱化的状况，我们党提出坚持和加强党的全面领导。党的全面领导既坚持党的集中统一领导原则，坚持党是最高政治领导力量，又坚持民主集中制、发扬党内民主，坚持党的领导与人民当家作主、依法治国有机统一。</p></li></ul></li></ul><h3 id="党的领导是系统的">党的领导是系统的</h3><ul><li><p>中国特色社会主义制度是一个严密完整的科学制度体系，起四梁八柱作用的是根本制度、基本制度、重要制度，其中中国共产党的领导是载入宪法的，党的领导制度是我国的根本领导制度，居于统领地位。</p></li><li><p>坚持党的领导，是通过党的制度来保证实施的。制度带有根本性、全局性、稳定性和长期性，健全的领导制度体系对于保证党的领导活动的正常进行，发挥党的领导机关和领导者的作用，发挥党的各级组织和广大党员的积极性主动性创造性，保证党和国家事业的健康发展，具有十分重要的作用。</p></li><li><p>建立不忘初心、牢记使命的制度；完善坚定维护党中央权威和集中统一领导的各项制度；健全党的全面领导制度；健全为人民执政、靠人民执政各项制度；健全提高党的执政能力和领导水平制度；完善全面从严治党制度。</p></li><li><p>党的领导是整体的</p><ul><li>从党的中央组织到地方组织再到基层组织，都要按照党章的规定发挥应有作用，党的领导作用要体现到治国理政的全过程，领导功能的发挥要完整。</li></ul></li></ul><p>习近平强调，"我国社会主义政治制度优越性的一个突出特点是党总揽全局、协调各方的领导核心作用，形象地说是'众星捧月'，这个'月'就是中国共产党。"国家治理体系是由众多子系统构成的复杂系统，这个系统的核心是中国共产党，人大、政府、政协、监委、法院、检察院、军队，各民主党派和无党派人士，各企事业单位，工会、共青团、妇联等群团组织，都要坚持中国共产党领导。</p><p>党的领导不是空洞的、抽象的，要在各方面各环节落实和体现。中国共产党是国家治理体系的核心。哪个领域、哪个方面、哪个环节缺失了弱化了，都会削弱党的力量，损害党和国家事业。党的领导，体现在党的科学理论和正确路线方针政策上，体现在党的执政能力和领导水平上，体现在党的政治判断力、政治领悟力、政治执行力上，同时也体现在党的严密组织体系和强大组织能力上。</p><p>一系列重大制度安排确保党对国家和社会实施领导的制度不断得到加强。从央企集团"党建入章"全面完成，"双向进入、交叉任职"和党委、书记、董事长"一肩挑"实现全覆盖，到全国各高校坚持和完善党委领导下的校长负责制，普遍修订党委常委会、校长办公会等制度，再到公立中小学、医院、科研院所逐步实现党组织领导下的校(院、所)长负责制......一系列重大制度举措推动党的领导制度纵到底、横到边，实现全覆盖、全贯穿、落实落地。</p><p>坚持党对一切工作的领导，不能只停留在口头表态上，必须落实到行动上，切实贯彻和体现到改革发展稳定、内政外交国防、治党治国治军各个领域各个方面，确保党始终总揽全局、协调各方。</p><p>坚持党的领导是方向性问题，必须旗帜鲜明、立场坚定，决不能羞羞答答、语焉不详，决不能遮遮掩掩、搞自我麻痹。</p><ul><li><p>提高党把方向、谋大局、定政策、促改革的能力</p><ul><li>坚持党的全面领导，既要政治过硬，也要本领高强。要着力提高党把方向、谋大局、定政策、促改革的能力和定力，善于处理各种复杂矛盾，勇于战胜各种艰难险阻，牢牢把握工作主动权，把党总揽全局、协调各方落到实处。</li></ul></li><li><p>方向涉及根本、关系全局、决定长远。着力提高党把方向的能力和定力。党的领导第一位的就是举旗定向。把方向就是要高举中国特色社会主义伟大旗帜，坚持以习近平新时代中国特色社会主义思想为指导，以高度自觉推进社会革命和自我革命，一以贯之坚持和发展中国特色社会主义，一以贯之推进党的建设新的伟大工程，一以贯之增强忧患意识、防范风险挑战。</p></li></ul><p>我们既不走封闭僵化的老路，也不走改旗易帜的邪路，要坚定不移走中国特色社会主义道路。全党要从伟大胜利中激发奋进力量，从弯路挫折中吸取历史教训，不为任何风险所惧，不为任何干扰所惑，决不在根本性问题上出现颠覆性错误。</p><p>不谋全局者不足谋一域。着力提高谋大局的能力和定力。不谋全局者不足谋一域，要善于观大势、谋大事，自觉在大局下想问题、做工作。要牢固树立大局意识，自觉把工作放到大局中去思考、定位、摆布，做到正确认识大局、自觉服从大局、坚决维护大局。制定和实施国民经济和社会发展五年规划，引领经济社会发展，是我们党治国理政的一种重要方式，是中国特色社会主义发展模式的重要体现，是中国共产党谋大局的重要表现。从1953年开始，我国已经编制实施了14个五年规划，对我们创造出世所罕见的经济快速发展奇迹和社会长期稳定奇迹，发挥了卓有成效的作用。</p><ul><li>政策是体现执政党性质宗旨的试金石，是反映治国理政水平的标志。</li></ul><p>着力提高定政策的能力和定力。在推进经济社会发展中，要坚持以人民为中心，着眼解决人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，抓住群众最关心最直接最现实的利益问题，制定切实管用的政策措施。中央一号文件：中共中央在1982年至1986年连续五年发布以农业、农村和农民为主题的中央一号文件，对农村改革和农业发展作出具体部署。2004年至2022年又连续19年发布以"三农"(农业、农村、农民)为主题的中央一号文件，强调了"三农"问题在中国社会主义现代化建设中"重中之重"的地位。</p><ul><li>改革开放是决定当代中国命运的关键一招。着力提高促改革的能力和定力。　改革开放是决定当代中国命运的关键一招，也是实现"两个一百年"奋斗目标、实现中华民族伟大复兴的关键一招。当前，全面深化改革已经进入新的阶段，必须一鼓作气、坚定不移，敢于啃硬骨头、敢于涉险滩，进一步解放思想、进一步解放和发展社会生产力、进一步解放和增强社会活力。</li></ul><p>党的十八届三中全会审议通过了《中共中央关于全面深化改革若干重大问题的决定》。</p><p>2013年12月30日，中共中央政治局召开会议，决定成立中央全面深化改革领导小组，负责改革总体设计、统筹协调、整体推进、督促落实。各级党委要切实履行对改革的领导责任。</p><p>党的十八届三中全会以来，习近平先后主持召开多次中央全面深化改革领导小组会议、中央全面深化改革委员会会议，历次会议围绕全面深化改革提出了一系列深化改革的理念和方法。特别是立足就业、教育和医疗等重要民生领域，秉持"人民至上"的价值理念，出实招、办实事，进行了卓有成效的改革。</p><h2id="三怎样才能做到自觉在思想上政治上行动上同党中央保持高度一致">三、怎样才能做到自觉在思想上政治上行动上同党中央保持高度一致</h2><h3 id="增强四个意识">增强"四个意识"</h3><ul><li>全党同志要增强政治意识、大局意识、核心意识、看齐意识，切实做到对党忠诚、为党分忧、为党担责、为党尽责。</li></ul><p>2016年10月，党的十八届六中全会正式确立习近平总书记党中央的核心、全党的核心地位，要求全党必须牢固树立"四个意识"。</p><ul><li>政治意识表现为坚定政治信仰，坚持正确的政治方向，坚持政治原则，站稳政治立场，保持政治清醒和政治定力，不断提高政治判断力、政治领悟力、政治执行力。</li></ul><p>我们党要始终做到不忘初心、牢记使命，把党和人民事业长长久久推进下去，必须增强政治意识，善于从政治上看问题，善于把握政治大局。</p><ul><li>大局意识就是要正确处理中央与地方、局部与全局、当前与长远的关系，自觉从党和国家大局出发想问题、办事情、抓落实，坚决贯彻落实中央决策部署，确保中央政令畅通。</li></ul><p>必须牢固树立高度自觉的大局意识，自觉从大局看问题，把工作放到大局中去思考、定位、摆布，做到正确认识大局、自觉服从大局、坚决维护大局。</p><ul><li>核心意识就是要始终坚持、切实加强党的领导，特别是党中央的集中统一领导，更加紧密地团结在以习近平同志为核心的党中央周围，更加坚定地维护党中央权威，更加自觉地在思想上政治上行动上同党中央保持高度一致。</li></ul><p>党的历史表明，必须有一个在实践中形成的坚强的中央领导集体，在这个领导集体中必须有一个核心。如果没有这样的领导集体和核心，党的事业就不能胜利。</p><ul><li>看齐意识就是要求向党中央看齐，向党的理论和路线方针政策看齐，向党中央决策部署看齐，做到党中央提倡的坚决响应、党中央决定的坚决执行、党中央禁止的坚决不做。</li></ul><p>毛泽东说："要知道，一个队伍经常是不大整齐的，所以就要常常喊看齐，向左看齐，向右看齐，向中看齐。我们要向中央基准看齐，向大会基准看齐。看齐是原则，有偏差是实际生活，有了偏差，就喊看齐。"</p><h3 id="做到两个维护">做到"两个维护"</h3><p>事在四方，要在中央。党中央是大脑和中枢。在思想上政治上行动上同党中央保持高度一致，是党性，是大局，关系党、民族、国家前途命运，任何时候任何情况下都不能含糊、不能动摇。</p><ul><li>"两个维护"：<ul><li>坚决维护习近平总书记党中央的核心、全党的核心地位，</li><li>坚决维护党中央权威和集中统一领导。</li></ul></li></ul><p>首先，确立和维护无产阶级政党的领导核心，始终是马克思主义建党学说的一个基本观点。</p><p>坚决维护习近平总书记党中央的核心、全党的核心地位。</p><p>一个国家、一个政党，领导核心至关重要。坚决维护习近平总书记党中央的核心、全党的核心地位，保证全党令行禁止，形成思想和行动高度统一的整体，这是一个成熟的马克思主义执政党的必然要求。</p><p>坚决维护习近平总书记党中央的核心、全党的核心地位，必须自觉同以习近平同志为核心的党中央保持高度一致，在思想上高度认同，政治上坚决维护，组织上自觉服从，行动上紧紧跟随，把"四个意识"落实到一言一行之中。</p><p>坚决维护习近平总书记党中央的核心、全党的核心地位，形成思想和行动高度统一的整体，是党和国家前途命运所系，是全国各族人民根本利益所在。</p><p>坚决维护党中央权威和集中统一领导。党和国家大政方针的决定权在党中央。历史表明，要治理好中国共产党这个大党、治理好中国这个大国，保证党的团结和集中统一至关重要，维护党中央权威至关重要。党的任何组织和成员必须以实际行动维护党中央的权威，必须服从党中央集中统一领导，这是党的领导的最高原则。</p><p>维护党中央权威和集中统一领导同坚持民主集中制是否矛盾?</p><p>维护党中央权威和集中统一领导同坚持民主集中制是完全一致的。首先，民主集中制包括民主和集中两个方面，两者互为条件、相辅相成、缺一不可。民主是正确集中的前提和基础，离开民主讲集中，集中就成了个人专权专断。集中是民主的必然要求和归宿，离开集中搞民主，就会导致极端民主化和无政府状态。</p><p>其次，中国共产党实行民主集中制。在充分发扬民主的基础上进行集中，坚持党中央权威和集中统一领导，集中全党智慧，体现全党共同意志，是党的一大创举。</p><p>最后，坚持党中央权威和集中统一领导，不是说不要民主集中制了，不要发扬党内民主了，而是体现了充分发扬民主基础上的正确集中，把这两者对立起来是不对的、有害的。</p><p>"两个维护"有明确的内涵和要求，维护习近平总书记党中央的核心、全党的核心地位，对象是习近平总书记而不是其他任何人；维护党中央权威和集中统一领导，对象是党中央而不是其他任何组织。维护党中央权威、向党中央看齐，这个逻辑不能层层推下去。核心只有党中央的核心，看齐只能向党中央看齐。</p><p>"两个维护"作为马克思主义建党学说的最新发展，实现了坚持党的领导与加强党的建设的有机统一，有效解决了过去党的领导虚化弱化的问题，确保党和国家事业始终保持正确政治方向。</p><p>课堂小结</p><p>中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势。党的领导是全面的、系统的、整体的。要增强"四个意识"，做到"两个维护"，自觉在思想上政治上行动上同党中央保持高度一致。</p><p>正如《中共中央关于党的百年奋斗重大成就和历史经验的决议》指出的，"只要我们坚持党的全面领导不动摇，坚决维护党的核心和党中央权威，充分发挥党的领导政治优势，把党的领导落实到党和国家事业各领域各方面各环节，就一定能够确保全党全军全国各族人民团结一致向前进"。</p><h1 id="第四讲-坚持以人民为中心">第四讲 坚持以人民为中心</h1><h2id="一为什么必须坚持以人民为中心">一、为什么必须坚持以人民为中心</h2><ul><li><p>人民是创造历史的动力</p></li><li><p>人民是真正的英雄。</p></li><li><p>党的历史伟业是人民创造的</p></li><li><p>党坚持走群众路线，群众路线始终是党的生命线和根本工作路线，是我们党永葆青春活力和战斗力的重要传家宝。</p></li><li><p>江山就是人民、人民就是江山</p></li><li><p>我国的政权是人民的政权，人民是中国共产党执政兴国的最大底气，人民是我们党的生命之根、执政之基、力量之源。</p></li><li><p>历史是最好的教科书，也是最好的清醒剂，赢得人民信任、得到人民支持，党就能够克服任何困难。反之，我们将一事无成，甚至走向衰败。</p></li><li><p>打江山、守江山，守的是人民的心</p></li><li><p>尊重人民群众的首创精神。人民群众实践与智慧，可以增长党的执政智慧，增强党的执政本领。</p></li></ul><h3 id="党依靠人民创造历史伟业">党依靠人民创造历史伟业</h3><ul><li><p>党依靠人民夺取新民主主义革命伟大胜利</p></li><li><p>党依靠人民完成社会主义革命和推进社会主义建设</p></li><li><p>党依靠人民进行改革开放和社会主义现代化建设</p></li><li><p>党依靠人民开创中国特色社会主义新时代</p></li></ul><h2id="二如何理解不断实现人民对美好生活的向往">二、如何理解不断实现人民对美好生活的向往</h2><h3id="人民立场是中国共产党的根本政治立场">人民立场是中国共产党的根本政治立场</h3><ul><li><p>人民立场是马克思主义政党区别于资产阶级政党的显著标志</p></li><li><p>全心全意为人民服务是党的根本宗旨</p></li><li><p>党性和人民性是高度一致的</p></li></ul><h3id="为中国人民谋幸福是中国共产党的初心">为中国人民谋幸福是中国共产党的初心</h3><ul><li><p>中国共产党是人民利益的忠实代表，这是中国共产党立于不败之地的根本所在</p></li><li><p>党始终把人民放在心中最高位置</p></li></ul><h3id="中国共产党为人民的美好生活而不懈奋斗">中国共产党为人民的美好生活而不懈奋斗</h3><ul><li><p>准确把握人民对美好生活的新期待，人民不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长；</p></li><li><p>把所有精力都用在让老百姓过好日子上</p></li><li><p>党带领人民继续创造美好生活，以人民为中心的发展思想，要全方位贯穿于经济社会发展的各个环节，体现在人民群众获得感、幸福感、安全感的扎实提升上</p></li></ul><h2id="三怎样推动人的全面发展全体人民共同富裕">三、怎样推动人的全面发展、全体人民共同富裕</h2><h3id="科学认识人的全面发展全体人民共同富裕">科学认识人的全面发展、全体人民共同富裕</h3><ul><li><p>实现人的全面发展是共产主义的基本原则</p></li><li><p>人的全面发展是中国特色社会主义的价值目标</p><ul><li>人的全面发展的基本内涵：人的社会关系的充分发展；人的能力的全面发展；人的个性的自由发展</li></ul></li><li><p>共同富裕是中国共产党人始终不渝的奋斗目标</p></li><li><p>共同富裕是中国特色社会主义的本质要求</p></li><li><p>共同富裕是中国式现代化的重要特征</p></li></ul><p>6、促进人的全面发展与促进共同富裕是高度统一的</p><h3id="必须推动全体人民共同富裕取得更为明显的实质性进展">必须推动全体人民共同富裕取得更为明显的实质性进展</h3><ul><li><p>是践行以人民为中心发展思想的必然要求</p></li><li><p>是更好满足人民日益增长的美好生活需要的重要着力点</p></li><li><p>是关系党的执政基础的重大政治问题</p></li><li><p>是解决我国发展不平衡不充分问题的现实需要</p></li><li><p>新时代推进共同富裕有了更加坚实的发展基础</p></li></ul><h3id="使全体人民朝着共同富裕目标扎实迈进">使全体人民朝着共同富裕目标扎实迈进</h3><ul><li><p>把握扎实推动共同富裕的基本原则：鼓励勤劳创新致富；掌握就业创业真本领，端上勤劳创新致富"金饭碗"；坚持基本经济制度；尽力而为，量力而行；坚持循序渐进</p></li><li><p>扎实推动共同富裕的总体思路：坚持以人民为中心的发展思想，在高质量发展中促进共同富裕，正确处理效率和公平的关系，构建初次分配、再分配、三次分配协调配套的基础性制度安排，加大税收、社保、转移支付等调节力度并提高精准性，扩大中等收入群体比重，增加低收入群体收入，合理调节高收入，取缔非法收入，形成中间大、两头小的橄榄型分配结构，促进社会公平正义，促进人的全面发展，使全体人民朝着共同富裕目标扎实迈进。</p></li><li><p>扎实推动共同富裕的重大举措：提高发展的平衡性、协调性、包容性；着力扩大中等收入群体规模；促进基本公共服务均等化；加强对高收入的规范和调节；促进人民精神生活共同富裕；促进农民农村共同富裕。</p></li><li><p>全体人民共同富裕是一个总体概念，要从全局上来看，是一个在动态中向前发展的过程，要持续推动，不断取得成效。</p></li></ul><h1 id="第五讲-以新发展理念引领高质量发展">第五讲以新发展理念引领高质量发展</h1><p>习近平经济思想是习近平新时代中国特色社会主义思想的重要组成部分，是运用马克思主义政治经济学基本原理对新时代经济发展实践作出的系统理论概括，是以习近平同志为核心的党中央治国理政实践创新和理论创新在经济领域的集中体现，是立足国情、放眼世界、引领未来的科学理论，是党和国家十分宝贵的精神财富，为做好新时代经济工作指明了正确方向、提供了根本遵循。</p><h2id="一如何把握新发展阶段贯彻新发展理念构建新发展格局">一、如何把握新发展阶段、贯彻新发展理念、构建新发展格局</h2><h3id="进入新发展阶段是中华民族伟大复兴历史进程的大跨越">进入新发展阶段是中华民族伟大复兴历史进程的大跨越</h3><ul><li>进入新发展阶段是我国经济发展的历史方位</li></ul><p>正确认识党和人民事业所处的历史方位和发展阶段，是我们党明确阶段性中心任务、制定路线方针政策的根本依据，也是我们党领导革命、建设、改革不断取得胜利的重要经验。</p><h4id="如何理解我国进入新发展阶段的基本依据">如何理解我国进入新发展阶段的基本依据？</h4><ul><li><p>理论依据：马克思主义是远大理想和现实目标相结合、历史必然性和发展阶段性相统一的统一论者，坚信人类社会必然走向共产主义，但实现这一崇高目标必然经历若干历史阶段。</p></li><li><p>历史依据：新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段。</p></li><li><p>现实依据：我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础。</p></li></ul><p>新发展阶段是社会主义初级阶段中的一个阶段。今天我们所处的新发展阶段，就是社会主义初级阶段中的一个阶段，同时是其中经过几十年积累、站到了新的起点上的一个阶段。全面建设社会主义现代化国家、基本实现社会主义现代化，既是社会主义初级阶段我国发展的要求，也是我国社会主义从初级阶段向更高阶段迈进的要求。</p><p>社会主义初级阶段，既不是一个静态、一成不变、停滞不前的阶段，也不是一个自发、被动、不用费多大气力自然而然就可以跨过的阶段，而是一个动态、积极有为、始终洋溢着蓬勃生机活力的过程和一个阶梯式递进、不断发展进步、日益接近质的飞跃的量的积累和发展变化的过程。</p><h4id="新发展阶段是全面建设社会主义现代化国家的阶段">新发展阶段是全面建设社会主义现代化国家的阶段</h4><ul><li>我国发展仍然处于重要战略机遇期</li></ul><p>经济方面的五个新机遇：加快经济结构优化升级带来新机遇；提升科技创新能力带来新机遇；深化改革开放带来新机遇；加快绿色发展带来新机遇；参与全球经济治理体系变革带来新机遇。</p><ul><li>国内外环境深刻变化带来的新挑战：<ul><li>国际环境日趋复杂，新冠肺炎疫情影响广泛深远，经济全球化遭遇逆流，世界进入新的动荡变革期，大国博弈日趋激烈，单边主义、保护主义、霸权主义对世界和平与发展构成威胁。</li><li>我国发展不平衡不充分问题仍然突出，重点领域关键环节改革任务仍然艰巨，创新能力不适应高质量发展等。</li></ul></li></ul><h3id="贯彻新发展理念是关系我国发展全局的一场深刻变革">贯彻新发展理念是关系我国发展全局的一场深刻变革</h3><ul><li><p>新发展理念是新时代我国经济发展的指导原则</p><ul><li>新发展理念的重大意义：<ul><li>十八大以来，我们党对经济社会发展提出了许多重大理论和理念，其中新发展理念是最重要、最主要的。</li><li>新发展理念是一个系统的理论体系：回答了关于发展的目的、动力、方式、路径等一系列理论和实践问题。阐明了我们党关于发展的政治立场、价值导向、发展模式、发展道路等重大政治问题。</li></ul></li></ul></li><li><p>新发展理念的提出背景</p></li></ul><p>新发展理念不是凭空得来的，是在深刻总结国内外发展经验教训、分析国内外发展大势的基础上形成的，集中反映了我们党对经济社会发展规律认识的深化，针对我国发展中的突出矛盾和问题。</p><ul><li><p>创新注重解决发展动力问题。创新是一个国家、一个民族发展进步的不竭动力。创新发展理念：抓住了创新，就抓住了牵动经济社会发展全局的"牛鼻子"。不断推进理论创新、制度创新、科技创新、文化创新等各方面创新。重大科技创新成果是国之重器、国之利器，必须牢牢掌握在自己手上，必须依靠自力更生、自主创新。</p></li><li><p>协调注重解决发展不平衡问题。协调发展理念：协调既是发展手段又是发展目标，同时还是评价发展的标准和尺度；注重发展的整体效能，否则"木桶"效应就会愈加显现，一系列社会矛盾会不断加深。</p></li><li><p>绿色注重解决人与自然和谐共生问题。绿色发展理念：坚定不移走生态优先、绿色发展之路，2030年前二氧化碳排放达到峰值，2060年前实现碳中和，建立健全绿色低碳循环发展经济体系，促进经济社会发展全面绿色转型。</p></li><li><p>开放注重解决发展内外联动问题。开放发展理念：对外开放是我国的基本国策，任何时候都不能动摇；经济全球化遇到一些回头浪，但开放合作仍然是历史潮流，互利共赢依然是人心所向；当今时代，任何关起门来搞建设的想法，任何拒人于千里之外的做法，都是逆历史潮流而动的。</p></li><li><p>共享注重解决社会公平正义问题。共享发展理念：改革发展搞得成功不成功，最终的判断标准是人民是不是共同享受到了改革发展成果；坚持全民共享、全面共享、共建共享、渐进共享，使全体人民有更多获得感、幸福感、安全感，朝着共同富裕方向稳步前进。</p></li></ul><h4id="如何完整准确全面贯彻新发展理念">如何完整、准确、全面贯彻新发展理念？</h4><ul><li><p>从根本宗旨把握新发展理念。为人民谋幸福、为民族谋复兴，这既是我们党领导现代化建设的出发点和落脚点，也是新发展理念的"根"和"魂"。</p></li><li><p>从问题导向把握新发展理念。突出问题和挑战：发展不平衡不充分的一些突出问题尚未解决，发展质量和效益还不高，创新能力不够强，实体经济水平有待提高，生态环境保护任重道远，民生领域还有不少短板，城乡区域发展和收入分配差距依然较大，群众在就业、教育、医疗、居住、养老等方面面临不少难题。</p></li><li><p>从忧患意识把握新发展理念。增强忧患意识，坚持底线思维；积极主动，未雨绸缪；见微知著，防微杜渐；下好先手棋，打好主动仗。</p></li></ul><h3id="构建新发展格局是把握发展主动权的战略性布局">构建新发展格局是把握发展主动权的战略性布局</h3><ul><li><p>构建新发展格局是我国经济发展的路径选择</p><p>-构建新发展格局的重大意义。构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，是根据我国发展阶段、环境、条件变化，特别是基于我国比较优势变化，审时度势作出的重大决策，是新发展阶段要着力推动完成的重大历史任务，也是贯彻新发展理念的重大举措。</p><ul><li><p>构建新发展格局的提出背景。改革开放前，我国经济以国内循环为主，进出口占国民经济的比重很小。改革开放以来，特别是加入世界贸易组织后，我国加入国际大循环，市场和资源"两头在外"，形成"世界工厂"发展模式，对我国快速提升经济实力、改善人民生活发挥了重要作用。</p></li><li><p>构建新发展格局是对我国客观经济规律的自觉把握。自2008年国际金融危机以来，我国经济已经向以国内大循环为主体转变，国内需求对经济增长的贡献率有多个年份超过100%。构建新发展格局是把握发展主动权的先手棋，不是被迫之举和权宜之计。</p></li><li><p>构建新发展格局的本质特征。改革开放以来，我们遭遇过很多外部风险冲击，最终都能化险为夷，靠的就是办好自己的事、把发展立足点放在国内。我们只有立足自身，把国内大循环畅通起来，努力炼就百毒不侵、金刚不坏之身，才能任由国际风云变幻，始终充满朝气生存和发展下去，没有任何人能打倒我们、卡死我们！</p></li></ul></li><li><p>把握扩大内需战略基点</p><ul><li><p>加快培育完整内需体系。市场资源是我国的巨大优势：我国具有全球最完整、规模最大的工业体系；有强大的生产能力、完善的配套能力；拥有1亿多市场主体和-7亿多受过高等教育或拥有各类专业技能的人才；还有包括4亿多中等收入群体在内的14亿多人口所形成的超大规模内需市场。</p></li><li><p>加快建设全国统一大市场。主要目标：持续推动国内市场高效畅通和规模拓展；加快营造稳定公平透明可预期的营商环境；进一步降低市场交易成本；促进科技创新和产业升级；培育参与国际竞争合作新优势。</p></li></ul></li><li><p>以国内大循环为主体、国内国际双循环相互促进</p><ul><li><p>畅通国内大循环。依托强大国内市场；形成需求牵引供给、供给创造需求的更高水平动态平衡；贯通生产、分配、流通、消费各环节；促进国民经济良性循环。</p></li><li><p>国内国际双循环相互促进。构建新发展格局，绝不是关起门来搞国内循环。顺应经济全球化的历史潮流，坚定不移全面扩大开放，推动建设开放型世界经济。以国际循环提升国内大循环效率和水平，改善国内生产要素质量和配置水平。通过参与国际市场竞争，增强出口产品和服务竞争力.推动国内产业转型升级，增强我国在全球产业链供应链创新链中的影响力。</p></li></ul></li><li><p>新发展阶段、新发展理念、新发展格局紧密关联</p></li></ul><p>进入新发展阶段：历史方位和现实依据；贯彻新发展理念：指导原则和行动指南；构建新发展格局：路径选择和战略选择。</p><h2id="二如何理解我国经济转向高质量发展">二、如何理解我国经济转向高质量发展</h2><h3 id="我国经济发展进入新常态">我国经济发展进入新常态</h3><ul><li><p>进入新常态的判断依据</p><ul><li><p>从时间上看，新常态是我国不同发展阶段更替变化的结果。我国经济发展正处于增长速度换挡期、结构调整阵痛期和前期刺激政策消化期。经济发展面临着速度换挡节点、结构调整节点和动力转换节点。</p></li><li><p>从空间上看，新常态是我国出口优势和参与国际产业分工模式变化的体现。维持出口高增长、出口占国内生产总值的高比例已不大可能，必须把经济增长动力更多放在创新驱动和扩大内需特别是消费需求上。</p></li></ul></li><li><p>新常态下我国经济发展的特点和趋势。</p><ul><li><p>新常态下我国经济发展的主要特点</p></li><li><p>中国经济发展进入新常态主要特征：</p><ul><li>一是增长速度从高速增长转为中高速增长；</li><li>二是发展方式由规模速度型向质量效率型转变；</li><li>三是经济结构由增量扩能为主转向调整存量做优增量并举转变；</li><li>四发展动力由是从主要依靠资源和低成本劳动力等要素投入转向创新驱动。</li></ul></li></ul></li></ul><p>新常态下我国经济发展大势。经济发展长期向好的基本面；经济结构调整优化的前进态势；经济韧性好、潜力足、回旋余地大的基本特质；经济持续增长的良好支撑基础和条件。</p><ul><li>转向高质量发展</li></ul><p>高质量发展是从"有没有"转向"好不好"，是能够很好满足人民日益增长的美好生活需要的发展，是体现新发展理念的发展。</p><p>推动高质量发展的必要性：推动高质量发展是保持经济持续健康发展的必然要求，只有推动高质量发展，才能适应科技新变化、人民新需要，形成优质高效多样化的供给体系，提供更多优质产品和服务，在新的水平上实现供求均衡和经济持续健康发展。</p><p>推动高质量发展是适应我国社会主要矛盾变化的必然要求。我国经济发展阶段也在发生历史性变化，不平衡不充分的发展就是发展质量不高的表现，发展中的矛盾和问题主要就集中在发展质量上。解决我国社会的主要矛盾，必须把发展质量摆在更为突出的位置，着力提升发展质量和效益，推动高质量发展。我们既要重视量的发展，更要重视解决质的问题，在质的大幅度提升中实现量的有效增长。</p><p>推动高质量发展是遵循经济发展规律的必然要求。经济发展是一个螺旋式上升的过程，上升不是线性的，量积累到一定阶段，必须转向质的提升，我国经济发展要遵循这一规律。20世纪60年代以来，全球100多个中等收入经济体中只有十几个成为高收入经济体。那些取得成功的国家和地区，都是在经历高速增长阶段后实现了经济发展从量的扩张转向质的提高。那些徘徊不前甚至倒退的国家和地区，都是没有实现这种根本性转变。只有通过高质量发展，实现投资有回报、企业有利润、员工有收入、政府有税收，实现生产、流通、分配、消费循环通畅，国民经济重大比例关系和空间布局比较合理，经济发展比较平衡，不出现大的起落，才能逐步进入高收入经济体行列。</p><h3 id="以供给侧结构性改革为主线">以供给侧结构性改革为主线</h3><ul><li><p>供给侧结构性改革的提出依据</p><ul><li><p>供给侧管理和需求侧管理。供给侧管理重在解决结构性问题；需求侧重在解决总量性问题。</p></li><li><p>供给侧结构性改革的提出。当前和今后一个时期，我国经济发展面临的问题，供给和需求两侧都有，但矛盾的主要方面在供给侧。解决结构性问题，必须把改善供给侧结构作为主攻方向，实现由低水平供需平衡向高水平供需平衡跃升。</p></li></ul></li><li><p>完整准确理解供给侧结构性改革</p><ul><li><p>供给侧结构性改革的内涵和目的</p><ul><li>内涵：增强供给侧结构对需求变化的适应性、灵活性，不断让新的需求催生新的供给，让新的供给创造新的需求，在相互推动中实现经济发展。</li><li>目的：使我国供给能力更好满足广大人民日益增长的美好生活需要，从而实现社会主义生产目的。</li></ul></li></ul></li></ul><p>供给侧结构性改革不是西方"供给学派"的翻版。西方供给学派兴起于上世纪70年代，以"拉弗曲线"为代表思想，主张重点是减税，过分突出税率作用，思想方法比较绝对，只注重供给而忽视需求，只注重市场功能而忽视政府作用。供给侧结构性改革既强调供给又关注需求，既突出发展社会生产力又注重完善生产关系，既发挥市场在资源配置中的决定性作用又更好发挥政府作用，既着眼当前又立足长远。</p><ul><li><p>深化供给侧结构性改革的意义与方向</p><ul><li><p>供给侧结构性改革的必要性。适应把握引领经济发展新常态的重大创新；适应国际金融危机发生后综合国力竞争新形势的主动选择；推动我国经济实现高质量发展的必然要求。</p></li><li><p>推进供给侧结构性改革是一场硬仗。大力破除无效供给；大力培育新动能；大力降低实体经济成本。例如2021年全国粗钢产量同比减少近3000万吨，引导钢铁企业摒弃以量取胜的粗放发展方式，促进钢铁行业高质量发展。</p></li><li><p>深化供给侧结构性改革的八字方针：巩固、增强、提升、畅通。巩固"三去一降一补"成果，推动更多产能过剩行业加快出清，降低全社会各类营商成本，加大基础设施等领域补短板力度；增强微观主体活力，发挥企业和企业家主观能动性，建立公平开放透明的市场规则和法治化营商环境，促进正向激励和优胜劣汰，发展更多优质企业；提升产业链水平，注重利用技术创新和规模效应形成新的竞争优势，培育和发展新的产业集群。畅通国民经济循环，加快建设统一开放、竞争有序的现代市场体系，提高金融体系服务实体经济能力，形成国内市场和生产主体、经济增长和就业扩大、金融和实体经济良性循环。</p></li></ul></li><li><p>建设现代化经济体系</p><ul><li><p>现代化经济体系的内容。现代化经济体系是由社会经济活动各个环节、各个层面、各个领域的相互关系和内在联系构成的一个有机整体。创新引领、协同发展的产业体系；统一开放、竞争有序的市场体系；体现效率、促进公平的收入分配体系；彰显优势、协调联动的城乡区域发展体系；资源节约、环境友好的绿色发展体系；多元平衡、安全高效的全面开放体系；充分发挥市场作用、更好发挥政府作用的经济体制。</p></li><li><p>建设现代化经济体系的重点举措。筑牢坚实基础，大力发展实体经济；强化战略支撑，实施创新驱动发展战略；夯实重要基础，实施乡村振兴战略；优化空间布局，实施区域协调发展战略；提高国际竞争力，着力发展开放型经济；完善制度保障，深化经济体制改革。</p></li></ul></li></ul><h2id="三如何坚持和完善社会主义基本经济制度">三、如何坚持和完善社会主义基本经济制度</h2><h3id="社会主义基本经济制度是我国经济发展的制度基础">社会主义基本经济制度是我国经济发展的制度基础</h3><ul><li>社会主义基本经济制度的发展。社会主义革命和建设时期，通过社会主义改造，建立了以公有制和按劳分配为基础的社会主义经济制度。改革开放和社会主义现代化建设新时期，逐步确立了公有制为主体、多种所有制经济共同发展的基本经济制度，按劳分配为主体、多种分配方式并存的基本分配制度，实现了从计划经济体制到社会主义市场经济体制的历史性转变。进入新时代，党的十九届四中全会将公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等作为社会主义基本经济制度。</li></ul><p>党的十九届四中全会第一次从所有制结构、分配制度、资源配置方式等方面阐述了我国基本经济制度的内涵，把我们党对社会主义基本经济制度的认识提高到一个新境界。</p><ul><li>社会主义基本经济制度的科学内涵：所有制结构是以公有制为主体、多种所有制经济共同发展；分配制度是以按劳分配为主体、多种分配方式并存；经济体制是社会主义市场经济体制。</li></ul><p>我国基本经济制度是中国特色社会主义制度的重要支柱，既体现了社会主义制度的优越性，又同我国社会主义初级阶段社会生产力发展水平相适应，既有利于激发各类市场主体活力、解放和发展社会生产力，又有利于促进效率和公平有机统一、推动全体人民共同富裕。</p><h3id="坚持公有制为主体多种所有制经济共同发展">坚持公有制为主体、多种所有制经济共同发展</h3><ul><li>毫不动摇巩固和发展公有制经济。</li></ul><p>生产资料所有制是生产关系的核心，决定着社会的基本性质和发展方向。国有企业是中国特色社会主义的重要物质基础和政治基础，关系公有制主体地位的巩固，关系我们党的执政地位和执政能力，关系我国社会主义制度。</p><p>公有制经济为国家建设、国防安全、人民生活改善作出了突出贡献。公有制主体地位、国有经济主导作用是我国各族人民共享发展成果的制度性保证，也是巩固党的执政地位、坚持我国社会主义制度的重要保证。</p><p>支持国有资本和国有企业做强做优做大；建立中国特色现代企业制度；增强国有经济竞争力、创新力、控制力、影响力、抗风险能力。</p><ul><li>毫不动摇鼓励、支持、引导非公有制经济发展。</li></ul><p>生产资料所有制是生产关系的核心，决定着社会的基本性质和发展方向。非公有制经济是稳定经济的重要基础，是国家税收的重要来源，是技术创新的重要主体，是金融发展的重要依托，是经济持续健康发展的重要力量。构建亲清政商关系，促进非公有制经济健康发展和非公有制经济人士健康成长。民营经济是社会主义市场经济发展的重要成果，也是我们党长期执政、团结带领全国人民实现"两个一百年"奋斗目标和中华民族伟大复兴中国梦的重要力量。贡献了50%以上的税收，60%以上的国内生产总值，70%以上的技术创新成果，80%以上的城镇劳动就业，90%以上的企业数量。</p><h3id="坚持按劳分配为主体多种分配方式并存">坚持按劳分配为主体、多种分配方式并存</h3><p>要发挥分配的功能和作用。要处理好效率和公平关系，构建初次分配、再分配、三次分配协调配套的基础性制度安排。</p><ul><li>中国特色社会主义初次分配------完善制度、规范秩序。</li></ul><p>社会总产品在生产资料所有者、劳动者和国家间的分配，表现为利润、劳动报酬和流转税等；坚持按劳分配主体地位，增加劳动者特别是一线劳动者劳动报酬，提高劳动报酬在初次分配中的比重；完善按要素分配体制机制，允许一部分人靠诚实劳动和合法经营先富起来。</p><ul><li>中国特色社会主义再分配------统筹兼顾、公平合理。</li></ul><p>履行好政府再分配调节职能；强化税收调节，合理调节城乡、区域、不同群体间的分配关系；合理调节过高收入，清理规范不合理收入；强化互助共济功能，把更多人纳入社会保障体系；加大对革命老区、民族地区、边疆地区、欠发达地区的转移支付。</p><ul><li>中国特色社会主义三次分配------鼓励引导、自觉自愿。</li></ul><p>发挥第三次分配作用，发展慈善等社会公益事业；加强公益慈善事业规范管理，鼓励高收入人群和企业更多回报社会；提升社会公益事业透明度，推动社会公益资源配置更加公平公正。</p><h3 id="加快完善社会主义市场经济体制">加快完善社会主义市场经济体制</h3><ul><li><p>完善社会主义市场经济体制的核心问题是处理好政府和市场关系。</p><ul><li><p>有效的市场，有为的政府。市场配置资源的决定性作用：市场配置资源是最有效率的形式，市场决定资源配置是市场经济的一般规律，市场经济本质上就是市场决定资源配置的经济。更好发挥政府作用：保持宏观经济稳定，优化公共服务，保障公平竞争，加强市场监管，维护市场秩序，推动可持续发展，促进共同富裕，弥补市场失灵。</p></li><li><p>用好"看不见的手"和"看得见的手"。市场即"看不见的手"：要坚持使市场在资源配置中起决定性作用，完善市场机制，打破行业垄断、进入壁垒、地方保护，增强企业对市场需求变化的反应和调整能力，提高企业资源要素配置效率和竞争力。政府即"看得见的手"：要更好发挥政府作用，在尊重市场规律的基础上，用改革激发市场活力，用政策引导市场预期，用规划明确投资方向，用法治规范市场行为。</p></li><li><p>发挥社会主义市场经济体制优势的内在要求。我国实行的是社会主义市场经济体制，仍然要坚持发挥社会主义制度的优越性、发挥党和政府的积极作用。科学的宏观调控、有效的政府治理，是发挥社会主义市场经济体制优势的内在要求。</p></li><li><p>正确认识和把握资本的特性和行为规律，为资本设置"红绿灯"。</p></li></ul></li></ul><p>资本是社会主义市场经济的重要生产要素，在社会主义市场经济条件下规范和引导资本发展，既是一个重大经济问题、也是一个重大政治问题，既是一个重大实践问题、也是一个重大理论问题。</p><p>资本是带动各类生产要素集聚配置的重要纽带，要促进各类资本良性发展、共同发展，发挥资本发展生产力、创造社会财富、增进人民福祉的作用，各类资本都不能横冲直撞，要防止有些资本野蛮生长，不让"资本大鳄"恣意妄为，要反垄断、反暴利、反天价、反恶意炒作、反不正当竞争。</p><h1 id="第六讲-全面深化改革">第六讲 全面深化改革</h1><h2 id="一为什么要全面深化改革">一、为什么要全面深化改革</h2><h3id="改革开放是决定当代中国前途命运的关键一招">改革开放是决定当代中国前途命运的关键一招</h3><ul><li><p>建立中国共产党、成立中华人民共和国、推进改革开放和中国特色社会主义事业是五四运动以来我国发生的三大历史性事件，是近现代以来实现中华民族伟大复兴的三大里程碑。</p></li><li><p>改革开放推动了中国特色社会主义事业的伟大飞跃；走出了中华民族伟大复兴的正确道路。</p></li><li><p>如何理解改革开放是决定当代中国命运和实现中华民族伟大复兴的关键一招？</p><ul><li>改革开放可以解决好生产力和生产关系的矛盾，解放和发展生产力；解决好经济基础和上层建筑的矛盾，完善和发展社会主义制度；进行广泛而深刻的社会变革，推动走出一条中国式现代化道路；吸收人类一切优秀文明成果，创造人类文明新形态</li><li>改革开放44年取得辉煌成就</li><li>改革开放是当代中国最壮丽的气象</li></ul></li><li><p>改革进入攻坚期和深水区</p><ul><li>原因：<ul><li>好吃的肉都吃掉了，剩下的都是硬骨头</li><li>矛盾交织叠加，单项改革难奏效</li><li>新形势新挑战，提出新的改革任务</li><li>产业结构不合理</li><li>科技创新能力不强</li></ul></li></ul></li><li><p>对策：</p><ul><li>只有全面深化改革，才能赢得主动</li><li>新时代坚持和发展中国特色社会主义，根本动力仍然是全面深化改革</li><li>在更高起点、更高层次、更高目标上推进全面深化改革，将改革开放进行到底。</li></ul></li><li><p>什么是"全面"深化改革</p><ul><li>改革目标的总体性：完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化</li><li>改革领域的全面性改革机制的系统性</li></ul></li><li><p>为何要"全面"深化改革</p><ul><li>我们的主要历史任务是完善和发展中国特色社会主义制度，为党和国家事业发展、为人民幸福安康、为社会和谐稳定、为国家长治久安提供一整套更完备、更稳定、更管用的制度体系。这项工程极为宏大，零敲碎打调整不行,碎片化修补也不行，必须是全面的系统的改革和改进，是各领域改革和改进的联动和集成，在国家治理体系和治理能力现代化上形成总体效应、取得总体效果。</li></ul></li><li><p>要敢于啃硬骨头、敢于涉险滩</p></li></ul><p>全面领导、统筹各方：中央全面深化改革委员会负责对改革总体设计、统筹协调、整体推进、督促落实。</p><h2 id="二怎样推进全面深化改革">二、怎样推进全面深化改革</h2><h3 id="坚持全面深化改革总目标">坚持全面深化改革总目标</h3><ul><li><p>党的十八届三中全会对全面深化改革作出顶层设计和全面部署，提出了全面深化改革的总目标：完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化</p></li><li><p>深刻理解和准确把握全面深化改革的总目标</p><ul><li><p>完善和发展中国特色社会主义制度，赋予社会主义新的生机活力，提供一套更完备、更稳定、更管用的制度体系；最核心是坚持和改善党的领导、坚持和完善中国特色社会主义制度</p></li><li><p>推进国家治理体系和治理能力现代化</p></li></ul></li><li><p>原因：国家治理体系和治理能力还有许多亟待改进的地方；制度还没有达到更加成熟更加定型的要求；有些地方甚至成为制约发展和稳定的重要因素</p></li><li><p>强调：推进国家治理体系和治理能力现代化，</p><ul><li><p>一是不等于西方化------"治理"概念并非西方现代政治文明的专利，我国的治理体系和治理能力现代化是建立在中国特色社会主义制度基础之上的。</p></li><li><p>二是不等于资本主义化；西方的治理体系和治理能力现代化以资本为中心，我国的治理体系和治理能力现代化以人民为中心。</p></li><li><p>必须是全面的系统的改革和改进，形成总体效应、取得总体效果</p></li><li><p>要不断提升国家治理本领。国家治理体系和国家治理能力是一个国家制度和制度执行力的集中体现，两者相辅相成，不能单靠其中一个治理国家。</p></li><li><p>全面深化改革是有方向、有立场、有原则的</p></li><li><p>改革是在中国特色社会主义道路上不断前进</p></li><li><p>完善和发展中国特色社会主义制度，规定了全面深化改革的根本方向，就是走中国特色社会主义道路，而不是其他什么道路；</p></li><li><p>推进国家治理体系和治理能力现代化，规定了在根本方向指引下完善和发展中国特色社会主义制度的鲜明指向。</p></li><li><p>加强党对全面深化改革的集中统一领导，这是全面深化改革取得成功的关键，党要总揽全局、协调各方</p></li><li><p>坚持市场经济改革的社会主义方向：发挥经济体制改革的牵引作用；完善社会主义市场经济体制</p></li><li><p>必须以促进社会公平正义、增进人民福祉为出发点和落脚点</p></li><li><p>许多领域实现历史性变革、系统性重塑、整体性重构</p><p>党的十八届三中全会开启了全面深化改革、系统整体设计推进改革的新时代，实现了改革开放由局部探索、破冰突围到系统集成、全面深化的转变；</p></li><li><p>全面深化改革不是某个领域某个方面的单项改革</p></li></ul></li></ul><p>做到"六个紧紧围绕"：</p><ul><li><p>紧紧围绕使市场在资源配置中起决定性作用深化经济体制改革；</p></li><li><p>紧紧围绕坚持党的领导、人民当家作主、依法治国有机统一深化政治体制改革；</p></li><li><p>紧紧围绕建设社会主义核心价值体系、社会主义文化强国深化文化体制改革；</p></li><li><p>紧紧围绕更好保障和改善民生、促进社会公平正义深化社会体制改革；</p></li><li><p>紧紧围绕建设美丽中国深化生态文明体制改革；</p></li><li><p>紧紧围绕提高科学执政、民主执政、依法执政水平深化党的建设制度改革。</p></li></ul><p>党的十九届四中全会，对坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化作出总体擘画。</p><ul><li>改革的系统集成主要体现：<ul><li>加强顶层设计和总体规划；</li><li>注重系统性、整体性、协同性；</li><li>从"五位一体"总体布局和党的制度建设上整体推进。</li></ul></li><li>党的十八大以来，党和国家组织结构实现系统性、整体性重构</li></ul><h2 id="三如何构建对外开放新格局">三、如何构建对外开放新格局</h2><h3 id="实行更加积极主动的开放战略">实行更加积极主动的开放战略</h3><ul><li><p>开放是当代中国的鲜明标识</p></li><li><p>党的十八大以来，我国采取了更加积极主动的开放战略</p></li></ul><p>主动开放、双向开放、全面开放、公平开放、共赢开放、包容开放</p><ul><li><p>党的十八大以来，我国对外开放水平持续提升</p></li><li><p>我国对外开放正面临着逆全球化的挑战，但中国对外开放的大门只会越开越大</p></li><li><p>构建互利共赢、多元平衡、安全高效的开放型经济体系</p></li></ul><p>全新的开放型经济体系：扩内需和增外需相互动；引进来"和"走出去"并举；促开放和护安全统筹；规则、规制、管理、标准等制度型开放</p><h3 id="推动共建一带一路高质量发展">推动共建"一带一路"高质量发展</h3><ul><li><p>坚持共商共建共享原则：不打地缘博弈小算盘；不搞封闭排他小圈子；不做凌驾于人的强买强卖</p></li><li><p>基础设施更加通畅</p></li><li><p>合作层次进一步提升</p></li><li><p>政策对接更加顺畅</p></li><li><p>人文交流更加深入</p></li><li><p>围绕经济发展、民生改善和文明进步，建设和平之路、繁荣之路、开放之路、绿色之路、创新之路、文明之路。</p></li></ul><h1 id="第七讲-发展全过程人民民主">第七讲 发展全过程人民民主</h1><h2 id="一什么是全过程人民民主">一、什么是全过程人民民主</h2><h3 id="民主是一种国家形式">民主是一种国家形式</h3><ul><li><p>民主是一种阶级统治的国家制度，是统治阶级用来实现其阶级利益的政治形式和手段。</p></li><li><p>古希腊雅典民主：实质是奴隶主的民主制，是奴隶主对奴隶的统治。</p></li></ul><blockquote><p>近现代的西方资本主义民主：资产阶级的阶级本质决定其民主是虚假的民主，是资产阶级维护其统治的工具。社会主义民主：在人类历史上第一次实现多数人对少数人的统治，它不同于以往的一切少数剥削阶级占统治地位的国家的民主。</p></blockquote><ul><li><p>为什么说社会主义民主是一种新的民主类型？</p><ul><li><p>资本主义民主：建立在生产资料私有制的经济基础之上；关注政治权利和政治平等，却无视人民群众经济权利平等，反对实行经济平等和社会平等；私人资本和权势集团控制公共权力；民主形式与实质相背离；实质是资产阶级的专政。</p></li><li><p>社会主义民主：建立在以生产资料公有制为主体的经济基础之上；不仅要实现全体人民的政治民主，还要实现人民群众的经济权利和社会权利；国家一切权力属于人民；民主内容和形式是一致的；实质是人民当家作主。</p></li><li><p>社会主义民主的实质是人民当家作主，人民当家作主是社会主义民主政治的本质和核心。</p></li></ul></li><li><p>怎样评价民主？</p><ul><li><p>从主体看，民主应该由这个国家的人民来评判；</p></li><li><p>从功效看，民主要用来解决人民需要解决的问题；</p></li><li><p>从标准看，民主作为一种国家制度，有其基本的评价依据。</p></li></ul></li><li><p>人民民主是社会主义的生命,没有民主就没有社会主义,就没有社会主义的现代化,就没有中华民族伟大复兴。</p></li></ul><h3id="全过程人民民主是全链条全方位全覆盖的民主">全过程人民民主是全链条、全方位、全覆盖的民主</h3><ul><li><p>具有完整的制度程序和完整的参与实践</p></li><li><p>在领域上，全过程人民民主涵盖经济、政治、文化、社会、生态文明等各个方面；以多样、畅通、有序的民主渠道，充分调动各地区、各民族、各方面、各阶层的积极性主动性创造性；充分发挥各级国家机关和武装力量、各政党和各社会团体、各企业事业组织的作用。</p></li><li><p>在环节上，人民民主具体地、生动地体现在人民当家作主的全过程各环节，民主选举、民主协商、民主决策、民主管理、民主监督，五个环节，环环相扣，内在统一，形成全过程人民民主的完整链条。</p></li><li><p>在形式和特点上，人民通过选举、投票行使权利和人民内部各方面在重大决策之前进行充分协商，尽可能就共同性问题取得一致意见。</p></li><li></li><li><p>在实际效果上，实现了过程民主和成果民主、程序民主和实质民主、直接民主和间接民主、人民民主和国家意志相统一。</p></li><li><p>党的领导是根本保证。中国共产党的领导，是中国发展全过程人民民主的根本保证。</p></li></ul><h2 id="二全过程人民民主好在哪里">二、全过程人民民主好在哪里</h2><h3 id="人民民主参与不断扩大">人民民主参与不断扩大</h3><ul><li><p>民主参与的形式不断创新、渠道不断拓展</p></li><li><p>人民参与的广度和深度不断拓展</p></li><li><p>人民利益要求畅通表达</p></li><li><p>人民利益要求得到回应</p></li></ul><h3 id="国家治理高效">国家治理高效</h3><ul><li><p>充分彰显人民的主体地位</p></li><li><p>有效调节国家政治关系</p></li><li><p>把党的主张、国家意志、人民意愿紧密融合在一起</p></li><li><p>始终把中国人民利益放在第一位</p></li></ul><h3 id="社会和谐稳定">社会和谐稳定</h3><ul><li>人民民主是中国社会进步的推进器和润滑剂</li></ul><h3 id="权力运用得到有效制约和监督">权力运用得到有效制约和监督</h3><ul><li><p>权力是一把"双刃剑"。权力在有效制约和监督下运行才能实现民主、造福人民；权力失去约束、恣意妄为必然破坏民主、危害人民。</p></li><li><p>人民民主监督的形式和成效不断拓展深化。</p></li><li><p>民主好不好，实践最有说服力，人民最有发言权。</p></li></ul><h2id="三如何进一步发展全过程人民民主">三、如何进一步发展全过程人民民主</h2><h3id="坚持走中国特色社会主义政治发展道路">坚持走中国特色社会主义政治发展道路</h3><ul><li>坚持党的领导、人民当家作主、依法治国有机统一。</li></ul><p>核心是坚持党的领导，党的领导是人民当家作主和依法治国的根本保证。人民当家做主是社会主义民主政治的本质特征。依法治国是党领导人民治理国家的基本方式。三者有机统一。</p><ul><li>绝不照搬西方政治制度模式。</li></ul><p>西方民主概念陷阱：概念泛化、价值矮化、原理神化、模式幻化。"照搬"无用、"照搬"危险、不用"照搬"。</p><ul><li>中国特色社会主义政治制度。</li></ul><p>是源于历史、根植民意的制度选择；是彰显民主、凝聚共识的制度设计；是中国发展、中国梦想的制度保障。</p><h3 id="健全人民当家作主制度体系">健全人民当家作主制度体系</h3><ul><li>充分发挥人民代表大会制度的重要制度载体作用。</li></ul><p>坚持党的领导、保证人民权利、完善平台载体、讲好民主故事。</p><ul><li>增加和扩大制度的优势和特点。</li></ul><p>坚持党的领导核心作用、坚持国家一切权力属于人民、坚持和完善多党合作和政治协商制度、坚持和完善民族区域自治制度、坚持和完善基层群众自治制度、坚持和完善民主集中制的制度和原则。</p><h3id="推进社会主义协商民主广泛多层制度化发展">推进社会主义协商民主广泛多层制度化发展</h3><ul><li><p>发挥社会主义协商民主的独特优势。</p></li><li><p>巩固和发展最广泛的爱国统一战线。</p></li></ul><h3id="把人民当家作主具体地现实地体现出来">把人民当家作主具体地、现实地体现出来</h3><ul><li><p>我们要继续推进全过程人民民主建设，把人民当家作主具体地、现实地体现到党治国理政的政策措施上来。</p></li><li><p>我们要继续推进全过程人民民主建设，具体地、现实地体现到党和国家机关各个方面各个层级工作上来。</p></li><li><p>我们要继续推进全过程人民民主建设，具体地、现实地体现到实现人民对美好生活向往的工作上来。</p></li></ul><h1 id="第八讲-全面依法治国">第八讲 全面依法治国</h1><h2 id="一为什么要全面推进依法治国">一、为什么要全面推进依法治国</h2><p>习近平法治思想的内容"十一个坚持"</p><ul><li><p>坚持党对全面依法治国的领导</p></li><li><p>坚持以人民为中心</p></li><li><p>坚持中国特色社会主义法治道路</p></li><li><p>坚持依宪治国、依宪执政</p></li><li><p>坚持在法治轨道上推进国家治理体系和治理能力现代化</p></li><li><p>坚持建设中国特色社会主义法治体系</p></li><li><p>坚持依法治国、依法执政、依法行政共同推进，法治国家、法治政府、法治社会一体建设</p></li><li><p>坚持全面推进科学立法、严格执法、公正司法、全民守法</p></li><li><p>坚持统筹推进国内法治和涉外法治</p></li><li><p>坚持建设德才兼备的高素质法治工作队伍</p></li><li><p>坚持抓住领导干部这个"关键少数"</p></li><li><p>法治固根本、稳预期、利长远</p></li><li><p>法治固根本。</p></li></ul><p>法治对于国家制度和治理体系具有"固根本"的保障作用。</p><ul><li>法治稳预期。</li></ul><p>在法治框架内活动，在法治轨道上运行，有利于全社会稳定预期、增强信心。</p><ul><li>法治利长远。</li></ul><p>法治是经验的总结、规律的反映、社会的共识，是制度之治最基本最稳定最可靠的保障。</p><ul><li><p>中国特色社会主义的本质要求和重要保障</p></li><li><p>法治保障人民当家作主。</p></li><li><p>法治保障党和国家长治久安。</p></li><li><p>国家治理的一场深刻革命</p></li><li><p>党对法治理论和实践的探索逐步深化。</p></li><li><p>解决党和国家事业发展中重大问题的根本要求</p></li></ul><h2id="二如何理解全面依法治国的总目标">二、如何理解全面依法治国的总目标</h2><h3 id="从依法治国到全面依法治国">从"依法治国"到"全面依法治国"</h3><ul><li><p>从"依法治国"到"全面依法治国"的历史发展脉络。</p></li><li><p>从"依法治国"到"全面依法治国"的全面升级。</p></li><li><p>全面依法治国。</p><p>-全方位：法律规范体系、法治实施体系、法治监督体系、法治保障体系、党内法规体系。</p><ul><li><p>全层次：依法治国、依法执政、依法行政共同推进；法治国家、法治政府、法治社会一体建设。</p></li><li><p>全过程：科学立法、严格执法、公正司法、全民守法。</p></li></ul></li></ul><h3 id="全面依法治国的总目标">全面依法治国的总目标</h3><ul><li><p>全面依法治国的总目标是建设中国特色社会主义法治体系、建设社会主义法治国家。</p></li><li><p>全面推进依法治国总抓手，就是建设中国特色社会主义法治体系。</p></li><li><p>什么是中国特色社会主义法治体系。完备的法律规范体系、高效的法治实施体系、严密的法治监督体系、有力的法治保障体系、完善的党内法规体系。</p></li></ul><h3 id="坚持依宪治国依宪执政">坚持依宪治国、依宪执政</h3><ul><li><p>宪法是治国理政的总章程。</p></li><li><p>我国宪法的社会主义性质。</p></li><li><p>为什么我们不能跟着西方所谓的"宪政"跑？</p><ul><li><p>坚持依宪治国、依宪执政，就包括坚持宪法确定的中国共产党领导地位不动摇，坚持宪法确定的人民民主专政的国体和人民代表大会制度的政体不动摇。</p></li><li><p>拿西方"宪政"的标准来框住我们，用所谓"宪政"架空中国共产党领导、攻击我们不是"宪政国家""法治国家"。以任何借口否定中国共产党领导和社会主义根本制度，都是错误的、有害的，都是绝对不能接受的，也是从根本上违反宪法的。</p></li></ul></li><li><p>全面贯彻实施宪法。宪法的生命在于实施，宪法的权威也在于实施。</p></li><li><p>推动合宪性审查工作。维护宪法权威。</p></li><li><p>深入开展宪法宣传教育。加强宪法学习宣传教育是实施宪法的重要基础。</p></li></ul><h2 id="三如何建设法治中国">三、如何建设法治中国</h2><h3 id="坚持党对全面依法治国的领导">坚持党对全面依法治国的领导</h3><ul><li><p>坚持党的领导是中国特色社会主义法治之魂。</p></li><li><p>把党的领导贯彻到依法治国全过程和各方面。</p></li><li><p>正确认识把握党和法的关系。</p><ul><li><p>在中国"党大还是法大"是一个伪命题。党和法、党的领导和依法治国是高度统一的，党和法的关系是政治和法治关系的集中反映。</p></li><li><p>"权大还是法大"是个真命题。必须牢牢树立"权不能大于法"基本行为准则。</p></li><li><p>坚持抓住领导干部这个"关键少数。</p></li></ul></li></ul><h3id="完善以宪法为核心的中国特色社会主义法律体系">完善以宪法为核心的中国特色社会主义法律体系</h3><ul><li><p>完善立法体制。</p></li><li><p>深入推进科学立法、民主立法。</p></li><li><p>加强重点领域立法。</p></li></ul><h3id="深入推进依法行政加快建设法治政府">深入推进依法行政，加快建设法治政府</h3><ul><li><p>依法全面履行政府职能，健全依法决策机制。</p></li><li><p>深化行政执法体制改革。</p></li><li><p>加强执法管理，坚持严格规范公正文明执法。</p></li><li><p>强化对行政权力的制约和监督，全面推进政务公开。</p></li></ul><h3 id="保证公正司法提高司法公信力">保证公正司法，提高司法公信力</h3><ul><li><p>完善司法权行使制度，优化司法职权配置。</p></li><li><p>推进严格司法，加强人权司法保障</p></li><li><p>保障人民群众参与司法，加强对司法活动的监督</p></li></ul><h3id="增强全民法治观念推进法治社会建设">增强全民法治观念，推进法治社会建设</h3><ul><li><p>推动全社会树立法治意识。</p></li><li><p>推进多层次多领域依法治理。</p></li><li><p>建设完备的法律服务体系，健全依法维权和化解纠纷机制。</p></li></ul><h3 id="加强法治工作队伍建设">加强法治工作队伍建设</h3><ul><li><p>建设高素质法治专门队伍，加强法律服务队伍建设。</p></li><li><p>创新法治人才培养机制。</p></li></ul><h1 id="第九讲-建设社会主义文化强国">第九讲 建设社会主义文化强国</h1><h2id="一为什么建设中国特色社会主义文化">一、为什么建设中国特色社会主义文化</h2><h3id="文化是一个国家一个民族的灵魂">文化是一个国家、一个民族的灵魂</h3><ul><li><p>为什么文化如此重要。</p><ul><li>文化是一种重要的力量，融入经济力量、政治力量、社会力量之中，成为经济发展的"助推器"、政治文明的"导航灯"、社会和谐的"黏合剂"。化解矛盾，要依靠文化的熏陶、教化、激励作用，发挥先进文化的凝聚、润滑、整合作用。</li></ul></li><li><p>为什么中国文化具有独特性。</p><ul><li>中华文明5000多年绵延不断、经久不衰，在长期演进过程中，形成了中国人看待世界、看待社会、看待人生的独特价值体系、文化内涵和精神品质，这是我们区别于其他国家和民族的根本特征，铸就了中华民族博采众长的文化自信。</li></ul></li><li><p>为什么强调文化自信。</p><ul><li>文化自信是更基础、更广泛、更深厚的自信，是一个国家、一个民族发展中最基本、最深沉、最持久的力量。</li></ul></li><li><p>如何发挥文化的重要作用。</p><ul><li>先进思想文化，一旦被群众掌握，就会转化为强大的物质力量。</li></ul></li></ul><h3id="没有文化繁荣兴盛就没有中华民族伟大复兴">没有文化繁荣兴盛就没有中华民族伟大复兴</h3><ul><li><p>中华民族伟大复兴以文化繁荣兴盛为支撑条件。</p></li><li><p>文化的繁荣兴盛需要强大的领导力量。</p></li></ul><h3id="更好满足人民日益增长的精神文化需要">更好满足人民日益增长的精神文化需要</h3><ul><li><p>促进满足人民文化需求和增强人民精神力量相统一。</p></li><li><p>为人民提供更多优秀精神文化产品。</p></li><li><p>促进人民精神生活共同富裕。</p></li></ul><h2id="二为什么要坚持马克思主义在意识形态领域指导地位的根本制度">二、为什么要坚持马克思主义在意识形态领域指导地位的根本制度</h2><h3id="意识形态工作是党的一项极端重要的工作">意识形态工作是党的一项极端重要的工作</h3><ul><li><p>做好意识形态工作。</p></li><li><p>意识形态关乎旗帜、关乎道路、关乎国家政治安全。</p></li></ul><h3id="巩固马克思主义在意识形态领域的指导地位">巩固马克思主义在意识形态领域的指导地位</h3><ul><li><p>为什么坚持马克思主义在意识形态领域指导地位的根本制度是历史的结论、现实的必然。</p></li><li><p>为什么要坚持马克思主义在意识形态领域指导地位的根本制度。</p></li></ul><p>是由马克思主义的理论性质决定的。马克思主义是共产党人的"真经"。马克思主义是社会主义事业的"北斗"。马克思主义是当代中国文化发展的灵魂。</p><h3id="不断增强意识形态领域主导权和话语权">不断增强意识形态领域主导权和话语权</h3><ul><li>意识形态领域现状：形势依然复杂、挑战依然严峻。</li></ul><p>社会思想意识复杂多样、相互交织；社会主流价值遭遇市场逐利性的挑战；媒体格局和舆论生态发生深刻变化；各种敌对势力对我国渗透遏制。</p><ul><li>如何应对：牢牢掌握意识形态工作领导权。</li></ul><p>用习近平新时代中国特色社会主义思想武装全党；巩固和发展主流意识形态；提升党、国家和民族的凝聚力向心力；加强意识形态人才队伍建设；推动传播手段建设和创新。</p><ul><li><p>互联网是意识形态斗争的主阵地、主战场、最前沿</p></li><li><p>为什么网络意识形态如此重要。</p><ul><li><p>互联网是社会舆论的放大器；互联网是意识形态交锋最前沿。</p></li><li><p>加强互联网内容建设，壮大主流舆论阵地。</p></li><li><p>做强网上正面宣传，旗帜鲜明坚持正确政治方向、舆论导向、价值取向。</p></li><li><p>加强网络空间治理，构建良好网络秩序。</p></li></ul></li></ul><h2id="三为什么要用社会主义核心价值观凝心聚力">三、为什么要用社会主义核心价值观凝心聚力</h2><h3id="文化的影响力首先是价值观念的影响力">文化的影响力首先是价值观念的影响力</h3><ul><li><p>不同民族、国家有不同的核心价值观。</p></li><li><p>培育社会主义核心价值观的意义是什么。</p></li></ul><p>一个国家的文化软实力，从根本上说，取决于其核心价值观的生命力、凝聚力、感召力。确立反映全国各族人民共同认同的价值观"最大公约数"，使全体人民同心同德、团结奋进，关乎国家前途命运，关乎人民幸福安康。</p><h3 id="社会主义核心价值观的内涵要义">社会主义核心价值观的内涵要义</h3><ul><li><p>社会主义核心价值观的提出。</p></li><li><p>应该坚守什么样的社会主义核心价值观。</p></li></ul><p>国家、社会、公民三个层面，24字概括。</p><ul><li><p>国家层面：富强 民主 文明 和谐；</p></li><li><p>社会层面：自由 平等 公正 法治；</p></li><li><p>公民层面：爱国 敬业 诚信 友善.</p></li><li><p>培育和践行社会主义核心价值观</p></li><li><p>使核心价值观的影响像空气一样无所不在、无时不有。</p></li><li><p>推动理想信念教育常态化、制度化。</p></li><li><p>融入法治建设和社会治理。</p></li><li><p>在落细、落小、落实上下功夫</p></li></ul><h2id="四如何提升国家文化软实力和中华文化影响力">四、如何提升国家文化软实力和中华文化影响力</h2><ul><li><p>推动中华优秀传统文化创造性转化、创新性发展</p></li><li><p>从中华优秀传统文化中寻找源头活水。</p></li><li><p>传承弘扬中华优秀传统文化。</p></li><li><p>传统文化与现代文化相融合。</p></li><li><p>警惕对待传统文化的两种错误倾向。</p></li></ul><p>反对文化复古主义、反对文化虚无主义，坚持守正创新。</p><ul><li><p>用中国特色社会主义文化培根铸魂</p></li><li><p>发展社会主义先进文化。</p></li><li><p>传承弘扬革命文化。</p></li><li><p>推进文化事业和文化产业全面发展</p></li><li><p>繁荣发展文化事业和文化产业，提高国家文化软实力。</p></li><li><p>发展文化事业和文化产业。</p></li><li><p>讲好中国故事，传播好中国声音</p></li><li><p>展现中国形象。</p></li><li><p>加强对外话语体系建设。</p></li><li><p>提高讲好中国故事的能力。</p></li><li><p>讲好中国故事的底气。</p></li></ul><h1 id="第十讲-加强以民生为重点的社会建设">第十讲加强以民生为重点的社会建设</h1><h2id="一为什么说悠悠万事民生为大">一、为什么说"悠悠万事，民生为大"</h2><h3 id="民生是最大的政治">民生是最大的政治</h3><ul><li><p>民生事关人民幸福生活。</p></li><li><p>民生事关社会和谐稳定。</p></li><li><p>抓民生也是抓发展。</p></li></ul><h3 id="人民美好生活需要日益增长">人民美好生活需要日益增长</h3><p>人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。</p><h3 id="增进民生福祉是发展的根本目的">增进民生福祉是发展的根本目的</h3><p>中国共产党自成立之日起，就始终把为中国人民谋幸福、为中华民族谋复兴作为自己的初心使命。从中国共产党的百年奋斗历史来看，让老百姓过上好日子是党一切工作的出发点和落脚点。</p><h2id="二怎样增强人民获得感幸福感安全感">二、怎样增强人民获得感、幸福感、安全感</h2><h3id="抓住人民最关心最直接最现实的利益问题">抓住人民最关心最直接最现实的利益问题</h3><ul><li><p>在幼有所育、学有所教、劳有所得、病有所医、老有所养、住有所居、弱有所扶上不断取得新进展。</p></li><li><p>保障和改善民生的重要原则。</p></li></ul><p>既要尽力而为，又要量力而行。</p><ul><li>谨防三个"陷阱"。</li></ul><p>避免"中等收入陷阱"、警惕"福利国家陷阱"、摆脱"贫困陷阱"。</p><ul><li><p>坚决打赢脱贫攻坚战</p></li><li><p>党中央把脱贫攻坚摆在治国理政的突出位置、把脱贫攻坚作为全面建成小康社会的底线任务、把精准脱贫作为三大攻坚战的重要内容。</p></li><li><p>脱贫攻坚取得了伟大成就。</p></li><li><p>脱贫攻坚精神。</p></li></ul><p>上下同心、尽锐出战、精准务实、开拓创新、攻坚克难、不负人民。</p><ul><li><p>脱贫攻坚的伟大经验。</p></li><li><p>脱贫攻坚的伟大意义。</p></li></ul><h3id="抗疫斗争最大限度保护人民生命安全和身体健康">抗疫斗争最大限度保护人民生命安全和身体健康</h3><ul><li><p>抗击新冠肺炎疫情成果显著。</p></li><li><p>伟大抗疫精神。</p></li></ul><p>生命至上、举国同心、舍生忘死、尊重科学、命运与共。</p><ul><li>抗击新冠肺炎疫情的伟大经验。</li></ul><p>中国共产党的坚强领导力、中国人民不屈不挠的意志力、中国特色社会主义制度的显著优势、新中国成立以来积累的坚实国力、社会主义核心价值观中华优秀传统文化所具有的强大精神动力、构建人类命运共同体所具有的广泛感召力。</p><ul><li>统筹推进疫情防控和经济社会发展工作。</li></ul><h2 id="三怎样推进社会治理现代化">三、怎样推进社会治理现代化</h2><h3id="坚持系统治理综合治理依法治理源头治理">坚持系统治理、综合治理、依法治理、源头治理</h3><ul><li>推动社会管理向社会治理转变。</li></ul><p>行动理念、行动主体、行动取向。</p><ul><li>不断改进社会治理方式。</li></ul><p>系统治理、综合治理、依法治理、源头治理</p><ul><li>加强和创新社会治理工作的重点内容。</li></ul><p>创新社会治理体制、完善正确处理新形势下人民内部矛盾有效机制、健全公共安全体系、完善社会治安防控体系、加强社会心理服务体系建设、构建基层社会治理新格局。</p><h3id="健全党组织领导的自治法治德治相结合的城乡基层治理体系">健全党组织领导的自治、法治、德治相结合的城乡基层治理体系</h3><ul><li><p>坚持党组织领导基层群众性自治组织的制度。</p></li><li><p>推进基层法治与德治建设。</p></li><li><p>发展公益慈善事业。</p></li><li><p>加强社会治安综合治理</p></li><li><p>建设立体化、信息化的全方位社会治安防控体系。</p></li><li><p>防范化解影响社会安定的问题，打击违法犯罪活动。</p></li><li><p>扎实开展平安中国建设，维护社会稳定、保障人民安全。</p></li><li><p>常态化开展扫黑除恶斗争。</p></li></ul><h1 id="第十一讲-建设社会主义生态文明">第十一讲建设社会主义生态文明</h1><p>习近平生态文明思想是习近平新时代中国特色社会主义思想的重要组成部分，是我们党不懈探索生态文明建设的理论升华和实践结晶，是马克思主义基本原理同中国生态文明建设实践相结合、同中华优秀传统生态文化相结合的重大成果，是以习近平同志为核心的党中央治国理政实践创新和理论创新在生态文明建设领域的集中体现，是人类社会实现可持续发展的共同思想财富，是新时代我国生态文明建设的根本遵循和行动指南。</p><p>十个坚持：</p><ul><li><p>坚持党对生态文明建设的全面领导</p></li><li><p>坚持生态兴则文明兴</p></li><li><p>坚持人与自然和谐共生</p></li><li><p>坚持绿水青山就是金山银山</p></li><li><p>坚持良好生态环境是最普惠的民生福祉</p></li><li><p>坚持绿色发展是发展观的深刻革命</p></li><li><p>坚持统筹山水林田湖草沙系统治理</p></li><li><p>坚持用最严格制度最严密法治保护生态环境</p></li><li><p>坚持把建设美丽中国转化为全体人民自觉行动</p></li><li><p>坚持共谋全球生态文明建设之路</p></li></ul><h2id="一为什么建设生态文明------关乎中华民族永续发展的根本大计">一、为什么建设生态文明------关乎中华民族永续发展的根本大计</h2><h3 id="顺应人类文明进程">顺应人类文明进程</h3><p>生态文明是人类社会进步的重大成果。人类经历了原始文明、农业文明、工业文明，生态文明是工业文明发展到一定阶段的产物，是实现人与自然和谐发展的新要求。历史地看，生态兴则文明兴，生态衰则文明衰。古今中外，这方面的事例众多。</p><ul><li>生态兴则文明兴，生态衰则文明衰</li></ul><p>在人类发展史上特别是工业化进程中，曾发生过大量破坏自然资源和生态环境的事件，酿成惨痛教训。马克思在研究这一问题时，曾列举了波斯、美索不达米亚、希腊等由于砍伐树木而导致土地荒芜的事例。据史料记载，丝绸之路、河西走廊一带曾经水草丰茂。由于毁林开荒、乱砍滥伐，致使这些地方生态环境遭到严重破坏。据反映，三江源地区有的县，三十多年前水草丰美，但由于人口超载、过度放牧、开山挖矿等原因，虽然获得过经济超速增长，但随之而来的是湖泊锐减、草场退化、沙化加剧、鼠害泛滥，最终牛羊无草可吃。古今中外的这些深刻教训，一定要认真吸取，不能再在我们手上重犯！</p><ul><li>人类文明进程的生态趋向</li></ul><p>建设生态文明是顺应人类文明进程、实现人与自然和谐共生的必然要求，具有历史必然性。原始文明、农业文明、工业文明、生态文明。</p><h3 id="破解我国经济社会发展短板问题">破解我国经济社会发展短板问题</h3><p>改革开放以后，党日益重视生态环境保护。同时，生态文明建设仍然是一个明显短板，资源环境约束趋紧、生态系统退化等问题越来越突出，特别是各类环境污染、生态破坏呈高发态势，成为国土之伤、民生之痛。如果不抓紧扭转生态环境恶化趋势，必将付出极其沉重的代价。</p><ul><li>破解我国资源保障能力较弱对经济社会可持续发展的制约</li></ul><p>随着经济社会不断发展，我国已成为世界上最大的能源消费国，大量能源需要进口；从长远看，对资源的需求仍然在不断增长。要破解这一短板问题，实现我国经济社会的可持续发展，必须着力开发利用清洁能源，提高资源利用效率。</p><ul><li>破解环境污染依然严重对人民生活质量和幸福感的制约</li></ul><p>大气污染、水体污染、土壤污染严重制约人民群众的生活质量和幸福感。要破解这一短板问题，必须坚决打好环境污染防治攻坚战，从根本上改善我国生态环境。</p><ul><li>破解我国生态系统依然脆弱对其服务经济社会发展能力的制约</li></ul><p>过去一段时期，我国生态退化比较严重，致使我国经济社会发展的环境承载力下降。要破解这一短板问题，必须加快构建生态功能保障基线，提升生态系统质量和稳定性。像青海和西藏等地的重点生态功能区，生态产品和服务的价值极大。如果盲目开发造成破坏，今后花多少钱也补不回来。</p><h3id="满足人民日益增长的优美生态环境需要">满足人民日益增长的优美生态环境需要</h3><p>现在，随着我国社会主要矛盾转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，人民群众对优美生态环境需要已经成为这一矛盾的重要方面，广大人民群众热切期盼加快提高生态环境质量。人民对美好生活的向往是我们党的奋斗目标，解决人民最关心最直接最现实的利益问题是执政党使命所在。</p><ul><li>生态环境破坏与人民优美生态环境需要不相适应</li></ul><p>改革开放以来，多年快速发展积累的生态环境问题十分突出，老百姓意见大、怨言多，生态环境破坏和污染不仅影响经济社会可持续发展，而且严重影响人民优美生态环境需要的满足。随着人民群众的生活水平不断提高，保护生态环境、建设美丽中国应该而且必须成为发展的题中之义。</p><ul><li>人民日益增长的优美生态环境需要</li></ul><p>生态环境是关系党的使命宗旨的重大政治问题，也是关系民生的重大社会问题。进入新时代，生态环境在群众生活幸福指数中的地位不断凸显，人民对优美生态环境的需要愈益普遍、愈发强烈，渴望远离浓烟重霾、臭水脏土、垃圾围城，期盼蓝天白云、繁星闪烁、清水绿岸、鱼翔浅底、鸟语花香。</p><ul><li>凸显生态文明建设的利民、惠民、为民价值</li></ul><p>"民之所好好之，民之所恶恶之。"积极回应人民群众所想、所盼、所急，不断满足人民群众日益增长的优美生态环境需要是新时代中国共产党不忘初心、牢记使命的自觉担当。迫切需要大力推进生态文明建设，提供更多优质生态产品，让人民群众吃穿住行更放心、更称心、更安心，望得见山、看得见水、记得住乡愁。</p><h3 id="应对全球生态环境领域挑战">应对全球生态环境领域挑战</h3><p>近年来，气候变化、生物多样性丧失、荒漠化加剧、极端气候事件频发，给人类生存和发展带来严峻挑战。新冠肺炎疫情持续蔓延，使各国经济社会发展雪上加霜。面对全球环境治理前所未有的困难，国际社会要以前所未有的雄心和行动，勇于担当，勠力同心，共同构建人与自然生命共同体。</p><ul><li>生态环境恶化是当代人类面临的严重全球性问题</li></ul><p>　　当代生态环境恶化的影响日益扩大，人为造成的生态环境问题日益严重，并迅速由发达国家向发展中国家蔓延，对生态安全等造成威胁。气候变化、海洋污染、臭氧空洞、生化污染、土地沙漠化、生物多样性锐减等严峻状况，威胁着整个人类社会的生存和发展。</p><ul><li>积极参与全球环境治理是我国生态文明建设的有机组成部分</li></ul><p>气候变化等全球性生态环境问题导致当代世界生态环境风险凸显，需要国际社会共同担当和应对。积极参与气候变化等全球环境治理，不仅能推动国际社会共同构建人与自然命运共同体，展现我国作为负责任发展中大国的担当和影响力，而且可化解全球生态环境问题给中华民族永续发展带来的风险。</p><h2id="二建设什么样的生态文明------树立社会主义生态文明观">二、建设什么样的生态文明------树立社会主义生态文明观</h2><h3 id="人与自然和谐共生的现代化">人与自然和谐共生的现代化</h3><p>把握进入新发展阶段、贯彻新发展理念、构建新发展格局对生态文明建设提出的新任务新要求，分析我国生态文明建设面临的新形势，推动建设人与自然和谐共生的现代化。</p><ul><li>人与自然是生命共同体</li></ul><p>人因自然而生，人与自然是一种共生关系。生态环境没有替代品，用之不觉，失之难存。如果竭泽而渔，最后必然是什么鱼也没有了。河北塞罕坝几代人驰而不息所创造的"绿色奇迹"堪称恢复和优化人与自然生命共同体的典范。人类对大自然的伤害最终会伤及人类自身，这是无法抗拒的规律。这从20世纪发生的世界十大环境公害事件可见一斑。</p><ul><li>实现人与自然和谐共生的现代化</li></ul><p>我国生态文明是以生态规律为依循、以实现人与自然和谐共生的现代化为目标的文明新形态。在整个建设过程中，我们不是只讲索取不讲投入，不是只讲发展不讲保护，不是只讲利用不讲修复，而是像保护眼睛一样保护生态环境，还自然以宁静、和谐、美丽，追求人与自然和谐共生。</p><h3 id="绿水青山就是金山银山">绿水青山就是金山银山</h3><p>既要绿水青山，也要金山银山；绿水青山就是金山银山。绿水青山和金山银山决不是对立的，关键在人，关键在思路。为什么说绿水青山就是金山银山？"鱼逐水草而居，鸟择良木而栖。"如果其他各方面条件都具备，谁不愿意到绿水青山的地方来投资、来发展、来工作、来生活、来旅游？从这一意义上说，绿水青山既是自然财富，又是社会财富、经济财富。</p><ul><li>绿水青山与金山银山的内在联系</li></ul><p>绿水青山的诱人景象及其宜居宜业宜游特征，不仅会成为当地人民的生态福祉，而且会使游客、人才和投资者偏爱有加，成为引来"金凤凰"的"梧桐树"和激活土地、劳动力、资产等要素的"催化剂"。</p><ul><li>绿水青山与金山银山的良性循环</li></ul><p>绿水青山在社会生产中持续"为劳动提供材料"，促进金山银山量和质的双重提升，推动社会生产力的绿色发展，而这又将回馈、绵延绿水青山的生机，保护和改善自然生产力。</p><h3id="良好生态环境是最普惠的民生福祉">良好生态环境是最普惠的民生福祉</h3><p>动员全社会力量推进生态文明建设，共建美丽中国，让人民群众在绿水青山中共享自然之美、生命之美、生活之美，走出一条生产发展、生活富裕、生态良好的文明发展道路。</p><ul><li>保护生态环境是为了民生</li></ul><p>环境就是民生，青山就是美丽，蓝天也是幸福。发展经济是为了民生，保护生态环境同样也是为了民生。如新疆哈密市着力推动生态恢复的目的就是惠民生。</p><ul><li>人民共同建设共同享有的生态文明</li></ul><p>生态惠民、生态利民、生态为民，生态靠民。重点解决损害群众健康的突出环境问题，建设健康宜居美丽家园，有效防范生态环境风险，为人民群众提供更多优质生态产品，让人民群众日益普遍地享有优美生态环境。生态文明成为人民群众共同参与共同建设共同享有的事业和全体人民的自觉行动。</p><h3 id="山水林田湖草沙是生命共同体">山水林田湖草沙是生命共同体</h3><p>山水林田湖草是生命共同体。生态是统一的自然系统，是相互依存、紧密联系的有机链条。人的命脉在田，田的命脉在水，水的命脉在山，山的命脉在土，土的命脉在林和草，这个生命共同体是人类生存发展的物质基础。一定要算大账、算长远账、算整体账、算综合账，如果因小失大、顾此失彼，最终必然对生态环境造成系统性、长期性破坏。</p><ul><li>生态系统是有机关联的系统整体</li></ul><p>生态系统是一个系统整体，山水林田湖草沙构成相依共存、有机关联的生命共同体。这个生命共同体的生生循环、绵延不息葆有着人类生存发展的物质根基。</p><ul><li><p>山水林田湖草沙系统治理之道</p></li><li><p>坚持系统观念，保护生态环境</p></li><li><p>国土绿化规模增大，生态安全屏障牢固</p></li><li><p>各种生态环境要素之间的比例和空间关系得到维持、恢复、优化</p></li><li><p>自然生态系统稳定性和生态服务功能全面提升</p></li></ul><h3id="用最严格制度最严密法治保护生态环境">用最严格制度最严密法治保护生态环境</h3><p>保护生态环境必须依靠制度、依靠法治。只有实行最严格的制度、最严密的法治，才能为生态文明建设提供可靠保障。</p><ul><li>保护生态环境必须依靠最严格制度最严密法治</li></ul><p>保证党中央关于生态文明建设决策部署落地生根见效，牢固树立生态环境法治理念，生态文明制度体系健全、配套完善，管权治吏、护蓝增绿制度严格，有权必有责、有责必担当、失责必追究。</p><ul><li>生态环境治理的体系化、法治化和效能化</li></ul><p>制度涵盖生态文明建设的源头处置、过程控制、损害赔偿和责任追究，覆盖生态环境保护的主体和对象，建有最严格的执行机制。以制度力量提升生态环境治理效能，促进人与自然和谐共生。</p><h3 id="共谋全球生态文明建设">共谋全球生态文明建设</h3><p>生态文明建设关乎人类未来，建设绿色家园是人类的共同梦想，保护生态环境、应对气候变化需要世界各国同舟共济、共同努力，任何一国都无法置身事外、独善其身。我国已成为全球生态文明建设的重要参与者、贡献者、引领者，主张加快构筑尊崇自然、绿色发展的生态体系，共建清洁美丽的世界。</p><ul><li>地球是全人类的共有家园</li></ul><p>当代经济和生态环境问题的全球化，将人类的利益和命运紧紧联系在一起，构成了现实的命运共同体。生态环境问题的跨国界蔓延，危及全人类的共有家园，需要世界各国同舟共济、携手合作、共同应对。</p><ul><li>全球生态文明建设的重要参与者、贡献者、引领者</li></ul><p>我国是全球气候变化谈判进程和《巴黎协定》签署、生效、实施的积极推动者，是将绿色发展纳入"一带一路"合作规划和中非合作计划的引领者。</p><p>我国秉持历史与现实相统一、可持续发展、共同但有区别的责任原则，根据自身条件，努力解决生态环境问题，美丽中国建设不断迈上新台阶，同时携手国际社会共同应对环境问题，成为全球生态环境治理智慧和方案的重要贡献者。</p><h2id="三怎样建设美丽中国------推进绿色发展循环发展低碳发展">三、怎样建设美丽中国------推进绿色发展、循环发展、低碳发展</h2><h3 id="形成绿色发展方式和生活方式">形成绿色发展方式和生活方式</h3><p>推动形成绿色发展方式和生活方式是贯彻新发展理念的必然要求，必须把生态文明建设摆在全局工作的突出地位，坚持节约资源和保护环境的基本国策，坚持节约优先、保护优先、自然恢复为主的方针，形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式，努力实现经济社会发展和生态环境保护协同共进，为人民群众创造良好生产生活环境。</p><ul><li>加快推动发展方式和生活方式绿色转型</li></ul><p>构建市场导向的绿色科技创新体系，推进资源全面节约和循环利用体系，倡导简约适度绿色低碳的生活方式，建立健全绿色低碳循环的经济体系。</p><ul><li><p>产业结构，空间结构，能源结构，消费方式绿色转型</p></li><li><p>打造国家重大战略绿色发展高地</p></li></ul><h3 id="着力解决突出环境问题">着力解决突出环境问题</h3><ul><li><p>环境保护和治理要以解决损害群众健康突出环境问题为重点，坚持预防为主、综合治理，强化水、大气、土壤等污染防治，着力推进重点流域和区域水污染防治，着力推进重点行业和重点区域大气污染治理。</p></li><li><p>着力打赢污染防治攻坚战，深入实施大气、水、土壤污染防治三大行动计划，深入打好蓝天、碧水、净土保卫战，开展农村人居环境整治。全面禁止洋垃圾入境：严打走私严查倒卖。</p></li></ul><h3 id="加快推进生态环境保护修复">加快推进生态环境保护修复</h3><ul><li><p>要深入实施山水林田湖草一体化生态保护和修复，开展大规模国土绿化行动，加快水土流失和荒漠化石漠化综合治理。</p></li><li><p>多措并举，全方位推进生态环境保护修复</p></li></ul><p>优化国土空间开发保护格局，建立以国家公园为主体的自然保护地体系，持续开展大规模国土绿化行动，加强大江大河和重要湖泊湿地及海岸带生态保护和系统治理。建立市场化、多元化生态补偿机制</p><h3 id="扎实推进碳达峰碳中和工作">扎实推进碳达峰碳中和工作</h3><p>实现碳达峰、碳中和是我国向世界作出的庄严承诺，也是一场广泛而深刻的经济社会变革，绝不是轻轻松松就能实现的。</p><ul><li>增加碳吸收 减少碳使用 加强碳转换 控制碳排放</li></ul><p>必须坚持全国统筹、节约优先、双轮驱动、内外畅通、防范风险的原则，更好发挥我国制度优势、资源条件、技术潜力、市场活力。</p><ul><li>最大限度地克制"生存和发展排放"</li></ul><p>发达国家应减少的是"奢侈排放"，中国则是最大限度地克制"生存和发展排放"。我们要坚持共同但有区别的责任原则、公平原则和各自能力原则，坚定维护多边主义，有效应对一些西方国家对我国进行"规锁"的企图，坚决维护我国发展利益。</p><ul><li>注重处理好四对关系，落实六项举措</li></ul><p>四对关系包含发展和减排、整体和局部、长远和短期、政府和市场。</p><blockquote><p>六项举措包含</p></blockquote><ul><li><p>加强统筹协调</p></li><li><p>推动能源革命</p></li><li><p>推进产业优化升级</p></li><li><p>加快绿色低碳科技革命</p></li><li><p>完善绿色低碳政策体系</p></li><li><p>积极参与和引领全球气候治理</p></li></ul><h3 id="改革完善生态环境监管考核体制">改革完善生态环境监管考核体制</h3><p>推进生态文明建设，解决资源约束趋紧、环境污染严重、生态系统退化的问题，必须采取一些硬措施，真抓实干才能见效。</p><p>健全落地见效的生态环境监管考核体制</p><ul><li><p>设立国有自然资源资产管理和自然生态监管机构</p></li><li><p>构建国土空间全方位开发保护制度体系</p></li><li><p>建立政府、企业、社会、公众参与的治理体系</p></li></ul><p>党的十八大以来，我国全面加强生态文明建设，决心之大、力度之大、成效之大前所未有。习近平在主持中共十九届中央政治局第二十九次集体学习时的讲话时指出，"九年来，蓝天白云重新展现，绿色版图不断扩展，绿色经济加快发展，能耗物耗不断降低，浓烟重霾有效抑制，黑臭水体明显减少，城乡环境更加宜居，美丽中国建设迈出坚实步伐，绿水青山就是金山银山的理念成为全党全社会的共识和行动。"</p><p>生态文明建设是关乎中华民族永续发展的根本大计。建设社会主义生态文明主要涵括人与自然和谐共生的现代化，绿水青山就是金山银山，良好生态环境是最普惠的民生福祉，山水林田湖草沙是生命共同体，用最严格制度最严密法治保护生态环境，共谋全球生态文明建设。要加快推进绿色发展、循环发展、低碳发展，开创美丽中国建设新局面。</p><p><br /></p><h1 id="第十二讲-建设巩固国防和强大人民军队">第十二讲建设巩固国防和强大人民军队</h1><p>习近平强军思想作为习近平新时代中国特色社会主义思想的重要组成部分，是我们党不懈探索中国特色强军之路形成的宝贵思想结晶，是加快国防和军队现代化、全面建设世界一流军队的行动纲领，谱写了当代中国马克思主义军事理论和军事实践发展的新篇章，为新时代国防和军队建设提供了科学指南和行动纲领。</p><p>十一个方面</p><ul><li><p>关于强国必须强军</p></li><li><p>关于实现党在新时代的强军目标</p></li><li><p>关于坚持党对人民军队的绝对领导</p></li><li><p>关于全面提高新时代备战打仗能力</p></li><li><p>关于弘扬我党我军光荣传统和优良作风</p></li><li><p>关于推动我军高质量发展</p></li><li><p>关于深化国防和军队改革</p></li><li><p>关于加快国防科技创新</p></li><li><p>关于锻造高素质专业化新型军事人才</p></li><li><p>关于提高国防和军队建设法治化水平</p></li><li><p>关于构建一体化国家战略体系和能力</p></li></ul><h2id="一为什么要建设一支强大人民军队------强国必须强军军强才能国安">一、为什么要建设一支强大人民军队------强国必须强军、军强才能国安</h2><h3 id="国际战略形势发生深刻变化">国际战略形势发生深刻变化</h3><ul><li>经济全球化进程出现波折</li></ul><p>保护主义、霸凌行径上升，新冠肺炎疫情和乌克兰危机影响交织叠加，全球面临粮食、能源、金融安全危机，国际安全风险加大。</p><ul><li>国际战略格局深度调整</li></ul><p>一超多强趋势明显，一些西方国家长期主导国际事务的优势逐渐丧失，国际格局演变进程不会风平浪静。</p><ul><li>全球治理体系变革加速推进</li></ul><p>发展中国家话语权的增加涉及各国特别是大国利益，必然会有斗争，不可能一帆风顺。</p><ul><li>发展道路和发展模式的竞争更加激烈</li></ul><p>新冠肺炎疫情全球大流行，各国的领导力和制度优越性激烈较量，围绕发展道路的竞争是长期复杂的。</p><h3id="我国处于由大向强发展的关键阶段">我国处于由大向强发展的关键阶段</h3><p>一个国家往往在两个时期面临的外部压力最大，一个是积贫积弱之时，另一个是发展振兴之时。今天，我们比历史上任何时期都更接近中华民族伟大复兴的目标，比历史上任何时期都更需要建设一支强大的人民军队。</p><ul><li>由大向强、将强未强之际是国家安全的高风险期<ul><li>我国国家安全形势不稳定性不确定性增大；</li><li>必须建立强大的人民军队；</li><li>人民军队必须时刻绷紧备战打仗这根弦。</li></ul></li><li>某些西方大国不甘心让中国"赢得21世纪"<ul><li>经济压制 、高科技封锁 、疫情溯源 ("甩锅"中国)、印太战略(印太版的"北约")、所谓"五四三二"的遏制阵势(强化"五眼联盟"、兜售"四边机制"、拼凑三边安全伙伴关系、收紧双边军事同盟)。</li></ul></li><li>我国周边热点地区局势充满变数<ul><li>"三股势力"威胁西北边境地区安全稳定、海上安全环境更趋复杂、陆上部分边境地区可能爆发冲突。</li></ul></li></ul><h3 id="国际军事竞争日趋激烈">国际军事竞争日趋激烈</h3><p>世界新军事革命加速发展，军事技术和战争形态发生革命性变化，军事竞争战略主动权的争夺更加激烈。这场世界新军事革命给我军提供了难得的历史机遇，同时也提出了严峻挑战。机遇稍纵即逝，抓住了就能乘势而上，抓不住就可能错过整整一个时代。</p><ul><li>世界新军事革命正加速推进</li></ul><p>这场军事领域的变革以信息化为核心，以军事战略、军事技术、作战思想、作战力量、组织体制和军事管理创新为基本内容，以重塑军事体系为主要目标，其速度之快、范围之广、程度之深、影响之大，为第二次世界大战结束以来所罕见。武器装备远程精确化、智能化、隐身化、无人化趋势更加明显，战争形态加速向信息化战争演变，智能化战争初现端倪。</p><p>我军必须加快推进中国特色军事变革，缩小同世界强国在军事实力上的差距，掌握军事竞争战略主动权。</p><p>未来智能化战争的场景：智能化作战体系成为主要力量形态。人的智能移植到了武器上。人与武器实现高度一体化，智能化作战体系的核心要义在于"人类指挥、机器自主、网络支撑"。自主作战成为主要作战方式。智能化作战系统广泛应用于装备部队，并逐渐成为战场的主要作战力量，自主作战上升为主要作战方式，从自主、规模、弹性、认知等方面深刻改变着作战样式。"制智权"成为战争核心制权。"制智权"成为战争制权争夺的核心，智能主导、自主驭能、以智谋胜将成为智能化战争的基本法则。</p><ul><li>各主要国家纷纷加快军事变革</li></ul><p>美国、俄罗斯、英国、法国、德国、日本、印度等国家纷纷采取新的重大军事举措，加紧推进军事转型。我军不仅要赶上潮流、赶上时代，还要力争走在时代前列。</p><h3id="我军需要一场革命性变革------全面推进国防和军队现代化">我军需要一场革命性变革------全面推进国防和军队现代化</h3><p>我军许多年没有打过仗了，打现代化战争能力不够，各级干部指挥现代化战争能力不够，这两个问题依然很现实地摆在我们面前。</p><ul><li>回答好"胜战之问"，需要一支强大人民军队</li></ul><p>现代战争特点</p><ul><li><p>制信息权是战场争夺的核心</p></li><li><p>一体化联合作战是基本作战形式</p></li><li><p>运用精锐力量实施精确作战</p></li></ul><p>我军差距</p><p>中国特色军事变革取得重大进展，但机械化建设任务尚未完成，信息化水平亟待提高，军事安全面临技术突袭和技术代差被拉大的风险，军队现代化水平与国家安全需求相比差距还很大，与世界先进军事水平相比差距还很大。</p><ul><li><p>解决军队长期积累的制度性障碍、结构性矛盾、政策性问题，需要革命性重塑</p></li><li><p>军事理论现代化</p></li><li><p>军队组织形态现代化</p></li><li><p>军事人员现代化</p></li><li><p>武器装备现代化</p></li><li><p>加快军事智能化发展，提高基于网络信息体系的联合作战能力、全域作战能力</p></li><li><p>加快机械化信息化智能化融合发展</p></li></ul><h2id="二怎样建设巩固国防和强大人民军队------全面推进国防和军队现代化">二、怎样建设巩固国防和强大人民军队------全面推进国防和军队现代化</h2><h3 id="确立党在新时代的强军目标">确立党在新时代的强军目标</h3><p>明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队。</p><ul><li><p>听党指挥是灵魂</p><ul><li>决定军队建设的政治方向</li></ul></li></ul><p>毛泽东在1929年指出，"一个子弹不问过党不能支配，他们是绝对的党领导"。人民军队由党缔造，自人民军队诞生起，其命运就与党的命运紧密相连。</p><p>坚持党对人民军队的绝对领导，这一建军根本原则不是凭空产生的，而是我们党和军队以鲜血为代价换来的、历经艰辛探索得来的。</p><p>无论时代如何发展、形势如何变化，坚持党对人民军队的绝对领导始终是我军的军魂和命根子，永远不能变，永远不能丢。</p><ul><li>引领我军从胜利走向胜利</li></ul><blockquote><p>1935年12月，红军到达陕北后，毛泽东在瓦窑堡党的活动分子会议上指出："谁使长征胜利的呢？是共产党。没有共产党，这样的长征是不可能设想的。"</p></blockquote><p>我军之所以能够无往而不胜，最终战胜一切敌人而不为敌人所压倒，是因为坚决听党指挥，这是我们的建军之魂、强军之魂。</p><ul><li>确保我军不变质不变色</li></ul><p>党旗所指，军旗所向。这是一切敌人最惧怕我们的一点，也是保证我们党长期执政、国家长治久安的根本法宝。党对军队的绝对领导是中国特色社会主义的本质特征，是党和国家的重要政治优势，是人民军队的建军之本、强军之魂。</p><ul><li>能打胜仗是核心</li></ul><p>当兵就是要打仗，这就像工人要做工、农民要种田一样，打仗和准备打仗是军人的天职，也是军队使命职责之所在。</p><ul><li>战场打不赢，一切等于零</li></ul><p>军事上的落后一旦形成，对国家安全的影响将是致命的。</p><ul><li>英雄的人民军队打出了国威军威</li></ul><p>90年来，人民军队历经硝烟战火，一路披荆斩棘，付出巨大牺牲，取得一个又一个辉煌胜利，为党和人民建立了伟大的历史功勋。</p><ul><li>切实把战斗队思想立起来</li></ul><p>必须扭住能打仗、打胜仗这个强军之要，强化当兵打仗、带兵打仗、练兵打仗思想。按照打仗的要求搞建设、抓准备，坚持不懈拓展和深化军事斗争准备。锻造召之即来、来之能战、战之必胜的精兵劲旅。</p><ul><li><p>作风优良是保证</p><ul><li><p>人民军队在党的旗帜下前进，培育了特有的光荣传统和优良作风</p></li><li><p>人民军队为党的伟大精神的形成作出突出贡献</p></li></ul></li></ul><p>井冈山精神、长征精神、抗美援朝精神、雷锋精神</p><ul><li><p>风清弊绝，才能实现强军目标</p></li><li><p>新时代全军必须夯实依法治军、从严治军这个强军之基，持之以恒推进作风建设和反腐败斗争，自觉践行人民军队根本宗旨，保持人民军队长期形成的良好形象。</p></li><li><p>贯彻依法治军战略，提高国防和军队建设法治化水平。"依法治军战略"的内涵要求------"八个坚持"：坚持党对军队绝对领导，坚持战斗力标准，坚持建设中国特色军事法治体系，坚持按照法治要求转变治军方式，坚持从严治军铁律，坚持抓住领导干部这个"关键少数"，坚持官兵主体地位，坚持贯彻全面依法治国要求。</p></li><li><p>大力弘扬优良作风，把红色基因一代代传下去。</p></li><li><p>建成世界一流军队</p></li></ul><p>到2027年实现建军一百年奋斗目标，到2035年基本实现国防和军队现代化，到本世纪中叶把人民军队全面建成世界一流军队。</p><ul><li><p>在强军目标下确立新时代军事战略方针</p><ul><li><p>新时代军事战略方针，坚持防御、自卫、后发制人原则，实行积极防御，坚持"人不犯我、我不犯人，人若犯我、我必犯人"，强调遏制战争与打赢战争相统一。强调战略上防御与战役战斗上进攻相统一。</p></li><li><p>增强军事战略指导的进取性和主动性。整体运筹备战与止战、维权与维稳、威慑与实战、战争行动与和平时期军事力量运用，注重深远经略，塑造有利态势，综合管控危机，坚决遏制和打赢战争。</p></li></ul></li><li><p>在强军目标下调整优化军事战略布局</p><ul><li><p>根据中国地缘战略环境、面临安全威胁和军队战略任务，构建全局统筹、分区负责，相互策应、互为一体的战略部署和军事布势；应对太空、网络空间等新型安全领域威胁，维护共同安全；加强海外利益攸关区国际安全合作，维护海外利益安全。</p></li><li><p>根据国家面临的安全威胁，扎实做好军事斗争准备，全面提高新时代备战打仗能力，构建立足防御、多域统筹、均衡稳定的新时代军事战略布局。</p></li></ul></li></ul><h3 id="贯彻政治建军方略">贯彻政治建军方略</h3><ul><li>在古田召开全军政治工作会议</li></ul><p>习近平提议并主持召开全军政治工作会议 ( 2014年10月30日至11月2日)</p><ul><li><p>强调革命的政治工作是革命军队的生命线，明确提出军队政治工作的时代主题。</p></li><li><p>要求把理想信念、党性原则、战斗力标准、政治工作威信4个带根本性的东西立起来。</p></li><li><p>着力抓好铸牢军魂工作、高中级干部管理、作风建设和反腐败斗争、战斗精神培育、政治工作创新发展等五个方面的重点工作。</p></li><li><p>全面深入贯彻军委主席负责制</p></li></ul><p>中央军委实行主席负责制，是坚持党对人民军队绝对领导的根本制度和根本实现形式，在党领导军队的一整套制度体系中处于最高层次、居于统领地位。</p><ul><li><p>加强新时代军队党的建设</p></li><li><p>着力抓好军队党的政治建设，严肃政治纪律和政治规矩，确保部队绝对忠诚、绝对纯洁、绝对可靠，确保枪杆子永远听党指挥。</p></li><li><p>严肃军队党内政治生活，认真执行党的民主集中制，认真开展批评和自我批评。</p></li><li><p>锻造坚强有力的党组织，加强我军党的组织体系建设，增强各级党组织的领导力、组织力、执行力，把党的政治优势和组织优势转化为制胜优势。</p></li><li><p>用习近平强军思想武装官兵</p></li><li><p>全面系统学习习近平新时代中国特色社会主义思想，学习习近平强军思想。</p></li><li><p>把习近平强军思想作为学习教育的主题主课，打牢部队听党指挥、履行使命的思想政治基础。</p></li><li><p>加强研究阐释，深入回答强军兴军的重大理论和实践问题，推动习近平强军思想入脑入心。</p></li><li><p>培养"四有"新时代革命军人，锻造"四铁"过硬部队。(有灵魂、有本事、有血性、有品德；铁一般的信仰、铁一般的信念、铁一般的纪律、铁一般的担当)</p></li></ul><h3 id="深化国防和军队改革">深化国防和军队改革</h3><ul><li>搞好深化国防和军队改革的顶层设计</li></ul><p>深化国防和军队改革是一场回避不了的大考。不改革军队是打不了仗、打不了胜仗的，要树立向改革要战斗力的思想。</p><ul><li><p>2013年11月，党的十八届三中全会把深化国防和军队改革单列为一个部分写入全会决定中，纳入全面深化改革总体布局、上升为党的意志和国家行为，这在党的历史上是首次。</p></li><li><p>2015年11月，中央军委改革工作会议召开，对深化国防和军队改革进行总体部署。</p></li><li><p>2016年1月，印发《中央军委关于深化国防和军队改革的意见》。</p></li><li><p>深化国防和军队改革的"三大战役"</p></li></ul><p>第一大战役：领导指挥体制改革，重在解决体制性障碍 (2015年底开始)</p><p>第二大战役：压茬推进规模结构和力量编成改革，重在解决结构性矛盾(2016年底开始)</p><p>第三大战役：深化政策制度改革，重在解决政策性问题 (2018年底开始)</p><ul><li>深化国防和军队改革取得重大成效</li></ul><p>体制一新------打破了长期实行的总部体制、大军区体制、大陆军体制。</p><p>结构一新------形成了军委管总、战区主战、军种主建的新格局。</p><p>格局一新------改变了长期以来陆战型、国土防御型的力量结构和兵力布势。</p><p>面貌一新------实现了我军组织架构和力量体系的整体性、革命性重塑。</p><p>党的十八大以来，深化国防和军队改革大开大合、大破大立、蹄疾步稳，实现了我军组织架构和力量体系的整体性、革命性重塑，有效解决了制约我军建设的体制性障碍、结构性矛盾。</p><h3 id="聚焦能打胜仗练兵备战">聚焦能打胜仗练兵备战</h3><ul><li><p>牢固确立战斗力这个唯一的根本的标准</p></li><li><p>军队是要打仗的，要牢固树立战斗力这个唯一的根本的标准，坚持把战斗力标准贯彻到全军各项建设和工作之中。</p></li><li><p>把新时代军事战略思想、新时代军事战略方针、备战打仗指挥棒、抓备战打仗的责任担当立起来。</p></li><li><p>大力纠治和平积弊，推进军事训练转型升级，狠抓军事斗争准备，大抓战斗精神培育。</p></li><li><p>加快构建新型军事训练体系</p></li><li><p>坚持以战领训、以训促战、战训一致，大抓实战化军事训练。</p></li><li><p>加快军事训练条件建设，创新训练保障模式，创设逼真战场环境，开发先进训练手段。</p></li><li><p>深入推进联战联训，加速提升一体化联合作战能力，广泛开展各战略方向使命课题针对性训练和各军兵种演训。</p></li><li><p>更好更快进行武器装备现代化建设</p></li></ul><p>设计武器装备就是设计未来战争。把发展高技术武器装备摆在战略位置，抓紧攻坚具有前瞻性、战略性意义的"杀手锏"装备，加强前瞻性、先导性、探索性、颠覆性技术研究，加快军事智能化发展。</p><h2id="三人民军队怎样捍卫国家主权安全发展利益------坚决履行新时代人民军队使命任务">三、人民军队怎样捍卫国家主权、安全、发展利益------坚决履行新时代人民军队使命任务</h2><h3 id="人民军队实现整体性革命性重塑">人民军队实现整体性革命性重塑</h3><ul><li>重振政治纲纪</li></ul><p>有一个时期，人民军队党的领导弱化问题突出，如果不彻底解决，不仅影响战斗力，而且事关党指挥枪这一重大政治原则。党中央和中央军委狠抓全面从严治军，果断决策整肃人民军队政治纲纪，在古田召开全军政治工作会议，对新时代政治建军作出部署，恢复和发扬我党我军光荣传统和优良作风，以整风精神推进政治整训，全面加强军队党的领导和党的建设，深入推进军队党风廉政建设和反腐败斗争，坚决查处郭伯雄、徐才厚、房峰辉、张阳等严重违纪违法案件并彻底肃清其流毒影响，推动人民军队政治生态根本好转。</p><ul><li>重塑组织形态</li></ul><p>形成军委管总、战区主战、军种主建新格局，打造以精锐作战力量为主体的军事力量体系，初步形成中国特色社会主义军事政策制度体系基本框架。</p><ul><li>重整斗争格局</li></ul><p>军事斗争准备基点放在打赢具有智能化特征的信息化局部战争上</p><ul><li><p>重构建设布局</p></li><li><p>作出新"三步走"战略安排</p></li><li><p>形成"五个坚持"战略布局坚持政治建军、改革强军、科技强军、</p></li></ul><p>人才强军、依法治军</p><ul><li>确立"五个更加注重"战略指导更加注重聚焦实战，更加注重创新驱动，</li></ul><p>更加注重体系建设，更加注重集约高效，更加注重军民融合</p><ul><li><p>加快机械化信息化智能化融合发展</p></li><li><p>重树作风形象</p></li></ul><p>坚决纠"四风"转作风全面停止有偿服务；坚持有腐必反有贪必肃；弘扬人民军队的光荣传统和优良作风。</p><p>十年砥砺奋进，强军事业取得历史性成就、发生历史性变革，最根本在于以习近平同志为核心的党中央坚强领导，在于习近平强军思想的科学指引。</p><h3 id="新时代人民军队使命任务">新时代人民军队使命任务</h3><ul><li><p>为巩固中国共产党领导和我国社会主义制度提供战略支撑</p></li><li><p>为捍卫国家主权、统一、领土完整提供战略支撑</p></li><li><p>为维护我国海外利益提供战略支撑</p></li><li><p>为促进世界和平与发展提供战略支撑</p></li></ul><h3 id="坚定灵活开展军事斗争">坚定灵活开展军事斗争</h3><p>人民军队有效应对外部军事挑衅，震慑"台独"分裂行径，遂行边防斗争、海上维权、反恐维稳、抢险救灾、抗击疫情、维和护航、人道主义救援和国际军事合作等重大任务，以顽强斗争精神和实际行动捍卫了国家主权、安全、发展利益。</p><ul><li>维护边防安全稳定</li></ul><p>加强边境管控和反蚕食斗争</p><ul><li>应对海上安全威胁和侵权挑衅行为</li></ul><p>组织东海、南海、黄海等重要海区和岛礁警戒防卫，划设东海防空识别区，组织南海常态化战斗巡航，掌握周边海上态势，组织海上联合维权执法，妥善处置海空情况，坚决应对海上安全威胁和侵权挑衅行为。</p><ul><li>震慑"台独"分裂行径</li></ul><p>着眼捍卫国家统一，加强以海上方向为重点的军事斗争准备，组织舰机"绕岛巡航"，对"台独"分裂势力发出严正警告。</p><h3 id="积极遂行重大任务">积极遂行重大任务</h3><ul><li>抢险救灾</li></ul><p>哪里有危难，哪里就有人民子弟兵。</p><ul><li>抗击疫情</li></ul><p>新冠肺炎疫情发生后，全军闻令而动，勇挑重担，发挥出突击队作用。</p><ul><li>维和护航</li></ul><p>党的十八大以来，伴随使命任务的拓展，中国军人的身影越来越多地出现在国境之外，为世界提供公共安全产品和服务。在国际维和、亚丁湾护航等行动中，我军参与规模愈益扩大、发挥作用愈益突出，赢得了国际社会的高度赞誉。</p><ul><li>人道主义救援和国际军事合作</li></ul><p>在西非埃博拉疫情防控、马航失联航班搜寻、尼泊尔地震救援等行动中，都有中国军队紧急驰援的身影。从太平洋到印度洋，从东南亚到亚丁湾，中国军人在灾难中及时伸出援手，在困苦中播种美好希望，体现的是"真实力"，更是"暖实力"。</p><p>青春不只有诗和远方，还有家国与边关。要把对祖国血浓于水、与人民同呼吸共命运的情感贯穿于学业全过程、融汇在事业追求中。我们的军队是人民军队，我们的国防是全民国防。强军号角已经吹响，加快构建一体化的国家战略体系和能力，需要全社会共同努力。</p><p>大学生要把小我融入大我，立志作出我们这一代人的历史贡献。把爱国之心化为报国之行，把热血挥洒在实现中国梦、强军梦的伟大实践之中，书写绚烂无悔的青春篇章。</p><p>小结：</p><p>强国必须强军，军强才能国安。党的十八大以来，党中央和中央军委就加快国防和军队现代化作出一系列战略谋划和部署，引领全军开创了强军事业新局面。在全面建设社会主义现代化国家、实现第二个百年奋斗目标的历史进程中，必须把国防和军队建设摆在更加重要的位置，加快建设巩固国防和强大军队。</p><h1 id="第十三讲-全面贯彻落实总体国家安全观">第十三讲全面贯彻落实总体国家安全观</h1><p>总体国家安全观是我们党历史上第一个被确立为国家安全工作指导思想的重大战略思想，是中国共产党和中国人民捍卫国家主权、安全、发展利益百年奋斗实践经验和集体智慧的结晶，是马克思主义国家安全理论中国化的最新成果，是习近平新时代中国特色社会主义思想的重要组成部分，是新时代国家安全工作的根本遵循和行动指南。</p><p>十个坚持：</p><ul><li><p>党对国家安全工作的绝对领导</p></li><li><p>中国特色国家安全道路</p></li><li><p>以人民安全为宗旨</p></li><li><p>统筹发展和安全</p></li><li><p>把政治安全放在首位</p></li><li><p>统筹推进各领域安全</p></li><li><p>把防范化解国家安全风险摆在突出位置</p></li><li><p>推进国际共同安全</p></li><li><p>推进国家安全体系和能力现代化</p></li><li><p>加强国家安全干部队伍建设</p></li></ul><h2id="一为什么说保证国家安全是头等大事------国家安全是安邦定国的重要基石">一、为什么说保证国家安全是头等大事------国家安全是安邦定国的重要基石</h2><h3id="安而不忘危存而不忘亡治而不忘乱">安而不忘危，存而不忘亡，治而不忘乱</h3><p>国家安全是指国家政权、主权、统一和领土完整、人民福祉、经济社会可持续发展和国家其他重大利益相对处于没有危险和不受内外威胁的状态，以及保障持续安全状态的能力。</p><ul><li><p>中华优秀传统文化中蕴含着丰富的国家安全战略思想</p></li><li><p>强调忧患意识------"生于忧患，死于安乐"</p></li><li><p>注重民本思想------"民惟邦本，本固邦宁"</p></li><li><p>倡导和平共处------"和衷共济""和合共生"</p></li><li><p>主张讲信修睦------"亲人善邻，国之宝也"</p></li><li><p>力求内外兼修------"内事文而和，外事武而义"</p></li><li><p>重视刚柔并济------"方而又刚，柔而又圆，求安难以"</p></li><li><p>推崇张弛有度------"文武之道，一张一弛"</p></li><li><p>党中央始终把维护国家安全工作紧紧抓在手上</p></li></ul><p>我们党诞生于国家内忧外患、民族危难之时，对国家安全的重要性有着刻骨铭心的认识。新中国成立以来，党中央对发展和安全高度重视，始终把维护国家安全工作紧紧抓在手上。</p><ul><li>为实现中华民族伟大复兴提供坚强安全保障</li></ul><p>近代史上的惨痛教训证明，失去国家安全保障，中华民族就无法掌握自己的命运。实现伟大梦想，就必须进行具有许多新的历史特点的伟大斗争，其中就包括为实现中国梦筑牢安全保障的伟大斗争。</p><h3id="安全基础不牢发展大厦地动山摇">安全基础不牢，发展大厦地动山摇</h3><p>推动创新发展、协调发展、绿色发展、开放发展、共享发展，前提都是国家安全、社会稳定。没有安全和稳定，一切都无从谈起。</p><p>国家安全：内涵外延比历史上任何时候都要丰富，时空领域比历史上任何时候都要宽广，内外因素比历史上任何时候都要复杂。</p><p>进入新时代，我国面临复杂多变的安全和发展环境，面临更为严峻的国家安全形势，外部压力前所未有，传统安全威胁和非传统安全威胁相互交织，各种可以预见和难以预见的风险因素明显增多，各方面风险可能不断积累甚至集中显露。</p><p>过去</p><ul><li><p>我们顺势而上，机遇比较好把握</p></li><li><p>大环境相对平稳，风险挑战容易看清楚</p></li><li><p>我们发展水平低，同别人的互补性多一些</p></li></ul><p>现在</p><ul><li><p>我们顶风而上，把握机遇难度加大</p></li><li><p>世界形势动荡复杂，对应变能力提出更高要求</p></li><li><p>我们发展水平提高，同别人的竞争性多起来</p></li></ul><h3id="国泰民安是人民群众最基本最普遍的愿望">国泰民安是人民群众最基本、最普遍的愿望</h3><p>人民希望：国家更加强大，更有力地维护国家统一和民族团结；党和政府更加主动作为，更有效地保护生命财产安全；着力解决空气、水、土壤污染以及农产品、食品药品安全等突出问题。</p><p>国家安全工作，归根结底是保障人民利益，为群众安居乐业提供坚强保障。有了安全感，获得感才有保障，幸福感才会持久。</p><h3id="新时代国家安全经受住了来自多方面的风险挑战考验">新时代国家安全经受住了来自多方面的风险挑战考验</h3><p>党的十八大以来，国家安全得到全面加强，经受住了来自政治、经济、意识形态、自然界等方面的风险挑战考验，为党和国家兴旺发达、长治久安提供了有力保证。</p><p>党的十八大以来，以习近平同志为核心的党中央加强对国家安全工作的集中统一领导，把坚持总体国家安全观纳入坚持和发展中国特色社会主义基本方略，从全局和战略高度对国家安全作出一系列重大决策部署，强化国家安全工作顶层设计，完善各重要领域国家安全政策，健全国家安全法律法规，有效应对了一系列重大风险挑战，保持了我国国家安全大局稳定。</p><ul><li>国家安全的重要地位更加凸显</li></ul><p>中央国家安全委员会第一次会议 -：我们党要巩固执政地位，要团结带领人民坚持和发展中国特色社会主义，保证国家安全是头等大事。</p><p>十八届中央政治局第十四次集体学习 -维护国家安全和社会安定，对全面深化改革、实现"两个一百年"奋斗目标、实现中华民族伟大复兴的中国梦都十分紧要。</p><p>党的十九大 -国家安全是安邦定国的重要基石，维护国家安全是全国各族人民根本利益所在。</p><p>十九届中央政治局第二十六次集体学习 -国家安全工作是党治国理政一项十分重要的工作，也是保障国泰民安一项十分重要的工作。</p><ul><li><p>国家安全体系基本形成</p><ul><li><p>建立国家安全领导体制</p><ul><li><p>设立中央国家安全委员会 (2013年)</p></li><li><p>出台《中国共产党领导国家安全工作条例》 (2021年)</p></li></ul></li><li><p>制定完善国家安全战略体系</p><ul><li>《国家安全战略纲要》 (2015年)</li></ul><p>-《国家安全战略 (2021---2025年)》 (2021年)</p></li><li><p>着力构建国家安全法治体系</p><ul><li><p>国家安全法</p></li><li><p>国家情报法</p></li><li><p>反恐怖主义法</p></li><li><p>境外非政府组织境内活动管理法</p></li><li><p>国防交通法</p></li><li><p>网络安全法</p></li><li><p>核安全法</p></li><li><p>数据安全法</p></li></ul></li><li><p>建立健全国家安全工作机制</p><ul><li><p>情报信息工作协调机制</p></li><li><p>风险评估机制</p></li><li><p>审查和监管制度</p></li><li><p>危机管控制度</p></li><li><p>保障体系</p></li><li><p>国家安全能力显著增强</p></li></ul></li></ul></li><li><p>反渗透反恐怖反分裂斗争卓有成效</p><ul><li><p>坚定维护政权安全、制度安全、意识形态安全</p></li><li><p>顶住和反击外部极端打压遏制</p></li><li><p>推动香港局势实现由乱到治的重大转折</p></li><li><p>深入开展涉台、涉疆、涉藏、涉海等斗争</p></li><li><p>稳步推进兴边富民、稳边固边</p></li><li><p>妥善处置周边安全风险</p></li></ul></li><li><p>把安全发展贯穿国家发展各领域全过程</p><ul><li><p>防控经济金融风险取得重大进展</p></li><li><p>关键核心技术攻关取得重要进展</p></li><li><p>扫黑除恶专项斗争取得胜利</p></li><li><p>妥善应对重大自然灾害</p></li><li><p>统筹疫情防控和经济社会发展</p></li><li><p>网络、数据、人工智能、生物、太空、深海、极地等新型领域安全能力持续增强</p></li><li><p>有力应对海外利益风险挑战</p></li><li><p>维护国家安全的民心基础更加巩固</p></li></ul></li></ul><p>加强国家安全宣传教育和全民国防教育，巩固国家安全人民防线。人民群众国家安全意识显著增强，汇聚起维护国家安全的强大力量，有力夯实了国家安全的社会基础。</p><p>经过不懈努力，我国的国家主权、安全、发展利益得到全面维护，社会大局保持长期稳定。中国成为世界上最有安全感的国家之一。</p><h2id="二什么是总体国家安全观------新时代国家安全工作的根本遵循和行动指南">二、什么是总体国家安全观------新时代国家安全工作的根本遵循和行动指南</h2><h3 id="总体国家安全观的形成过程">总体国家安全观的形成过程</h3><p>2014年4月中央国家安全委员会第一次会议，习近平首次提出"坚持总体国家安全观"，强调走中国特色国家安全道路。</p><p>2017年10月党的十九大将"坚持总体国家安全观"纳入新时代坚持和发展中国特色社会主义的基本方略，并写入党章。</p><p>2018年4月十九届中央国家安全委员会第一次会议，习近平进一步阐述了总体国家安全观，提出坚持人民安全、政治安全、国家利益至上的有机统一，坚持维护和塑造国家安全等重大判断。</p><p>2020年10月党的十九届五中全会强调牢牢守住安全发展底线，首次把统筹发展和安全纳入"十四五"时期我国经济社会发展的指导思想，历史性地用专章对筑牢国家安全屏障作出战略部署。</p><p>2020年12月十九届中央政治局第二十六次集体学习：习近平对总体国家安全观作出全面、系统、完整的论述，阐明了新时代国家安全工作的总体目标，提出"十个坚持"的工作要求。</p><p>2021年11月党的十九届六中全会：系统总结新时代维护国家安全取得的重大成就和宝贵经验。</p><h3 id="总体国家安全观的丰富内涵">总体国家安全观的丰富内涵</h3><p>总体国家安全观以一系列紧密联系、相互贯通的基本观点，科学回答了中国这样一个发展中的社会主义大国如何维护和塑造国家安全的一系列基本问题，把我们党对国家安全的认识提升到了新的高度和境界，为破解我国国家安全面临的难题，推进新时代国家安全工作提供了基本遵循。</p><ul><li>总体国家安全观的关键是"总体"，强调大安全理念；</li><li>强调科学统筹； <img src="image3.png" /></li></ul><p>总体国家安全观强调做好国家安全工作的系统思维和方法，做到"五个统筹"，着力解决国家安全工作不平衡不充分的问题。</p><ul><li>统筹发展和安全</li></ul><p>发展和安全是一体之两翼、驱动之双轮。发展是安全的基础和目的，安全是发展的条件和保障，发展和安全要同步推进。</p><ul><li>统筹开放和安全</li></ul><p>健全开放安全保障体系，是"中国开放的大门越开越大"的重要保证。要坚持开放和安全的有机统筹，在保障安全中持续扩大开放，着力增强自身竞争能力、开放监管能力、风险防控能力，创造有利于我国经济社会发展的安全环境，牢固树立开放型经济安全防线。</p><ul><li>统筹传统安全和非传统安全</li></ul><p>面对传统安全威胁和非传统安全威胁相互交织、复杂演变的国际国内安全环境，必须统筹好传统安全和非传统安全，统筹推进各领域安全，构筑兼顾传统安全与非传统安全威胁的大安全格局。</p><ul><li>统筹自身安全和共同安全</li></ul><p>各国安全相互关联、彼此影响，安全利益你中有我、我中有你，没有绝对安全的世外桃源，必须摈弃唯我独尊、损人利己、以邻为壑等狭隘思维，把合作作为唯一选择。</p><p>中国始终坚持对内求发展、求变革、求稳定，建设平安中国；对外求和平、求合作、求共赢，维护世界和平与发展。</p><ul><li>统筹维护国家安全和塑造国家安全</li></ul><p>维护国家安全，要立足国际秩序大变局来把握，立足防范风险的大前提来统筹，立足我国发展重要战略机遇期大背景来谋划，保持战略定力、战略自信、战略耐心，把战略主动权牢牢掌握在自己手中。</p><p>塑造是更高层次更具前瞻性的维护，要发挥负责任大国作用，引导国际社会共同塑造更加公正合理的国际新秩序，推动各方朝着互利互惠、共同安全的目标相向而行。</p><ul><li>强调打总体战</li></ul><p>总体国家安全观强调国家安全要贯穿到党和国家工作全局各方面、各环节，绝非某一领域、单一部门的职责，必须汇聚党政军民学各战线各方面各层级的强大合力，全社会全政府全体系全手段应对重大国家安全风险挑战。</p><ul><li>总体国家安全观具有重大而深远的意义</li></ul><p>理论意义：总体国家安全观深化了我们党对中国特色社会主义建设规律的认识，为发展马克思主义国家安全理论作出了重大原创性贡献。</p><p>实践意义：总体国家安全观经过实践检验、富有实践伟力，为维护和塑造新时代国家安全提供了行动纲领</p><p>文化意义：总体国家安全观提炼中华优秀传统战略文化，总结我们党维护国家安全的理论和实践成果，为坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合树立了光辉典范。</p><p>世界意义：总体国家安全观开辟了国家安全治理新路径，为推动和完善全球安全治理贡献了中国方案。</p><h3 id="坚持中国特色国家安全道路">坚持中国特色国家安全道路</h3><p>中国特色国家安全道路本质上是中国特色社会主义道路在国家安全上的具体体现。必须坚持总体国家安全观，以人民安全为宗旨，以政治安全为根本，以经济安全为基础，以军事、科技、文化、社会安全为保障，以促进国际安全为依托，走出一条中国特色国家安全道路。</p><p>中国特色国家安全道路的重要特征</p><ul><li><p>坚持党的绝对领导，完善集中统一、高效权威的国家安全工作体制，实现人民安全、政治安全、国家利益至上相统一。</p></li><li><p>坚持捍卫国家主权和领土完整，维护边疆、边境、周边安定有序。</p></li><li><p>坚持安全发展，推动高质量发展和高水平安全动态平衡。</p></li><li><p>坚持总体战，统筹传统安全和非传统安全。</p></li><li><p>坚持走和平发展道路，促进自身安全和共同安全相协调。</p></li></ul><p>走中国特色国家安全道路，努力开创国家安全工作新局面，是对总体国家安全观的贯彻落实，归根到底是为了确保中华民族伟大复兴进程不被迟滞甚至中断。</p><h3id="贯彻总体国家安全观要统筹推进重点领域安全">贯彻总体国家安全观要统筹推进重点领域安全</h3><p>政治安全、国土安全、经济安全、社会安全、网络安全、外部安全</p><ul><li>维护政治安全</li></ul><p>政治安全攸关党和国家生死存亡，是国家安全的根本。政治安全的核心是政权安全和制度安全，最根本的就是维护中国共产党的领导和执政地位、维护中国特色社会主义制度。</p><ul><li><p>要毫不动摇地坚持和巩固党的领导地位和执政地位</p></li><li><p>要毫不动摇地坚持和完善中国特色社会主义制度</p></li><li><p>要坚决打赢意识形态斗争</p></li><li><p>要严密防范和坚决打击各种渗透颠覆破坏活动</p></li><li><p>要全面贯彻党的民族政策和宗教政策</p></li><li><p>要防范化解党的建设面临的风险</p></li><li><p>要高度重视对青年一代的思想政治工作</p></li><li><p>维护国土安全</p></li></ul><p>国土安全是立国之基。国土的安全状态与国家能否繁荣息息相关。</p><ul><li><p>要加强边防、海防、空防建设，坚决捍卫领土主权和海洋权益</p></li><li><p>要有效遏制侵害我国国土安全的各种图谋和行为，筑牢国土安全的铜墙铁壁</p></li><li><p>要坚决反对一切分裂祖国的活动，严厉打击恐怖主义、分裂主义、极端主义这"三股势力"，坚决防范"藏独""东突"，防范恐怖极端势力回流</p></li><li><p>要坚决挫败任何形式的"台独"分裂图谋，全力维护香港、澳门长期繁荣稳定</p></li><li><p>维护经济安全</p></li></ul><p>经济安全是国家安全的基础。只有推动经济持续健康发展，才能筑牢国家繁荣富强、人民幸福安康、社会和谐稳定的物质基础。</p><ul><li><p>要保证基本经济制度安全</p></li><li><p>要坚决守住不发生系统性金融风险底线</p></li><li><p>要深化供给侧结构性改革</p></li><li><p>要优化和稳定产业链、供应链</p></li><li><p>要确保能源和重要资源安全</p></li><li><p>要牢牢把住粮食安全主动权</p></li><li><p>要织密织牢开放安全网</p></li><li><p>要加强自主创新能力建设</p></li><li><p>维护社会安全</p></li></ul><p>社会安全与人民群众切身利益关系最密切，是人民群众安全感的晴雨表，是社会安定的风向标。</p><ul><li><p>要大力推进平安中国建设</p></li><li><p>要完善立体化信息化社会治安防控体系</p></li><li><p>要深入推进扫黑除恶专项斗争</p></li><li><p>要坚决打击恐怖主义</p></li><li><p>要推进应急管理体系和能力现代化</p></li><li><p>维护网络安全</p></li></ul><p>网络安全已经成为我国面临的最复杂、最现实、最严峻的非传统安全问题之一。</p><ul><li><p>要加速推动信息领域核心技术突破</p></li><li><p>要加强关键信息基础设施网络安全防护</p></li><li><p>要加强网络安全预警监测</p></li><li><p>要依法加强网络空间治理</p></li><li><p>要切实维护国家网络空间主权安全，共同构建网络空间命运共同体</p></li><li><p>维护外部安全</p></li></ul><p>和平稳定的国际环境和国际秩序是国家安全的重要保障。</p><ul><li><p>要坚持共同、综合、合作、可持续的新安全观，积极塑造外部安全环境</p></li><li><p>要切实维护我国海外利益安全，努力形成强有力的海外利益安全保障体系</p></li><li><p>要加强安全领域国际合作，引导国际社会共同维护国际安全</p></li></ul><h2id="三怎样着力防范化解重大风险------新时代维护国家安全的实践要求">三、怎样着力防范化解重大风险------新时代维护国家安全的实践要求</h2><h3 id="增强忧患意识坚持底线思维">增强忧患意识、坚持底线思维</h3><p>忧患意识是中华民族能够生生不息、绵延不绝的文化基因，也是融入中国共产党精神血脉的政治品质。中国共产党在内忧外患中诞生，在磨难挫折中成长，在战胜风险挑战中壮大，始终有着强烈的忧患意识、风险意识。</p><p>新形势下我国国家安全和社会安定面临的威胁和挑战增多，特别是各种威胁和挑战联动效应明显。如果防范不及、应对不力，就会传导、叠加、演变、升级，使小的矛盾风险挑战发展成大的矛盾风险挑战，局部的矛盾风险挑战发展成系统的矛盾风险挑战，国际上的矛盾风险挑战演变为国内的矛盾风险挑战，经济、社会、文化、生态领域的矛盾风险挑战转化为政治矛盾风险挑战，最终危及党的执政地位、危及国家安全。</p><p>面对波谲云诡的国际形势、复杂敏感的周边环境、艰巨繁重的改革发展稳定任务，我们必须树立底线思维。</p><ul><li><p>各种风险我们都要防控，但重点要防控那些可能迟滞或中断中华民族伟大复兴进程的全局性风险。</p></li><li><p>把困难估计得更充分，把风险思考得更深入，注重堵漏洞、强弱项，提高防控能力，用大概率思维应对小概率事件，牢牢守住不发生系统性风险的底线。</p></li></ul><h3 id="坚持立足于防又有效处置风险">坚持立足于防、又有效处置风险</h3><ul><li><p>既要高度警惕"黑天鹅"事件，也要防范"灰犀牛"事件</p></li><li><p>既要有防范风险的先手，也要有应对和化解风险挑战的高招</p></li><li><p>既要打好防范和抵御风险的有准备之战，也要打好化险为夷、转危为机的战略主动战</p></li><li><p>既要高度警惕"黑天鹅"事件，也要防范"灰犀牛"事件</p></li></ul><p>"黑天鹅"事件：难以预测，但突然发生时会引起连锁反应、带来巨大负面影响的小概率事件</p><p>"灰犀牛"事件：明显的、高概率的却又屡屡被人忽视、最终有可能酿成大危机的事件。</p><ul><li>既要有防范风险的先手，也要有应对和化解风险挑战的高招</li></ul><p>既要有防范风险的先手：要加强战略预判和风险预警，见微知著、未雨绸缪，力争把风险化解在源头，防止各种风险传导、叠加、演变、升级。</p><p>不让小风险演化为大风险；不让个别风险演化为综合风险；不让局部风险演化为系统性风险；不让经济风险演化为社会政治风险；不让国际风险演化为国内风险</p><p>应对和化解风险挑战的高招：要提高风险化解能力，抓住要害、找准原因，果断决策，引导群众、组织群众，整合各方力量、科学排兵布阵，有效予以处理。</p><h3 id="运用制度威力应对风险挑战">运用制度威力应对风险挑战</h3><p>我们要打赢防范化解重大风险攻坚战，必须坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化，运用制度威力应对风险挑战的冲击。发展环境越是严峻复杂，越要坚定不移深化改革，健全各方面制度，完善治理体系，促进制度建设和治理效能更好转化融合。</p><p>小结：</p><p>党的十八大以来，习近平创造性提出总体国家安全观的系统思想，成为维护国家安全的行动纲领和科学指南。总体国家安全观以一系列紧密联系、相互贯通的基本观点，科学回答了中国这样一个发展中的社会主义大国如何维护和塑造国家安全的一系列基本问题，标志着我们党对国家安全基本规律的认识达到了新高度。国家安全是安邦定国的重要基石，必须坚持总体国家安全观，实现人民安居乐业、党的长期执政、国家长治久安。</p><h1 id="第十四讲-坚持一国两制和推进祖国统一">第十四讲坚持"一国两制"和推进祖国统一</h1><h2 id="一如何坚持一国两制">一、如何坚持"一国两制"</h2><h3id="一国两制是中国特色社会主义的一个伟大创举">"一国两制"是中国特色社会主义的一个伟大创举</h3><p>"一国两制"是国家的一项基本国策，"一国两制"就是在统一的国家之内，国家主体实行社会主义制度，个别地区依法实行资本主义制度。</p><ul><li><p>"一国两制"构想最早是针对台湾问题提出来的。1956年，毛泽东委托章士钊转去一封中共中央致蒋介石的信，并在信中提出了一系列和平统一台湾的具体办法。1963年1月，这些主张被周恩来概括归纳为"一纲四目"。1982年1月11日，邓小平会见美国华人协会主席李耀滋时说："九条方针是以叶剑英副主席的名义提出来的，实际上就是一个国家，两种制度。"这是邓小平首次提出"一国两制"的概念。"一国两制"构想在实践中首先被运用于解决香港、澳门问题。按照这一伟大构想，1997年和1999年香港、澳门相继回归祖国，改变了历史上但凡收复失地都要大动干戈的所谓定势，创造了推进祖国和平统一的伟大创举。"一国两制"在香港、澳门的成功实践为解决台湾问题提供了实践样本。</p></li><li><p>"一国两制"伟大构想为世界和平与发展作出积极贡献。"一国两制"的伟大构想，以海纳百川、有容乃大的政治智慧，获得了有关各方的一致认可，不费一兵一卒实现了港澳和平回归。这个新构想新方案，为国际社会解决类似问题提供了新的选择，为世界和平与发展作出了重要贡献。</p></li><li><p>"一国两制"是人类政治文明史上前无古人的伟大创举。"一国两制"重要制度，立足中国国情，顺应时代潮流，观照人民福祉，把原则性和灵活性、现实性和长远性、一致性和差异性统一起来，凝结了中国共产党人为解决国家统一问题展现出的超凡勇气和卓越智慧，是人类政治文明史上前无古人的伟大创举。</p></li></ul><h3 id="全面准确贯彻一国两制方针">全面准确贯彻"一国两制"方针</h3><p>"一国两制"是一个完整的概念。"一国"是实行"两制"的前提和基础，"两制"从属和派生于"一国"并统一于"一国"之内。"一国"是根，根深才能叶茂；"一国"是本，本固才能枝荣。</p><ul><li>如何理解中央对香港、澳门的全面管治权？</li></ul><p>近年来，香港社会有些人鼓吹香港有所谓"固有权力""自主权力"等，否认或抗拒中央对香港的管治权。事实上，我国是单一制国家，中央对包括香港、澳门特别行政区在内的所有区域拥有全面管治权，香港、澳门两个特别行政区的高度自治权不是固有的，主权和治权都在中央，其高度自治权是中央授予的。</p><ul><li>中央依据宪法和基本法对特别行政区拥有全面管治权。通过宪法和基本法，使中央政府拥有全面管治权，香港特别行政区拥有高度自治权。</li></ul><h3 id="坚定不移贯彻一国两制方针">坚定不移贯彻"一国两制"方针</h3><ul><li><p>支持特别行政区政府和行政长官依法施政、积极作为</p></li><li><p>坚守"一国"之本，实现"两制"和谐相处、彼此促进</p></li></ul><p>在"一国两制"的实践中，必须把坚持"一国"原则和尊重"两制"差异有机结合起来，做到坚守"一国"之本，实现"两制"和谐相处、彼此促进，既要把实行社会主义制度的内地建设好，也要把实行资本主义制度的香港、澳门建设好。例如不断支持内地与港澳地区在CEPA框架下不断扩大和升级经贸合作。</p><ul><li>在"一国"前提下，"两制"成为保持社会长期繁荣的最佳制度形式</li></ul><p>香港、澳门长期遭受殖民统治，受西方资本主义制度影响深重，与国家主体社会主义制度存在较大差异。在"一国"的前提下，"两制"并存具有最大程度的包容性和适应性，为港澳顺利回归、保持长期繁荣稳定提供了最佳制度形式。</p><p>二、为什么说"一国两制"行得通、办得到、得人心</p><h3id="推动香港局势由乱到治的重大转折">推动香港局势由乱到治的重大转折</h3><ul><li><p>香港"修例风波"的缘起。香港回归祖国以来，"一国两制"实践取得举世公认的成就。但香港内外的破坏性力量一直没有停止对"一国两制"方针的干扰和破坏，"港独"组织和本土激进分离势力的活动日益猖獗。自2019年6月以来，香港反对派和一些激进势力借和平游行集会之名，进行各种激进抗争活动。虽然特区政府已多次表示修订《逃犯条例》工作已彻底停止，但他们继续以"反修例"为幌子，得寸进尺、变本加厉，暴力行为不断升级，社会波及面越来越广。2019年"修例风波"期间，"港独"组织和激进分离势力在外国和"台独"势力支持下，公然叫嚣"香港独立"等口号，煽动无底线的"揽炒"，实施触目惊心甚至具有恐怖主义性质的暴力犯罪，乞求并勾连外国和"台独"势力赤裸裸地干预香港事务......这些违法行径，严重挑战"一国两制"原则底线，严重冲击香港的法治和社会秩序，严重威胁香港居民的权利、自由和香港的繁荣稳定。</p></li><li><p>"修例风波"的实质。"修例风波"实质上是一场港版"颜色革命"，反中乱港势力及其背后支持的外部势力不仅是要夺取香港管治权，搞乱香港，而且企图搞乱内地，颠覆中国共产党的领导和中国特色社会主义制度，阻挠中华民族伟大复兴的进程。</p></li></ul><p>在此次香港"修例风波"中，黎智英、李柱铭、陈方安生、何俊仁组成的"叛国乱港四人帮"勾结美国等西方势力，上蹿下跳、肆意妄为，演出了一幕幕"反中乱港"的丑剧。香港"修例风波"期间，美国众议院议长南希·佩洛西曾把乱港暴力游行形容为"美丽风景线"，并暗中扶持、教唆、挑动乱港暴行。</p><ul><li>香港地区政治经济社会生活秩序面临严峻挑战。</li></ul><p>根据香港政府经济顾问办公室推算，2019年香港"修例风波"期间，共计造成经济损失至少约150亿元。仅2019年第三季度，访港游客数环比下跌逾26%，超过40个地区向香港发出旅游警示。零售业销售总量环比下跌-5%。香港地区罪案数字在2019年期间上升9%。</p><p>面对"修例风波"造成的香港回归以来最严峻的局势，以习近平同志为核心的党中央审时度势，果断决策，决定成立中央港澳工作领导小组，并接连推出一系列标本兼治的举措，止暴制乱，促使香港局势由乱到治、香港发展重回正轨。</p><ul><li>制定实施《中华人民共和国香港特别行政区维护国家安全法》。</li></ul><p>2020年6月30日，为堵塞香港国家安全法律漏洞，保持香港繁荣稳定，保障香港居民合法权益，第十三届全国人大常委会第二十次会议表决通过《中华人民共和国香港特别行政区维护国家安全法》。2020年7月3日，香港特别行政区维护国家安全委员会正式成立，并于7月6日召开首次会议。</p><ul><li>香港法治得到彰显，政治社会生活逐步回归正轨。</li></ul><p>2021年以来，在新选举制度下，香港先后举行了选举委员会选举、第七届立法会选举、第六任行政长官选举，都取得成功。在新选制的保障下，越来越多贤能爱国者进入特别行政区管治架构，一支爱国爱港、担当作为、精诚团结、为民服务的爱国者治港队伍初步形成。</p><p>6、香港已实现由乱到治的重大转折，正处在由治及兴的关键时期</p><p>在中央政府、香港特别行政区政府和社会各界的共同努力下，香港已实现由乱到治的重大转折，正处在由治及兴的关键时期。香港新起点与国家新征程相交汇，必将产生强大合力，迸发巨大能量。行而不辍，未来可期。只要毫不动摇坚持"一国两制"，香港的未来一定会更加美好，香港一定能为中华民族伟大复兴作出新的更大贡献！</p><h3id="推进具有澳门特色的一国两制成功实践">推进具有澳门特色的"一国两制"成功实践</h3><ul><li><p>全面落实"一国两制"与"爱国者治澳"相结合.澳门特别行政区政府和社会各界人士坚持把"一国两制"原则要求同澳门实际相结合，勇于探索和创新，使澳门"一国两制"实践呈现出许多亮点：爱国爱澳成为全社会的核心价值，宪法和基本法权威牢固树立，行政主导体制顺畅运行，融入国家发展大局积极主动，包容和谐增强社会凝聚力。</p></li><li><p>实现澳门地区经济发展、社会有效治理。</p></li></ul><p>回归以来，澳门地区在中央大力支持下实现了经济迅速发展，旅游、会展、餐饮、酒店及零售业欣欣向荣，实现跨越式发展，人均收入水平稳居世界前列。</p><p>在中央政府和祖国内地的大力支持下，在"爱国爱澳"主流价值的引领下，在澳门各界的努力下，澳门发生了翻天覆地的变化，丰富了"一国两制"内涵，走出一条具有澳门特色的"一国两制"成功实践道路。</p><h3id="支持香港澳门融入国家发展大局">支持香港、澳门融入国家发展大局</h3><p>当前，香港、澳门经济社会发展中遇到一些新情况新问题，传统优势相对减弱，新的经济增长点尚未形成，住房等民生问题比较突出。囿于港澳地域、经济结构和体量、市场空间等条件，仅靠自身力量难以解决这些问题。</p><ul><li><p>积极推动港澳地区与内地经济发展互动。</p><ul><li><p>2014年以来，以"沪港通""深港通""债券通"为主要载体的港澳地区与内地金融市场互联互通机制正式建立，并实现了有序发展。</p></li><li><p>粤港澳大湾区建设，是习近平总书记亲自谋划、亲自部署、亲自推动的重大国家战略。"一个国家、两种制度、三个关税区、三种货币"之下的湾区建设，开世界未有之先例。目前，横琴粤澳深度合作区建设稳步推进，创新粤澳双方共商共建共管新体制，管委会、执委会和省派出机构已揭牌运作。截至2022年6月末，合作区实有企业54350户，其中内资企业46690户，外商及港澳台商投资企业7660户(含澳资企业4934户)，就业登记人数67569人。</p></li><li><p>开发建设前海深港现代服务业合作区，是习近平总书记亲自谋划、亲自部署、亲自推动的国家改革开放重大举措，对于支持香港经济社会发展、提升粤港澳合作水平、增强香港同胞对祖国的向心力具有重要意义。2021年，前海合作区在地港资企业数量同比增长156%，实际使用港资占前海实际使用外资-8%。前海深港现代服务业合作区统筹推进"物理扩区"和"政策扩区"，坚持1/3以上土地面向港企出让，累计注册港资企业-19万家，2021年前海合作区### 完成地区生产总值- 7亿元，同比增长-5%。推动粤港澳青年交往交流交融，2022年7月，前海深港青年梦工场北区正式开园，拓展创业空间至-9万平方米，新孵化创业团队87家。</p></li></ul></li></ul><p>三、为什么说祖国完全统一的时和势始终在我们这一边</p><p>党的十八大以来，习近平总书记全面把握两岸关系时代变化，就对台工作提出一系列重要理念、重大政策主张，形成新时代党解决台湾问题的总体方略。新时代党解决台湾问题的总体方略，是习近平新时代中国特色社会主义思想的重要组成部分，是中国共产党人在解决台湾问题、推进祖国统一实践中形成的最新理论结晶，为新时代对台工作提供了根本遵循和行动指南。</p><h3 id="祖国必须统一也必然统一">祖国必须统一，也必然统一</h3><ul><li>民族复兴、国家统一是大势所趋、大义所在、民心所向。虽然两岸迄今尚未统一，但中国的主权和领土完整从未分裂。两岸同属一个国家、两岸同胞同属一个民族，这一历史事实和法理基础从未改变，也不可能改变。</li></ul><p>2005年颁布实施的《反分裂国家法》明确指出：世界上只有一个中国，大陆和台湾同属一个中国，中国的主权和领土完整不容分割。完成统一祖国的大业是包括台湾同胞在内的全中国人民的神圣职责。</p><p>2完成统一祖国的大业是全体中华儿女的神圣职责。解决台湾问题、实现祖国完全统一，是党矢志不渝的历史任务，是全体中华儿女的共同愿望，是实现中华民族伟大复兴的必然要求。确保国家完整不被分裂，维护中华民族根本利益，是全体中华儿女共同意志，是不可阻挡的历史潮流。</p><h3 id="推进祖国和平统一进程">推进祖国和平统一进程</h3><p>1恪守"一个中国"原则，努力实现两岸和平统一。"一个中国"原则是两岸关系的政治基础，推动两岸关系和平发展的最根本原则。</p><p>2推进两岸经济社会融合发展。</p><p>近年来，两岸交流合作日益广泛，互动往来日益密切，给两岸同胞特别是台湾同胞带来实实在在的好处，充分说明两岸合则两利、合则双赢。</p><p>3秉持"两岸一家亲"，出台一系列惠及广大台胞的政策</p><p>从《关于促进两岸经济文化交流合作的若干措施》到《关于进一步促进两岸经济文化交流合作的若干措施》，从《关于应对疫情统筹做好支持台资企业发展和推进台资项目有关工作的通知》到《关于支持台湾同胞台资企业在大陆农业林业领域发展的若干措施》......大陆种种举措给予台胞生活、学习、就业及创业同等待遇，使广大台胞积极融入祖国发展新格局，在两岸融合发展中画出最大同心圆。</p><h3id="绝不允许把任何一块中国领土从中国分裂出去">绝不允许把任何一块中国领土从中国分裂出去</h3><p>1坚决反对任何形式的"台独"分裂行径</p><p>2016年以来，台湾当局加紧进行"台独"分裂活动，致使两岸关系和平发展势头受到严重冲击。当前，对两岸关系和平发展的最大现实威胁是"台独"势力及其分裂活动。"台独"煽动两岸同胞敌意和对立，损害国家主权和领土完整，破坏台海和平稳定，阻挠两岸关系发展，只会给两岸同胞带来深重祸害，是走不通的绝路。</p><p>民进党当局坚持"台独"分裂立场，勾连外部势力不断进行谋"独"挑衅。他们拒不接受一个中国原则，歪曲否定"九二共识"，妄称"中华民国与中华人民共和国互不隶属"，公然抛出"新两国论"；在岛内推行"去中国化""渐进台独"，纵容"急独"势力鼓噪推动"修宪修法"，欺骗台湾民众，煽动仇视大陆，阻挠破坏两岸交流合作和融合发展，加紧"以武谋独""以武拒统"；勾结外部势力，在国际上竭力制造"两个中国""一中一台"。民进党当局的谋"独"行径导致两岸关系紧张，危害台海和平稳定，破坏和平统一前景、挤压和平统一空间，是争取和平统一进程中必须清除的障碍。</p><p>2"台独"分裂势力抗拒统一不会得逞</p><p>台湾是包括2300万台湾同胞在内的全体中国人民的台湾，中国人民捍卫国家主权和领土完整、维护中华民族根本利益的决心不可动摇、意志坚如磐石，这是挫败一切"台独"分裂图谋的根本力量。搞"台独"分裂抗拒统一，根本过不了中华民族的历史和文化这一关，也根本过不了14亿多中国人民的决心和意志这一关，是绝对不可能得逞的。</p><p>当前，美国一些势力图谋"以台制华"，处心积虑打"台湾牌"，刺激"台独"分裂势力冒险挑衅，不仅严重危害台海和平稳定，妨碍中国政府争取和平统一的努力，也严重影响中美关系健康稳定发展。</p><p>3外部势力阻碍中国完全统一必遭失败</p><p>　中国坚定不移走和平发展道路，同时决不会在任何外来干涉的压力面前退缩，决不会容忍国家主权、安全、发展利益受到任何损害。"挟洋谋独"没有出路，"以台制华"注定失败。祖国统一的历史车轮滚滚向前，任何人任何势力都无法阻挡。</p><p>我们愿继续以最大诚意、尽最大努力争取和平统一。我们不承诺放弃使用武力，保留采取一切必要措施的选项，针对的是外部势力干涉和极少数"台独"分裂分子及其分裂活动，绝非针对台湾同胞，非和平方式将是不得已情况下做出的最后选择。如果"台独"分裂势力或外部干涉势力挑衅逼迫，甚至突破红线，我们将不得不采取断然措施。</p><p>课堂小结</p><p>"一国两制"是国家的一项基本国策，是中国特色社会主义的一个伟大创举，必须完整准确理解"一国两制"方针，坚定不移贯彻"一国两制"方针。"一国两制"是维护港澳长期繁荣稳定的最佳制度，推动香港实现了由乱到治的重大转折，推进了具有澳门特色的成功实践，有力支持了港、澳融入国家发展大局。祖国必须统一，也必然统一。新时代党解决台湾问题的总体方略，有力推进了祖国和平统一进程，也为彻底解决"台独"问题，实现祖国完全统一提供了根本遵循。</p><h1 id="第十五讲-推动构建人类命运共同体">第十五讲推动构建人类命运共同体</h1><h2 id="一世界怎么了">一、世界怎么了</h2><h3 id="世界进入动荡变革期">世界进入动荡变革期</h3><p>把握世界历史大势的方法论：正确历史观、正确大局观、正确角色观</p><ul><li><p>百年变局与世纪疫情交织叠加</p><ul><li><p>表征之一：世界经济增长放缓</p></li><li><p>表征之二："西方之乱"凸显资本主义制度缺陷</p></li></ul></li></ul><h3id="国际力量对比发生深刻变化新兴市场国家和发展中国家快速发展">国际力量对比发生深刻变化：新兴市场国家和发展中国家快速发展</h3><h3 id="经济全球化遭遇逆流">经济全球化遭遇逆流</h3><ul><li><p>单边主义、保护主义抬头</p></li><li><p>经济全球化不是世界问题的"祸根"</p></li></ul><h3 id="国际体系和国际秩序深度调整">国际体系和国际秩序深度调整</h3><ul><li><p>美国全球霸权地位遭遇挑战</p></li><li><p>发展中国家在全球治理体系中的话语权提升</p></li></ul><h2 id="二人类向何处去">二、人类向何处去</h2><h3id="人类是一个整体地球是一个家园">人类是一个整体，地球是一个家园</h3><ul><li><p>人类生活在同一个"地球村"</p></li><li><p>人类是不可分割的有机整体，解决全球性问题包括治理赤字、和平赤字、信任赤字、发展赤字等需要全人类共同努力</p></li></ul><h3 id="人类命运共同体的内涵">人类命运共同体的内涵</h3><ul><li><p>人类命运共同体理念是回答和解决当今世界面临的"时代之问"的中国方案</p></li><li><p>人类命运共同体的提出与深化</p><ul><li><p>2013年3月，习近平在莫斯科国际关系学院发表题为《顺应时代前进潮流促进世界和平发展》的演讲，指出这个世界越来越成为你中有我、我中有你的命运共同体，和平、发展、合作、共赢成为时代潮流。</p></li><li><p>2015年9月，习近平在纽约联合国总部出席第70届联合国大会一般性辩论时发表题为《携手构建合作共赢新伙伴同心打造人类命运共同体》的重要讲话，指出我们要继承和弘扬联合国宪章的宗旨和原则，构建以合作共赢为核心的新型国际关系，打造人类命运共同体。</p></li><li><p>2017年1月，习近平在联合国日内瓦总部发表《共同构建人类命运共同体》的主旨演讲，提出世界怎么了、我们怎么办？这是整个世界都在思考的问题。中国方案是：构建人类命运共同体，实现共赢共享。</p></li><li><p>2019年5月，习近平在亚洲文明对话大会开幕式上发表题为《深化文明交流互鉴共建亚洲命运共同体》的主旨演讲，希望各国秉持开放精神，推进政策沟通、设施联通、贸易畅通、资金融通、民心相通，共同构建亚洲命运共同体、人类命运共同体。</p></li><li><p>2020年9月，习近平在第75届联合国大会一般性辩论上发表重要讲话，强调坚守和平、发展、公平、正义、民主、自由的全人类共同价值，推动构建新型国际关系，推动构建人类命运共同体，共同创造世界更加美好的未来。</p></li><li><p>2021年1月，习近平在世界经济论坛"达沃斯议程"对话会上发表题为《让多边主义的火炬照亮人类前行之路》的特别致辞，强调人类只有一个地球，人类也只有一个共同的未来。无论是应对眼下的危机，还是共创美好的未来，人类都需要同舟共济、团结合作。实践一再证明，任何以邻为壑的做法，任何单打独斗的思路，任何孤芳自赏的傲慢，最终都必然归于失败！让我们携起手来，让多边主义火炬照亮人类前行之路，向着构建人类命运共同体不断迈进。</p></li><li><p>2022年4月，习近平在博鳌亚洲论坛2022年年会开幕式上发表题为《携手迎接挑战，合作开创未来》的主旨演讲，强调人类是休戚与共的命运共同体，各国要顺应和平、发展、合作、共赢的时代潮流，向着构建人类命运共同体的正确方向，携手迎接挑战、合作开创未来。</p></li></ul></li><li><p>如何理解人类命运共同体的内涵？</p></li></ul><p>------人类生活在同一个地球村，生活在历史和现实交汇的同一个时空，越来越成为你中有我，我中有你的命运共同体。构建人类命运共同体是为解决世界之问、人类之问、时代之问而提出的中国方案，需要国际社会从伙伴关系、安全格局、经济发展、文明交流、生态建设等方面作出努力。</p><ul><li><p>坚持对话协商，建设持久和平的世界</p></li><li><p>坚持共建共享，建设普遍安全的世界</p></li><li><p>坚持合作共赢，建设共同繁荣的世界</p></li><li><p>坚持交流互鉴，建设开放包容的世界</p></li><li><p>坚持绿色低碳，建设清洁美丽的世界</p></li></ul><p>中国是全球应对气候变化事业的积极参与者</p><h3 id="弘扬全人类共同价值">弘扬全人类共同价值</h3><ul><li>全人类共同价值：和平、发展、公平、正义、民主、自由</li></ul><p>全人类共同价值是构建人类命运共同体的重要思想基础，凝聚了人类不同文明的价值共识，反映了世界各国人民普遍认同的价值理念的最大公约数，超越了意识形态、社会制度和发展水平的差异，顺应历史潮流，契合时代需要。</p><ul><li><p>西方"普世价值"并不"普世"</p><ul><li><p>含义：西方"普世价值"是指，试图将自由、民主、人权等西方资本主义社会的核心价值观作为人类普遍遵循的价值观念。</p></li><li><p>目的：西方国家打着"普世价值"的旗号为其推行霸权主义寻找借口，攻击甚至颠覆不符合其意愿和利益的他国政权，以获取战略利益和战略资源。</p></li><li><p>本质："普世价值"是西方推行霸权主义的工具、抢占道德高地的道具和对外形象宣传的面具。</p></li><li><p>全人类共同价值与普世价值的本质区别</p></li></ul></li><li><p>形成条件不同。全人类共同价值是全人类共同追求和坚守的价值观念，是人类历史从民族的历史走向世界的历史的必然产物。西方"普世价值"的本质是西方资本主义的价值观，是基于西方独特历史实践而形成的价值理念。</p></li><li><p>目标追求不同。全人类共同价值倡导不同社会制度、不同意识形态、不同历史文化、不同发展水平的国家在国际事务中利益共生、权利共享、责任共担。西方"普世价值"旨在推销资本主义政治体制和意识形态，所追求的是维护西方主导的国际秩序，并将之拓展到世界每一个角落。</p></li><li><p>实现方式不同。全人类共同价值主张推动构建人类命运共同体，携手应对全球性风险和挑战，共同创造人类更加美好的未来。西方"普世价值"将世界划分为三六九等，强迫非西方国家接受西方理念，不惜发动战争，先制造危机，而后通过"解决危机"实现价值渗透。</p></li></ul><p>总结：弘扬和平、发展、公平、正义、民主、自由的全人类共同价值是人间正道。</p><h2 id="三中国怎么办">三、中国怎么办</h2><h3 id="全面推进中国特色大国外交">全面推进中国特色大国外交</h3><p>中国特色大国外交新路：以周边和大国为重点、以发展中国家为基础、以多边为舞台</p><ul><li><p>推进大国协调合作，构建总体稳定、均衡发展的大国关系框架</p></li><li><p>秉承亲诚惠容的周边外交理念，打造周边命运共同体</p></li></ul><p>中国视周边为安身立命之所、发展繁荣之基，始终将周边置于外交全局的首要位置</p><ul><li>秉承正确义利观和真实亲诚理念，加强同发展中国家团结合作</li></ul><h3 id="推动建设新型国际关系">推动建设新型国际关系</h3><ul><li>创造性提出建设新型国际关系</li></ul><p>新型国际关系"新"在何处？</p><ul><li><p>"新"在合作共赢，强调把本国利益同各国共同利益结合起来，努力扩大各方共同利益的汇合点，积极树立双赢、多赢、共赢的新理念，摒弃赢者通吃的旧思维。</p></li><li><p>核心是维护联合国宪章的宗旨和原则，维护不干涉别国内政和尊重国家主权、独立、领土完整等国际关系基本准则，维护联合国及其安理会对世界和平承担的首要责任，开展对话和合作，而不是对抗；实现双赢和共赢，而不是单赢。</p></li></ul><p>总结：构建人类命运共同体是目标和方向，建设新型国际关系是前提和路径，实质是要走出一条国与国交往的新路，并为构建人类命运共同体开辟道路、创造条件。</p><ul><li>中国的"朋友圈"越来越大</li></ul><h3 id="积极参与全球治理体系改革">积极参与全球治理体系改革</h3><ul><li>全球治理理念创新</li></ul><p>全球治理观：国际社会发展到今天已经成为一部复杂精巧、有机一体的机器，拆掉一个零部件就会使整个机器运转面临严重困难，被拆的人会受损，拆的人也会受损。当今世界，任何单边主义、极端利己主义都是根本行不通的，任何脱钩、断供、极限施压的行径都是根本行不通的，任何搞"小圈子"、以意识形态划线挑动对立对抗也都是根本行不通的。我们要践行共商共建共享的全球治理观，弘扬全人类共同价值，倡导不同文明交流互鉴。</p><ul><li>践行真正的多边主义</li></ul><h3 id="开展抗疫国际合作">开展抗疫国际合作</h3><p>携手抗疫国际合作，展现大国担当形象</p><p>第十六讲 全面从严治党</p><p>一、为什么全面从严治党</p><ul><li>从严治党是马克思主义政党的政治优势。</li></ul><p>我们党是用革命理想和铁的纪律组织起来的马克思主义政党，组织严密、纪律严明是党的优良传统和政治优势，也是我们的力量所在。</p><p>首先，从严治党是马克思主义政党建设的一贯要求。马克思在《国际工人协会共同章程》中提出，"每一支部应对接受的会员的品质纯洁负责"。</p><p>其次，从严治党是中国共产党建设的优良传统。百年来，中国共产党始终把从严治党视为重中之重。新民主主义革命时期，红都瑞金打响了中国共产党惩治腐败分子的第一枪；社会主义革命和建设时期，针对刘青山、张子善等人的腐败行为，中国共产党坚持从严治党，坚决进行了处理；改革开放和社会主义现代化建设新时期，中共中央在1983年到1987年开展了全面整党工作。党始终坚持从严治党，保持了党的先进性和纯洁性。</p><ul><li>全面从严治党是实现民族复兴的根本保证</li></ul><p>坚持党的领导，坚持党要管党、全面从严治党，是进行具有许多新的历史特点的伟大斗争、推进中国特色社会主义伟大事业、实现民族复兴伟大梦想的根本保证，也是我们党紧跟时代前进步伐、始终保持先进性和纯洁性的必然要求。我们党团结带领人民进行革命、建设、改革的实践都证明，什么时候我们党自身坚强有力，什么时候党和人民事业就能无往而不胜。------习近平在党的十九届一中全会上的讲话</p><p>把全面从严治党纳入"四个全面"战略布局。党的十八大以来，以习近平同志为核心的党中央将全面从严治党纳入"四个全面"战略布局，把严的标准、严的措施贯穿管党治党全过程和各方面，为实现中华民族伟大复兴提供坚强政治引领和政治保障。</p><h3id="全面从严治党是决定党兴衰成败的关键因素">全面从严治党是决定党兴衰成败的关键因素</h3><p>新形势下，我们党的自身建设面临一系列新情况新问题新挑战，落实党要管党、从严治党的任务比以往任何时候都更为繁重、更为紧迫。我们必须以更大的决心和勇气抓好党的自身建设。------习近平在党的十八届一中全会上的讲话</p><p>新形势下党面临"四大考验""四种危险"</p><p>"四大考验"长期执政考验、改革开放考验、市场经济考验、外部环境考验。</p><p>"四种危险"：精神懈怠、能力不足、脱离群众、消极腐败。</p><p>党内出现的管党不力治党不严的问题：七个有之。</p><p>搞任人唯亲、排斥异己的有之</p><p>搞团团伙伙、拉帮结派的有之</p><p>搞匿名诬告、制造谣言的有之</p><p>搞收买人心、拉动选票的有之</p><p>搞封官许愿、弹冠相庆的有之</p><p>搞自行其是、阳奉阴违的有之</p><p>搞尾大不掉、妄议中央的也有之</p><p>二、为什么十八大以来管党治党宽松软状况得到根本扭转</p><h3 id="把党的政治建设摆在首位">把党的政治建设摆在首位</h3><h3 id="补足共产党人精神上的钙">补足共产党人精神上的钙</h3><h3 id="贯彻落实新时代党的组织路线">贯彻落实新时代党的组织路线</h3><h3 id="始终绷紧作风建设这根弦">始终绷紧作风建设这根弦</h3><h3 id="把纪律的螺丝拧得紧而又紧">把纪律的螺丝拧得紧而又紧</h3><h3 id="把权力关进制度的笼子里">把权力关进制度的笼子里</h3><h3 id="巩固发展反腐败斗争压倒性胜利">巩固发展反腐败斗争压倒性胜利</h3><p>坚持和加强党的全面领导，坚持党要管党、全面从严治党，以加强党的长期执政能力建设、先进性和纯洁性建设为主线，以党的政治建设为统领，以坚定理想信念宗旨为根基，以调动全党积极性、主动性、创造性为着力点，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，不断提高党的建设质量，把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党。</p><p>------习近平在中国共产党第十九次全国代表大会上的报告</p><h3 id="把党的政治建设摆在首位-1">把党的政治建设摆在首位</h3><p>党的十九大明确提出党的政治建设这个重大命题，强调党的政治建设是党的根本性建设，要把党的政治建设摆在首位，以党的政治建设为统领。</p><p>为什么要把党的政治建设摆在首位？</p><p>首先，政治建设决定党的建设的方向和效果。如果在方向问题上出现偏离，就会犯颠覆性错误。只有党的政治建设抓好了，党的政治方向、政治立场、政治大局把握住了，党的政治能力提高了，党的建设才能铸魂扎根。党的其他建设最终的着眼点和落脚点必须在政治建设上。不抓党的政治建设或背离党的政治建设指引的方向，党的其他建设就难以取得预期成效。</p><p>其次，把政治建设摆在首位，抓住了全面从严治党的根本性问题。党的十八大以来，在全面从严治党实践中，党深刻认识到，党内存在的很多问题都同政治问题相关联，都是因为党的政治建设没有抓紧、没有抓实。不从政治上认识问题、解决问题，就会陷入头痛医头、脚痛医脚的被动局面，就无法从根本上解决问题。"全面从严治党首先要从政治上看"。</p><p>再次，突出政治建设是十八大以来全面从严治党的成功经验。党的十八大以来，以习近平同志为核心的党中央突出强调党的政治建设，不断强化管党治党政治责任，严肃党内政治生活，严明政治纪律和政治规矩，党内政治生态明显好转，为党和国家各项事业发展提供了良好政治氛围和有力政治保证。这些成功实践使全党同志深刻认识到，党内存在的许多问题，原因都是过去一个时期管党治党宽松软，特别是对党的政治建设没有抓紧、抓实、抓好。党的十九大明确提出党的政治建设这个重大命题，强调党的政治建设是党的根本性建设，把党的政治建设纳入党的建设总体布局并摆在首位，这是马克思主义党建理论的重大创新。</p><p>党的政治建设的基本内容：1保证全党服从中央，坚持党中央权威和集中统一领导2坚定执行党的政治路线，严格遵守政治纪律和政治规矩3尊崇党章，严格执行新形势下党内政治生活若干准则4完善和落实民主集中制的各项制度5弘扬忠诚老实、公道正派、实事求是、清正廉洁等价值观6加强党性锻炼，不断提高政治觉悟和政治能力</p><p>最后，保证全党服从中央，坚持党中央权威和集中统一领导。中国共产党是中国特色社会主义事业的领导核心，是最高政治领导力量。坚持和完善党的领导，是党和国家的根本所在、命脉所在，是全国各族人民的利益所在、幸福所在。应对和战胜前进道路上的各种风险和挑战，关键在党。在坚持党中央权威和集中统一领导这个重大原则问题上，全党全国必须保持高度的思想自觉、政治自觉、行动自觉，丝毫不能动摇。</p><h3 id="补足共产党人精神上的钙-1">补足共产党人精神上的钙</h3><p>共产党人如果没有信仰、没有理想，或信仰、理想不坚定，精神上就会"缺钙"，就会得"软骨病"，就必然导致政治上变质、经济上贪婪、道德上堕落、生活上腐化。</p><p>------习近平在全国党校工作会议上的讲话 (2015年12月11日)</p><p>为什么苏共拥有20万党员时夺取了政权，拥有200万党员时打败了希特勒，而拥有近2000万党员时却失去了政权？</p><p>基础不牢，地动山摇。信念不牢也是要地动山摇的。苏联解体、苏共垮台、东欧剧变不就是这个逻辑吗？历史和现实都告诫我们：全党理想信念坚定，党就拥有无比强大力量；全党理想信念淡薄，党就会成为乌合之众，风一吹就散。</p><p>百年来，中国共产党坚持性质宗旨，坚持理想信念，坚守初心使命，勇于自我革命，从最初50多名党员发展到今天拥有9600多万名党员的世界第一大执政党，历经千锤百炼而朝气蓬勃，正带领中国人民以不可阻挡的步伐迈向伟大复兴。</p><p>如何做？</p><p>用科学理论武装头脑。党的十八大以来，我们党坚持思想建党和制度治党同向发力，用党的创新理论武装全党，推进学习型政党建设，教育引导广大党员、干部特别是领导干部从思想上正本清源、固本培元，筑牢信仰之基、补足精神之钙、把稳思想之舵，保持共产党人政治本色，挺起共产党人的精神脊梁。</p><p>党的十八大以来的5次集中学习教育一脉相承、次第展开，环环紧扣、层层深入，每一次都是理论武装的重要课堂，每一次都是自我革命的生动实践，每一次都是凝心聚力的奋进号角。</p><p>用习近平新时代中国特色社会主义思想武装全党。要坚持不懈用习近平新时代中国特色社会主义思想武装全党、教育人民，引导人们把握丰富内涵、精神实质、实践要求，打牢信仰信念的思想理论根基。</p><p>如何深入学习贯彻习近平新时代中国特色社会主义思想？</p><p>深入学习贯彻习近平新时代中国特色社会主义思想，必须在学懂弄通做实上下功夫。坚持读原著、学原文、悟原理，全面系统学、及时跟进学、深入思考学、联系实际学。强化理论武装，聚焦解决思想根子问题，深刻把握贯穿其中的马克思主义立场观点方法，知其然又知其所以然，不断提高马克思主义理论水平。</p><h3 id="贯彻落实新时代党的组织路线-1">贯彻落实新时代党的组织路线</h3><p>全面贯彻新时代中国特色社会主义思想，以组织体系建设为重点，着力培养忠诚干净担当的高素质干部，着力集聚爱国奉献的各方面优秀人才，坚持德才兼备、以德为先、任人唯贤，为坚持和加强党的全面领导、坚持和发展中国特色社会主义提供坚强组织保证。</p><p>------习近平在全国组织工作会议上的讲话 (2018年7月3日)</p><p>首先，以组织体系建设为重点。</p><p>党的力量来自组织。党的全面领导、党的全部工作要靠党的坚强组织体系去实现。进入新时代，开启新征程，我们必须更加注重党的组织体系建设，不断增强党的政治领导力、思想引领力、群众组织力、社会号召力，把党员组织起来，把人才凝聚起来，把群众动员起来，为实现党的十九大提出的宏伟目标团结奋斗。</p><p>------习近平在全国组织工作会议上的讲话 (2018年7月3日)</p><p>其次，各级各类党组织应建尽建。 - 党的地方委员会. -城市街道、乡镇、社区### 、行政村党组织. -机关、事业单位、企业和社会组织党组织</p><p>最后，扩大基层党的组织覆盖和工作覆盖。截至2021年12月31日，中国共产党现有基层组织-6万个，比2020年净增- 7万个，增幅为- 4%。其中基层党委- 8万个，总支部-6万个，支部- 2万个。</p><p>明确新时代好干部标准：信念坚定、为民服务、勤政务实、敢于担当、清正廉洁。</p><p>坚持正确选人用人导向。</p><h3 id="始终绷紧作风建设这根弦-1">始终绷紧作风建设这根弦</h3><p>"党的作风就是党的形象，关系人心向背，关系党的生死存亡。我们党作为一个在中国长期执政的马克思主义政党，对作风问题任何时候都不能掉以轻心。"</p><p>------习近平在十八届中央政治局第十六次集体学习时的讲话(2014年6月30日)</p><p>首先，持之以恒纠治四风。党的十八大以来，我们坚持党要管党、全面从严治党，坚持问题导向，以整治"四风"(形式主义、官僚主义、享乐主义和奢靡之风)为突破口，大力弘扬真抓实干作风，交出了新答卷，取得了新成效。应清醒看到，作风问题具有顽固性和反复性，形成优良作风不可能一劳永逸，克服不良作风也不可能一蹴而就，作风建设永远在路上。</p><p>中央八项规定：</p><p>一改进调查研究。到基层调研要深入了解真实情况，总结经验、研究问题、解决困难、指导工作，向群众学习、向实践学习，多同群众座谈，多同干部谈心，多商量讨论，多解剖典型，多到困难和矛盾集中、群众意见多的地方去，切忌走过场、搞形式主义；要轻车简从、减少陪同、简化接待，不张贴悬挂标语横幅，不安排群众迎送，不铺设迎宾地毯，不摆放花草，不安排宴请。</p><p>二要精简会议活动。切实改进会风，严格控制以中央名义召开的各类全国性会议和举行的重大活动，不开泛泛部署工作和提要求的会，未经中央批准一律不出席各类剪彩、奠基活动和庆祝会、纪念会、表彰会、博览会、研讨会及各类论坛；提高会议实效，开短会、讲短话，力戒空话、套话。</p><p>三要精简文件简报。切实改进文风，没有实质内容、可发可不发的文件、简报一律不发。</p><p>四要规范出访活动。从外交工作大局需要出发合理安排出访活动，严格控制出访随行人员，严格按照规定乘坐交通工具，一般不安排中资机构、华侨华人、留学生代表等到机场迎送。</p><p>五要改进警卫工作。坚持有利于联系群众的原则，减少交通管制，一般情况下不得封路、不清场闭馆。</p><p>六要改进新闻报道。中央政治局同志出席会议和活动应根据工作需要、新闻价值、社会效果决定是否报道，进一步压缩报道的数量、字数、时长。</p><p>七要严格文稿发表。除中央统一安排外，个人不公开出版著作、讲话单行本，不发贺信、贺电，不题词、题字。</p><p>八要厉行勤俭节约。严格遵守廉洁从政有关规定，严格执行住房、车辆配备等有关工作和生活待遇的规定。</p><ul><li>严肃整治享乐主义和奢靡之风。</li></ul><p>党的十八大以来，在以习近平同志为核心的党中央坚强领导下，各地各部门持之以恒落实中央八项规定精神，驰而不息将作风建设引向深入，反对特权思想和特权现象，狠刹公款送礼、公款吃喝、公款旅游、奢侈浪费等不正之风；"舌尖上的浪费""会所中的歪风""车轮上的铺张""节日中的腐败"，高档小区"一桌餐"、调研考察搭车旅游等隐形变异"四风"问题得到严肃整治。</p><ul><li>力戒形式主义和官僚主义作风。</li></ul><p>党的十九大以来，作风建设更加注重集中整治形式主义、官僚主义问题。2019年，党中央、国务院发文数量都比上年减少30%以上；省区市文件和会议平均压缩39%、37%，中央和国家机关分别压缩39%、33%；中央和国家机关督查检查考核事项从近900项大幅压缩至96项，实际开展88项。力戒形式主义、官僚主义取得成效。</p><p>其次，党风政风与社会风气为之一新。党的十八大以来，党中央从制定和落实中央八项规定破题，坚持从中央政治局做起、从领导干部抓起，以上率下改进工作作风，刹住了一些过去被认为不可能刹住的歪风，纠治了一些多年未除的顽瘴痼疾，党风政风为之一新，社风民风向上向善。</p><h3 id="把纪律的螺丝拧得紧而又紧-1">把纪律的螺丝拧得紧而又紧</h3><p>加强纪律建设是全面从严治党的治本之策。党要管党、从严治党，靠什么管，凭什么治？就要靠严明纪律和规矩。党员"破法"，无不始于"破纪"。党的十八大以来，我们党坚持纪严于法、纪在法前，严在日常，把纪律和规矩挺在前面，不断完善纪律规定，持续加强执纪问责，做到惩前毖后、治病救人。</p><p>必须使纪律成为带电的"高压线"。遵守党的纪律是无条件的，要说到做到，有纪必执，有违必查，不能把纪律作为一个软约束或是束之高阁的一纸空文。对违规违纪、破坏法规制度踩"红线"、越"底线"、闯"雷区"的，要坚决严肃查处，不以权势大而破规，不以问题小而姑息，不以违者众而放任，不留"暗门"、不开"天窗"。深化运用监督执纪"四种形态"，特别是要在用好第一种形态上下功夫，多做红脸出汗、咬耳扯袖的工作。</p><ul><li>把权力关进制度的笼子里</li></ul><p>制约和监督权力是制度建设的关键问题。公权力姓公，也必须为公。各级党组织、各级领导干部手中的权力是党和人民赋予的，姓公不姓私。只要公权力存在，就必须受到制约，否则就会被滥用。必须把权力关进制度的笼子里，依法设定权力、规范权力、制约权力、监督权力，让权力在阳光下运行。</p><p>把权力关进制度的笼子里，首先要建好笼子。要坚持权责法定，科学配置权力，明晰权力边界，强化权力制约，扎细扎密扎牢制度笼子。以党章为根本遵循，本着于法周延、于事有效的原则，制定新的法规制度，完善已有的法规制度，废止不适应的法规制度，进一步健全覆盖党的领导和党的建设各方面的党内法规制度体系，最大限度减少权力出轨、个人寻租的机会。</p><p>强化政治监督，深化政治巡视。把权力关进制度的笼子里，健全党和国家监督制度、坚持和完善党和国家监督体系是重点。强化政治监督，深化政治巡视，切实发挥监督"利剑"和巡视"千里眼"作用。把党委###全面监督、纪委监委专责监督、党的工作部门职能监督、党的基层组织日常监督、党员民主监督等结合起来、融为一体。</p><h3id="巩固发展反腐败斗争压倒性胜利-1">巩固发展反腐败斗争压倒性胜利</h3><p>一体推进不敢腐、不能腐、不想腐；反腐败斗争取得空前成效；打好反腐败攻坚战持久战。</p><p>三、如何理解全面从严治党这场伟大自我革命</p><h3id="勇于自我革命是跳出历史周期率的第二个答案">勇于自我革命是跳出历史周期率的第二个答案</h3><p>勇于自我革命是我们党最鲜明的品格和最大的优势。马克思主义政党以实现人的自由全面发展和解放全人类为己任，要实现这样的崇高使命，永葆先进性和纯洁性，就必须一刻不放松地解决自身存在的问题，以彻底的自我革命来推动深刻的社会革命。中国共产党的伟大不在于不犯错误,而在于从不讳疾忌医, 敢于直面问题, 勇于自我革命,具有极强的自我修复能力。</p><p>勇于自我革命是我们党区别于其他政党的显著标志纵观各国政党。真正像中国共产党这样能够始终如一正视自身问题，能够形成一整套自我约束的制度规范体系，能够严肃惩处党内一大批腐化变质分子的，可以说少之又少。中国共产党作为马克思主义政党，党的性质决定了我们党除了国家、民族、人民的利益，没有任何自己的特殊利益。不谋私利才能谋根本、谋大利，才有资格、有底气敢于直面问题、勇于自我革命。</p><h3id="全面从严治党以其丰富内涵诠释了自我革命的内在要求">全面从严治党以其丰富内涵诠释了自我革命的内在要求</h3><p>从明确提出"从严治党"，到提升为"全面从严治党"，谈谈你对此的理解。</p><p>"全面"就是管全党、治全党，面向全体党员、党组织，覆盖党的建设各个领域、各个方面、各个部门，重点是抓住"关键少数"。把从严治党的要求落实到每个党组织中、落实到每名党员身上。对象全覆盖，体现到党的思想建设、组织建设、作风建设、反腐倡廉建设和制度建设各个领域、各个方面；领域全范围，一把尺子量到底、一根竿子插到底，层层传导责任压力，让全面从严治党真正落地生根；责任全担负，一把尺子量到底、一根竿子插到底，层层传导责任压力，让全面从严治党真正落地生根。</p><p>"严"：真管真严，要动真格，不降标准，不图形式，不走过场，确保全面从严治党真正落实；敢管敢严，要敢于碰硬，不惧压力，不畏艰难，不避矛盾，让一切违纪违规的言行无处遁形；常管常严，要善始善终，不松劲头，不减力度，不打折扣，坚持不懈严管严治。</p><p>"治"就是从党中央到地方各级党委，从中央部委、国家机关部门党组###到基层党支部，都要肩负起主体责任。</p><h3id="全面从严治党推进自我革命不断走向深入">全面从严治党推进自我革命不断走向深入</h3><p>实施中央八项规定改进作风，构建行之有效的权力监督制度和执纪执法体系；反腐败无禁区、全覆盖、零容忍，一体推进不敢腐、不能腐、不想腐；开展党的群众路线教育实践活动，建立不忘初心、牢记使命的制度；严格规范党内政治生活，着力营造风清气正的政治生态。</p>]]></content>
    
    
    <categories>
      
      <category>trash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>trash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的快速入门</title>
    <link href="/posts/31475/"/>
    <url>/posts/31475/</url>
    
    <content type="html"><![CDATA[<h1 id="redis命令行客户端">Redis命令行客户端</h1><p>Redis安装完成后就自带了命令行客户端：<code>redis-cli</code>，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的Redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的Redis节点的端口，默认是6379</li><li><code>-a 123456</code>：指定Redis的访问密码</li></ul><p>其中的<code>commonds</code>就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与Redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定<code>commond</code>时，会进入<code>redis-cli</code>的交互控制台</p><h1 id="redis的通用命令">Redis的通用命令</h1><blockquote><p>通过<code>help [command]</code> 可以查看一个命令的具体用法Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在<ahref="https://redis.io/commands">Redis官网</a>可以查看到不同的命令：</p></blockquote><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li><code>KEYS</code>：查看符合模板的所有<code>key</code>，可以使用通配符（模糊查询效率不高，单线程阻塞请求）<ul><li><code>KEYS *</code> 查询所有</li><li><code>KEYS a*</code> 查询以a开头的所有</li></ul></li><li><code>DEL</code>：删除一个指定的<code>key</code>，可删除多个，返回值是删除个数</li><li><code>EXISTS</code>：判断key是否存在，可判断多个</li><li><code>EXPIRE</code>：给一个key设置有效期，有效期到期时该key会被自动删除（Redis基于内存存储，节省内存，防止内存占满）</li><li><code>TTL</code>( Time ToLive)：查看一个KEY的剩余有效期，返回<code>-1</code>表示永久有效</li></ul><h2 id="string类型">String类型</h2><p>String类型是Redis中最简单的存储类型。其<code>value</code>是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>底层都是<strong>字节数组</strong>形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><h3 id="string的常用命令">String的常用命令</h3><ul><li><code>SET</code>：添加或者修改已经存在的一个String类型的键值对</li><li><code>GET</code>：根据<code>key</code>获取String类型的<code>value</code></li><li><code>MSET</code>：批量添加多个String类型的键值对</li><li><code>MGET</code>：根据多个<code>key</code>获取多个String类型的<code>value</code></li><li><code>INCR</code>：让一个整型的<code>key</code>自增1</li><li><code>INCRBY</code>:让一个整型的<code>key</code>自增并指定步长，例如：<code>incrby num 2</code>让<code>num</code>值自增2</li><li><code>INCRBYFLOAT</code>：让一个浮点类型的数字自增并指定步长</li><li><code>SETNX</code>：添加一个String类型的键值对，前提是这个<code>key</code>不存在，否则不执行</li><li><code>SETEX</code>：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="key结构">Key结构</h3><p>Redis的<code>key</code>允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JSON">Key1<span class="hljs-punctuation">:</span>Key2<span class="hljs-punctuation">:</span>Key3<br></code></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了<code>key</code>的冲突问题。</p><p>如果<code>Value</code>是一个Java对象，例如一个<code>User</code>对象，则可以将对象序列化为<code>JSON</code>字符串后存储</p><table><thead><tr class="header"><th><code>Key</code></th><th><code>Value</code></th></tr></thead><tbody><tr class="odd"><td><code>Key1:Key2:Key3</code></td><td><code>&#123;"Key3": value3, …&#125;</code></td></tr></tbody></table><h2 id="hash类型">Hash类型</h2><p>Hash类型，也叫散列，其<code>value</code>是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为<code>JSON</code>字符串后存储，当需要修改对象某个字段时很不方便，Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p><h3 id="hash的常见命令">Hash的常见命令</h3><ul><li><code>HSET key field value</code>：添加或者修改hash类型<code>key</code>的<code>field</code>的值</li><li><code>HGET key field</code>：获取一个hash类型<code>key</code>的<code>field</code>的值</li><li><code>HMSET</code>：批量添加多个hash类型<code>key</code>的<code>field</code>的值</li><li><code>HMGET</code>：批量获取多个hash类型<code>key</code>的<code>field</code>的值</li><li><code>HGETALL</code>：获取一个hash类型的<code>key</code>中的所有的<code>field</code>和<code>value</code></li><li><code>HKEYS</code>：获取一个hash类型的<code>key</code>中的所有的<code>field</code></li><li><code>HINCRBY</code>：让一个hash类型<code>key</code>的字段值自增并指定步长</li><li><code>HSETNX</code>：添加一个hash类型的<code>key</code>的<code>field</code>值，前提是这个<code>field</code>不存在，否则不执行</li></ul><h2 id="list类型">List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索,特征为：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><img src="/posts/31475/linkedlist.png" class="" title="linkedlist"><h3 id="list常见命令">List常见命令</h3><ul><li><code>LPUSH key element ...</code>：向列表左侧插入一个或多个元素（倒序）</li><li><code>LPOP key</code>：移除并返回列表左侧的第一个元素，没有则返回nil</li><li><code>RPUSH key element ...</code>：向列表右侧插入一个或多个元素（顺序）</li><li><code>RPOP key</code>：移除并返回列表右侧的第一个元素</li><li><code>LRANGE key star end</code>：返回一段角标范围内的所有元素</li><li><code>BLPOP</code>和<code>BRPOP</code>(Block)：与<code>LPOP</code>和<code>RPOP</code>类似，只不过在没有元素时等待指定时间，而不是直接返回<code>nil</code></li></ul><h2 id="set类型">Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个<code>value</code>为<code>null</code>的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><h3 id="set的常见命令">Set的常见命令</h3><ul><li><code>SADD key member ...</code>：向set中添加一个或多个元素</li><li><code>SREM key member ...</code>: 移除set中的指定元素</li><li><code>SCARD key</code>： 返回set中元素的个数</li><li><code>SISMEMBER key member</code>：判断一个元素是否存在于set中</li><li><code>SMEMBERS</code>：获取set中的所有元素</li><li><code>SINTER key1 key2 ...</code>：求<code>key1</code>与<code>key2</code>的交集</li><li><code>SDIFF key1 key2 ...</code>：求<code>key1</code>与<code>key2</code>的差集</li><li><code>SUNION key1 key2 ..</code>：求<code>key1</code>和<code>key2</code>的并集</li></ul><h2 id="sortedset类型">SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个<code>score</code>属性，可以基于<code>score</code>属性对元素排序，底层的实现是一个跳表（SkipList）加hash表，具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>SortedSet经常被用来实现排行榜这样的功能</p><h3 id="sortedset的常见命令">SortedSet的常见命令</h3><ul><li><p><code>ZADD key score member</code>：添加一个或多个元素到sortedset ，如果已经存在则更新其<code>score</code>值</p></li><li><p><code>ZREM key member</code>：删除sortedset中的一个指定元素</p></li><li><p><code>ZSCORE key member</code> : 获取sortedset中的指定元素的<code>score</code>值</p></li><li><p><code>ZRANK key member</code>：获取sorted set中的指定元素的排名</p></li><li><p><code>ZCARD key</code>：获取sorted set中的元素个数</p></li><li><p><code>ZCOUNT key min max</code>：统计<code>score</code>值在给定范围内的所有元素的个数</p></li><li><p><code>ZINCRBY key increment member</code>：让sortedset中的指定元素自增，步长为指定的<code>increment</code>值</p></li><li><p><code>ZRANGE key min max</code>：按照<code>score</code>排序后，获取指定排名范围内的元素</p></li><li><p><code>ZRANGEBYSCORE key min max</code>：按照<code>score</code>排序后，获取指定<code>score</code>范围内的元素</p></li><li><p><code>ZDIFF</code>、<code>ZINTER</code>、<code>ZUNION</code>：求差集、交集、并集</p><blockquote><p>所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：<code>ZREVRANK key memeber</code></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Best Way For A Student To Make Friends</title>
    <link href="/posts/42679/"/>
    <url>/posts/42679/</url>
    
    <content type="html"><![CDATA[<p>Friendship is an essential aspect of a student’s life that fosterspersonal growth and emotional well-being by providing support,encouragement, and companionship. However, making friends can bedaunting for some students, especially when seeking meaningfulconnections. Fortunately, there are some effective strategies that youcan use to make friends.</p><p>The first step is <strong>to be open and approachable</strong>. Forexample, a simple smile can break the ice between strangers. A friendlyattitude creates a comfortable atmosphere and makes others feelwelcomed. By being approachable, you signal to others that you are opento conversations and building connections.</p><p><strong>Participating actively in extracurricular activities andclubs</strong> is another proven way of making friends that enrichesyour academic and social life. By engaging in shared interests, you willbond with like-minded people and nurture new friendships.</p><p>It’s important to remember that <em>a friend without faults willnever be found</em>. <strong>Try to be patient and tolerant of diversityamong people</strong>. Do not judge people based on appearance,background, or opinions. Try to learn from others and respectdifferences.</p><p><em>Be slow in choosing a friend</em>. Building meaningfulconnections requires <strong>patience and persistence</strong>. Do notbe discouraged if friendships do not form immediately. Continue puttingyourself in social situations and engaging with others.</p><p><em>The only way to have a friend is to be one</em>. I believe thebest way for students to make friends is to become their best selves.Therefore, by following these strategies, you will not only form lastingbonds and relationships, but also form a whole new self.</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学复习</title>
    <link href="/posts/12732/"/>
    <url>/posts/12732/</url>
    
    <content type="html"><![CDATA[<blockquote><p><ahref="https://ivansnow02.github.io/assets/DiscreteMathMindMap.html">思维导图</a></p></blockquote><hr /><h1 id="集合论">集合论</h1><h2 id="集合的基本概念">集合的基本概念</h2><h3 id="集合的定义">集合的定义</h3><ul><li>具有某种特定性质事物的全体，通常，用大写的英文字母<spanclass="math inline">\(A, B, C,……\)</span>表示集合</li></ul><h3 id="集合的元素">集合的元素</h3><ul><li>组成一个集合的那些对象或单元称为这个集合的元素，通常，用小写的英文字母<spanclass="math inline">\(a\)</span>,<spanclass="math inline">\(b\)</span>,<spanclass="math inline">\(c\)</span>,…，或者<spanclass="math inline">\(a_1\)</span>,<spanclass="math inline">\(a_2\)</span>,<spanclass="math inline">\(b_1\)</span>,<spanclass="math inline">\(b_2\)</span>…表示集合中的元素</li></ul><h3 id="属于">属于</h3><ul><li>设A是一个集合，a是集合A中的元素，记以<span class="math inline">\(a\in A\)</span>，读作<span class="math inline">\(a\)</span>属于<spanclass="math inline">\(A\)</span>；若<spanclass="math inline">\(a\)</span>不是集合<spanclass="math inline">\(A\)</span>中的元素，则记以<spanclass="math inline">\(a \notin A\)</span>，读作<spanclass="math inline">\(a\)</span>不属于<spanclass="math inline">\(A\)</span></li></ul><h3 id="有限集">有限集</h3><ul><li>包含有限个元素的集合，称为有限集或有穷集(finite set)</li></ul><h3 id="无限集">无限集</h3><ul><li>包含无限个元素的集合，称为无限集或无穷集(infinite set )</li></ul><h3 id="空集">空集</h3><ul><li>约定，存在一个没有任何元素的集合，称为空集(empty set) ，记为<spanclass="math inline">\(\varnothing\)</span>，有时也用<spanclass="math inline">\(\{\}\)</span>来表示</li></ul><h3 id="全集">全集</h3><ul><li><p>约定，所讨论的对象的全体称为全集(universal set)，记作<spanclass="math inline">\(E\)</span>或<spanclass="math inline">\(U\)</span>，我们所讨论的集合都是全集的子集</p></li><li><p><strong>全集是相对的</strong></p></li></ul><h3 id="集合的元素数">集合的元素数</h3><ul><li>设<span class="math inline">\(A\)</span>是有穷集合，<spanclass="math inline">\(A\)</span>中元素的个数称为集合<spanclass="math inline">\(A\)</span>的元素数，记为<spanclass="math inline">\(|A|\)</span>，<strong>特别，<spanclass="math inline">\(|\varnothing|=0\)</span></strong></li></ul><h3 id="集合的表示法">集合的表示法</h3><h4 id="列举法">列举法</h4><ul><li>将集合中的元素一一列举，或列出足够多的元素以反映集合中元素的特征</li></ul><h4 id="描述法">描述法</h4><ul><li>通过描述集合中元素的共同特征来表示集合</li></ul><h4 id="文氏图">文氏图</h4><ul><li>用一个大的矩形表示全集，在矩形内画一些圆或其它的几何图形，来表示集合，有时也用一些点来表示集合中的特定元素</li></ul><h3 id="集合的特征">集合的特征</h3><h4 id="确定性">确定性</h4><ul><li>任何一个对象，或者是这个集合的元素，或者不是，二者必居其一</li></ul><h4 id="互异性">互异性</h4><ul><li>集合中任何两个元素都是不同的，即集合中不允许出现重复的元素</li></ul><h4 id="无序性">无序性</h4><ul><li>集合与其中的元素的顺序无关</li></ul><h4 id="多样性">多样性*</h4><ul><li>集合中的元素可以是任意的对象，相互独立，不要求一定要具备明显的共同特征</li></ul><h2 id="集合间的关系">集合间的关系</h2><h3 id="集合相等">集合相等</h3><ul><li>当两个集合<span class="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>的元素完全一样，即<spanclass="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>实际上是同一个集合时，则称集合<spanclass="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>相等，记以<spanclass="math inline">\(A=B\)</span></li></ul><h3 id="集合包含">集合包含</h3><h4 id="子集">子集</h4><ul><li>设<span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>是两个集合，若<spanclass="math inline">\(A\)</span>的元素都是<spanclass="math inline">\(B\)</span>的元素，则称<spanclass="math inline">\(A\)</span>是<spanclass="math inline">\(B\)</span>的子集(subset) ，也称<spanclass="math inline">\(B\)</span>包含<spanclass="math inline">\(A\)</span>，或<spanclass="math inline">\(A\)</span>包含于<spanclass="math inline">\(B\)</span>，记以<span class="math inline">\(A\subseteq B\)</span>，或<span class="math inline">\(B \supseteqA\)</span></li></ul><h4 id="真子集">真子集</h4><ul><li>若<span class="math inline">\(A \subseteq B\)</span>，且<spanclass="math inline">\(A \neq B\)</span>，则称<spanclass="math inline">\(A\)</span>是<spanclass="math inline">\(B\)</span>的真子集(proper subset)，也称<spanclass="math inline">\(B\)</span>真包含<spanclass="math inline">\(A\)</span>，或<spanclass="math inline">\(A\)</span>真包含于<spanclass="math inline">\(B\)</span>，记以<span class="math inline">\(A\subset B\)</span>，或<span class="math inline">\(B \supsetA\)</span></li></ul><h4 id="重要结论">重要结论</h4><ul><li>对任意集合<span class="math inline">\(A\)</span>, 有<spanclass="math inline">\(A ⊆ A\)</span></li><li><spanclass="math inline">\(\varnothing\)</span>是任意集合的子集，且空集是唯一的</li><li>对于任意两个集合<span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>，<spanclass="math inline">\(A=B\)</span>当且仅当<spanclass="math inline">\(A⊆B\)</span>且<span class="math inline">\(B⊆A\)</span>。</li></ul><h3 id="幂集">幂集</h3><h4 id="定义">定义</h4><ul><li>设<span class="math inline">\(A\)</span>是集合，<spanclass="math inline">\(A\)</span>的所有子集为元素组成的集合称为<spanclass="math inline">\(A\)</span>的幂集，记以<spanclass="math inline">\(ρ(A)\)</span>或<spanclass="math inline">\(2^A\)</span>，<spanclass="math inline">\(ρ(A)=\{S|S ⊆ A\}\)</span></li></ul><h4 id="性质">性质</h4><ul><li>若A为有穷集，<span class="math inline">\(|A|=n\)</span>，则<spanclass="math inline">\(|2^A | = |ρ(A)|= C_n^0 + C_n^1 + … + C_n^n=2^n\)</span></li><li><span class="math inline">\(x∈ρ(A)\)</span>当且仅当<spanclass="math inline">\(x⊆A\)</span></li><li>设<span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>是两个集合，<spanclass="math inline">\(A⊆B\)</span>当且仅当<spanclass="math inline">\(ρ(A)⊆ρ(B)\)</span></li></ul><h2 id="集合运算">　集合运算</h2><h3 id="集合的并集">集合的并集</h3><ul><li>设<span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>是两个集合。所有属于<spanclass="math inline">\(A\)</span>或者属于<spanclass="math inline">\(B\)</span>的元素组成的集合，称为<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>的并集，记以<spanclass="math inline">\(A∪B\)</span>。即<spanclass="math inline">\(A∪B=\{x|x∈A或x∈B\}\)</span></li></ul><h3 id="集合的交集">集合的交集</h3><ul><li>设<span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>是两个集合。由属于<spanclass="math inline">\(A\)</span>又属于<spanclass="math inline">\(B\)</span>的元素组成的集合，称为<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>的交集，记以<spanclass="math inline">\(A∩B\)</span>。即<spanclass="math inline">\(A∩B=\{x|x∈A且x∈B\}\)</span></li></ul><h3 id="并集和交集的推广">并集和交集的推广</h3><ul><li><p>设<span class="math inline">\(A_1\)</span>，<spanclass="math inline">\(A_2\)</span>，…，<spanclass="math inline">\(A_n\)</span>是<spanclass="math inline">\(n\)</span>个集合，则：<spanclass="math inline">\(A_1∪A_2∪…∪A_n\)</span>，简记为<spanclass="math inline">\(\bigcup\limits_{i=1}^nA_i\)</span></p></li><li><p><span class="math inline">\(A_1∩A_2∩…∩A_n\)</span>，简记为<spanclass="math inline">\(\bigcap\limits_{i=1}^n A_i\)</span></p></li></ul><h3 id="集合的补集">集合的补集</h3><ul><li><p>设<span class="math inline">\(A\)</span>是一个集合，全集<spanclass="math inline">\(E\)</span>与<spanclass="math inline">\(A\)</span>的差集称为<spanclass="math inline">\(A\)</span>的补集，记以<spanclass="math inline">\(\sim A\)</span>，即<spanclass="math inline">\(\sim A=E-A\)</span></p></li><li><p>特别， <span class="math inline">\(\sim\varnothing=E\)</span>，<span class="math inline">\(\sim E=\varnothing\)</span></p></li></ul><h3 id="集合的差集">集合的差集</h3><ul><li>设<span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>是两个集合。由属于集合<spanclass="math inline">\(A\)</span>而不属于集合<spanclass="math inline">\(B\)</span>的所有元素组成的集合，称为<spanclass="math inline">\(A\)</span>与<spanclass="math inline">\(B\)</span>的差集，记以<spanclass="math inline">\(A-B\)</span>。即<spanclass="math inline">\(A-B=\{x|x∈A且x ∉B\}\)</span></li></ul><h3 id="集合的对称差">集合的对称差</h3><ul><li>设<span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>是两个集合。则<spanclass="math inline">\(A\)</span>与<spanclass="math inline">\(B\)</span>的和(对称差),记以<spanclass="math inline">\(A⊕B\)</span>, 定义为<spanclass="math inline">\(A⊕B=(A-B)∪(B-A)\)</span>，即<spanclass="math inline">\(A \oplus B=\{x|(x \in A)且(x \notin B)或(x \inB)且(x \notin A)\}\)</span></li><li><span class="math inline">\(A\)</span>与<spanclass="math inline">\(B\)</span>的对称差还有一个等价的定义，即<spanclass="math inline">\(A⊕B=(A∪B)-(A∩B)\)</span></li></ul><h3 id="集合的运算律">集合的运算律</h3><h4 id="等幂律">等幂律</h4><ul><li><span class="math inline">\(A∩A=A\)</span></li><li><span class="math inline">\(A∪A=A\)</span></li></ul><h4 id="交换律">交换律</h4><ul><li><span class="math inline">\(A∩B=B∩A\)</span></li><li><span class="math inline">\(A∪B=B∪A\)</span></li></ul><h4 id="结合律">结合律</h4><ul><li><span class="math inline">\((A∩B)∩C=A∩(B∩C)\)</span></li><li><span class="math inline">\((A∪B)∪C=A∪(B∪C)\)</span></li></ul><h4 id="分配律">分配律</h4><ul><li><span class="math inline">\(A∩(B∪C)=(A∩B)∪(A∩C)\)</span></li><li><span class="math inline">\(A∪(B∩C)=(A∪B)∩(A∪C)\)</span></li></ul><h4 id="吸收律">吸收律</h4><ul><li><span class="math inline">\(A∩(A∪B)=A\)</span></li><li><span class="math inline">\(A∪(A∩B)=A\)</span></li></ul><h4 id="互补律">互补律</h4><ul><li><span class="math inline">\(\sim A∩A= \varnothing\)</span></li><li><span class="math inline">\(\sim A∪A=E\)</span></li></ul><h4 id="德摩根律">德摩根律</h4><ul><li><span class="math inline">\(\sim (A∩B)=\sim A ∪ \sim B\)</span></li><li><span class="math inline">\(\sim(A∪B)=\sim A ∩ \sim B\)</span></li></ul><h4 id="同一律">同一律</h4><ul><li><span class="math inline">\(E∩A=A\)</span></li><li><span class="math inline">\(\varnothing ∪A=A\)</span></li></ul><h4 id="零一律">零一律</h4><ul><li><p><spanclass="math inline">\(\varnothing∩A=\varnothing\)</span></p></li><li><p><span class="math inline">\(E∪A=E\)</span></p></li></ul><h4 id="双重否定律">双重否定律</h4><ul><li><span class="math inline">\(\sim (\sim A)=A\)</span></li></ul><h4 id="其他算律">其他算律</h4><ul><li><span class="math inline">\(A-B=A∩ \sim B\)</span></li><li><spanclass="math inline">\(A⊕B=(A-B)∪(B-A)=(A∪B)-(A∩B)\)</span></li><li><span class="math inline">\(A⊕A=\varnothing\)</span></li><li><span class="math inline">\(\sim\varnothing=E\)</span></li><li><span class="math inline">\(\sim E=\varnothing\)</span></li></ul><h2 id="有限集合的计数">有限集合的计数</h2><h3 id="容斥原理">容斥原理</h3><ul><li><span class="math inline">\(|A∪B|=|A|+|B|-|A∩B|\)</span></li><li><spanclass="math inline">\(|A∪B∪C|=|A|+|B|+|C|-|A∩B|-|A∩C|-|B∩C|+|A∩B∩C|\)</span></li><li>设<span class="math inline">\(A_1，A_2，…，A_n\)</span>是<spanclass="math inline">\(n\)</span>个集合，则：<spanclass="math inline">\(|\bigcup\limits_{i=1}^nA_i|=\sum\limits_{i=1}^n|A_i|-\sum\limits_{i&lt;j}^n|A_i\capA_j|+\sum\limits_{i&lt;j&lt;k}^n|A_i\cap A_j \capA_k|+...+(-1)^{n-1}|A_1 \cap A_2 \cap A_3 \cap ...\capA_n|\)</span>称为包含排斥原理，简称容斥原理</li></ul><h2 id="集合恒等式的证明">集合恒等式的证明</h2><h3 id="基本定义法">基本定义法</h3><h3 id="公式等价法">公式等价法</h3><h4 id="基本原则">基本原则</h4><ul><li>将集合运算表达式中其他运算符号转换为∩和∪；</li><li>将补运算作用到单一集合上；</li><li>左<span class="math inline">\(\implies\)</span>右，右<spanclass="math inline">\(\implies\)</span>左，左<spanclass="math inline">\(\implies\)</span>中间式，右<spanclass="math inline">\(\implies\)</span>中间式；</li><li>根据基本运算符号的定义和运算定律转换。</li></ul><h3 id="集合成员表法">集合成员表法*</h3><h1 id="关系">关系</h1><h2 id="序偶和笛卡尔积">序偶和笛卡尔积</h2><h3 id="序偶">序偶</h3><h4 id="定义-1">定义</h4><ul><li>对于有序<span class="math inline">\(n\)</span>元组，当<spanclass="math inline">\(n=2\)</span>时，我们将其称作有序二元组，也称作有序对,或序偶。</li></ul><h4 id="特点">特点</h4><ul><li>若<span class="math inline">\(a≠b\)</span>,则<spanclass="math inline">\((a,b)≠(b,a)\)</span></li><li>两个有序对<span class="math inline">\((a,b)\)</span>和<spanclass="math inline">\((c,d)\)</span>相等当且仅当<spanclass="math inline">\(a=c\)</span>，<spanclass="math inline">\(b=d\)</span></li></ul><h4 id="特征">特征</h4><ul><li>成对出现、具有一定的顺序</li></ul><h3 id="笛卡尔积">笛卡尔积</h3><h4 id="定义-2">定义</h4><ul><li>设<span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>是两个集合，所有有序对<spanclass="math inline">\((x, y)\)</span>做成的集合<spanclass="math inline">\((其中x∈A，y∈B)\)</span>，称为<spanclass="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>的笛卡儿积，记为<spanclass="math inline">\(A×B\)</span>，<spanclass="math inline">\(A×B=\{(x，y)|x∈A且y∈B\}\)</span></li><li>设<span class="math inline">\(A_1,A_2 , ...,A_n\)</span>是<spanclass="math inline">\(n\)</span>个集合，由所有有序<spanclass="math inline">\(n\)</span>元组(<spanclass="math inline">\(a_1,a_2,…,a_n\)</span>)组成的集合<spanclass="math inline">\((其中ai∈A_i，i=1,2, … ,n)\)</span>，称为<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>的笛卡儿积，记以<spanclass="math inline">\(A_1×A_2 ×...×A_n\)</span>，<spanclass="math inline">\(A_1×A_2 ×...×A_n=\{(a_1,a_2 ,… ,a_n) |a_i∈A_i，i=1,2, … ,n \}\)</span></li></ul><h4 id="性质-1">性质</h4><ul><li><p><span class="math inline">\(|A×B|=|A|× |B|\)</span></p></li><li><p>对任意集合<span class="math inline">\(A\)</span>，有<spanclass="math inline">\(A×\varnothing=\varnothing\)</span>，<spanclass="math inline">\(\varnothing \times A=\varnothing\)</span></p></li><li><p>笛卡儿积运算<strong>不满足</strong>交换律，即<spanclass="math inline">\(A×B≠B×A\)</span></p></li><li><p>笛卡儿积运算<strong>不满足</strong>结合律，即<spanclass="math inline">\((A×B)×C≠A×(B×C)\)</span></p></li><li><p>笛卡儿积运算对并和交运算<strong>满足</strong>分配律， 即</p><ul><li><span class="math inline">\(A×(B∪C)=(A×B)∪(A×C)\)</span></li><li><span class="math inline">\((B∪C)×A=(B×A)∪(C×A)\)</span></li><li><span class="math inline">\(A×(B∩C)=(A×B)∩(A×C)\)</span></li><li><span class="math inline">\((B∩C)×A=(B×A)∩(C×A)\)</span></li></ul></li><li><p>设<span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>，<spanclass="math inline">\(C\)</span>，<spanclass="math inline">\(D\)</span>是集合，若<spanclass="math inline">\(A⊆C\)</span>且<spanclass="math inline">\(B⊆D\)</span>，则<span class="math inline">\(A×B ⊆C×D\)</span></p></li></ul><h2 id="二元关系">二元关系</h2><h3 id="定义-3">定义</h3><ul><li>给定任意集合<span class="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>，若<spanclass="math inline">\(R⊆A×B\)</span>，则称<spanclass="math inline">\(R\)</span>为从<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的二元关系，特别在<spanclass="math inline">\(A=B\)</span>时，称<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(A\)</span>上的二元关系</li></ul><h3 id="补充">补充</h3><ul><li><strong>关系是一个集合，是序偶的集合</strong></li><li><span class="math inline">\(R\)</span>是有序对的集合。若<spanclass="math inline">\((x,y)∈R\)</span>，则也表示为<spanclass="math inline">\(x R y\)</span>，即<spanclass="math inline">\((x,y)∈ R \iff x R y\)</span><ul><li>若<span class="math inline">\(R =\varnothing\)</span>，则称<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>上<strong>空关系</strong></li><li>若<span class="math inline">\(R =A×B\)</span>，称<spanclass="math inline">\(R\)</span>为<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>上<strong>全域关系</strong></li><li>称<span class="math inline">\(R=\{(x,x)|x∈A\}\)</span>为<spanclass="math inline">\(A\)</span>上的<strong>恒等关系</strong>，记为<spanclass="math inline">\(I_A\)</span></li></ul></li><li>当集合<span class="math inline">\(A,B\)</span>都是有限集时，<spanclass="math inline">\(A×B\)</span>共有<spanclass="math inline">\(2^{|A|\cdot|B|}\)</span>个不同的子集， 即从<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的不同关系共有<spanclass="math inline">\(2^{|A|\cdot|B|}\)</span>个</li></ul><h3 id="定义域值域和域">定义域、值域和域</h3><h4 id="定义-4">定义</h4><ul><li>令<span class="math inline">\(R \subseteq A \times B\)</span>，且<span class="math inline">\(\begin{cases} D (R) = \{ x | (∃y) (x R y )\}\\R (R) = \{ y | (∃x) (x R y ) \}\\F(R) =D(R)∪R(R)\end{cases}\)</span>则称<spanclass="math inline">\(D(R)\)</span>、<spanclass="math inline">\(R(R)\)</span>和<spanclass="math inline">\(F(R)\)</span>分别是二元关系<spanclass="math inline">\(R\)</span>的定义域、值域和域，显然<spanclass="math inline">\(D(R) ⊆ A\)</span>，<spanclass="math inline">\(R(R) ⊆ B\)</span></li></ul><h3 id="关系矩阵与关系图">关系矩阵与关系图</h3><h4 id="关系矩阵">关系矩阵</h4><ul><li>给定集合<span class="math inline">\(A=\{a_1,a_2,···,a_m\}\)</span>和<span class="math inline">\(B=\{b_1,b_2,···,b_n\}\)</span>，且<span class="math inline">\(R⊆A×B\)</span>，若<spanclass="math inline">\(r_{ij}=\begin{cases} 1 ,&amp; {a_i R b_j}\\0,&amp; 否则 \end{cases}\)</span> 则称矩阵<spanclass="math inline">\(M_R=(r _{i j})\)</span>为<spanclass="math inline">\(R\)</span>的关系矩阵</li></ul><h4 id="关系图">关系图</h4><ul><li>给定集合<span class="math inline">\(A=\{a_1,a_2,···,a_m\}\)</span>和<span class="math inline">\(A\)</span>上的关系<spanclass="math inline">\(R\)</span>，且<spanclass="math inline">\(R⊆A×A\)</span>，若：以<spanclass="math inline">\(A\)</span>中的元素为结点；对<spanclass="math inline">\(R\)</span>中的元素<span class="math inline">\((a_i,a_j )\)</span>, 以<spanclass="math inline">\(a_i\)</span>为起点,以<spanclass="math inline">\(a_j\)</span>为终点,作有向边所构成的图，则称该图为<spanclass="math inline">\(R\)</span>的关系图</li></ul><h2 id="关系运算">关系运算</h2><h3 id="关系的并交补差">关系的并、交、补、差</h3><ul><li>关系是序偶(有序对)的集合，因此可以对关系进行运算。 若<spanclass="math inline">\(R, S⊆A×B\)</span>，则<spanclass="math inline">\(R∪S\)</span>，<span class="math inline">\(R∩S\)</span>，<span class="math inline">\(\sim R\)</span>，<spanclass="math inline">\(R-S⊆A×B\)</span></li></ul><h3 id="关系的复合">关系的复合</h3><h4 id="定义-5">定义</h4><ul><li>设<span class="math inline">\(R\)</span>是从集合<spanclass="math inline">\(X\)</span>到<spanclass="math inline">\(Y\)</span>的关系，<spanclass="math inline">\(S\)</span>是从<spanclass="math inline">\(Y\)</span>到<spanclass="math inline">\(Z\)</span>的关系，把<spanclass="math inline">\(X\)</span>到<spanclass="math inline">\(Z\)</span>的关系定义为<spanclass="math inline">\(R\circ S\)</span>。称<spanclass="math inline">\(R\circ S\)</span>是关系<spanclass="math inline">\(R\)</span>和<spanclass="math inline">\(S\)</span>的合成关系或复合关系，<spanclass="math inline">\(R\circ S=\{(x,z)|∃x∈X, ∃z∈Z, 至少存在一个y∈Y有(x ,y)∈R且(y , z)∈S\}\)</span></li></ul><h4 id="定理">定理</h4><ul><li><p>已知集合<span class="math inline">\(X,Y,Z,W\)</span>，关系<spanclass="math inline">\(R_1,R_2,R_3,R_4\)</span>如下<spanclass="math inline">\(X\stackrel {R_1}\longrightarrow Y \stackrel{R_2R_3}\longrightarrow Z \stackrel {R_4}\longrightarrowW\)</span>，则有：</p><ul><li><spanclass="math inline">\(𝑅_1∘(𝑅_2∪𝑅_3)=(𝑅_1∘𝑅_2)∪(𝑅_ 1∘𝑅_3)\)</span></li><li><spanclass="math inline">\(R_1∘(R_2∩R_3)⊆(R_1∘R_2)∩(R_1∘R_3)\)</span></li><li><spanclass="math inline">\((𝑅_2∪𝑅_3)∘𝑅_4=(𝑅_2∘𝑅_4)∪(𝑅_3∘𝑅_4)\)</span></li><li><spanclass="math inline">\((𝑅_2∩𝑅_3)∘𝑅_4⊆(𝑅_2∘𝑅_4)∩(𝑅_3∘𝑅_4)\)</span></li></ul></li><li><p>已知集合<span class="math inline">\(X, Y, Z,W\)</span>，关系<span class="math inline">\(R_1, R_2,R_3\)</span>如下<span class="math inline">\(X\stackrel{R_1}\longrightarrow Y \stackrel {R_2}\longrightarrow Z \stackrel{R_3}\longrightarrow W\)</span>，则有：<span class="math inline">\((R_1\circ R_2)\circ R_3=R_1\circ (R_2 \circ R_3)\)</span><strong>结合律</strong></p></li><li><p><span class="math inline">\(R\circ R\circ R \circ\dots\circR=R^{(n)}\)</span></p></li><li><p><span class="math inline">\(R^{(0)}=I_X=\{(x,x)|x\inX\}\)</span></p></li></ul><h3 id="逆关系">逆关系</h3><h4 id="定义-6">定义</h4><ul><li>若<span class="math inline">\(R⊆A×B\)</span>，则关系<spanclass="math inline">\(\overline R =\{(y,x)|(x,y)∈ R\}\)</span>是集合<span class="math inline">\(B\)</span>到<spanclass="math inline">\(A\)</span>的关系，<spanclass="math inline">\(\overline R\)</span>称为关系<spanclass="math inline">\(R\)</span>的逆关系</li></ul><h4 id="定理-1">定理</h4><ul><li><span class="math inline">\(R_1, R_2, R\)</span>为<spanclass="math inline">\(X\)</span>到<spanclass="math inline">\(Y\)</span>的二元关系，则<ul><li><p><span class="math inline">\(\overline{R_1∪ R_2} =\overline{R_1}∪\overline{R_2}\)</span></p></li><li><p><span class="math inline">\(\overline{R_1 \cap R_2}=\overline{R_1} \cap \overline {R_2}\)</span></p></li><li><p><span class="math inline">\(\overline{X \times Y} = Y \timesX\)</span></p></li><li><p><span class="math inline">\(\overline{\sim R}=\sim\overline{R}\)</span></p></li><li><p><spanclass="math inline">\(\overline{R_1-R_2}=\overline{R_1}-\overline{R_2}\)</span></p></li><li><p><span class="math inline">\(S \subseteq R \iff\overline{S}\subseteq\overline{R}\)</span></p></li></ul></li><li>已知集合<span class="math inline">\(X, Y, Z\)</span>，关系<spanclass="math inline">\(R, S\)</span>如下，<span class="math inline">\(X\stackrel {R}\longrightarrow Y \stackrel {S}\longrightarrowZ\)</span>，则有：<span class="math inline">\(\overline{R\circS}=\overline{S}\circ\overline{R}\)</span></li></ul><h4 id="注意">注意</h4><ul><li>将<span class="math inline">\(R\)</span>的关系矩阵转置即得<spanclass="math inline">\(\overline R\)</span>的关系矩阵，即<spanclass="math inline">\(R\)</span>和<span class="math inline">\(\overlineR\)</span>的关系矩阵互为转置矩阵</li><li><span class="math inline">\(\overlineR\)</span>的前域与后域正好是<spanclass="math inline">\(R\)</span>的后域和前域，即<spanclass="math inline">\(domR=ran\overline R\)</span>，<spanclass="math inline">\(dom\overline R=ranR\)</span></li><li><span class="math inline">\(|R|=|\overline R|\)</span></li></ul><h2 id="关系性质">关系性质</h2><h3 id="自反性">自反性</h3><ul><li>令<span class="math inline">\(R⊆A×A\)</span>，若对<spanclass="math inline">\(A\)</span>中每个<spanclass="math inline">\(x\)</span>，都有<spanclass="math inline">\(xRx\)</span>，则称<spanclass="math inline">\(R\)</span>是自反的，即<spanclass="math inline">\(A上关系R是自反的\iff∀x(x∈A→xRx)\)</span></li><li>该定义表明了，在自反的关系<spanclass="math inline">\(R\)</span>中，除其他有序对外，必须包括由每个<spanclass="math inline">\(x∈A\)</span>所组成的元素相同的有序对</li></ul><h3 id="反自反性">反自反性</h3><ul><li>令<span class="math inline">\(R⊆A×A\)</span>，若对于<spanclass="math inline">\(A\)</span>中每个<spanclass="math inline">\(x\)</span>，有<span class="math inline">\((x,x)∉R\)</span>，则称<spanclass="math inline">\(R\)</span>是反自反的，即<spanclass="math inline">\(A上关系R是反自反的\iff∀x (x∈A→(x,x)∉R)\)</span></li><li>该定义表明了，一个反自反的关系<spanclass="math inline">\(R\)</span>中，不应包括有任何相同元素的有序对</li><li>应该指出，任何一个不是自反的关系，未必是反自反的；反之，任何一个不是反自反的关系，未必是自反的。这就是说，<strong>存在既不是自反的也不是反自反的二元关系</strong></li></ul><h3 id="对称性">对称性</h3><ul><li>令<span class="math inline">\(R⊆A×A\)</span>，对于<spanclass="math inline">\(A\)</span>中每个<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>，若<spanclass="math inline">\(xRy\)</span>，则<spanclass="math inline">\(yRx\)</span>，称<spanclass="math inline">\(R\)</span>是对称的，即<spanclass="math inline">\(在A上关系R是对称的\iff(∀x)(∀y)(x,y∈A且xRy→yRx)\)</span></li><li>该定义表明了，在表示对称的关系<spanclass="math inline">\(R\)</span>的有序对集合中，若有有序对<spanclass="math inline">\((x, y)\)</span>，则必定还会有有序对<spanclass="math inline">\((y, x)\)</span></li></ul><h3 id="反对称性">反对称性</h3><ul><li>令<span class="math inline">\(R⊆A×A\)</span>，对于<spanclass="math inline">\(A\)</span>中每个<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>，若<spanclass="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>，则<spanclass="math inline">\(x=y\)</span>，称<spanclass="math inline">\(R\)</span>是反对称的，即<spanclass="math inline">\(A上关系R是反对称的 \iff(∀x)(∀y)(x,y∈A且xRy且yRx→x=y)\)</span></li><li>该定义表明了，在表示反对称关系<spanclass="math inline">\(R\)</span>的有序对集合中，若存在有序对<spanclass="math inline">\((x, y)\)</span>和<span class="math inline">\((y,x)\)</span>，则必定是<spanclass="math inline">\(x=y\)</span>。或者说，在<spanclass="math inline">\(R\)</span>中若有有序对<spanclass="math inline">\((x, y)\)</span>，则除非<spanclass="math inline">\(x=y\)</span>，否则必定不会出现<spanclass="math inline">\((y, x)\)</span></li></ul><h3 id="传递性">传递性</h3><ul><li>令<span class="math inline">\(R⊆A×A\)</span>，对于<spanclass="math inline">\(A\)</span>中每个<span class="math inline">\(x, y,z\)</span>，若<span class="math inline">\(xRy且yRz\)</span>，则<spanclass="math inline">\(xRz\)</span>，称<spanclass="math inline">\(R\)</span>是传递的，即<spanclass="math inline">\(A上关系R是传递的 \iff(∀x)(∀y)(∀z)(x,y,z∈A且xRy且yRz→xRz)\)</span></li><li>该定义表明了，在表示可传递关系<spanclass="math inline">\(R\)</span>的有序对集合中，若有有序对<spanclass="math inline">\((x, y)\)</span>和<span class="math inline">\((y,z)\)</span>，则必有有序对<span class="math inline">\((x,z)\)</span></li></ul><h3 id="结论">结论</h3><ul><li>关系<span class="math inline">\(R\)</span>是自反的<spanclass="math inline">\(\implies\)</span> <spanclass="math inline">\(R\)</span>不是反自反的</li><li>关系<span class="math inline">\(R\)</span>是自反的<spanclass="math inline">\(\iff\)</span>关系图中每个结点都有环</li><li>关系<span class="math inline">\(R\)</span>是反自反的<spanclass="math inline">\(\iff\)</span>关系图中每个结点都无环</li><li>关系<span class="math inline">\(R\)</span>是自反的<spanclass="math inline">\(\iff\)</span>关系矩阵的主对角线上全为1</li><li>关系<span class="math inline">\(R\)</span>是反自反的<spanclass="math inline">\(\iff\)</span>关系矩阵的主对角线上全为0</li><li>关系<span class="math inline">\(R\)</span>是对称的<spanclass="math inline">\(\iff\)</span>关系图中任何一对结点之间，要么有方向相反的两条边，要么无任何边</li><li>关系<span class="math inline">\(R\)</span>是反对称的<spanclass="math inline">\(\iff\)</span>关系图中任何一对结点之间，至多有一条边</li><li>关系<span class="math inline">\(R\)</span>是对称的<spanclass="math inline">\(\iff\)</span> <spanclass="math inline">\(R\)</span>的关系矩阵为对称矩阵</li><li>关系<span class="math inline">\(R\)</span>是反对称的<spanclass="math inline">\(\iff\)</span> <spanclass="math inline">\(R\)</span>的关系系矩阵满足<spanclass="math inline">\(r_{ij}\cdotr_{ji}＝0，i,j=1,2,…,n，i≠j\)</span></li><li><strong>非空集合上的空关系</strong>是反自反的，对称的，反对称的和传递的，但不是自反的。<strong>空集合上的空关系</strong>则是自反的，反自反的，对称的，反对称的和传递的</li><li><strong>非空集合上的全域关系</strong>是自反的，对称的和传递的，但不是反自反的和反对称的</li><li>设<span class="math inline">\(R⊆A×A\)</span>，若<spanclass="math inline">\(R\)</span>是反自反的和传递的，则<spanclass="math inline">\(R\)</span>是反对称的</li></ul><h2 id="闭包运算">闭包运算</h2><h3 id="自反闭包">自反闭包</h3><ul><li>设<span class="math inline">\(R\)</span>是<spanclass="math inline">\(A\)</span>上的二元关系，若<spanclass="math inline">\(R&#39;\)</span>是<spanclass="math inline">\(R\)</span>的自反闭包,记作<spanclass="math inline">\(r(R)\)</span>，则：<ul><li><span class="math inline">\(R&#39;\)</span>是自反的</li><li><span class="math inline">\(R⊆R&#39;\)</span></li><li>对任意的自反关系<spanclass="math inline">\(R&#39;&#39;\)</span>，<spanclass="math inline">\(R⊆R&#39;&#39;\)</span>，则必有<spanclass="math inline">\(R&#39;⊆R&#39;&#39;\)</span></li></ul></li></ul><h3 id="对称闭包">对称闭包</h3><ul><li>设<span class="math inline">\(R\)</span>是<spanclass="math inline">\(A\)</span>上的二元关系，若<spanclass="math inline">\(R&#39;\)</span>是<spanclass="math inline">\(R\)</span>的对称闭包,记作<spanclass="math inline">\(s(R)\)</span>，则：<ul><li><span class="math inline">\(R&#39;\)</span>是对称的</li><li><span class="math inline">\(R⊆R&#39;\)</span></li><li>对任意的对称关系<spanclass="math inline">\(R&#39;&#39;\)</span>，<spanclass="math inline">\(R⊆R&#39;&#39;\)</span>，则必有<spanclass="math inline">\(R&#39;⊆R&#39;&#39;\)</span></li></ul></li></ul><h3 id="传递闭包">传递闭包</h3><ul><li><p>设<span class="math inline">\(R\)</span>是<spanclass="math inline">\(A\)</span>上的二元关系，若<spanclass="math inline">\(R&#39;\)</span>是<spanclass="math inline">\(R\)</span>的传递闭包,记作<spanclass="math inline">\(t(R)\)</span>，则：</p><ul><li><span class="math inline">\(R&#39;\)</span>是传递的</li><li><span class="math inline">\(R⊆R&#39;\)</span></li><li>对任意的传递关系<spanclass="math inline">\(R&#39;&#39;\)</span>，<spanclass="math inline">\(R⊆R&#39;&#39;\)</span>，则必有<spanclass="math inline">\(R&#39;⊆R&#39;&#39;\)</span></li></ul></li></ul><h3 id="定理-2">定理</h3><ul><li>R是 X 上的二元关系,则：<ul><li><span class="math inline">\(r(R)=R∪\{(x,x)|x∈X\}=R∪I_x\)</span></li><li><span class="math inline">\(s(R) = R∪ \overline{R}\)</span></li><li><span class="math inline">\(t(R)=R∪ R^{(2)}∪ R^{(3)}...∪R^{(n)}\)</span>，<span class="math inline">\(n\)</span>为集合<spanclass="math inline">\(X\)</span>的元素的个数</li><li><span class="math inline">\(R\)</span>是自反的<spanclass="math inline">\(\iff\)</span> <spanclass="math inline">\(r(R)\)</span></li><li><span class="math inline">\(R\)</span>是对称的<spanclass="math inline">\(\iff\)</span> <spanclass="math inline">\(s(R)=R\)</span></li><li><span class="math inline">\(R\)</span>是传递的<spanclass="math inline">\(\iff\)</span> <spanclass="math inline">\(t(R)\)</span></li></ul></li></ul><h2 id="等价关系">等价关系</h2><h3 id="定义-7">定义</h3><ul><li>设<span class="math inline">\(R\)</span>是集合<spanclass="math inline">\(X\)</span>上的二元关系，如果<spanclass="math inline">\(R\)</span>是自反的、对称的、传递的，那么称<spanclass="math inline">\(R\)</span>是等价关系</li></ul><h3 id="划分">划分</h3><ul><li>设集合<span class="math inline">\(A=\{S_1, S_2 , …,S_m\}\)</span>,<span class="math inline">\(S_i\)</span>是<spanclass="math inline">\(S\)</span>的非空子集, 如果称<spanclass="math inline">\(A\)</span>是<spanclass="math inline">\(S\)</span>的一个划分，称<spanclass="math inline">\(S_i\)</span>为划分的块，则：<ul><li><span class="math inline">\(S_i\)</span>之间是不相交的</li><li><span class="math inline">\(S_1∪S_2∪…∪S_m = S\)</span></li></ul></li></ul><h3 id="等价类">等价类</h3><h4 id="定义-8">定义</h4><ul><li><span class="math inline">\(R\)</span>是集合<spanclass="math inline">\(S\)</span>上的等价关系, 对任一<spanclass="math inline">\(x\in S\)</span>，均可构造一个<spanclass="math inline">\(S\)</span>的非空子集<spanclass="math inline">\([x]_R= \{ y | y\in S 且 xRy\}\)</span>，也可记为<span class="math inline">\([x]\)</span>，叫做<spanclass="math inline">\(x\)</span>关于<spanclass="math inline">\(R\)</span>的等价类:</li></ul><h4 id="性质-2">性质</h4><ul><li><span class="math inline">\(x\in[x]\)</span></li><li>若<span class="math inline">\(y\in[x]\)</span>, 则<spanclass="math inline">\([y]=[x]\)</span></li><li>若<span class="math inline">\(y\in[x]\)</span>, 则<spanclass="math inline">\([y]∩[x]=\varnothing\)</span></li></ul><h4 id="定理-3">定理</h4><ul><li>集合<span class="math inline">\(S\)</span>上的一个等价关系<spanclass="math inline">\(R\)</span>生成的等价类集合对应<spanclass="math inline">\(S\)</span>的一个划分</li><li>集合<span class="math inline">\(S\)</span>上的一个等价关系<spanclass="math inline">\(R\)</span>生成的等价类集合对应<spanclass="math inline">\(S\)</span>的一个划分。此划分称为集合<spanclass="math inline">\(S\)</span>关于<spanclass="math inline">\(R\)</span>的商集，记为<spanclass="math inline">\(S/R\)</span></li><li>集合<span class="math inline">\(S\)</span>上的一个划分可产生<spanclass="math inline">\(S\)</span>上的一个等价关系</li></ul><h2 id="偏序关系">偏序关系</h2><h3 id="定义-9">定义</h3><ul><li>设<span class="math inline">\(R\)</span>是集合<spanclass="math inline">\(A\)</span>中的二元关系，如果<spanclass="math inline">\(R\)</span>是自反的、反对称的和可传递的，则称<spanclass="math inline">\(R\)</span>是<spanclass="math inline">\(A\)</span>中的偏序关系。</li><li>通常用符号“<spanclass="math inline">\(≼\)</span>”来标记偏序关系<spanclass="math inline">\(R\)</span></li></ul><h3 id="偏序集">偏序集</h3><ul><li>在偏序集合<span class="math inline">\((A ,≼)\)</span>中，如果有元素<spanclass="math inline">\(x,y∈A\)</span>,且<span class="math inline">\(x≼y\)</span>(或者写为<span class="math inline">\((x,y)∈≼\)</span>)和<spanclass="math inline">\(x≠y\)</span>,同时不存在其它任何元素<spanclass="math inline">\(z∈A\)</span>，能使<span class="math inline">\(x≼z\)</span>和<span class="math inline">\(z≼ y\)</span>,则称元素<spanclass="math inline">\(y\)</span>盖住<spanclass="math inline">\(x\)</span>，若元素<spanclass="math inline">\(y\)</span>盖住<spanclass="math inline">\(x\)</span>，则可以将<spanclass="math inline">\(x,y\)</span>间的关系用图形表示，即：哈斯图</li></ul><h3 id="哈斯图">哈斯图</h3><ul><li>用小圆圈表示<span class="math inline">\(A\)</span>中的元素</li><li>若<span class="math inline">\(x≼y\)</span>且<spanclass="math inline">\(x≠y\)</span>, 则<spanclass="math inline">\(x\)</span>在<spanclass="math inline">\(y\)</span>的下方</li><li>若<span class="math inline">\(x≼y\)</span>且<spanclass="math inline">\(x≠y\)</span>, 并且<spanclass="math inline">\(A\)</span>中不存在另外的元素<spanclass="math inline">\(z\)</span>, 满足<spanclass="math inline">\(x≼z\)</span>,<spanclass="math inline">\(z≼y\)</span>, 则在<spanclass="math inline">\(x\)</span>与<spanclass="math inline">\(y\)</span>之间画一直线</li></ul><h3 id="拟序关系">拟序关系</h3><ul><li>设<span class="math inline">\(R\)</span>是集合<spanclass="math inline">\(A\)</span>中的反自反和传递的二元关系，则称<spanclass="math inline">\(R\)</span>是<spanclass="math inline">\(A\)</span>中的拟序关系 (“<spanclass="math inline">\(≺\)</span>”)</li></ul><h3 id="全序和全序集">全序和全序集</h3><ul><li>设<span class="math inline">\(≼\)</span>是<spanclass="math inline">\(A\)</span>中的偏序关系，若对任意的<spanclass="math inline">\(x,y∈A\)</span>，必有<span class="math inline">\(x≼ y\)</span>或<span class="math inline">\(y ≼ x\)</span>，即<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>可比较，则称<spanclass="math inline">\(≼\)</span>是<spanclass="math inline">\(A\)</span>中的线性次序关系或全序关系，又称全序或线性序。相应的偏序集<spanclass="math inline">\((A,≼)\)</span>称为线性序集或全序集</li><li>显然，任一全序集也是偏序集，其哈斯图为一条链，但是任一偏序集不一定是全序集合</li></ul><h3 id="最大小元素">最大（小）元素</h3><ul><li>设<span class="math inline">\(( X, ≼ )\)</span>是偏序集，<spanclass="math inline">\(Y\)</span>是<spanclass="math inline">\(X\)</span>的子集。若存在元素<spanclass="math inline">\(y∈ Y\)</span>,对于每一个<spanclass="math inline">\(y’ ∈ Y\)</span>，<ul><li>若有<span class="math inline">\(y’ ≼ y\)</span>，则称<spanclass="math inline">\(y\)</span>是集合<spanclass="math inline">\(Y\)</span>的最大元素</li><li>若有<span class="math inline">\(y ≼y’\)</span>，则称<spanclass="math inline">\(y\)</span>是集合<spanclass="math inline">\(Y\)</span>的最小元素</li></ul></li></ul><h3 id="性质-3">性质</h3><ul><li>设<span class="math inline">\(( X, ≼ )\)</span>是偏序集，<spanclass="math inline">\(Y\)</span>是<spanclass="math inline">\(X\)</span>的子集，如果<spanclass="math inline">\(Y\)</span>有最大（最小）元素，则必定是唯一的</li></ul><h3 id="极大小元素">极大（小）元素</h3><ul><li>设<span class="math inline">\(( X, ≼)\)</span>是偏序集，<spanclass="math inline">\(Y\)</span>是<spanclass="math inline">\(X\)</span>的子集，若<span class="math inline">\(y∈ Y\)</span>，且不存在<span class="math inline">\(y’ ∈ Y\)</span>，<spanclass="math inline">\(y≠ y’\)</span>，<ul><li>若有<span class="math inline">\(y ≼ y’\)</span>，则称<spanclass="math inline">\(y\)</span>是<spanclass="math inline">\(Y\)</span>的极大元素</li><li>若有<span class="math inline">\(y’ ≼ y\)</span>，则称<spanclass="math inline">\(y\)</span>是<spanclass="math inline">\(Y\)</span>的极小元素</li></ul></li></ul><h3 id="上下界">上（下）界</h3><ul><li>设<span class="math inline">\(( X, ≼ )\)</span>是偏序集，<spanclass="math inline">\(Y\subseteq X\)</span>，若<spanclass="math inline">\(x ∈ X\)</span>，使得对任意<spanclass="math inline">\(y’ ∈ Y\)</span>,<ul><li>若有<span class="math inline">\(y’≼x\)</span>，则称<spanclass="math inline">\(x\)</span>是<spanclass="math inline">\(Y\)</span>的上界</li><li>若有<span class="math inline">\(x ≼ y’\)</span>，则称<spanclass="math inline">\(x\)</span>是<spanclass="math inline">\(Y\)</span>的下界</li></ul></li></ul><h3 id="上下确界">上（下）确界</h3><ul><li>设<span class="math inline">\(( X, ≼ )\)</span>是偏序集，<spanclass="math inline">\(Y\)</span>是<spanclass="math inline">\(X\)</span>的子集。<ul><li><span class="math inline">\(x\)</span>是<spanclass="math inline">\(Y\)</span>的上界，若对<spanclass="math inline">\(Y\)</span>的任一上界<spanclass="math inline">\(x’\)</span>，都有<span class="math inline">\(x≼x’\)</span>，则称<span class="math inline">\(x\)</span>是<spanclass="math inline">\(Y\)</span>的上确界，记作<spanclass="math inline">\(LUB\)</span> <spanclass="math inline">\(Y\)</span></li><li><span class="math inline">\(x\)</span>是<spanclass="math inline">\(Y\)</span>的下界，若对于<spanclass="math inline">\(Y\)</span>的任一下界<spanclass="math inline">\(x’\)</span>，均有<span class="math inline">\(x’≼x\)</span>，则称<span class="math inline">\(x\)</span>是<spanclass="math inline">\(Y\)</span>的下确界,记作<spanclass="math inline">\(GLB\)</span> <spanclass="math inline">\(Y\)</span></li></ul></li></ul><h1 id="函数">函数</h1><h2 id="函数及其分类">函数及其分类</h2><h3 id="函数的定义">函数的定义</h3><ul><li>设<span class="math inline">\(f\)</span>是集合<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的关系 若称<spanclass="math inline">\(f\)</span>是集合<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的函数或映射，记作<spanclass="math inline">\(f: A→B\)</span> 或 <span class="math inline">\(A →B\)</span>。 当<spanclass="math inline">\((a,b)∈f\)</span>时，通常记为<spanclass="math inline">\(b=f(a)\)</span>，<spanclass="math inline">\(b\)</span>称为<spanclass="math inline">\(a\)</span>在<spanclass="math inline">\(f\)</span>下的像，称<spanclass="math inline">\(a\)</span>为<spanclass="math inline">\(b\)</span>的原像。则<spanclass="math inline">\(f\)</span>满足下列两个条件：<ul><li>对每个<span class="math inline">\(a∈A\)</span>，必存在<spanclass="math inline">\(b∈B\)</span>，使得<spanclass="math inline">\((a,b)∈f\)</span>——<strong>存在性条件</strong></li><li>对每个<span class="math inline">\(a∈A\)</span>，只存在一个<spanclass="math inline">\(b∈B\)</span>，使得<spanclass="math inline">\((a,b)∈f\)</span>——<strong>唯一性条件</strong></li></ul></li><li>即：值域为函数的像集合</li></ul><h3 id="函数相等">函数相等</h3><ul><li>设<span class="math inline">\(f:X→Y\)</span>，<spanclass="math inline">\(g:Z→W\)</span>，如果<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>具有相同的定义域和值域，即<spanclass="math inline">\(X=Z\)</span>和<spanclass="math inline">\(Y=W\)</span>，并且对于所有的<spanclass="math inline">\(x∈X\)</span>和<spanclass="math inline">\(x∈Z\)</span>，都有<spanclass="math inline">\(f(x)=g(x)\)</span>，则称函数<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>相等，并记作<spanclass="math inline">\(f=g\)</span></li></ul><h3 id="函数个数">函数个数</h3><ul><li>设<span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span>是非空有限集合，则从<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>共有<spanclass="math inline">\(|B|^{|A|}\)</span> 个不同的函数</li><li>因为函数是一种特殊的关系，所以一个函数确定一个关系；但一个关系不一定确定一个函数</li></ul><h3 id="函数的分类">函数的分类</h3><ul><li>设<span class="math inline">\(f: A→B\)</span>是一个函数：<ul><li>对任意的<span class="math inline">\(a_1\)</span>和<spanclass="math inline">\(a_2∈A\)</span>，若<spanclass="math inline">\(a_1≠a_2\)</span>，均有<spanclass="math inline">\(f(a_1)≠f(a_2)\)</span>，则称<spanclass="math inline">\(f\)</span>为<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的<strong>单射函数</strong>或<strong>一对一函数</strong>；否则，称<spanclass="math inline">\(f\)</span>为<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的<strong>多对一函数</strong>。</li><li>如果对任意的<span class="math inline">\(b∈B\)</span>，均有<spanclass="math inline">\(a∈A\)</span>，使<spanclass="math inline">\(b=f(a)\)</span>，即<spanclass="math inline">\(C_f=B\)</span>，则<spanclass="math inline">\(f\)</span>为<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的<strong>满射函数</strong>；否则，称<spanclass="math inline">\(f\)</span>为<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的<strong>内射函数</strong>。</li><li>如果<span class="math inline">\(f\)</span>既是<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的<strong>单射</strong>，又是<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的<strong>满射</strong>，则称<spanclass="math inline">\(f\)</span>为<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的<strong>双射函数</strong>或<strong>一一对应函数</strong>。特殊地，在一一对应函数<spanclass="math inline">\(f: A→B\)</span>中，若<spanclass="math inline">\(A=B\)</span>，则此函数叫做<spanclass="math inline">\(A\)</span>的变换。</li></ul></li></ul><h3 id="函数分类结论">函数分类结论</h3><ul><li>设A，B为有限集合，f是从A到B的函数，则：<ul><li><span class="math inline">\(f\)</span>是单射的必要条件为<spanclass="math inline">\(|A|≤|B|\)</span></li><li><span class="math inline">\(f\)</span>是满射的必要条件为<spanclass="math inline">\(|B|≤|A|\)</span></li><li><span class="math inline">\(f\)</span>是双射的必要条件为<spanclass="math inline">\(|A|＝|B|\)</span></li></ul></li></ul><h3 id="特殊函数">特殊函数</h3><ul><li>设<span class="math inline">\(f\)</span>是一个函数，若对任意的<spanclass="math inline">\(a∈A\)</span>，均有<spanclass="math inline">\(f(a)=b\)</span>，<spanclass="math inline">\(b∈B\)</span>，则称<spanclass="math inline">\(f\)</span>是从<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的<strong>常值函数</strong>或<strong>常函数</strong></li><li>设<span class="math inline">\(f\)</span>是一个函数，若对任意的<spanclass="math inline">\(a∈A\)</span>，均有<spanclass="math inline">\(f(a)=a\)</span>，则称<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(A\)</span>上的<strong>恒等函数</strong></li><li>设<span class="math inline">\(f:R→R\)</span>是一个函数，其中<spanclass="math inline">\(R\)</span>为实数集，<ul><li>对任意<span class="math inline">\(a,b∈R\)</span>，若<spanclass="math inline">\(a&lt;b\)</span>，必有<spanclass="math inline">\(f(a)≤f(b)\)</span>，则称<spanclass="math inline">\(f\)</span>为单调递增函数</li><li>对任意<span class="math inline">\(a,b∈R\)</span>，若<spanclass="math inline">\(a&lt;b\)</span>，必有<spanclass="math inline">\(f(a)&lt;f(b)\)</span>，则称<spanclass="math inline">\(f\)</span>为严格单调递增函数</li></ul></li><li>设<span class="math inline">\(U\)</span>是全集，且<spanclass="math inline">\(A⊆U\)</span>，函数<span class="math inline">\(\Psi_A:U\to \{0,1\}\)</span>定义为: <spanclass="math inline">\(\Psi_A=\begin{cases} 1,&amp; a \in A\\ 0,&amp; a\notin A \end{cases}\)</span> 则称<spanclass="math inline">\(\Psi_A\)</span>是集合<spanclass="math inline">\(A\)</span>的特征函数</li></ul><h2 id="复合函数与逆函数">复合函数与逆函数</h2><h3 id="复合函数">复合函数</h3><h4 id="复合函数定义">复合函数定义</h4><ul><li>函数的合成运算可定义如下：设<span class="math inline">\(f :X→Y\)</span>, <span class="math inline">\(g :Y→Z\)</span>是两个函数，于是合成函数记为<spanclass="math inline">\(g\circ f : X→Z\)</span> <spanclass="math inline">\(\\g\circf=\{(x,z)|x∈X且z∈Z且存在y∈Y且y=f(x)且z=g(y)\}\)</span> 通常称为函数<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>的合成，确切的说，<spanclass="math inline">\(g\circ f\)</span>称为<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>左合成，从<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>求得<span class="math inline">\(g\circf\)</span>的运算“<spanclass="math inline">\(\circ\)</span>”称为左合成运算关系的合成运算为<span class="math inline">\(f\circg\)</span>，函数的合成运算为<span class="math inline">\(g\circf\)</span></li></ul><h4 id="复合函数定理">复合函数定理</h4><ul><li>函数的合成运算是可结合的</li><li>设<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>是函数，并且有合成函数<spanclass="math inline">\(g\circ f\)</span>,则<ul><li>如果<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>都是满射函数，则<spanclass="math inline">\(g \circ f\)</span>也是满射函数</li><li>如果<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>都是单射函数，则<spanclass="math inline">\(g\circ f\)</span>也是单射函数</li><li>如果<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>都是双射函数，则<spanclass="math inline">\(g\circ f\)</span>也是双射函数</li></ul></li></ul><h3 id="逆函数">逆函数</h3><h4 id="逆函数定义">逆函数定义</h4><ul><li>设<span class="math inline">\(f : A→B\)</span>是一个双射函数 ,称<span class="math inline">\(f^{-1} : B→A\)</span>是<spanclass="math inline">\(f\)</span>的逆函数</li><li>在关系部分，曾定义了从集合<spanclass="math inline">\(X\)</span>到<spanclass="math inline">\(Y\)</span>的关系<spanclass="math inline">\(R\)</span>的逆关系，但是对于函数来说，交换序偶中的成员次序并<strong>不一定</strong>能保证得到的仍然是个函数</li><li>设<spanclass="math inline">\(f:A→B\)</span>是一一对应的函数，则<spanclass="math inline">\(f\)</span>的逆关系 称为它的逆函数，记成<spanclass="math inline">\(f^{-1}: B→A\)</span>。这时称函数<spanclass="math inline">\(f\)</span>是可逆的</li></ul><h4 id="逆函数的定理">逆函数的定理</h4><ul><li>函数<span class="math inline">\(f : A→B\)</span>，若存在逆函数<spanclass="math inline">\(f^{-1} : B→A\)</span>，则必须满足：<ul><li>对任意的<span class="math inline">\(a∈A\)</span>，必有唯一的<spanclass="math inline">\(b∈B\)</span>与之对应；</li><li>对任意的<span class="math inline">\(b∈B\)</span>，必有唯一的<spanclass="math inline">\(a∈A\)</span>与之对应；</li></ul></li></ul><h1 id="代数系统">代数系统</h1><h2 id="代数系统的基本概念">代数系统的基本概念</h2><h3 id="二元运算">二元运算</h3><h4 id="定义-10">定义</h4><ul><li>设<span class="math inline">\(A, B, C\)</span>是非空集合，从<spanclass="math inline">\(A×B\)</span>到<spanclass="math inline">\(C\)</span>的一个函数<span class="math inline">\(f：A×B→C\)</span>称为一个<span class="math inline">\(A×B\)</span>到<spanclass="math inline">\(C\)</span>的二元代数运算，简称二元运算</li><li>一个二元运算就是一个特殊的函数 ，该函数能够对<spanclass="math inline">\(a\in A\)</span>和<span class="math inline">\(b\inB\)</span>进行运算，得到<spanclass="math inline">\(C\)</span>中的一个元素<spanclass="math inline">\(c\)</span> ， 即 <span class="math inline">\(\circ(a, b)＝c\)</span>。 中缀方法表示为：<span class="math inline">\(a \circb＝c\)</span></li></ul><h3 id="特点-1">特点</h3><h4 id="封闭性">封闭性</h4><ul><li>如果“<span class="math inline">\(*\)</span>”是<spanclass="math inline">\(A×A\)</span>到<spanclass="math inline">\(A\)</span>的二元运算，则称运算“<spanclass="math inline">\(*\)</span>”对集合<spanclass="math inline">\(A\)</span>是封闭的，或者称“<spanclass="math inline">\(*\)</span>”是<spanclass="math inline">\(A\)</span>上的二元运算</li><li>设“<span class="math inline">\(*\)</span>”是一个<spanclass="math inline">\(A_1×A_2×…×A_n\)</span>到<spanclass="math inline">\(A\)</span>的<spanclass="math inline">\(n\)</span>元代数运算，如果<spanclass="math inline">\(A_1＝A_2＝…＝A_n＝A\)</span>，则称代数运算“<spanclass="math inline">\(*\)</span>”对集合<spanclass="math inline">\(A\)</span>是封闭的，或者称“<spanclass="math inline">\(*\)</span>”是<spanclass="math inline">\(A\)</span>上的<spanclass="math inline">\(n\)</span>元代数运算</li></ul><h3 id="代数系统的定义">代数系统的定义</h3><ul><li>设<span class="math inline">\(A\)</span>是非空集合，<spanclass="math inline">\(*\)</span>是定义在<spanclass="math inline">\(A\)</span>上<spanclass="math inline">\(k\)</span>元封闭运算，称集合<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(*\)</span>所组成的系统称为代数系统，简称代数，记为<spanclass="math inline">\((A, *)\)</span></li><li>当<spanclass="math inline">\(A\)</span>是有限集合时，该代数系统称为有限代数系统，否则称为无限代数系统</li><li>注意：判断集合<spanclass="math inline">\(A\)</span>和其上的代数运算是否是代数系统，关键是判断两点：<ul><li>集合<span class="math inline">\(A\)</span>非空</li><li>这些运算关于<spanclass="math inline">\(A\)</span>是否满足封闭性</li></ul></li></ul><h3 id="同类型代数系统">同类型代数系统</h3><ul><li>设<span class="math inline">\((A, *)\)</span>和<spanclass="math inline">\((B, \circ )\)</span>是两个代数系统，若“<spanclass="math inline">\(\circ\)</span>”和“<spanclass="math inline">\(*\)</span>”都是<spanclass="math inline">\(k\)</span>元运算，<span class="math inline">\(i =1, 2, …, m\)</span>，则称这两个代数同类型</li></ul><h2 id="运算规律">运算规律</h2><h3 id="结合律-1">结合律</h3><ul><li>设<span class="math inline">\((A,*)\)</span>是二元代数系统，若对任意<span class="math inline">\(a, b,c∈A\)</span>，都有 <span class="math inline">\((a*b)*c＝a*(b*c)\)</span>则称“<span class="math inline">\(*\)</span>”在<spanclass="math inline">\(A\)</span>上是可结合的，或称满足结合律</li></ul><h3 id="交换律-1">交换律</h3><ul><li>设<span class="math inline">\((A,*)\)</span>是二元代数系统，若对任意<span class="math inline">\(a,b∈A\)</span>，都有 <span class="math inline">\(a*b＝b*a\)</span>则称“<span class="math inline">\(*\)</span>”在<spanclass="math inline">\(A\)</span>上是可交换的，或称“<spanclass="math inline">\(*\)</span>”满足交换律</li></ul><h3 id="消去律">消去律</h3><ul><li>设<span class="math inline">\((A,*)\)</span>是二元代数系统，元素<spanclass="math inline">\(a∈A\)</span>，<ul><li>对任意<span class="math inline">\(x, y∈A\)</span>，都有如果<spanclass="math inline">\(a*x = a*y\)</span>，那<spanclass="math inline">\(x = y\)</span>，则称<spanclass="math inline">\(a\)</span>在<spanclass="math inline">\(A\)</span>中关于“<spanclass="math inline">\(*\)</span>”是左可消去元</li><li>对任意<span class="math inline">\(x, y∈A\)</span>，都有如果<spanclass="math inline">\(x*a = y*a\)</span>，那么<spanclass="math inline">\(x = y\)</span>，则称<spanclass="math inline">\(a\)</span>在<spanclass="math inline">\(A\)</span>中关于“<spanclass="math inline">\(*\)</span>”是右可消去元</li><li>如果<span class="math inline">\(a\)</span>既是<spanclass="math inline">\(A\)</span>左可消去元又是右可消去元，则称<spanclass="math inline">\(a\)</span>是<spanclass="math inline">\(A\)</span>的可消去元</li><li>若<spanclass="math inline">\(A\)</span>中所有元素都是可消去元，则称“<spanclass="math inline">\(*\)</span>”在<spanclass="math inline">\(A\)</span>上可消去，或称“<spanclass="math inline">\(*\)</span>”满足消去律</li></ul></li></ul><h3 id="幂等律">幂等律</h3><ul><li>设<span class="math inline">\((A,*)\)</span>是二元代数系统，若元素<spanclass="math inline">\(a∈A\)</span>，满足<spanclass="math inline">\(a*a=a\)</span>则称<spanclass="math inline">\(a\)</span>是<spanclass="math inline">\(A\)</span>中关于“<spanclass="math inline">\(*\)</span>”的一个幂等元，简称<spanclass="math inline">\(a\)</span>为幂等元。若<spanclass="math inline">\(A\)</span>中的每一个元素都是幂等元，则称“<spanclass="math inline">\(*\)</span>”在<spanclass="math inline">\(A\)</span>中是幂等的，或称“<spanclass="math inline">\(*\)</span>”满足幂等律</li></ul><h3 id="幂">幂</h3><ul><li>设“<span class="math inline">\(*\)</span>”是集合<spanclass="math inline">\(A\)</span>上可结合的二元运算，<spanclass="math inline">\(a∈A\)</span>，则<spanclass="math inline">\(a*a∈A，a*a*a∈A，…，\)</span>由此，可以归纳定义<spanclass="math inline">\(a\)</span>的正整数幂方： <spanclass="math inline">\(a^1 = a，a^2 = a*a，a^3 = a^2*a，… ， a^n =a^{n-1}*a，…\)</span></li><li>对任意正整数<span class="math inline">\(n\)</span>，<spanclass="math inline">\(m\)</span>，有以下等式：<spanclass="math inline">\(a^n * a^m = a^{n+m}， (a^n)^m =a^{nm}\)</span></li></ul><h3 id="分配律-1">分配律</h3><ul><li>设“<span class="math inline">\(*\)</span>”、“<spanclass="math inline">\(\circ\)</span>”是集合A上的二元运算，<spanclass="math inline">\((A,*, \circ)\)</span>是一个代数系统， 对任意<spanclass="math inline">\(a,b,c\in A\)</span>，<ul><li><span class="math inline">\(a\circ (b*c)=(a\circ b)*(a\circc)\)</span>， 则称运算“<spanclass="math inline">\(\circ\)</span>”对“<spanclass="math inline">\(*\)</span>”在<spanclass="math inline">\(A\)</span>上满足左分配律(或第一分配律)</li><li><span class="math inline">\((b*c) \circ a=(b\circ a)*(c\circa)\)</span>， 则称运算“<spanclass="math inline">\(\circ\)</span>”对“<spanclass="math inline">\(*\)</span>”在<spanclass="math inline">\(A\)</span>上满足右分配律(或第二分配律)</li><li>如果“<span class="math inline">\(\circ\)</span>”对“<spanclass="math inline">\(*\)</span>”既满足左分配律又满足右分配律，则称“<spanclass="math inline">\(\circ\)</span>”对“<spanclass="math inline">\(*\)</span>”在<spanclass="math inline">\(A\)</span>上满足分配律</li></ul></li></ul><h3 id="吸收律-1">吸收律</h3><ul><li>设“<span class="math inline">\(*\)</span>”、“<spanclass="math inline">\(\circ\)</span>”是集合<spanclass="math inline">\(A\)</span>上的二元运算，<spanclass="math inline">\((A,*, \circ)\)</span>是一个代数系统，如果对任意<span class="math inline">\(x,y∈A\)</span>，都有<span class="math inline">\(x *(x \circ y) = x，x\circ(x*y) = x\)</span> 则称“<spanclass="math inline">\(*\)</span>”和“<spanclass="math inline">\(\circ\)</span>”满足吸收律</li></ul><h2 id="特殊元">特殊元</h2><h3 id="特殊元的定义">特殊元的定义</h3><ul><li>在代数系统中，有些元素有特殊性质，叫特殊元</li></ul><h3 id="单位元">单位元</h3><ul><li>设<span class="math inline">\((A, *)\)</span>是二元代数系统，<ul><li>若存在<span class="math inline">\(e∈A\)</span>，对任意<spanclass="math inline">\(a∈A\)</span>，都有 <span class="math inline">\(a*e = e* a = a\)</span>，则称<spanclass="math inline">\(e\)</span>是<spanclass="math inline">\(A\)</span>中关于运算“<spanclass="math inline">\(*\)</span>”的一个单位元</li><li>若存在<span class="math inline">\(e_l∈A\)</span>，使得对任意<spanclass="math inline">\(a∈A\)</span>，都有 <span class="math inline">\(e_l*a = a\)</span>，则称<span class="math inline">\(e_l\)</span>是<spanclass="math inline">\(A\)</span>中关于运算“<spanclass="math inline">\(*\)</span>”的一个左单位元</li><li>若存在<span class="math inline">\(e_r∈A\)</span>，使得对任意<spanclass="math inline">\(a∈A\)</span>，都有 <span class="math inline">\(a*e_r = a\)</span>，则称<span class="math inline">\(e_r\)</span>是<spanclass="math inline">\(A\)</span>中关于运算“<spanclass="math inline">\(*\)</span>”的一个右单位元</li></ul></li></ul><h3 id="零元">零元</h3><ul><li>设<span class="math inline">\((A, *)\)</span>是一个二元代数系统，<ul><li>若存在<span class="math inline">\(θ∈A\)</span>，使得对任意<spanclass="math inline">\(a∈A\)</span>，都有<span class="math inline">\(a *θ= θ* a =θ\)</span>，则称<span class="math inline">\(θ\)</span>是<spanclass="math inline">\(A\)</span>中关于运算“<spanclass="math inline">\(*\)</span>”的一个零元</li><li>若存在<span class="math inline">\(θ_l∈A\)</span>，使得对任意<spanclass="math inline">\(a∈A\)</span>，都有<span class="math inline">\(θ_l*a = θ_l\)</span>，则称<span class="math inline">\(θ_l\)</span>是<spanclass="math inline">\(A\)</span>中关于运算“<spanclass="math inline">\(*\)</span>”的一个左零元</li><li>若存在<span class="math inline">\(θ_r∈A\)</span>，使得对任意<spanclass="math inline">\(a∈A\)</span>，都有<span class="math inline">\(a*θ_r = θ_r\)</span>，则称<span class="math inline">\(θ_r\)</span>是<spanclass="math inline">\(A\)</span>中关于运算“<spanclass="math inline">\(*\)</span>”的一个右零元。</li></ul></li></ul><h3 id="逆元">逆元</h3><ul><li>设<span class="math inline">\((A, *)\)</span>是二元代数系统，<spanclass="math inline">\(e\)</span>是幺元，<spanclass="math inline">\(a∈A\)</span>，若存在一个元素<spanclass="math inline">\(b∈A\)</span>，<ul><li>使得：<span class="math inline">\(a *b = b* a =e\)</span>，则称<span class="math inline">\(a\)</span>可逆，并称<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(a\)</span>的一个逆元，记为<spanclass="math inline">\(a^{-1}\)</span></li><li>使得：<span class="math inline">\(b*a = e\)</span>，则称<spanclass="math inline">\(a\)</span>左可逆，并称<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(a\)</span>的一个左逆元，记为<spanclass="math inline">\(a_l^{-1}\)</span></li><li>使得：<span class="math inline">\(a*b = e\)</span>，则称<spanclass="math inline">\(a\)</span>右可逆，并称<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(a\)</span>的一个右逆元，记为<spanclass="math inline">\(a_r^{-1}\)</span></li></ul></li></ul><h3 id="定理-4">定理</h3><ul><li>设<span class="math inline">\((A, *)\)</span>是一个代数系统，“<spanclass="math inline">\(*\)</span>” 满足结合律，<spanclass="math inline">\(a∈A\)</span>，<spanclass="math inline">\(a\)</span>可逆，则<spanclass="math inline">\(a\)</span>是可消去元</li><li>设<span class="math inline">\((A, *)\)</span>是二元代数系统，<ul><li>如果<span class="math inline">\((A,*)\)</span>存在单位元，则单位元唯一</li><li>如果<span class="math inline">\((A,*)\)</span>存在单位元，则该单位元一定是左、右单位元</li><li>如果<span class="math inline">\((A,*)\)</span>存在左、右单位元，则该左、右单位元相等，且是单位元。</li></ul></li><li>设<span class="math inline">\((A, *)\)</span>是二元代数系统，<ul><li>如果<span class="math inline">\((A,*)\)</span>存在零元，则零元唯一</li><li>如果<span class="math inline">\((A,*)\)</span>存在零元，则该零元一定是左、右零元</li><li>如果<span class="math inline">\((A,*)\)</span>存在左、右零元，则该左、右零元相等，且是零元。</li></ul></li><li>设<span class="math inline">\((A, *)\)</span>是二元代数系统，“<spanclass="math inline">\(*\)</span>”满足结合律且设<spanclass="math inline">\(e\)</span>是单位元，则对任意<spanclass="math inline">\(a∈A\)</span>，<ul><li>如果<span class="math inline">\(a\)</span>存在逆元，则逆元唯一</li><li>如果<spanclass="math inline">\(a\)</span>存在逆元，则该逆元一定是左、右逆元</li><li>如果<spanclass="math inline">\(a\)</span>存在左、右逆元，则该左、右逆元相等，且是逆元。</li></ul></li><li>设<span class="math inline">\((A, *)\)</span>是二元代数系统，“<spanclass="math inline">\(*\)</span>”满足结合律，<spanclass="math inline">\(a, b∈A\)</span>，<ul><li>如果<span class="math inline">\(a, b\)</span>分别有逆元<spanclass="math inline">\(a^{-1}, b^{-1}\)</span>，则<spanclass="math inline">\((a*b)^{-1} = b^{-1}*a^{-1}\)</span></li><li>如果<spanclass="math inline">\(a\)</span>是左（或右）可逆的元素，则<spanclass="math inline">\(a\)</span>是左（或右）可消去的元素</li><li>如果<span class="math inline">\(a\)</span>是可逆的元素，则<spanclass="math inline">\(a\)</span>是可消去的元素</li></ul></li></ul><h3 id="同构">同构</h3><h4 id="同构的定义">同构的定义</h4><ul><li>在现实社会中，存在着很多代数系统，但仔细分析这些众多的代数系统发现，有些代数系统，他们之间表面上似乎不相同，但他们本质上是“相同”的</li></ul><h4 id="同构的条件">同构的条件</h4><ul><li>必须是同型代数系统</li><li>两个集合的元素个数应相等</li><li>运算定义法则相同，即对应元素运算后的结果也对应</li></ul><h3 id="同态">同态</h3><h4 id="同态的定义">同态的定义</h4><ul><li>设<span class="math inline">\((A, *)\)</span>和<spanclass="math inline">\((B, \circ)\)</span>为两个二元代数系统，<spanclass="math inline">\(g\)</span>是<spanclass="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的函数。对任意<spanclass="math inline">\(x, y∈A\)</span>，都有<spanclass="math inline">\(g(x*y) = g(x) \circ g(y)\)</span>，则称<spanclass="math inline">\(g\)</span>是从<span class="math inline">\((A,*)\)</span>到<span class="math inline">\((B,\circ)\)</span>的<strong>同态映射</strong>，称<spanclass="math inline">\(g(A)\)</span>为<strong>同态像</strong>，其中<spanclass="math inline">\(g(A) = \{g(x) |x∈A\}\)</span>。如果存在一个从<spanclass="math inline">\((A,*)\)</span>到<span class="math inline">\((B,\circ )\)</span>的同态映射，则称<span class="math inline">\((A,*)\)</span>与<span class="math inline">\((B, \circ)\)</span>同态，记为<span class="math inline">\((A,*)∽(B, \circ)\)</span>。当<span class="math inline">\((A, *)= (B, \circ)\)</span>时，称其同态为<strong>自同态</strong></li><li>当同态映射<spanclass="math inline">\(g\)</span>分别是<strong>单射</strong>、<strong>满射</strong>、<strong>双射</strong>时，分别称<spanclass="math inline">\(g\)</span>是<strong>单一同态映射</strong>、<strong>满同态映射</strong>、<strong>同构映射</strong></li><li>如果存在一个从<span class="math inline">\((A, *)\)</span>到<spanclass="math inline">\((B, \circ)\)</span>的<strong>同构映射</strong>（单一同态映射、满同态映射），则称代数系统<spanclass="math inline">\((A,*)\)</span>与<span class="math inline">\((B,\circ )\)</span><strong>同构</strong>（单一同态、满同态）。 用<spanclass="math inline">\((A, *)≌(B, \circ )\)</span>表示<spanclass="math inline">\((A,*)\)</span>与<span class="math inline">\((B,\circ )\)</span>同构</li></ul><h1 id="命题逻辑">命题逻辑</h1><h2 id="命题与命题联结词">命题与命题联结词</h2><h3 id="命题">命题</h3><ul><li>具有真假意义的<strong>陈述句</strong>称为命题</li><li>命题可以取一个“值”，称为真值</li><li>真值只有“真”和“假”两种，分别用“<spanclass="math inline">\(Ｔ\)</span>”(或“<spanclass="math inline">\(１\)</span>”)和“<spanclass="math inline">\(Ｆ\)</span>”(或“<spanclass="math inline">\(０\)</span>)表示</li></ul><h3 id="命题的分类">命题的分类</h3><ul><li>原子命题(简单命题)：不能再分解为更为简单命题的命题</li><li>复合命题：可以分解为原子命题的命题，这些原子命题之间通过如“或者”、“并且”、“不”、“如果...则...”、“当且仅当”等这样的关联词和标点符号复合而构成一个复合命题。（优先级：<strong>否定→合取→析取→蕴涵→等价</strong>）</li></ul><h3 id="命题联结词">命题联结词</h3><h4 id="否定neg">否定<span class="math inline">\(\neg\)</span></h4><ul><li>设<span class="math inline">\(P\)</span>是任一命题，复合命题“非<spanclass="math inline">\(P\)</span>”(或“<spanclass="math inline">\(P\)</span>的否定”)称为<spanclass="math inline">\(P\)</span>的否定式(Negation)，记作<spanclass="math inline">\(\neg P\)</span>，“<spanclass="math inline">\(\neg\)</span>”为否定联结词</li></ul><h4 id="合取wedge">合取<span class="math inline">\(\wedge\)</span></h4><ul><li>设<span class="math inline">\(P\)</span>、<spanclass="math inline">\(Q\)</span>是任两个命题，复合命题“<spanclass="math inline">\(P并且Q\)</span>”(或“<spanclass="math inline">\(P和Q\)</span>”)称为<spanclass="math inline">\(P\)</span>与<spanclass="math inline">\(Q\)</span>的合取式(Conjunction)，记作<spanclass="math inline">\(P∧Q\)</span>，“<spanclass="math inline">\(∧\)</span>”为合取联结词</li></ul><h4 id="析取vee">析取<span class="math inline">\(\vee\)</span></h4><ul><li>设<span class="math inline">\(P\)</span>、<spanclass="math inline">\(Q\)</span>是任两个命题，复合命题“<spanclass="math inline">\(P或者Q\)</span>”称为<spanclass="math inline">\(P\)</span>与<spanclass="math inline">\(Q\)</span>的析取式(Disjunction)，记作<spanclass="math inline">\(P∨Q\)</span>，“<spanclass="math inline">\(∨\)</span>”为析取联结词</li></ul><h4 id="蕴涵">蕴涵<span class="math inline">\(→\)</span></h4><ul><li>设<span class="math inline">\(P\)</span>、<spanclass="math inline">\(Q\)</span>是任两个命题，复合命题“<spanclass="math inline">\(如果P，则Q\)</span>”称为<spanclass="math inline">\(P\)</span>与<spanclass="math inline">\(Q\)</span>的蕴涵式(Implication)，记作<spanclass="math inline">\(P→Q\)</span>，“<spanclass="math inline">\(→\)</span>”称为蕴涵联结词，<spanclass="math inline">\(P\)</span>称为蕴涵式的前件，<spanclass="math inline">\(Q\)</span>称为后件</li></ul><h4 id="等价leftrightarrow">等价<spanclass="math inline">\(\leftrightarrow\)</span></h4><ul><li>设<spanclass="math inline">\(P、Q\)</span>是任两个命题，复合命题“<spanclass="math inline">\(P当且仅当Q\)</span>”称为<spanclass="math inline">\(P\)</span>与<spanclass="math inline">\(Q\)</span>的等价式(Equivalence)，记作<spanclass="math inline">\(P\leftrightarrow Q\)</span>，“<spanclass="math inline">\(\leftrightarrow\)</span>”称为等价联结词</li></ul><h4 id="说明">说明</h4><ul><li>联结词与自然语言之间的对应并非一一对应：<ul><li>合取联结词“<spanclass="math inline">\(∧\)</span>”对应自然语言的“既…又…”、“不仅…而且…”、“虽然…但是…”、“并且”、“和”、“与”等</li><li>蕴涵联结词“<span class="math inline">\(→\)</span>”,“<spanclass="math inline">\(P→Q\)</span>”对应自然语言中的“如P则Q” ,“只要P就Q”,“P仅当Q”,“只有Q才P”,“除非Q否则<spanclass="math inline">\(\neg\)</span> P”等</li><li>等价联结词“<spanclass="math inline">\(↔\)</span>”对应了自然语言中的“等价”、“当且仅当”、“充分必要”等</li><li>析取联结词“<spanclass="math inline">\(\vee\)</span>”对应的是相容（可兼）的或</li><li>否定联结词“<spanclass="math inline">\(\neg\)</span>”是自然语言中的“非”、“不”和“没有”等</li></ul></li><li>当前件<span class="math inline">\(P\)</span>为假时，不管<spanclass="math inline">\(Q\)</span>的真假如何，则<spanclass="math inline">\(P→Q\)</span>都为真。此时称为“<strong>善意推定</strong>”</li><li>复合命题的真值<strong>只取决于</strong>构成他们的各原子命题的真值，而与它们的内容、含义无关，与联结次所连接的两原子命题之间是否有关系无关</li></ul><h2 id="命题公式与符号化">命题公式与符号化</h2><h3 id="命题公式的定义">命题公式的定义</h3><ul><li>一个特定的命题是一个<strong>常值命题</strong>，它不是具有值“T”(“1”)，就是具有值“F”(“0”)</li><li>一个任意的没有赋予具体内容的原子命题称为<strong>命题变量</strong>(或<strong>命题变元</strong>)，该命题变量无具体的真值，它的变域是集合<spanclass="math inline">\(\{T，F\}\)</span>(或<spanclass="math inline">\(\{0，1\}\)</span>)</li><li>当原子命题是命题变元时，此复合命题也即为命题变元的“函数”，且该“函数”的值仍为“真”或“假”值，这样的函数可形象地称为“<strong>真值函数</strong>”,或称为<strong>命题公式</strong>，此命题公式<strong>没有确切真值</strong></li></ul><h3 id="公式的解释">公式的解释</h3><h4 id="定义-11">定义</h4><ul><li>设<spanclass="math inline">\(P_1、P_2、…、P_n\)</span>是出现在公式<spanclass="math inline">\(G\)</span>中的所有命题变元，指定<spanclass="math inline">\(P_1、P_2、…、P_n\)</span>一组真值，则这组真值称为<spanclass="math inline">\(G\)</span>的一个解释,常记为<spanclass="math inline">\(I\)</span></li></ul><h4 id="性质-4">性质</h4><ul><li>一般来说，若有<spanclass="math inline">\(ｎ\)</span>个命题变元，则应有<spanclass="math inline">\(2^n\)</span>个不同的解释</li><li>如果公式<span class="math inline">\(G\)</span>在解释<spanclass="math inline">\(I\)</span>下是真的，则称<spanclass="math inline">\(I\)</span>满足<spanclass="math inline">\(G\)</span>；如果<spanclass="math inline">\(G\)</span>在解释<spanclass="math inline">\(I\)</span>下是假的，则称<spanclass="math inline">\(I\)</span>弄假<spanclass="math inline">\(G\)</span></li></ul><h3 id="真值表">真值表</h3><h4 id="定义-12">定义</h4><ul><li>将公式<spanclass="math inline">\(G\)</span>在其所有可能解释下的真值情况列成的表，称为<spanclass="math inline">\(G\)</span>的真值表</li></ul><h2 id="公式的等价性">公式的等价性</h2><h3 id="基本等价式">基本等价式</h3><h4 id="交换律-2">交换律</h4><ul><li><span class="math inline">\(P∧Q\iff Q∧P\)</span></li><li><span class="math inline">\(P∨Q\iff Q∨P\)</span></li><li><span class="math inline">\(P\leftrightarrow Q\iff Q\leftrightarrowP\)</span></li></ul><h4 id="结合律-2">结合律</h4><ul><li><span class="math inline">\((P∧Q)∧R\iff P∧(Q∧R)\)</span></li><li><span class="math inline">\((P∨Q)∨R\iff P∨(Q∨R)\)</span></li><li><span class="math inline">\((P\leftrightarrow Q)\leftrightarrowR\iff P\leftrightarrow (Q\leftrightarrow R)\)</span></li></ul><h4 id="分配律-2">分配律</h4><ul><li><span class="math inline">\(P∧(Q∨R)\iff (P∧Q)∨(P∧R)\)</span></li><li><span class="math inline">\(P∨(Q∧R)\iff(P∨R)∧(P∨R)\)</span></li></ul><h4 id="否定深入">否定深入</h4><ul><li><span class="math inline">\(\neg \neg P \iff P\)</span></li><li><span class="math inline">\(\neg (P∧Q) \iff \neg P∨ \negQ\)</span></li><li><span class="math inline">\(\neg (P\vee Q) \iff \neg P\wedge \negQ\)</span></li><li><span class="math inline">\(\neg (P → Q)\iff P ∧ \negQ\)</span></li><li><span class="math inline">\(\neg(P \leftrightarrow Q) \iff \neg P\leftrightarrow Q \iff P \leftrightarrow \neg Q\)</span></li></ul><h4 id="联结词化归">联结词化归</h4><ul><li><span class="math inline">\(P∧Q\iff \neg（\neg P∨\negQ）\)</span></li><li><span class="math inline">\(P∨Q\iff \neg （\neg P∧\negQ）\)</span></li><li><span class="math inline">\(P→Q\iff \neg P∨Q\)</span></li><li><span class="math inline">\(P \leftrightarrow Q \iff (P→Q)∧(Q→P)\iff (\neg P∨Q) ∧(\neg Q∨P) \iff (P ∧ Q) ∨(\neg P ∧ \negQ)\)</span></li></ul><h3 id="命题与集合的关系">命题与集合的关系</h3><ul><li>将<spanclass="math inline">\(G，H\)</span>理解为某总体论域上的子集合，而规定<spanclass="math inline">\(G∧H\)</span>为两集合的公共部分（交集），<spanclass="math inline">\(G∨H\)</span>为两集合的全部（并集），<spanclass="math inline">\(\neg G\)</span>为总体论域（如矩形域）中<spanclass="math inline">\(G\)</span>的补集，将命题中的真值“1”理解为集合中的总体论域（全集），将命题中的真值“0”理解为集合中的空集</li></ul><h2 id="永真式永假式与蕴含式">永真式、永假式与蕴含式</h2><h3 id="定义-13">定义</h3><ul><li>公式G称为永真式，如果在它的所有解释之下都为“真”</li><li>公式G称为永假式，如果在它的所有解释之下都为“假”</li><li>公式G称为可满足的，如果它不是永假的</li></ul><h3 id="公式等价">公式等价</h3><h4 id="定义-14">定义</h4><ul><li>设G、H是公式，如果在任意解释I下，G与H的真值相同，则称公式G、H是等价的，记作<spanclass="math inline">\(G\iff H\)</span></li></ul><h4 id="定理-5">定理</h4><ul><li><span class="math inline">\(G\iffH\)</span>等价的充分必要条件为<span class="math inline">\(G\impliesH\)</span>且<span class="math inline">\(H\implies G\)</span></li><li>公式G、H等价的充分必要条件是公式<span class="math inline">\(G\iffH\)</span>是永真公式</li></ul><h4 id="性质-5">性质</h4><ul><li>由于“<spanclass="math inline">\(\iff\)</span>”不是一个联结词，而是一种关系，为此，这种关系具有如下三个性质：<ul><li>自反性 G=G</li><li>对称性 若G=H，则H=G</li><li>传递性 若G=H，H=S，则G=S</li></ul></li></ul><h2 id="命题逻辑推理">命题逻辑推理</h2><h3 id="基本蕴含式">基本蕴含式</h3><ul><li><span class="math inline">\((P \to Q) \land (Q \to R) \implies P \toR\)</span> (<strong>假言三段论</strong>)</li></ul><h3 id="定理-6">定理</h3><ul><li>若前提集合为<span class="math inline">\(\{ H_1，H_2，…，H_m\}\)</span>, 结论为<span class="math inline">\(P→ Q\)</span> ，则<spanclass="math inline">\(\{ H_1，H_2，…，H_m \}\implies P\toQ\)</span>等价于<spanclass="math inline">\(\{H_1，H_2，…，H_m，P\}\implies Q\)</span>(<strong>CP规则</strong>)</li></ul><h3 id="推理规则">推理规则</h3><ul><li><span class="math inline">\(P \to Q, Q \to R \vdash P \toR\)</span></li></ul><h3 id="公式蕴涵的证明方法">公式蕴涵的证明方法</h3><ul><li>真值表法</li><li>证<span class="math inline">\(G \to H\)</span>是恒真公式</li><li>利用一些基本等价式及蕴涵式进行推导</li><li>任取真值I，若I满足G，往证I满足H</li><li>反证法，设结论假，往证前提假</li></ul><h3 id="三个基本推理规则">三个基本推理规则</h3><ul><li>P规则(前提引入规则)：前提总是可用</li><li>T规则(推理引入规则)：推理中允许使用推理规则，所得结果在后面的推理中可用</li><li>CP规则(附加前提引入规则) ：证明<span class="math inline">\(P\toQ\)</span>时可将P作为附加前提引入</li></ul><h2 id="范式">范式</h2><h3 id="定义-15">定义</h3><h4 id="合取式">合取式</h4><ul><li>在一公式中，仅由命题变元及其否定构成的合取，称该公式为合取式</li><li>其中每个命题变元或其否定，称为合取项</li></ul><h4 id="析取式">析取式</h4><ul><li>在一公式中，仅由命题变元及其否定构成的析取，称该公式为析取式</li><li>其中每个命题变元或其否定，称为析取项</li></ul><h4 id="析取范式">析取范式</h4><ul><li>一个命题公式A称为析取范式可表示为：多个合取式的析取</li></ul><h4 id="合取范式">合取范式</h4><ul><li>一个命题公式A称为合取范式可表示为：多个析取式的合取</li></ul><h3 id="定理-7">定理</h3><ul><li>合取式为永假式的充要条件是：它同时含有某个命题变元及其否定</li><li>析取式为永真式的充要条件是：它同时含有某个命题变元及其否定</li><li>对于任何一命题公式，都存在与其等价的析取范式和合取范式</li></ul><h3 id="范式的应用">范式的应用</h3><ul><li>公式A为永假式的充要条件是其析取范式中每个简单合取式至少包含一个命题变元及其否定</li><li>公式A为永真式的充要条件是其合取范式中每个简单析取式至少包含一个命题变元及其否定</li></ul><h3 id="公式的主范式">公式的主范式</h3><h4 id="最小项">最小项</h4><ul><li>在含有n个命题变元的合取式中，若每个命题变元与其否定不同时存在，而二者之一出现一次且仅出现一次，则称该合取式为最小项</li><li>n个命题变元共形成<spanclass="math inline">\(2^n\)</span>个最小项</li><li>任意两个不同的最小项的合取式是永假的：<spanclass="math inline">\(m_i∧m_j\iff F,i≠j\)</span></li><li>所有最小项之析取为永真：<spanclass="math inline">\(\bigvee\limits_{i=1}^n m_i \iff T\)</span></li><li>每个最小项只有一个真值组合为真</li></ul><h4 id="最大项">最大项</h4><ul><li>在n个命题变元的析取式中，若每个命题变元与其否定不同时存在，而二者之一必出现一次且仅出现一次，则称该析取式为最大项</li><li>任何两个不同最大项之析取是永真的，即：<spanclass="math inline">\(M_i∨M_j\iff T,i≠j\)</span></li><li>所有最大项之合取为永假，即：<spanclass="math inline">\(\bigwedge\limits_{i=1}^n M_i \iff F\)</span></li><li>每个最大项只有一个真值组合为假，且其真值0位于主对角线上</li></ul><h4 id="主析取范式">主析取范式</h4><ul><li>在给定公式的析取范式中，若其合取式都是最小项，则称该范式为主析取范式</li><li>任意含n个命题变元的非永假命题公式A，都存在与其等价的主析取范式</li><li>任意含n个命题变元的非永假命题公式，其主析取范式是惟一的</li></ul><h4 id="主合取范式">主合取范式</h4><ul><li>在给定公式的合取范式中，若其所有简单析取式都是最大项，称该范式为主合取范式</li><li>任意含有n个命题变元的非永真命题公式A，都存在与其等价的主合取范式</li><li>任意含n个命题变元的非永真命题公式A，其主合取范式是唯一的</li></ul><h4 id="求法">求法</h4><ul><li>公式化归法</li><li>真值表法</li></ul><h4id="主析取范式与主合取范式之间的关系">主析取范式与主合取范式之间的关系</h4><ul><li>由于主范式是由最小项或最大项构成，由其定义，可知两者有下列关系：<spanclass="math inline">\(\neg m_i\iff M_i, \neg M_i\iff m_i\)</span></li><li>因此，主析取范式和主合取范式有着“互补”关系，即由公式的主析取范式可以求出其主合取范式</li></ul><h4 id="主范式的应用">主范式的应用</h4><ul><li>根据主范式的定义和定理，可以判定含n个命题变元的公式，其关键是先求出给定公式的主范式Ａ；其次按下列条件判定之：<ul><li>若<span class="math inline">\(A\iffＴ\)</span>，或A可化为与其等价的、含<spanclass="math inline">\(2^n\)</span>个最小项的主析取范式，则A为永真式</li><li>若<span class="math inline">\(A\iffＦ\)</span>，或A可化为与其等价的、含<spanclass="math inline">\(2^n\)</span>个最大项的主合取范式，则A为永假式</li><li>若A不与Ｔ或者Ｆ等价，且又不含<spanclass="math inline">\(2^n\)</span>个最小项或最大项，则A为可满足的</li></ul></li><li>由于任一公式的主范式是唯一的，所以将给定的公式求出其主范式，若主范式相同，则给定两公式是等价的</li></ul><h2 id="推理规则-1">推理规则</h2><h3 id="implies与to的不同">“<spanclass="math inline">\(\implies\)</span>”与“<spanclass="math inline">\(\to\)</span>”的不同</h3><ul><li>“<span class="math inline">\(→\)</span>”仅是一般的蕴涵联结词，<spanclass="math inline">\(G→H\)</span>的结果仍是一个公式，而“<spanclass="math inline">\(\implies\)</span>”却描述了两个公式G，H之间的一种逻辑蕴涵关系，<spanclass="math inline">\(G\implies H\)</span>的“结果”，是非命题公式</li><li>用计算机来判断<span class="math inline">\(G\impliesH\)</span>是办不到的。然而计算机却可“计算”公式<spanclass="math inline">\(G→H\)</span>是否为永真公式</li></ul><h1 id="谓词逻辑">谓词逻辑</h1><h2 id="谓词逻辑基本概念">谓词逻辑基本概念</h2><h3 id="谓词">谓词</h3><h4 id="定义-16">定义</h4><ul><li>用以刻划客体的性质或客体之间的关系即是谓词</li></ul><h4 id="简单命题函数">简单命题函数</h4><ul><li>由一个谓词和一些客体变元组成的表达式. <spanclass="math inline">\(A(x_1，x_2,…,x_n)\)</span>称n元命题函数或n元原子谓词公式，n元谓词就是有n 个客体变元的命题函数</li></ul><h4 id="复合命题函数">复合命题函数</h4><ul><li>由一个或 n个简单命题函数以及联结词组成的表达式</li></ul><h4 id="结论-1">结论</h4><ul><li>谓词中个体词的顺序是十分重要的，不能随意变更。如命题<spanclass="math inline">\(F(b, c)\)</span>为“真”，但命题<spanclass="math inline">\(F(c, b)\)</span>为“假”</li><li>一元谓词用以描述某一个个体的某种特性，而n元谓词则用以描述n个个体之间的关系</li><li>0元谓词(不含个体词的)实际上就是一般的命题</li><li>具体命题的谓词表示形式和n元命题函数(n元谓词)是不同的，前者是有真值的，而后者不是命题，它的真值是不确定的。如上例中S(a)是有真值的，但S(x)却没有真值</li><li>一个n元谓词不是一个命题，但将n元谓词中的个体变元都用个体域中具体的个体取代后，就成为一个命题。而且，个体变元在不同的个体域中取不同的值对是否成为命题及命题的真值有很大的影响</li></ul><h3 id="客体">客体</h3><ul><li>客体变元在哪些范围内取值（称客体），对是否成为命题及命题的真值都有影响</li><li>在命题函数中，命题变元的论述范围称作<strong>个体域</strong>，个体域可以是有限的，也可以是无限的，把各种个体域综合在一起作为论述范围的域称为<strong>全总客体域</strong></li></ul><h3 id="量词">量词</h3><h4 id="全称量词forall">全称量词<spanclass="math inline">\(\forall\)</span></h4><ul><li><span class="math inline">\(\forall\)</span>称为全称量词，“对所有的”,“每一个”, “对任一个”</li></ul><h4 id="存在量词exists">存在量词<spanclass="math inline">\(\exists\)</span></h4><ul><li><spanclass="math inline">\(\exists\)</span>称为存在量词，“存在一个”，“有一个”，“对于一些”</li></ul><h4 id="特性谓词">特性谓词</h4><ul><li>限定客体变元变化范围的谓词</li></ul><h4 id="注意-1">注意</h4><ul><li>由量词确定的表达式，都与个体域有关</li><li>用全总个体域，对每个的客体变元变化范围，用特性谓词加以限制，一般地：<ul><li>对全称量词，特性谓词常作条件的前提条件</li><li>对存在量词，特性谓词常作合取项</li></ul></li></ul><h3 id="谓词逻辑符号化的两条规则">谓词逻辑符号化的两条规则</h3><ul><li>统一个体域为全总个体域，而对每一个句子中个体变量的变化范围用一元特性谓词刻划之。这种特性谓词在加入到命题函数中时必定遵循如下原则：<ul><li>对于全称量词(<span class="math inline">\(\forallx\)</span>)，刻划其对应个体域的特性谓词作为蕴涵式之<strong>前件</strong>加入</li><li>对于存在量词(<span class="math inline">\(\existsx\)</span>)，刻划其对应个体域的特性谓词作为合取式之<strong>合取项</strong>加入</li></ul></li></ul><h2 id="谓词公式翻译">谓词公式翻译</h2><h3 id="谓词演算的逻辑公式">谓词演算的逻辑公式</h3><ul><li>原子谓词公式是逻辑公式，如Q，A(x)，A(x,y)，...</li><li>若<span class="math inline">\(A\)</span>是逻辑公式,则<spanclass="math inline">\(\neg A\)</span>也是逻辑公式</li><li>若A,B是逻辑公式，则<span class="math inline">\(A∧B\)</span>，<spanclass="math inline">\(A∨B\)</span>，<spanclass="math inline">\(A→B\)</span>，<spanclass="math inline">\(A\leftrightarrow B\)</span> 也是逻辑公式</li><li>若A是逻辑公式，x是A中出现的任何变元，则<spanclass="math inline">\(\forall xA\)</span>和<spanclass="math inline">\(\exists xA\)</span>也是逻辑公式</li></ul><h2 id="约束变元与自由变元">约束变元与自由变元</h2><h3 id="约束部分">约束部分</h3><ul><li>在谓词公式中,形如<span class="math inline">\(\forall x P(x)\)</span>，<span class="math inline">\(\exists xP(x)\)</span>的部分,称为谓词公式的<strong>x约束部分</strong><ul><li><span class="math inline">\(\forall\exists\)</span>后的x叫量词的<strong>指导变元</strong>或<strong>作用变元</strong></li><li>P(x)叫做相应量词的<strong>作用域</strong>或<strong>辖域</strong></li></ul></li></ul><h3 id="约束出现">约束出现</h3><ul><li>在作用域中x的一切出现，称为 x在公式中的<strong>约束出现</strong><ul><li>所有约束出现的变元叫做<strong>约束变元</strong></li><li>不受约束的变元为<strong>自由变元</strong></li></ul></li></ul><h3 id="n-k元谓词和有关命题">n-k元谓词和有关命题</h3><ul><li><spanclass="math inline">\(P(x_1,x_2,...,x_n)\)</span>是n元谓词，有n个独立的自由变元。若对其中k个变元进行约束，则称为<strong>n-k元谓词</strong>。若没有自由变量出现，则该式就成为<strong>有关命题</strong></li></ul><p>###　变元换名规则</p><ul><li>换名范围:量词中的指导变元和作用域中出现的该变元.公式中其余部分不变</li><li>要换成作用域中没有出现的变元名称</li></ul><h3 id="变元代入规则">变元代入规则</h3><ul><li>对该自由变元每一处进行代入</li><li>代入的变元与原公式中所有变元名称不能相同</li></ul><h2 id="谓词演算的等价式和蕴含式">谓词演算的等价式和蕴含式</h2><h3 id="基本概念">基本概念</h3><h4 id="等价">等价</h4><ul><li>任意给定两个谓词公式A和B , E 为它们共同的个体域, 若对A和B的任一组变元进行赋值, 所得命题真值相同,则称 A 和 B 在 E 上是等价的,记为<span class="math inline">\(A\iff B\)</span></li></ul><h4 id="永真的有效的">永真的(有效的)</h4><ul><li>给定任意谓词公式A，其个体域为E对于A的所有赋值A都真，则称A在E上是永真的(有效的)</li></ul><h4 id="可满足的">可满足的</h4><ul><li>一谓词公式A ，若至少在一种赋值下为真，则称A在E 上是可满足的</li></ul><h3 id="命题公式的推广">命题公式的推广</h3><ul><li>当用谓词演算中的公式代替命题演算中永真式的变元时，所得公式为<strong>有效公式</strong><ul><li><span class="math inline">\(∀𝑥(𝑃(𝑥)→𝑄(𝑥))\iff∀𝑥(¬𝑃(𝑥)∨𝑄(𝑥))\)</span></li></ul></li><li>量词与否定联结词<spanclass="math inline">\(\neg\)</span>间的关系：量词前的否定,是否定被量化了的<strong>整个命题</strong><ul><li><span class="math inline">\(¬∀𝑥𝑃(𝑥)\iff ∃𝑥¬𝑃(𝑥)\)</span></li><li><span class="math inline">\(¬∃𝑥𝑃(𝑥)\iff ∀𝑥¬𝑃(𝑥)\)</span></li></ul></li><li>量词作用域的扩张与收缩<ul><li><span class="math inline">\(∀𝑥(𝐴(𝑥)∨𝐵)\iff ∀𝑥𝐴(𝑥)∨𝐵\)</span></li><li><span class="math inline">\(∀𝑥(𝐴(𝑥)∧𝐵)\iff ∀𝑥𝐴(𝑥)∧𝐵\)</span></li><li><span class="math inline">\(∀𝑥(𝐴(𝑥)→𝐵)\iff ∃𝑥𝐴(𝑥)→𝐵\)</span></li><li><span class="math inline">\(∀𝑥(𝐵→𝐴(𝑥))\iff 𝐵→∀𝑥𝐴(𝑥)\)</span></li><li><span class="math inline">\(∃𝑥(𝐴(𝑥)∨𝐵)\iff ∃𝑥𝐴(𝑥)∨𝐵\)</span></li><li><span class="math inline">\(∃𝑥(𝐴(𝑥)∧𝐵)\iff ∃𝑥𝐴(𝑥)∧𝐵\)</span></li><li><span class="math inline">\(∃𝑥𝐴(𝑥)→𝐵\iff ∀𝑥(𝐴(𝑥)→𝐵)\)</span></li><li><span class="math inline">\(∃𝑥(𝐵→𝐴(𝑥))\iff 𝐵→∃𝑥𝐴(𝑥)\)</span></li></ul></li><li>量词分配律<ul><li><span class="math inline">\(∀𝑥(𝐴(𝑥)∧𝐵(𝑥))\iff∀𝑥𝐴(𝑥)∧∀𝑥𝐵(𝑥)\)</span></li><li><span class="math inline">\(∃𝑥(𝐴(𝑥)∨𝐵(𝑥))\iff∃𝑥𝐴(𝑥)∨∃𝑥𝐵(𝑥)\)</span></li><li><span class="math inline">\(∀𝑥𝐴(𝑥)∨∀𝑥𝐵(𝑥)\implies∀𝑥(𝐴(𝑥)∨𝐵(𝑥))\)</span></li><li><span class="math inline">\(∃𝑥(𝐴(𝑥)∧𝐵(𝑥))\implies∃𝑥𝐴(𝑥)∧∃𝑥𝐵(𝑥)\)</span></li></ul></li><li>含多个变元的等价式和蕴含式<ul><li><span class="math inline">\(∀𝑥∀𝑦𝑃(𝑥,𝑦)\iff ∀𝑦∀𝑥𝑃(𝑥,𝑦)\)</span></li><li><span class="math inline">\(∀𝑥∀𝑦𝑃(𝑥,𝑦)\implies∃𝑦∀𝑥𝑃(𝑥,𝑦)\)</span></li><li><span class="math inline">\(∀𝑦∀𝑥𝑃(𝑥,𝑦)\implies∃𝑥∀𝑦𝑃(𝑥,𝑦)\)</span></li><li><span class="math inline">\(∃𝑦∀𝑥𝑃(𝑥,𝑦)\implies∀𝑥∃𝑦𝑃(𝑥,𝑦)\)</span></li><li><span class="math inline">\(∃𝑥∀𝑦𝑃(𝑥,𝑦)\implies∀𝑦∃𝑥𝑃(𝑥,𝑦)\)</span></li><li><span class="math inline">\(∀𝑥∃𝑦𝑃(𝑥,𝑦)\implies∃𝑦∃𝑥𝑃(𝑥,𝑦)\)</span></li><li><span class="math inline">\(∀𝑦∃𝑥𝑃(𝑥,𝑦)\implies∃𝑥∃𝑦𝑃(𝑥,𝑦)\)</span></li><li><span class="math inline">\(∃𝑥∃𝑦𝑃(𝑥,𝑦)\iff ∃𝑦∃𝑥𝑃(𝑥,𝑦)\)</span></li></ul></li></ul><h2 id="谓词逻辑的推理理论">谓词逻辑的推理理论</h2><h3 id="规则">规则</h3><ul><li>设 A(x)是谓词公式<ul><li>全称移去规则 US (全称指定)：<spanclass="math inline">\(∀𝑥𝐴(𝑥)⇒𝐴(𝑐)\)</span>，c 是论域中某个任意客体</li><li>全称附加规则 UG (全称推广)：<spanclass="math inline">\(𝐴(𝑐)⇒∀𝑥𝐴(𝑥)\)</span>，每个 c, A(c)为真</li><li>存在移去规则 ES (存在指定)：<spanclass="math inline">\(∃𝑥𝐴(𝑥)⇒𝐴(𝑐)\)</span>，c是论域中使A(c)为真的客体</li><li>存在附加规则 EG (存在推广)：<spanclass="math inline">\(𝐴(𝑐)⇒∃𝑥𝐴(𝑥)\)</span>，c是论域中使A(c)为真的客体</li></ul></li></ul><h3 id="谓词演算的综合推理方法">谓词演算的综合推理方法</h3><ul><li>推导过程中可以引用命题演算中的P规则 和T规则</li><li>如果结论是以蕴涵形式(或析取形式)给出，我们还可以使用CP规则</li><li>若需消去量词，可以引用US规则和ES规则</li><li>当所要求的结论可能被定量时，此时可引用UG规则和EG规则将其量词加入</li><li>证明时可采用如命题演算中的直接证明方法和间接证明方法</li><li>在推导过程中，对消去量词的公式或公式中不含量词的子公式，完全可以引用命题演算中的基本等价公式和基本蕴涵公式</li><li>在推导过程中，对含有量词的公式可以引用谓词中的基本等价公式和基本蕴涵公式</li></ul><h1 id="图的基本概念">图的基本概念</h1><h2 id="图与子图">图与子图</h2><h3 id="图的定义">图的定义</h3><ul><li>图G是由非空集合<spanclass="math inline">\(V=\{v_1,v_2,…,v_n\}\)</span>，以及边的集合<spanclass="math inline">\(E=\{l_1,l_2,…,l_m\}\)</span>所组合，其中每条边可用一个结点对表示，即：<spanclass="math inline">\(l_i=(v_{i1},v_{i2}),i=1,2,…,m\)</span>，这样的图G可用<spanclass="math inline">\(G=(V，E)\)</span>表示</li></ul><h3 id="图的基本概念-1">图的基本概念</h3><h4 id="有向图">有向图</h4><ul><li>图中的所有边均为有向边，有向边<spanclass="math inline">\(l_k=&lt;v_i,v_j&gt;\)</span>, <spanclass="math inline">\(v_i\)</span>为起点，<spanclass="math inline">\(v_j\)</span>为终点，箭头指向终点</li></ul><h4 id="无向图">无向图</h4><ul><li>图中的所有边均为无向边</li></ul><h4 id="邻接与环">邻接与环</h4><ul><li>多条边关联于同一个结点，则这些边称为邻接的</li><li>构成边的一对结点之间称为邻接的</li><li>若一条边由相同的结点构成，则称为环<spanclass="math inline">\((v_i,v_i)\)</span></li></ul><h4 id="零图与平凡图">零图与平凡图</h4><ul><li>仅含一些孤立点的图称为零图</li><li>特别，仅含一个孤立点的零图称为平凡图</li></ul><h4 id="多重图与线图">多重图与线图</h4><ul><li>有相同端点（起终点）的两条无（有）向边叫做<strong>重边</strong></li><li>含重边的图称为多重图</li><li>非多重图称为线图</li><li>不含自环和重边的图称为简单图（无自环的线图）</li></ul><h4 id="完全图">完全图</h4><ul><li>每对结点间都有一条无向边（一对方向相反的有向边）的简单图，称为无（有）向完全图</li><li>设G是含有n个顶点和m条边的无（有）向完全图<spanclass="math inline">\(m=n(n-1)/2,m=n(n-1)\)</span></li></ul><h4 id="赋权图">赋权图</h4><ul><li>赋权图G是一个三重组<span class="math inline">\((V, E,g)\)</span>，其中V是结点集合，E是边的集合</li></ul><h4 id="子图与补图">子图与补图</h4><ul><li>若<span class="math inline">\(V’\subseteq V, E’\subseteq E\)</span>,则称<span class="math inline">\(G’=(V’,E’)\)</span>是<spanclass="math inline">\(G=(V,E)\)</span>的<strong>子图</strong></li><li><span class="math inline">\(E’\subseteqE\)</span>之子图叫做<strong>真子图</strong></li><li><spanclass="math inline">\(V’=V\)</span>之子图叫做<strong>生成子图</strong></li><li>设<span class="math inline">\(V’\subseteq V\)</span>且$V’≠<spanclass="math inline">\(，以\)</span>V’<spanclass="math inline">\(为结点集，以两个端点均在\)</span>V<spanclass="math inline">\(’中的边的全体为边集的G的子图，称为\)</span>V’<spanclass="math inline">\(导出的G的子图，简称\)</span>V’$的<strong>导出子图</strong></li><li>图<span class="math inline">\(G’=(V’, E’)\)</span>是图<spanclass="math inline">\(G=(V, E)\)</span>的子图。若G有子图<spanclass="math inline">\(G’’=(V’’, E’’)\)</span>,其中<spanclass="math inline">\(E’’=E-E’\)</span>，<spanclass="math inline">\(V’’\)</span>是仅含<spanclass="math inline">\(E’’\)</span>中的边关联的结点和不在<spanclass="math inline">\(G’\)</span>中的<spanclass="math inline">\(G\)</span>的孤立点的集合，则称<spanclass="math inline">\(G’’\)</span>是<spanclass="math inline">\(G’\)</span>关于<spanclass="math inline">\(G\)</span>的**补图*8</li><li>若称图<span class="math inline">\(G\)</span>和<spanclass="math inline">\(G’\)</span>互为补图，则两图<spanclass="math inline">\(G=(V, E)、G’=(V, E’)\)</span>满足：<ul><li><span class="math inline">\(E∩E’=\varnothing\)</span></li><li><span class="math inline">\((V, E∪E’)\)</span>是完全图</li></ul></li></ul><h4 id="节点的次数">节点的次数</h4><ul><li>结点的(全)度数d(v)：与结点v相关联的边数</li><li>在有向图中，度数又分为：<ul><li>引入度数<spanclass="math inline">\(d^-(v)\)</span>：以v为终点的边数</li><li>引出度数<spanclass="math inline">\(d^+(v)\)</span>：以v为起点的边数</li></ul></li><li><span class="math inline">\(d(v) = d^-(v)+ d^+(v)\)</span></li><li>次数为奇（偶）数的结点称为奇（偶）结点</li><li>图中若有奇结点，则必有偶数个奇结点</li><li>图中所有结点次数之和必为偶数，为图中边数的两倍</li></ul><h4 id="握手定理">握手定理</h4><ul><li>(n, m)图中，结点的总次数为：<spanclass="math inline">\(\sum\limits_{i=1}^nd(v_i)=2m\)</span></li></ul><h3 id="图的同构">图的同构</h3><h4 id="定义-17">定义</h4><ul><li>图<span class="math inline">\(G=(V, E)\)</span>与<spanclass="math inline">\(G’=(V’, E’)\)</span>，如果存在双射函数<spanclass="math inline">\(ƒ:V→V’\)</span>, 使得边也一一对应，则称<spanclass="math inline">\(G\)</span>与<spanclass="math inline">\(G’\)</span>同构</li></ul><h4 id="同构的必要条件">同构的必要条件</h4><ul><li>结点数目相同</li><li>边数相同</li><li>度数相同的结点数相同</li></ul><h2 id="通路回路与连通性">通路、回路与连通性</h2><h3 id="通路">通路</h3><h4 id="定义-18">定义</h4><ul><li>(有向)图中k条(首尾)相连的边<spanclass="math inline">\((v_{i0},v_{i1}),(v_{i1},v_{i2}),…,(v_{ik-1},v_{ik})\)</span>,记成<spanclass="math inline">\((v_{i0},v_{i1},v_{i2}, …,v_{ik})\)</span>，其中：<spanclass="math inline">\(v_{i0}\)</span>：起点，<spanclass="math inline">\(v_{ik}\)</span>：终点，<spanclass="math inline">\(k\)</span>：通路长度</li></ul><h4 id="简单通路">简单通路</h4><ul><li>边不同之通路</li></ul><h4 id="基本通路">基本通路</h4><ul><li>结点不同之通路</li></ul><h4 id="可达">可达</h4><ul><li>从结点u到结点v有通路，称u到v可达</li></ul><h4 id="短程线">短程线</h4><ul><li>两点间最短的通路</li></ul><h4 id="距离duv">距离d(u,v)</h4><ul><li>从u到v的短程线的长度(不可达则为无限)</li></ul><h3 id="回路">回路</h3><h4 id="定义-19">定义</h4><ul><li><spanclass="math inline">\(v_{i0}=v_{ik}\)</span>之通路，即“起点=终点”之通路</li></ul><h4 id="简单回路">简单回路</h4><ul><li>边不同之回路</li></ul><h4 id="基本回路">基本回路</h4><ul><li>结点不同之回路</li></ul><h3 id="结论-2">结论</h3><ul><li>任一通路删去所有回路必得基本通路</li><li>任一回路删去其中间回路必得基本回路</li></ul><h3 id="定理-8">定理</h3><ul><li>一个(n,m)有向图中任何基本通路长度都小于n，而任何基本回路长度都不大于n</li></ul><h3 id="连通性">连通性</h3><h4 id="无向连通图">无向连通图</h4><ul><li>任两点间均是可达的无向图</li></ul><h4 id="有向连通图">有向连通图</h4><ul><li>去掉边的方向后是无向连通图之有向图</li></ul><h4 id="强连通图">强连通图</h4><ul><li>任两点间均互相可达之有向图</li></ul><h4 id="单向连通图">单向连通图</h4><ul><li>任两点间至少有一向可达之有向图</li></ul><h4 id="弱连通图">弱连通图</h4><ul><li>有向连通图</li></ul><h2 id="图的矩阵表示法">图的矩阵表示法</h2><h3 id="有向图的邻接矩阵">有向图的邻接矩阵</h3><h4 id="定义-20">定义</h4><ul><li>对图 <span class="math inline">\(G=(\{v_1,v_2, …, v_n\},E)\)</span>,其邻接矩阵<span class="math inline">\(A\)</span>如下构成： <spanclass="math inline">\(A=(a_{ij})_{n\times n},a_{ij}=\begin{cases}1 &amp;v_i与v_j邻接\\0 &amp; v_i不与v_j邻接\end{cases}\)</span></li></ul><h4 id="矩阵中的信息">矩阵中的信息</h4><ul><li>结点<span class="math inline">\(v_i\)</span>的次数<ul><li>引出次数：<span class="math inline">\(d^+(v_i)=\sum\limits_{k=1}^na_{ik}\)</span></li><li>引出次数：<span class="math inline">\(d^-(v_i)=\sum\limits_{k=1}^na_{ki}\)</span></li></ul></li><li><span class="math inline">\(A^l\)</span><ul><li>令 <span class="math inline">\(C=A^l, c_{ij}\)</span> 是<spanclass="math inline">\(v_i\)</span>到<spanclass="math inline">\(v_j\)</span>的长度为<spanclass="math inline">\(l\)</span>的通路数目</li></ul></li></ul><h3 id="可达性矩阵">可达性矩阵</h3><ul><li><span class="math inline">\(R_n=A+A^2+…+A^n\)</span> ——反映任两点间的通路数目</li><li>可达性矩阵P —— 将<spanclass="math inline">\(R_n\)</span>中的非零值改为1——反映任两点间是否可达</li><li>P也可如下计算：$P=A (+) A^{(2)} (+) … (+) A^{(n)} $</li></ul><h3 id="无向图的矩阵表示">无向图的矩阵表示</h3><h4 id="无向图的邻接矩阵">无向图的邻接矩阵</h4><ul><li>无向图的邻接矩阵与有向图的类似，并且是对称的</li><li>结点的次数只要计算行(或列)之和即可，但对角线上的1要计算2次</li><li>矩阵<span class="math inline">\(R_n\)</span>及P的计算方法也相同</li></ul><h3 id="多重图的邻接矩阵">多重图的邻接矩阵</h3><ul><li>1改为重边的数目</li></ul><h3 id="有权图的邻接矩阵">有权图的邻接矩阵</h3><ul><li>1改为权值</li></ul><h3 id="矩阵与图的连通性">矩阵与图的连通性</h3><ul><li>无向图G是连通的<spanclass="math inline">\(\iff\)</span>G的可达性矩阵P除对角元外均为1</li><li>有向图G是强连通的<spanclass="math inline">\(\iff\)</span>G的可达性矩阵P除对角元外均为1</li><li>有向图G是单向连通的<span class="math inline">\(\iff P(+)P^T\)</span>(P的转置)除对角元外均为1</li><li>有向图G是弱连通的<span class="math inline">\(\iffA(+)A^T\)</span>图的可达性矩阵P除对角元外均为1 （A是G的邻接矩阵）</li></ul><h1 id="特殊图">特殊图</h1><h2 id="欧拉图及其应用">欧拉图及其应用</h2><h3 id="欧拉回路">欧拉回路</h3><ul><li>通过图中每条边一次之回路</li><li>欧拉回路是经过图中所有边的回路中长度最短的回路，即为通过图中所有边的简单回路</li></ul><h3 id="欧拉图">欧拉图</h3><ul><li>有欧拉回路之图</li></ul><h3 id="欧拉通路">欧拉通路</h3><ul><li>通过图中每条边一次之通路(非回路)</li><li>欧拉通路是经过图中所有边的通路中长度最短的通路，即为通过图中所有边的简单通路</li></ul><h3 id="定理-9">定理</h3><ul><li>无向连通图G是欧拉图<spanclass="math inline">\(\iff\)</span>G的所有结点的次数都是偶数</li><li>无向连通图中结点u、v之间有欧拉通路<spanclass="math inline">\(\iff\)</span>图中u、v的次数是奇数，其余结点的次数均为偶数</li><li>无向连通图G是欧拉图的充分必要条件是G的每个结点均具有偶次数</li></ul><h3 id="应用">应用</h3><ul><li>一笔画问题</li><li>蚂蚁比赛问题</li><li>邮递员问题</li><li>洒水车</li></ul><h2 id="哈密顿图及其应用">哈密顿图及其应用</h2><h3 id="哈密顿回路">哈密顿回路</h3><ul><li>通过图中每个结点一次之回路</li><li>是经过图中所有结点的回路中长度最短的回路，即为通过图中所有结点的基本回路</li></ul><h3 id="哈密顿图">哈密顿图</h3><ul><li>有哈密顿回路之图</li></ul><h3 id="哈密顿通路">哈密顿通路</h3><ul><li>通过图中每个结点一次之通路(非回路)</li><li>是经过图中所有结点的通路中长度最短的通路，即为通过图中所有结点的基本通路</li></ul><h3 id="定理-10">定理</h3><ul><li>设无向图<spanclass="math inline">\(G=(V,E)\)</span>是哈密顿图，<spanclass="math inline">\(\varnothing \subseteq V_1 \subseteq V\)</span>，则<span class="math inline">\(\omega(G-V_1)\leq|V_1|\)</span>（<strong>必要</strong>）</li><li>设无向图<span class="math inline">\(G = (V,E)\)</span>中存在哈密顿通路，则对<spanclass="math inline">\(V\)</span>的任意非空子集<spanclass="math inline">\(V_1\)</span>，都有<spanclass="math inline">\(ω(G-V_1) ≤ |V_1| + 1\)</span></li><li>设<span class="math inline">\(G = (V,E)\)</span>是具有n个结点的简单无向图。如果对任意两个不相邻的结点<spanclass="math inline">\(u, v∈V\)</span>，均有<spanclass="math inline">\(d(u)+d(v)≥n-1\)</span>则G中存在哈密顿通路</li><li>设<span class="math inline">\(G = (V,E)\)</span>是具有n个结点的简单无向图：<ul><li>如果对任意两个不相邻的结点<span class="math inline">\(u,v∈V\)</span>，均有<spanclass="math inline">\(d(u)+d(v)≥n\)</span>则G中存在哈密顿回路</li><li><span class="math inline">\(n≥3\)</span>，如果对任意<spanclass="math inline">\(v∈V\)</span>，均有<spanclass="math inline">\(d(v)≥ n/2\)</span>，则G是哈密顿图</li></ul></li><li>设<span class="math inline">\(G=(V, E)\)</span>是有<spanclass="math inline">\(n(n≥2)\)</span>个结点的一些简单有向图。如果忽略G中边的方向所得的无向图中含生成子图<spanclass="math inline">\(K_n\)</span>，则有向图G中存在哈密顿通路</li><li>设<span class="math inline">\(G=(V,E)\)</span>是有向图，<spanclass="math inline">\(|V|\geq2\)</span>，如果任意两个不同结点次数之和<span class="math inline">\(\geq|V|-1\)</span>，则G存在哈密顿通路(判断有向图是否是哈密顿图不要求)</li></ul><h3 id="哈密顿图的应用">哈密顿图的应用</h3><ul><li>考试安排问题</li><li>推销员问题</li></ul><h2 id="树">树</h2><h3 id="树-1">树</h3><ul><li>不含回路的简单连通无向图</li></ul><h3 id="叶">叶</h3><ul><li>树中次数为1的结点</li></ul><h3 id="森林">森林</h3><ul><li>每个连通分支是树的无向图</li></ul><h3 id="树枝">树枝</h3><ul><li>无向树（林）中的边</li></ul><h3 id="树的性质">树的性质</h3><ul><li>设无向图<span class="math inline">\(G = (V,E)，|V| = n，|E| =m\)</span>，下列各命题是等价的<ul><li>G连通而不含回路(即G是树)</li><li>G中无回路，且<span class="math inline">\(m = n-1\)</span></li><li>G是连通的，且<span class="math inline">\(m = n-1\)</span></li><li>G中无回路，但在G中任二结点之间增加一条新边，就得到惟一的一条基本回路</li><li>G是连通的，但删除G中任一条边后，便不连通(<spanclass="math inline">\(n≥2\)</span>)</li><li>G中每一对结点之间有惟一一条基本通路(<spanclass="math inline">\(n≥2\)</span>)</li></ul></li></ul><h3 id="定理-11">定理</h3><ul><li>任意非平凡树<span class="math inline">\(T = (n, m)\)</span>都至少有两片叶</li></ul><h3 id="生成树">生成树</h3><h4 id="定义-21">定义</h4><ul><li>给定图<span class="math inline">\(G = (V,E)\)</span>，若G的某个生成子图是树，则称之为G的生成树(SpanningTree)，记为TG。生成树TG中的边称为树枝(Branch)</li></ul><h4 id="定理-12">定理</h4><ul><li>一个图<span class="math inline">\(G = (V, E)\)</span>存在生成树<spanclass="math inline">\(T _G = (V,E_T)\)</span>的充分必要条件是G是连通的</li></ul><h4 id="破圈法与避圈法">破圈法与避圈法</h4><ul><li><strong>破圈法算法</strong> 求连通图<span class="math inline">\(G =(V,E)\)</span>的生成树的破圈法：每次删除回路中的一条边，其删除的边的总数为<spanclass="math inline">\(m-n+1\)</span></li><li><strong>避圈法算法</strong> 求连通图<span class="math inline">\(G =(V,E)\)</span>的生成树的避圈法：每次选取G中一条与已选取的边不构成回路的边，选取的边的总数为<spanclass="math inline">\(n-1\)</span></li></ul><h4 id="最小生成树">最小生成树</h4><ul><li>设<span class="math inline">\(G = (V,E)\)</span>是连通的赋权图，T是G的一棵生成树，T的每个树枝所赋权值之和称为T的权(Weight)，记为<spanclass="math inline">\(W(T)\)</span>。G中具有最小权的生成树称为G的最小生成树(MinimalSpanning Tree)</li></ul><h4 id="kruskal算法">Kruskal算法</h4><ul><li>(1)在G中选取最小权边<spanclass="math inline">\(e_1\)</span>，置<span class="math inline">\(i =1\)</span></li><li>(2)当<span class="math inline">\(i =n-1\)</span>时，结束，否则转(3)</li><li>(3)设已选取的边为<span class="math inline">\(e_1, e_2, …,e_i\)</span>，在G中选取不同于<span class="math inline">\(e_1, e_2, …,e_i\)</span>的边<span class="math inline">\(e_{i+1}\)</span>，使<spanclass="math inline">\(\{e_1, e_2, …, e_i,e_{i+1}\}\)</span>中无回路且<spanclass="math inline">\(e_{i+1}\)</span>是满足此条件的最小权边</li><li>(4)置<span class="math inline">\(i = i+1\)</span>，转(2)</li></ul><h4 id="prim算法">Prim算法</h4><ul><li>(1)在G中任选取一个结点<spanclass="math inline">\(v_1\)</span>，置<span class="math inline">\(V_T ={v_1}, E_T = \varnothing，k = 1\)</span></li><li>(2)在<span class="math inline">\(V-V_T\)</span>中选取与某个<spanclass="math inline">\(v_i∈V_T\)</span>邻接的结点<spanclass="math inline">\(v_j\)</span>，使得边<spanclass="math inline">\((v_i, v_j)\)</span>的权最小，置<spanclass="math inline">\(V_T = V_T∪{v_j}, E_T = E_T∪{(v_i, v_j)}，k =k+1\)</span></li><li>(3)重复(2)，直到<span class="math inline">\(k = |V|\)</span></li></ul><h3 id="有向树">有向树</h3><h4 id="定义-22">定义</h4><ul><li>一个有向图，若略去所有有向边的方向所得到的无向图是一棵树，则这个有向图称为有向树(DirectedTree)</li></ul><h4 id="外向树">外向树</h4><ul><li>T仅有一个结点的引入次数为0，该结点为T的<strong>根</strong></li><li>T的其他结点的入度均为1</li><li>T有一些结点的出度为0，该结点为T的<strong>叶</strong></li><li>由外向树的根到结点<spanclass="math inline">\(v_i\)</span>的通路长度称为结点<spanclass="math inline">\(v_i\)</span>的<strong>级</strong></li><li>若从结点<span class="math inline">\(v_i\)</span>到<spanclass="math inline">\(v_j\)</span>可达，则称<spanclass="math inline">\(v_i\)</span>是<spanclass="math inline">\(v_j\)</span>的<strong>祖先</strong>(Ancestor)，<spanclass="math inline">\(v_j\)</span>是<spanclass="math inline">\(v_i\)</span>的<strong>后代</strong>(Descendant)</li><li>若<span class="math inline">\(&lt;v_i,v_j&gt;\)</span>是根树中的有向边，则称<spanclass="math inline">\(v_i\)</span>是<spanclass="math inline">\(v_j\)</span>的<strong>父亲</strong>(Father)，<spanclass="math inline">\(v_j\)</span>是<spanclass="math inline">\(v_i\)</span>的<strong>儿子</strong>(Son)</li><li>如果两个结点是同一个结点的儿子，则称这两个结点是<strong>兄弟</strong>(Brother)</li><li>若每个分支点至多有k个儿子，则称T为<strong>k元树</strong>(k-aryTree)</li><li>若每个分支点都恰有k个儿子，则称T为<strong>k元完全树</strong>(k-aryComplete Tree)</li><li>若k元树T是有序的，则称T为<strong>k元有序树</strong>(k-ary OrderedTree)</li><li>若k元完全树T是有序的，则称T为<strong>k元有序完全树</strong>(k-aryOrdered Complete Tree)</li></ul><h4 id="内向树">内向树</h4><ul><li>T仅有一个结点的引出次数为0，该结点为T的<strong>根</strong></li><li>T的其他结点的引出次数均为1</li><li>T有一些结点的引入次数为0，该结点为T的<strong>叶</strong></li></ul><h4 id="有序树">有序树</h4><ul><li>如果在外向树中规定了每一层上结点的次序，这样的根树称为有序树</li><li>一般地，在有序树中同一层中结点的次序为从左至右。有时也可以用边的次序来代替结点的次序</li></ul><h4 id="二元树的遍历">二元树的遍历</h4><ul><li>二元树的<strong>先根次序遍历算法</strong>：<ul><li>访问根</li><li>按先根次序遍历根的左子树</li><li>按先根次序遍历根的右子树</li></ul></li><li>二元树的<strong>中根次序遍历算法</strong>:<ul><li>按中根次序遍历根的左子树</li><li>访问根</li><li>按中根次序遍历根的右子树</li></ul></li><li>二元树的<strong>后根次序遍历算法</strong>：<ul><li>按后根次序遍历根的左子树</li><li>按后根次序遍历根的右子树</li><li>访问根</li></ul></li></ul><h4 id="根树转化为二元树算法">根树转化为二元树算法</h4><ul><li>从根开始，保留每个父亲同其最左边儿子的连线，撤销与别的儿子的连线</li><li>兄弟间用从左向右的有向边连接</li><li>按如下方法确定二元树中结点的左儿子和右儿子：直接位于给定结点下面的结点，作为左儿子，对于同一水平线上与给定结点右邻的结点，作为右儿子，依此类推</li><li><strong>转化的要点</strong>：弟弟结点变右儿子结点</li></ul><h2 id="二分图">二分图</h2><h3 id="定义-23">定义</h3><ul><li>若无向图<span class="math inline">\(G = (V,E)\)</span>的结点集V能够划分为两个子集<span class="math inline">\(V_1,V_2\)</span>，满足<span class="math inline">\(V_1∩V_2 =\varnothing\)</span>，且<span class="math inline">\(V_1∪V_2 =V\)</span>，使得G中任意一条边的两个结点，一个属于<spanclass="math inline">\(V_1\)</span>，另一个属于<spanclass="math inline">\(V_2\)</span>，则称G为二分图(Bigraph)。<spanclass="math inline">\(V_1\)</span>和<spanclass="math inline">\(V_2\)</span>称为<strong>互补结点子集</strong>，二分图可记为<spanclass="math inline">\(G = (V_1, V_2)\)</span></li><li>二分图没有自回路</li><li>平凡图和零图可看成特殊的二分图</li></ul><h3 id="完全二分图">完全二分图</h3><ul><li>在二分图<span class="math inline">\(G = (V_1,V_2)\)</span>中，若<spanclass="math inline">\(V_1\)</span>中的每个结点与<spanclass="math inline">\(V_2\)</span>中的每个结点都有且仅有一条边相关联，则称二分图G为完全二分图(CompleteBigraph)，记为<span class="math inline">\(K_{m,n}\)</span>，其中，<spanclass="math inline">\(m = |V_1|，n = |V_2|\)</span></li></ul><h3 id="二分图的判定">二分图的判定</h3><ul><li>无向图<span class="math inline">\(G = (V,E)\)</span>为二分图的<strong>充分必要条件</strong>是G的所有回路的长度均为偶数</li><li><strong>无向图G不是二分图的充分必要条件是G中存在长度为奇数的回路</strong></li></ul><h3 id="匹配">匹配</h3><ul><li>在二分图<span class="math inline">\(G = (V_1, V_2)\)</span>中，<spanclass="math inline">\(V_1 = \{v_1, v_2, …,v_q\}\)</span>，若存在E的子集<span class="math inline">\(E’= \{(v_1,v_1’)，(v_2, v_2’)，…，(v_q, v_q’)，其中v_1’, v_2’, …, v_q’是V_2中的q个不同的结点\}\)</span>，则称G的子图<spanclass="math inline">\(G’ = (V_1, E’, V_2)\)</span>为从<spanclass="math inline">\(V_1\)</span>到<spanclass="math inline">\(V_2\)</span>的一个<strong>完全匹配</strong>(CompleteMatching)，简称匹配</li></ul><h2 id="平面图">平面图</h2><h3 id="定义-24">定义</h3><ul><li>如果能把一个无向图G的所有结点和边画在平面上，使得任何两边除公共结点外没有其他交叉点，则称G为平面图(PlaneGraph)，否则称G为非平面图(NonplanarGraph)。<strong>当且仅当一个图的每个连通分支都是平面图时，这个图是平面图</strong></li></ul><h3 id="判断图是否是可平面图的方法">判断图是否是可平面图的方法</h3><h4 id="观察法">观察法</h4><h4 id="欧拉公式">欧拉公式</h4><ul><li>在平面图G的一个平面表示中，<ul><li>由边所包围的其内部不包含图的结点和边的区域，称为G的<strong>一个面</strong>(Surface)</li><li>包围该面的诸边所构成的回路称为这个面的<strong>边界</strong>(Bound)</li><li>面r的边界的长度称为该面的<strong>次数</strong>(Degree)，记为<spanclass="math inline">\(D(r)\)</span></li><li>区域面积有限的面称为<strong>有限面</strong>(FiniteSurface)，区域面积无限的面称为<strong>无限面</strong>(InfiniteSurface)</li><li>平面图有且仅有一个无限面</li></ul></li><li>平面图中所有面的次数之和等于边数的二倍</li><li>设<span class="math inline">\(G = (V,E)\)</span>是连通平面图，若它有<spanclass="math inline">\(n\)</span>个结点、<spanclass="math inline">\(m\)</span>条边和<spanclass="math inline">\(r\)</span>个面，则有<spanclass="math inline">\(n-m+r = 2\)</span></li><li>设设G是一个<spanclass="math inline">\((n,m)\)</span>简单连通平面图，若<spanclass="math inline">\(m＞1\)</span>，则有<spanclass="math inline">\(m≤3n-6\)</span></li><li>一个简单连通图，若不满足<spanclass="math inline">\(m≤3n-6\)</span>，则一定是非平面图</li></ul><h4 id="库拉托夫斯基定理">库拉托夫斯基定理</h4><ul><li>一个图是平面图的<strong>充分必要条件</strong>是它的任何子图都不可能收缩为<spanclass="math inline">\(K_5\)</span>或<spanclass="math inline">\(K_{3,3}\)</span></li><li>一个图是非平面图的充分必要条件是它存在一个能收缩为<spanclass="math inline">\(K_5\)</span>或<spanclass="math inline">\(K_{3,3}\)</span>的子图</li><li>我们将<span class="math inline">\(K_5\)</span>和<spanclass="math inline">\(K_{3,3}\)</span>称为<strong>库拉托夫斯基图</strong>(KuratowskiGraph)</li></ul><h3 id="平面图的应用">平面图的应用</h3><ul><li>公共事业问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>Math</tag>
      
      <tag>Discrete Mathematics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的数据类型</title>
    <link href="/posts/14492/"/>
    <url>/posts/14492/</url>
    
    <content type="html"><![CDATA[<p>Redis 支持五种数据类型：</p><ul><li>string</li><li>hash</li><li>list</li><li>set</li><li>zset</li></ul><h2 id="string">String</h2><p>string 是最基本的类型。string 二进制安全，即可以包含任何数据。</p><p>string 一个键最大能存储512MB。</p><p>string类型的数据结构存储方式有三种<code>int</code>、<code>raw</code>、<code>embstr</code>：</p><h3 id="int">int</h3><p>Redis中规定假如存储的是<strong>整数型值</strong>，比如<code>set num 123</code>这样的类型，就会使用<code>int</code>的存储方式进行存储，在<code>redisObject</code>的<code>ptr属性</code>中就会保存该值。<img src="/posts/14492/int-1682306725947-10.png" class="" title="int"></p><h3 id="sds">SDS</h3><p>假如存储的<strong>字符串是一个字符串值并且长度大于32个字节</strong>就会使用SDS（simple dynamicstring）方式进行存储，并且<code>encoding</code>设置为<code>raw</code>；若是<strong>字符串长度小于等于32个字节</strong>就会将<code>encoding</code>改为<code>embstr</code>来保存字符串。</p><p>SDS称为<strong>简单动态字符串</strong>，对于SDS中的定义在Redis的源码中有的三个属性<code>int len</code>、<code>int free</code>、<code>char buf[]</code>。</p><p><code>len</code>保存了字符串的长度，<code>free</code>表示<code>buf数组</code>中未使用的字节数量，<code>buf数组</code>则是保存字符串的每一个字符元素。</p><p>因此当你在Redis中存储一个字符串<code>"Hello_World"</code>时，SDS的形式的<code>redisObject</code>结构图如下图所示： <img src="/posts/14492/SDS.png" class="" title="SDS"></p><h2 id="hash">Hash</h2><p>Redis hash 是一个<strong>键值(key=&gt;value)对集合</strong>。</p><p>Redis hash 是一个 string 类型的 field 和 value的<strong>映射表</strong>，hash 特别适合用于存储对象。</p><p>每个 hash 可以存储 <span class="math inline">\(2^{32} -1\)</span>键值对。</p><p>Hash对象的实现方式有两种分别是<code>ziplist</code>、<code>hashtable</code>，其中<code>hashtable</code>的存储方式<code>key</code>是String类型的，<code>value</code>也是以<code>key value</code>的形式进行存储。</p><h3 id="ziplist">ziplist</h3><p>压缩列表（ziplist）是<strong>一组连续内存块组成的顺序的数据结构</strong>，压缩列表能够节省空间，压缩列表中使用多个节点来存储数据。</p><p>压缩列表是列表键和哈希键底层实现的原理之一，<strong>压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间</strong>，压缩列表的内存结构图如下：<img src="/posts/14492/ziplist.png" class="" title="ziplist"></p><p>其中：</p><ol type="1"><li><code>zlbytes</code>：4个字节的大小，记录压缩列表占用内存的字节数。</li><li><code>zltail</code>：4个字节大小，记录表尾节点距离起始地址的偏移量，用于快速定位到尾节点的地址。</li><li><code>zllen</code>：2个字节的大小，记录压缩列表中的节点数。</li><li><code>entry</code>：表示列表中的每一个节点。</li><li><code>zlend</code>：表示压缩列表的特殊结束符号<code>'0xFF'</code></li></ol><p>每一个<code>entry</code>节点又有三部分组成，分别是<code>previous_entry_length</code>、<code>encoding</code>、<code>content</code>。</p><ol type="1"><li><code>previous_entry_length</code>表示前一个节点<code>entry</code>的长度，可用于计算前一个节点的其实地址，因为他们的地址是连续的。</li><li><code>encoding</code>：这里保存的是<code>content</code>的内容类型和长度。</li><li><code>content</code>：<code>content</code>保存的是每一个节点的内容。<img src="/posts/14492/entry.png" class="" title="entry"></li></ol><h3 id="hashtable">hashtable</h3><p>hashtable是<strong>一种字典类型的数据结构</strong>，用于存储键值对，其中键是字符串类型，值可以是字符串、列表、集合或有序集合。hashtable的<strong>底层实现是一个数组，每个数组元素是一个链表，用于解决哈希冲突</strong>。当hashtable中的键值对数量变化时，会进行扩展或收缩操作，重新分配数组的大小和哈希值。hashtable是哈希键和集合键的底层实现之一，当这些键的元素数量和长度较大时，Redis会使用 hashtable 作为其存储方式。</p><h2 id="list">List</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部或者尾部。</p><p>列表最多可存储 <span class="math inline">\(2^{32} - 1\)</span>元素。</p><p>Redis中的列表在3.2之前的版本是使用<code>ziplist</code>和<code>linkedlist</code>进行实现的。在3.2之后的版本就是引入了<code>quicklist</code>。</p><h3 id="linkedlist">linkedlist</h3><p>linkedlist是一个双向链表，他和普通的链表一样都是由指向前后节点的指针。插入、修改、更新的时间复杂度是O(1)，查询的时间复杂度是 O(n)。其特性为</p><ol type="1"><li>每一个节点都有指向前一个节点和后一个节点的指针。</li><li>头节点和尾节点的<code>prev</code>和<code>next</code>指针指向为<code>null</code>，所以链表是无环的。</li><li>链表有自己长度的信息，获取长度的时间复杂度为 O(1)。</li></ol><img src="/posts/14492/linkedlist.png" class="" title="linkedlist"><h3 id="quicklist">quicklist</h3><p>quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList按段切分，每一段使用 zipList 来紧凑存储，多个 zipList之间使用双向指针串接起来。</p><ol type="1"><li><code>prev</code>、<code>next</code>指向该节点的前后节点。</li><li><code>zl</code>指向该节点对应的 ziplist 结构。</li><li><code>sz</code>代表整个 ziplist 结构的大小。</li><li><code>encoding</code>代表采用的编码方式：<code>1</code>代表是原生的，<code>2</code>代表使用<code>LZF</code>进行压缩。</li><li><code>container</code>为 quickListNode节点<code>zl</code>指向的容器类型：<code>1</code>代表<code>none</code>，<code>2</code>代表使用<code>ziplist</code>存储数据。</li><li><code>recompress</code>代表这个节点之前是否是压缩节点，若是，则在使用压缩节点前先进行解压缩，使用后需要重新压缩，此外为<code>1</code>，代表是压缩节点。</li><li><code>attempted_compress</code>测试时使用。</li><li><code>extra</code>为预留。</li></ol><img src="/posts/14492/quicklist.png" class="" title="quicklist"><h2 id="set">Set</h2><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>集合中最大的成员数为 <span class="math inline">\(2^{32} -1\)</span>。</p><p>Redis 中列表和集合都可以用来存储字符串，但是 <strong>Set是不可重复的集合，而 List 列表可以存储相同的字符串</strong>。</p><p>Set 的底层实现是<code>hashtable</code>和<code>intset</code>。</p><h3 id="intset">intset</h3><p>inset也叫做<strong>整数集合</strong>，用于保存整数值的数据结构类型，它可以保存<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code> 的整数值。</p><p>在整数集合中，有三个属性值<code>encoding、length、contents[]</code>，分别表示编码方式、整数集合的长度、以及元素内容，<code>length</code>就是记录<code>contents</code>里面的大小。</p><p>在整数集合新增元素的时候，若是超出了原集合的长度大小，就会对集合进行升级，具体的升级过程如下：</p><ol type="1"><li>首先扩展底层数组的大小，并且数组的类型为新元素的类型。</li><li>然后将原来的数组中的元素转为新元素的类型，并放到扩展后数组对应的位置。</li><li>整数集合升级后就不会再降级，编码会一直保持升级后的状态。</li></ol><img src="/posts/14492/intset.png" class="" title="intset"><h2 id="zset">Zset</h2><p>Redis zset 和 set 一样也是 string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个 double 类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset 的成员是唯一的,但分数（score）却可以重复。</p><p>zset 的底层实现是<code>ziplist</code>和<code>skiplist</code>。</p><h3 id="skipset">skipset</h3><p>skiplist也叫做<strong>跳跃表</strong>，跳跃表是一种有序的数据结构，它通过每一个节点维持多个指向其它节点的指针，从而达到快速访问的目的。</p><p>skiplist 由如下几个特点：</p><ol type="1"><li>有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大。</li><li>每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点。</li><li>每一层的每一个每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针。</li><li>如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点。</li></ol><img src="/posts/14492/skiplist.png" class="" title="skiplist">]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VIM的学习</title>
    <link href="/posts/60968/"/>
    <url>/posts/60968/</url>
    
    <content type="html"><![CDATA[<figure><img src="vim键位.gif" alt="vim键位" /><figcaption aria-hidden="true">vim键位</figcaption></figure><h2 id="vim的哲学">Vim的哲学</h2><p>在编程时，您大部分时间都花在阅读/编辑上，而不是写作上。因此，Vim是一个模态编辑器：它有不同的插入文本和操作文本的模式。Vim是可编程的（使用 Vimscript 以及 Python 等其他语言），并且 Vim的界面本身就是一种编程语言：击键（具有助记名称）是命令，并且这些命令是可组合的。Vim避免使用鼠标，因为它太慢了；Vim甚至避免使用箭头键，因为它需要太多的移动。</p><p>最终结果是一个可以匹配您思考速度的编辑器。</p><h2 id="模态编辑">模态编辑</h2><p>Vim有多种运行模式</p><figure><img src="vim工作模式.png" alt="vim运行模式" /><figcaption aria-hidden="true">vim运行模式</figcaption></figure><ul><li><code>Normal</code> 用于在文件中移动并进行编辑</li><li><code>Insert</code> 用于插入文本，按 <code>i</code> 键</li><li><code>Replace</code> 用于替换文本，按 <code>R</code> 键</li><li><code>Visual</code> 用于选择文本块，可视模式为 <code>v</code>键，可视行模式为<code>V</code> 键，可视块模式为<code>&lt;C-v&gt;</code>键</li><li><code>Command-line</code> 用于运行命令，按 <code>:</code> 键</li></ul><p>击键在不同的操作模式下具有不同的含义。例如，字母 <code>x</code>在插入模式下只会插入一个文字字符 'x'，但在普通模式下，它会删除光标下的字符，而在可视模式下，它会删除选择的字符。</p><h2 id="缓冲区选项卡和窗口">缓冲区，选项卡和窗口</h2><p>Vim 维护一组打开的文件，称为"缓冲区"。一个 Vim会话有许多选项卡，每个选项卡都有许多窗口( 拆分窗格)。每个窗口显示一个缓冲区。与您熟悉的其他程序( 如网络浏览器)不同，缓冲区和窗口之间不存在一对一的对应关系，窗户只是视图。一个给定的缓冲区可以在多个窗口中打开，甚至在同一个选项卡中。这非常方便，例如，同时查看文件的两个不同部分。</p><p>默认情况下，Vim 打开一个选项卡，其中包含一个窗口。</p><h2 id="底线命令模式">底线命令模式</h2><p>命令模式可以通过在普通模式下输入<code>:</code>来进入。按下<code>:</code>后，光标会跳到屏幕底部的命令行，你可以在那里输入不同的命令。这种模式有很多功能，包括：</p><ul><li><code>:q</code> 退出（关闭窗口）</li><li><code>:w</code> 保存（“写入”）</li><li><code>:wq</code> 保存并退出</li><li><code>:e</code> {文件名} 打开文件进行编辑</li><li><code>:ls</code> 显示打开的缓冲区</li><li><code>:help</code> {主题} 打开帮助</li><li><code>:help :w</code> 打开:w命令的帮助</li><li><code>:help w</code> 打开w移动的帮助</li></ul><p>例如，如果你想打开一个名为<code>test.txt</code>的文件，你可以在命令模式下输入<code>:e test.txt</code>，然后按回车键。如果你想保存当前文件，你可以输入<code>:w</code>，然后按回车键。如果你想查看Vim的基本用法，你可以输入<code>:help</code>，然后按回车键。</p><h2 id="移动">移动</h2><ul><li><code>h</code> 或 向左箭头键 <code>←</code>光标向左移动一个字符</li><li><code>j</code> 或 向下箭头键 <code>↓</code>光标向下移动一个字符</li><li><code>k</code> 或 向上箭头键 <code>↑</code>光标向上移动一个字符</li><li><code>l</code> 或 向右箭头键 <code>→</code>光标向右移动一个字符</li><li><code>Ctrl + f</code> 屏幕向下移动<strong>一页</strong>，相当于<code>Page Down</code> 按键 (<strong>常用</strong>)</li><li><code>Ctrl + b</code> 屏幕向上移动一页，相当于 <code>Page Up</code>按键 (<strong>常用</strong>)</li><li><code>Ctrl + d</code> 屏幕向下移动<strong>半页</strong></li><li><code>Ctrl + u</code> 屏幕向上移动<strong>半页</strong></li><li><code>+</code> 光标移动到<strong>非空格符</strong>的下一行</li><li><code>-</code> 光标移动到<strong>非空格符</strong>的上一行</li><li><code>n&lt;space&gt;</code> 那个 <code>n</code> 表示数字，例如 20。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如<code>20&lt;space&gt;</code> 则光标会向后面移动 20 个字符距离。</li><li><code>0</code> 或功能键<code>Home</code>移动到这一行的<strong>最前面</strong>字符处 (<strong>常用</strong>)</li><li><code>$</code> 或功能键<code>End</code>移动到这一行的<strong>最后面</strong>字符处(<strong>常用</strong>)</li><li><code>H</code>光标移动到这个屏幕的<strong>最上方</strong>那一行的第一个字符</li><li><code>M</code>光标移动到这个屏幕的<strong>中央</strong>那一行的第一个字符</li><li><code>L</code>光标移动到这个屏幕的<strong>最下方</strong>那一行的第一个字符</li><li><code>G</code> 移动到这个档案的最后一行(<strong>常用</strong>)</li><li><code>nG</code> <code>n</code> 为数字。移动到这个档案的第 n 行。例如<code>20G</code> 则会移动到这个档案的第 20 行(可配合:<code>set nu</code>)</li><li><code>gg</code> 移动到这个档案的第一行，相当于 <code>1G</code>(<strong>常用</strong>)</li><li><code>n&lt;Enter&gt;</code> <code>n</code> 为数字。光标向下移动 n行(<strong>常用</strong>)</li></ul><h2 id="搜索替换">搜索替换</h2><ul><li><code>/word</code> 向光标之下寻找一个名称为 <code>word</code>的字符串。例如要在档案内搜寻 <code>vbird</code> 这个字符串，就输入<code>/vbird</code> 即可！ (<strong>常用</strong>)</li><li><code>?word</code> 向光标之上寻找一个字符串名称为 <code>word</code>的字符串。</li><li><code>n</code> 这个 <code>n</code>是英文按键。代表<strong>重复</strong>前一个搜寻的动作。举例来说，如果刚刚我们执行 <code>/vbird</code> 去向下搜寻 <code>vbird</code>这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 <code>vbird</code>的字符串。如果是执行 <code>?vbird</code> 的话，那么按下 n则会向上继续搜寻名称为 <code>vbird</code> 的字符串！</li><li><code>N</code> 这个 <code>N</code> 是英文按键。与 <code>n</code>刚好相反，为<strong>反向</strong>进行前一个搜寻动作。 例如<code>/vbird</code> 后，按下 <code>N</code>则表示<strong>向上</strong>搜寻 <code>vbird</code> 。</li></ul><h2 id="删除复制与粘贴">删除、复制与粘贴</h2><ul><li><code>x</code>, <code>X</code> 在一行字当中，<code>x</code>为向后删除一个字符 (相当于 <code>del</code> 按键)， <code>X</code>为向前删除一个字符(相当于 <code>backspace</code> 亦即是退格键)(<strong>常用</strong>)</li><li><code>nx</code> <code>n</code> 为数字，连续向后删除 n 个字符。</li><li><code>dd</code> 剪切游标所在的那一整行(<strong>常用</strong>)，用<code>p</code>/<code>P</code> 可以粘贴。</li><li><code>ndd</code> <code>n</code> 为数字。剪切光标所在的向下 n行，例如 <code>20dd</code> 则是剪切 20 行(<strong>常用</strong>)，用<code>p</code>/<code>P</code> 可以粘贴。</li><li><code>d1G</code> 删除光标所在到第一行的所有数据</li><li><code>dG</code> 删除光标所在到最后一行的所有数据</li><li><code>d$</code> 删除游标所在处，到该行的最后一个字符</li><li><code>d0</code> 那个是数字的 0，删除游标所在处，到该行的最前面一个字符</li><li><code>yy</code> 复制游标所在的那一行(<strong>常用</strong>)</li><li><code>nyy</code> <code>n</code> 为数字。复制光标所在的向下 n行，例如 <code>20yy</code> 则是复制 20 行(<strong>常用</strong>)</li><li><code>y1G</code> 复制游标所在行到第一行的所有数据</li><li><code>yG</code> 复制游标所在行到最后一行的所有数据</li><li><code>y0</code> 复制光标所在的那个字符到该行行首的所有数据</li><li><code>y$</code> 复制光标所在的那个字符到该行行尾的所有数据</li><li><code>p</code>, <code>P</code> <code>p</code>为将已复制的数据在光标下一行贴上，<code>P</code> 则为贴在游标上一行！(<strong>常用</strong>)</li><li><code>J</code> 将光标所在行与下一行的数据结合成同一行</li><li><code>c</code> 重复删除多个数据，例如 <code>10cj</code> 表示向下删除10 行</li><li><code>u</code> 复原前一个动作。(<strong>常用</strong>)</li><li><code>Ctrl + r</code> 重做上一个动作。(<strong>常用</strong>)</li></ul><h2 id="补充">补充</h2><table><thead><tr class="header"><th style="text-align: left;">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr class="even"><td style="text-align: left;">a, A</td><td>进入输入模式(Insert mode)： a为『从目前光标所在的下一个字符处开始输入』， A为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr class="odd"><td style="text-align: left;">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o为在目前光标所在的下一行处输入新的一行； O为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr class="even"><td style="text-align: left;">r, R</td><td>进入取代模式(Replace mode)： r只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下ESC 为止；(常用)</td></tr><tr class="odd"><td style="text-align: left;">上面这些按键中，在 vi画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时，一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr class="even"><td style="text-align: left;">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: left;">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr class="even"><td style="text-align: left;">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入，还是跟你对该档案的档案权限有关啊！</td></tr><tr class="odd"><td style="text-align: left;">:q</td><td>离开 vi (常用)</td></tr><tr class="even"><td style="text-align: left;">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr class="odd"><td style="text-align: left;">注意一下啊，那个惊叹号 (!) 在 vi当中，常常具有『强制』的意思～</td><td></td></tr><tr class="even"><td style="text-align: left;">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr class="odd"><td style="text-align: left;">ZZ</td><td>这是大写的 Z喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr class="even"><td style="text-align: left;">ZQ</td><td>不保存，强制退出。效果等同于 <strong>:q!</strong>。</td></tr><tr class="odd"><td style="text-align: left;">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr class="even"><td style="text-align: left;">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』这个档案内容加到游标所在行后面</td></tr><tr class="odd"><td style="text-align: left;">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr class="even"><td style="text-align: left;">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls/home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: left;">vim 环境的变更</th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr class="even"><td style="text-align: left;">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><h2 id="参考资料">参考资料</h2><p><a href="https://missing.csail.mit.edu/2020/editors/">Editors (Vim) ·Missing Semester (mit.edu)</a></p><p><a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim |菜鸟教程 (runoob.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TEST</title>
    <link href="/posts/59964/"/>
    <url>/posts/59964/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/posts/59964/1.jpg" class="" title="测试图片1"><figure><img src="1.jpg" alt="测试图片2" /><figcaption aria-hidden="true">测试图片2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
