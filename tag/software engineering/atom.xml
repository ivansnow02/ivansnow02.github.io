<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.ivansnow02.xyz</id>
    <title>IOyuk1Nya&#39;s Blog • Posts by &#34;software engineering&#34; tag</title>
    <link href="https://blog.ivansnow02.xyz" />
    <updated>2024-12-30T06:00:47.000Z</updated>
    <category term="coding" />
    <category term="algorithms" />
    <category term="computer science" />
    <category term="learning" />
    <category term="Django" />
    <category term="Python" />
    <category term="computer graphics" />
    <category term="Compilers" />
    <category term="Redis" />
    <category term="trash" />
    <category term="Java" />
    <category term="English" />
    <category term="test" />
    <category term="vim" />
    <category term="Spring" />
    <category term="Math" />
    <category term="Linear Algebra" />
    <category term="software engineering" />
    <category term="Physics" />
    <category term="data structure" />
    <category term="Discrete Mathematics" />
    <category term="coursera" />
    <category term="tree" />
    <entry>
        <id>https://blog.ivansnow02.xyz/software-engineering/</id>
        <title>软件工程复习</title>
        <link rel="alternate" href="https://blog.ivansnow02.xyz/software-engineering/"/>
        <content type="html">&lt;h2 id=&#34;判定表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判定表&#34;&gt;#&lt;/a&gt; 判定表&lt;/h2&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&#34;4&#34;&gt;条件&lt;/td&gt;
&lt;td&gt;条件 1&lt;/td&gt;
&lt;td rowspan=&#34;4&#34;&gt;条件取值的组合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;条件 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;条件 n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td rowspan=&#34;4&#34;&gt;动作&lt;/td&gt;
&lt;td&gt;动作 1&lt;/td&gt;
&lt;td rowspan=&#34;4&#34;&gt;动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动作 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动作 n&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/9e320b3103f9cdf12fa33f99c4da01a1aebc8976179c2815a65bf6426d5783f8.png&#34; alt=&#34;picture 10&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;判定树&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判定树&#34;&gt;#&lt;/a&gt; 判定树&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/6fffe564348fe5c6f28366aa66b24d86aa40e50a3387b91e3e4114f3cfa27743.png&#34; alt=&#34;picture 0&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;sa画dfd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sa画dfd&#34;&gt;#&lt;/a&gt; SA 画 DFD&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/8fbfc7fc45dd467a154a128ee55ca8c49e7daa3aac3fbf7960a6602a83496303.png&#34; alt=&#34;picture 1&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;dfd步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dfd步骤&#34;&gt;#&lt;/a&gt; DFD 步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;从顶层 DFD 开始，把整个系统视为加工处理。&lt;/li&gt;
&lt;li&gt;自上而下，逐步对系统分解：
&lt;ul&gt;
&lt;li&gt;每分解一次，增加系统的加工元素，进一步具体化每个加工的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复第 2 步，直到所有的加工元素都是足够简单，功能足够单一，视不必再分解为止。
&lt;ul&gt;
&lt;li&gt;不再分解的加工 ——“基本加工”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dfd原则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dfd原则&#34;&gt;#&lt;/a&gt; DFD 原则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;父 / 子图平衡（I/O）
&lt;ul&gt;
&lt;li&gt;如果一张数据流图中的某个加工分解成另一张数据流图时，则上层图为父图，直接下层图为子图。把一个处理分解为一系列处理时，分解前和分解后的输入 / 输出数据流必须相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;区分流程先后和层次。&lt;/li&gt;
&lt;li&gt;每个子图应该对应唯一的父加工。&lt;/li&gt;
&lt;li&gt;区分全局文件和外部项。&lt;/li&gt;
&lt;li&gt;画数据流而不是控制流。
&lt;ul&gt;
&lt;li&gt;数据流反映系统 “做什么”，不反映 “如何做”，因此箭头上的数据流名称只能是名词或名词短语。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一般不画物质流。
&lt;ul&gt;
&lt;li&gt;数据流反映能用计算机处理的数据，并不是实物。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个加工至少有一个输入数据流和一个输出数据流，反映出此加工数据的来源与加工的结果。&lt;/li&gt;
&lt;li&gt;加工框编号。
&lt;ul&gt;
&lt;li&gt;子图及其所有的加工都应编号，便于引用和追踪。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;掌握分解的速度。
&lt;ul&gt;
&lt;li&gt;一般一次引入 2~7 个加工处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部实体之间不能有数据流。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;uml&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#uml&#34;&gt;#&lt;/a&gt; UML&lt;/h2&gt;
&lt;h3 id=&#34;uml用例图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#uml用例图&#34;&gt;#&lt;/a&gt; UML 用例图&lt;/h3&gt;
&lt;h4 id=&#34;用例图元素&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图元素&#34;&gt;#&lt;/a&gt; 用例图元素&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Actor：参与者&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/bbe9f9796883e8cdd12135e74791a496db152b44ab7504569f7b2ac6c7000a0c.png&#34; alt=&#34;picture 4&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Use Case：用例&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/1c1351feb634b00db86c9d9864520582b5553fecc9da17eb51293be1c07a9463.png&#34; alt=&#34;picture 5&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Communication Association：通信关联&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/aabf5cc7be128bcfd7c47d4e4ad3abf31aa7d5e2f6b8fdeaecaa597c4f71db62.png&#34; alt=&#34;picture 6&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;note info no-icon&#34;&gt;
&lt;ul&gt;
&lt;li&gt;Use Case 说明系统需要提供什么而不是怎么提供&lt;/li&gt;
&lt;li&gt;用户并不关心你如何给他们提供所需要的功能&lt;/li&gt;
&lt;li&gt;Use Case 一般是用 “动宾” 短语命名&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h4 id=&#34;用例图角色&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图角色&#34;&gt;#&lt;/a&gt; 用例图角色&lt;/h4&gt;
&lt;p&gt;与系统发生交互作用的、系统之外的任何东西都是角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以是人&lt;/li&gt;
&lt;li&gt;也可以是机器&lt;/li&gt;
&lt;li&gt;角色不等同于使用者&lt;/li&gt;
&lt;li&gt;角色存在于系统外部&lt;/li&gt;
&lt;li&gt;角色不是活动的准确描述&lt;/li&gt;
&lt;li&gt;使用者是行使某个角色职责的系统的使用人员&lt;/li&gt;
&lt;li&gt;每个 Actor 都通过不同的方式使用系统，除非他们是相同的 Actor&lt;/li&gt;
&lt;li&gt;Actor 使用系统的每一种方式就是一个 Use Case&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用例图步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图步骤&#34;&gt;#&lt;/a&gt; 用例图步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;找出拟建系统以外的 Actor
&lt;ul&gt;
&lt;li&gt;与系统交互的人员&lt;/li&gt;
&lt;li&gt;与系统相连并交换信息的设备和其他系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 Use Case 来描述 Actor 怎样使用系统以及系统向 Actor 提供什么功能
&lt;ul&gt;
&lt;li&gt;Use Case 表示从外部用户角度观察的系统功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绘制 Use Case 图，并编写详细的 Use Case 描述
&lt;ul&gt;
&lt;li&gt;Use Case 图只能宏观地描述系统的功能&lt;/li&gt;
&lt;li&gt;每个功能的含义和具体实现步骤则以文本方式描述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;用例图关联&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图关联&#34;&gt;#&lt;/a&gt; 用例图关联&lt;/h4&gt;
&lt;h5 id=&#34;include&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#include&#34;&gt;#&lt;/a&gt; Include&lt;/h5&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/7d07cd65f7fdc444d9718363ee93216f262a80d36c6f5937260da8c9df59a9d6.png&#34; alt=&#34;picture 7&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use Case 中的包含关系。&lt;/li&gt;
&lt;li&gt;通常发生在多个 Use Case 中，有可以提取出来的公共部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;note info no-icon&#34;&gt;
&lt;p&gt;如果用例 A 确实要调用到用例 B，那么，可以进一步分析：&lt;/p&gt;
&lt;p&gt;用例 A 是调用了用例 B 的所有流程呢，还是其中部分流程？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是调用部分流程，此时可以把用例 B 中的那部分流程提取出来，形成用例 C，然后用例 A 和用例 B 都 include 用例 C。&lt;/li&gt;
&lt;li&gt;如果是调用所有流程，那么，用例 A 直接 include 用例 B 即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h5 id=&#34;extend&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#extend&#34;&gt;#&lt;/a&gt; Extend&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;UseCaseA 不知道 UseCaseB 和 UseCaseC 的存在&lt;/li&gt;
&lt;li&gt;UseCaseB 和 UseCaseC 却是知道 UseCaseA 并且知道如何在 UseCaseA 中作扩展的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/c0ba883ab92da8f358ae138aecd0e9905684f57932395f6dd15ff0418b84aacd.png&#34; alt=&#34;picture 8&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;泛化关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#泛化关系&#34;&gt;#&lt;/a&gt; 泛化关系&lt;/h5&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/bdb3e3b1b28dd1d7e3700884f822f94f4a8a86a02fb984d149c3ecf064e7cc7c.png&#34; alt=&#34;picture 9&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当多个用例共同拥有一种类似的结构和行为的时候，将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。&lt;/li&gt;
&lt;li&gt;子用例继承了父用例所有的结构、行为和关系。&lt;/li&gt;
&lt;li&gt;在实际应用中很少使用泛化关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用例图规则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图规则&#34;&gt;#&lt;/a&gt; 用例图规则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;主动角色画在图的左边&lt;/li&gt;
&lt;li&gt;被动角色画在图的右边&lt;/li&gt;
&lt;li&gt;每个 Use Case 必须为用户提供确切的功能&lt;/li&gt;
&lt;li&gt;Use Case 名称必须写在椭圆里面&lt;/li&gt;
&lt;li&gt;每一张图里不能有太多的 Use Case&lt;/li&gt;
&lt;li&gt;为每一个 Use Case 编号便于检索&lt;/li&gt;
&lt;li&gt;为 Use Case 建立目录（编号和名称）便于管理&lt;/li&gt;
&lt;li&gt;保持图面整洁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;发现对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#发现对象&#34;&gt;#&lt;/a&gt; 发现对象&lt;/h3&gt;
&lt;h4 id=&#34;实体类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实体类&#34;&gt;#&lt;/a&gt; 实体类&lt;/h4&gt;
&lt;p&gt;代表拟建系统要记录和维护的信息，同时描述其相关行为。需要长期保存。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/171dc57fa2a9972d3344c8fe88034cdfc74b74a4b748d6f9a253ccaf8bd203d7.png&#34; alt=&#34;picture 11&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;边界类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#边界类&#34;&gt;#&lt;/a&gt; 边界类&lt;/h4&gt;
&lt;p&gt;拟建系统和外部元素之间交互的边界，一个 Actor 和 Use Case 之间的通信关联对应一个边界类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户界面；&lt;/li&gt;
&lt;li&gt;与外部系统的接口；&lt;/li&gt;
&lt;li&gt;与其他设备的接口；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/68da89ce0ada1494e3a11762a9a98d26528a1b1014463cc359f71bd91fec84b5.png&#34; alt=&#34;picture 12&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;控制类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#控制类&#34;&gt;#&lt;/a&gt; 控制类&lt;/h4&gt;
&lt;p&gt;将 Use Case 所有的执行逻辑进行封装，相当于协调人。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己不处理具体的任务。&lt;/li&gt;
&lt;li&gt;知道哪些类有能力完成具体的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：&lt;br /&gt;
将拟建系统的其他部分（实体类和边界类）与 Use Case 的具体执行逻辑形成松散耦合。&lt;/p&gt;
&lt;p&gt;获取方法：一个 Use Case 对应一个控制类。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/d8ab6a793e4d2254ab3bb1c31aeda949f890ead532d81dafcda0d5b3eec74bd6.png&#34; alt=&#34;picture 13&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;类图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类图&#34;&gt;#&lt;/a&gt; 类图&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口：一组操作的集合，只有操作的声明而没有实现&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/735367b1fb71a53ef869c6093f9da0fa80d1070b09382870e2cd5d3f2655c84d.png&#34; alt=&#34;picture 27&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类：不能被实例化的类，一般至少包含一个抽象操作&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/dc72db42aa9d0741bac57f1e6dc61cd32185a63bee71e0b8d7e3d31728038d97.png&#34; alt=&#34;picture 28&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模版类：一种参数化的类，在编译时把模版参数绑定到不同的数据类型，从而产生不同的类&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/91d9cb3dffe6f8d47acd5c8f699b65e39c014cd72cbefad3dabe0439fd4bc0f1.png&#34; alt=&#34;picture 29&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;对象之间关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对象之间关系&#34;&gt;#&lt;/a&gt; 对象之间关系&lt;/h4&gt;
&lt;h5 id=&#34;关联&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关联&#34;&gt;#&lt;/a&gt; 关联&lt;/h5&gt;
&lt;p&gt;一个类的对象（实例）作为另一个类的对象的变量成员时，两个类之间有关联关系&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/0fde56f0d6076804bd3ea349bbce2008fec6cb7d668bd65255cd270a683f4d87.png&#34; alt=&#34;picture 30&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;聚合&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#聚合&#34;&gt;#&lt;/a&gt; 聚合&lt;/h5&gt;
&lt;p&gt;表示两个类的对象间有 “整体” 与 “部分” 的关系。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/dfe5fddeb8834aa2e9e1bdb47b71a4ebce09686a03e7cede308f6a379ff6184c.png&#34; alt=&#34;picture 31&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;组合关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组合关系&#34;&gt;#&lt;/a&gt; 组合关系&lt;/h5&gt;
&lt;p&gt;“整体” 与 “部分” 间有 “皮之不存，毛将焉附” 的语义。​&lt;/p&gt;
&lt;p&gt;“部分” 不能被 “整体” 共享。​&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/2d206bd9f39b27448de3ac47ffa19b4c8626db9ac5754a78414af4d5a584f5c3.png&#34; alt=&#34;picture 32&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;依赖关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#依赖关系&#34;&gt;#&lt;/a&gt; 依赖关系&lt;/h5&gt;
&lt;p&gt;表示 “使用” 的语义，是一种比较弱的关系。&lt;br /&gt;
对象作为参数、全局变量或者局部变量被另外一个对象使用&lt;br /&gt;
友元依赖：授权一个对象访问对象的私有或者保护成员&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/c13671b7566f0431c76d1c532fdde33ae8a480682bb3e6147de5ea649d8a6e49.png&#34; alt=&#34;picture 33&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;泛化关系-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#泛化关系-2&#34;&gt;#&lt;/a&gt; 泛化关系&lt;/h5&gt;
&lt;p&gt;类 A（特殊）到类 B（一般）的泛化关系表示 “类 A 是类 B 的一种”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类 A—— 子类&lt;/li&gt;
&lt;li&gt;类 B—— 父类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;泛化关系有助于代码共享和复用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共同的属性放在上层，而将特有的属性放在下层；&lt;/li&gt;
&lt;li&gt;共同的服务放在上层，而将特有的服务放在下层&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;note info no-icon&#34;&gt;
&lt;p&gt;&lt;strong&gt;泛化关系 vs. 继承&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泛化关系是一种关系的名称。&lt;/li&gt;
&lt;li&gt;继承是一种实现泛化关系的机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/230d7b698976ad822a5e1b63f1d6027b224555a9c8db21da17e76f374e390f9a.png&#34; alt=&#34;picture 34&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;实现关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实现关系&#34;&gt;#&lt;/a&gt; 实现关系&lt;/h5&gt;
&lt;p&gt;描述类实现接口&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/b9c07ecfe3aa35496111d3ee43fbe5b621c4d6535a55394186c60f1d2fab8637.png&#34; alt=&#34;picture 35&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;构件图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#构件图&#34;&gt;#&lt;/a&gt; 构件图&lt;/h3&gt;
&lt;p&gt;构件图描述代码部件的物理结构及各部件之间的依赖关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是比 “类” 更大的实体，例如一个 COM 组件、ActiveX 文件、一个 JavaBeans、进程内组件（.DLL）、进程外组件（.EXE）、C++ 中的头文件（.h）、实现文件（.cpp）等等。&lt;/li&gt;
&lt;li&gt;它包含逻辑类或实现类的有关信息。&lt;/li&gt;
&lt;li&gt;构件图有助于分析和理解部件之间的相互影响程度。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事务名称&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;图例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;构件&lt;/td&gt;
&lt;td&gt;指系统中可替换的物理部分&lt;/td&gt;
&lt;td&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/ae6642aef337c95abfe14f6c07e3fba7690629ca699282cdd9125bacb372efc5.png&#34; alt=&#34;picture 36&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;接口&lt;/td&gt;
&lt;td&gt;外部可访问到的服务&lt;/td&gt;
&lt;td&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/7437ca1e414511e03b2f3c59aec70b9dfcb99f76657e91af300ad1b9ac589a56.png&#34; alt=&#34;picture 37&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;构件实例&lt;/td&gt;
&lt;td&gt;节点实例上的构件的一个实例，冒号后是该构件实例的名字&lt;/td&gt;
&lt;td&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/f2d114162822d5c12b1e0e56b442b9d7a58e1eb673b10eb4081a97e776b117a1.png&#34; alt=&#34;picture 38&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;构件图中的关系及解释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖关系：构件依赖外部提供的服务 (由构件到接口), 用虚线表示&lt;/li&gt;
&lt;li&gt;实现关系：构件实现接口 (由构件到接口), 用实线表示&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/23edab3ee2312c412f07581ab1d35caacd4ff5e776fa461a39ef0f6ccf15e969.png&#34; alt=&#34;picture 39&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;部署图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#部署图&#34;&gt;#&lt;/a&gt; 部署图&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;节点是在运行时存在的物理元素，它表示一个计算机资源，通常至少有一些记忆能力和处理能力。&lt;/li&gt;
&lt;li&gt;一组构件可以驻留在一个节点内，也可以从一个节点迁移到另一个节点。&lt;/li&gt;
&lt;li&gt;在图形上，把节点画成一个立方体，通常在立方体中只写它的名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;顺序图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#顺序图&#34;&gt;#&lt;/a&gt; 顺序图&lt;/h3&gt;
&lt;h4 id=&#34;顺序图的组成&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#顺序图的组成&#34;&gt;#&lt;/a&gt; 顺序图的组成&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/a802a4d7adb62d8d77e67f15eb72354bd18656de4a9c5723035567f3ba79b179.png&#34; alt=&#34;picture 40&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;顺序图的消息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#顺序图的消息&#34;&gt;#&lt;/a&gt; 顺序图的消息&lt;/h4&gt;
&lt;p&gt;消息包含 3 个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;序号&lt;/li&gt;
&lt;li&gt;名称&lt;/li&gt;
&lt;li&gt;参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;消息的 4 种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步消息&lt;/strong&gt;：消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步消息&lt;/strong&gt;：消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接收者返回消息或者控制。异步消息的接收者和发送者是并发工作的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回消息&lt;/strong&gt;：返回消息表示从过程调用返回。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自关联消息&lt;/strong&gt;：表示方法的自身调用以及一个对象内的一个方法调用另一个方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/13ca3b0fe257b2ef402d98172319250cb5ec6fff09ff6175dbe96f3c5813e145.png&#34; alt=&#34;picture 41&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;协作图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#协作图&#34;&gt;#&lt;/a&gt; 协作图&lt;/h3&gt;
&lt;p&gt;与相关的顺序图有明确的对应关系。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/3cd7696c775b6597aeb83f24329221611dc9399dd4a397dfe18a00f74e0d5632.png&#34; alt=&#34;picture 42&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;状态图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#状态图&#34;&gt;#&lt;/a&gt; 状态图&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;状态图用来建模系统中的某个类对象、子系统或整个系统在其生命周期内出现的状态、状态的迁移和迁移条件。&lt;/li&gt;
&lt;li&gt;一个对象在某个时刻所处的状态是由该对象的属性值所决定的。&lt;/li&gt;
&lt;li&gt;对象由一种状态迁移到另一种状态，通常是由于受到了外部的刺激或自身性质的改变所引起的。导致对象状态变迁的原因即迁移条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;状态图符号&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#状态图符号&#34;&gt;#&lt;/a&gt; 状态图符号&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用导角矩形表示对象所处的状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始状态：必须有 &lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/a4c2952f7c481a161e9cf3af36de5e0a68a28c814da6a26d12c4c08874e65549.png&#34; alt=&#34;picture 43&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终止状态：可选的，也可以没有&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/51305bceda4a74e8049ca817878a84f1b24d08dc46e037d2f1f5348f86875ce3.png&#34; alt=&#34;picture 44&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带箭头的直线表示状态迁移的方向，其状态迁移的条件写在直线的上方或下方&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;活动图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#活动图&#34;&gt;#&lt;/a&gt; 活动图&lt;/h3&gt;
&lt;p&gt;活动图用于描述 Use Case 的事件流结构；属于一个特定的 Use Case。&lt;br /&gt;
活动之间带箭头的直线表示从一个活动到另一个活动的转移，可在直线上标注活动转移的条件&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/8bc78f32bf1809672825f04e04fd46e2b1d75197296be07482985b5ad2bd7c74.png&#34; alt=&#34;picture 45&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用圆角矩形表示活动&lt;/li&gt;
&lt;li&gt;用黑色实心圆和 “牛眼” 分别表示活动的开始和终止&lt;/li&gt;
&lt;li&gt;活动之间带箭头的直线表示从一个活动到另一个活动的转移，可在直线上标注活动转移的条件&lt;/li&gt;
&lt;li&gt;泳道不仅表示出活动的变化，而且也描述了完成各个活动的类。&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/af97136ba5e5c7bab77edd82cdcdcf73dfcbf6bcfd2a4ed53a7e0fb617114682.png&#34; alt=&#34;picture 46&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构图sc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结构图sc&#34;&gt;#&lt;/a&gt; 结构图 SC&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传入模块&lt;/strong&gt;：从下层模块取得数据，经过某些处理，再将其结果传递给上级模块。&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/c3be0785ed5a9512d25a18c4d4062c616730e6d53da503aa73319312427cced4.png&#34; alt=&#34;picture 14&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传出模块&lt;/strong&gt;：从上级模块获得数据，进行某些处理，再将其结果传送给下级模块。&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/fd411f4ae911dfc4d23ffde21419a67e7941cdc356fec35f2e18523bb42e9111.png&#34; alt=&#34;picture 15&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变换模块&lt;/strong&gt;：从上级模块获得数据，进行特定处理，转换成其它形式，再将其结果传送给上级模块。&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/4aa283df2a6ca71e341495857a08ca2dcc598b68028ef083dd94d9aec1650a25.png&#34; alt=&#34;picture 16&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;源模块&lt;/strong&gt;：不调用其它模块的传入模块。&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/5d8076cf0140281443a0a5765f44dcaeecc12582f8637cfa037e42ebbedadf4f.png&#34; alt=&#34;picture 17&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;漏模块&lt;/strong&gt;：不调用其它模块的传出模块。&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/48bdfeb9d77d83a7f25c98c9adcfd7e46a4d0682da097c4274607b42f3423bac.png&#34; alt=&#34;picture 18&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协调模块&lt;/strong&gt;：对下属模块进行控制和管理的模块。&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/2e7398415bffda5f72a89ac4a79b0af3ec8d405e71ebfa1c75ef2858f974c7ac.png&#34; alt=&#34;picture 19&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;note info no-icon&#34;&gt;
&lt;p&gt;附加符号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择调用：&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/eb0968d0faa3929bca9827f4398599c0ca2339ec0021e143d99cc5ec73695e5e.png&#34; alt=&#34;picture 20&#34; /&gt;&lt;/li&gt;
&lt;li&gt;循环调用：&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/76b2c699b05ea4b2a460def483a6da34afd23b7c9481baafbce46f49c6e7aa4a.png&#34; alt=&#34;picture 21&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id=&#34;结构化设计sd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结构化设计sd&#34;&gt;#&lt;/a&gt; 结构化设计 SD&lt;/h2&gt;
&lt;h3 id=&#34;变换映射&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#变换映射&#34;&gt;#&lt;/a&gt; 变换映射&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;识别输入边界、输出边界和变换中心三部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;逻辑输入&lt;/strong&gt;：离物理输入端（输入始端）最远，但仍可作为输入的数据流。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑输出&lt;/strong&gt;：离物理输出端（输出始端）最远，但仍可作为输出的数据流。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行第一级分解（映射顶层和第一层）&lt;/p&gt;
&lt;p&gt;设计主控模块和第一层软件结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;输入模块 ca&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：为主控模块提供数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出模块 ce&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：为主控模块提供数据的输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变换模块 ct&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：将逻辑输入转换为逻辑输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成 “第二级和下层的映射”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务：将 DFD 中的每一个处理映射到程序结构中的模块。&lt;/li&gt;
&lt;li&gt;方法：从变换中心的边界开始，沿输入路径和输出路径向外，将处理依次映射到从属层的软件结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化软件设计&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/55dc0c7a5ad9a0c9ee8c886eedd727b2bc922d33e6a1929f145a78862547160a.png&#34; alt=&#34;picture 22&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;事务映射&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#事务映射&#34;&gt;#&lt;/a&gt; 事务映射&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;识别事务输入、通路和事务中心三部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行第一级分解（映射顶层和第一层）&lt;/p&gt;
&lt;p&gt;设计事务控制模块和第一层软件结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;输入模块&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能：为主控模块提供数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调度模块&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能：根据输入的要求调度相应的执行通路。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行第二级分解：设计中下层模块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法：对通路再进行识别、划分、映射，反复此过程直到全部映射完毕。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化软件设计&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/6d691974ddfd455ea32a2f98d271cc6713928fb90cb59cd09bfd8423aa8613ab.png&#34; alt=&#34;picture 23&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;n-s图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#n-s图&#34;&gt;#&lt;/a&gt; N-S 图&lt;/h2&gt;
&lt;p&gt;N-S 图也叫做盒图。五种基本控制结构由五种图形构件表示。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/095b03b05b5d0c61ff7d9545b26c385ea8eb24e0a1cd5bbfb1b92896f91524aa.png&#34; alt=&#34;picture 24&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;问题分析图pad&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#问题分析图pad&#34;&gt;#&lt;/a&gt; 问题分析图 (PAD)&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/d61e5100ef9fdd1bef6645eb384b271857bce00ef093391ba2b71f9cb152c839.png&#34; alt=&#34;picture 25&#34; /&gt;&lt;/p&gt;
&lt;p&gt;扩充控制结构：&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/9f71471c036e3a8b6a354f2286e9c6323cb3e094bfc9bf608b55119f91bf3783.png&#34; alt=&#34;picture 26&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;白盒测试&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#白盒测试&#34;&gt;#&lt;/a&gt; 白盒测试&lt;/h2&gt;
&lt;h3 id=&#34;逻辑覆盖法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#逻辑覆盖法&#34;&gt;#&lt;/a&gt; 逻辑覆盖法&lt;/h3&gt;
&lt;h4 id=&#34;语句覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#语句覆盖&#34;&gt;#&lt;/a&gt; 语句覆盖&lt;/h4&gt;
&lt;p&gt;将程序中每个语句至少执行一次&lt;/p&gt;
&lt;h4 id=&#34;判定覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判定覆盖&#34;&gt;#&lt;/a&gt; 判定覆盖&lt;/h4&gt;
&lt;p&gt;每个判定的每个分支路径至少要执行一次。&lt;/p&gt;
&lt;h4 id=&#34;条件覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#条件覆盖&#34;&gt;#&lt;/a&gt; 条件覆盖&lt;/h4&gt;
&lt;p&gt;每个条件的真假两种情况至少执行一次。&lt;/p&gt;
&lt;div class=&#34;note info no-icon&#34;&gt;
&lt;p&gt;条件覆盖不一定符合判定覆盖。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&#34;判定条件覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判定条件覆盖&#34;&gt;#&lt;/a&gt; 判定 / 条件覆盖&lt;/h4&gt;
&lt;p&gt;每个条件的真假两种情况至少执行一次。&lt;br /&gt;
每个判定的每个分支路径至少要执行一次。&lt;/p&gt;
&lt;h4 id=&#34;条件组合覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#条件组合覆盖&#34;&gt;#&lt;/a&gt; 条件组合覆盖&lt;/h4&gt;
&lt;p&gt;每个判定的所有条件的各种可能组合至少执行一次。&lt;/p&gt;
&lt;h3 id=&#34;路径覆盖法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路径覆盖法&#34;&gt;#&lt;/a&gt; 路径覆盖法&lt;/h3&gt;
&lt;h4 id=&#34;点覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#点覆盖&#34;&gt;#&lt;/a&gt; 点覆盖&lt;/h4&gt;
&lt;p&gt;＝语句覆盖&lt;br /&gt;
每个结点至少执行一次。&lt;/p&gt;
&lt;h4 id=&#34;边覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#边覆盖&#34;&gt;#&lt;/a&gt; 边覆盖&lt;/h4&gt;
&lt;p&gt;＝判定覆盖&lt;br /&gt;
每条边至少执行一次。&lt;/p&gt;
&lt;h4 id=&#34;路径覆盖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路径覆盖&#34;&gt;#&lt;/a&gt; 路径覆盖&lt;/h4&gt;
&lt;p&gt;每个可能的路径至少执行一次。&lt;/p&gt;
&lt;h2 id=&#34;黑盒测试&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#黑盒测试&#34;&gt;#&lt;/a&gt; 黑盒测试&lt;/h2&gt;
&lt;h3 id=&#34;等价分类法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#等价分类法&#34;&gt;#&lt;/a&gt; 等价分类法&lt;/h3&gt;
&lt;p&gt;将所有可能的输入数据划分成若干个等价类，然后从每一类中选取少数有代表性的数据作为测试用例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;划分等价类（有效等价类、无效等价类）&lt;/li&gt;
&lt;li&gt;设计测试用例&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计测试用例原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有效等价类尽量选取公用测试用例，以减少测试次数。&lt;/li&gt;
&lt;li&gt;无效的每类一例，以防漏掉错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选取测试用例&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为每一个等价类规定一个唯一编号。&lt;/li&gt;
&lt;li&gt;设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止。&lt;/li&gt;
&lt;li&gt;设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等价类划分的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;规定了输入条件取值范围、取值的个数，则可以确立一个有效等价类和两个无效等价类。&lt;/li&gt;
&lt;li&gt;输入条件规定了输入条件输入值的集合，可确立一个有效等价类和一个无效等价类。&lt;br /&gt;
- 有效等价类 —— 集合内&lt;br /&gt;
 - 无效等价类 —— 集合外&lt;/li&gt;
&lt;li&gt;如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类。&lt;/li&gt;
&lt;li&gt;如果规定了输入数据的一组值，而且程序要对每个输入值分别进行处理：&lt;br /&gt;
- 每一个输入值 —— 一个有效等价类&lt;br /&gt;
 - 所有不允许的输入值的集合 —— 一个无效等价类&lt;/li&gt;
&lt;li&gt;如果规定了输入数据必须遵守的规则，则可以确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;边界值分析法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#边界值分析法&#34;&gt;#&lt;/a&gt; 边界值分析法&lt;/h3&gt;
&lt;p&gt;对等价分类法的补充：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对各种边界情况设计测试用例。&lt;/li&gt;
&lt;li&gt;大量的错误是发生在输入 / 输出范围的边界上，而不是在输入范围的内部。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先应确定边界情况。&lt;/li&gt;
&lt;li&gt;选取正好等于、刚刚大于、刚刚小于边界的值作为测试数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;错误推测法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#错误推测法&#34;&gt;#&lt;/a&gt; 错误推测法&lt;/h3&gt;
&lt;p&gt;人们也可以靠经验和直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的测试用例 —— 错误推测法。&lt;/p&gt;
</content>
        <category term="computer science" />
        <category term="learning" />
        <category term="software engineering" />
        <updated>2024-12-30T06:00:47.000Z</updated>
    </entry>
</feed>
