{
    "version": "https://jsonfeed.org/version/1",
    "title": "IOyuk1Nya's Blog • All posts by \"software engineering\" tag",
    "description": "some notes about computer science",
    "home_page_url": "https://blog.ivansnow02.xyz",
    "items": [
        {
            "id": "https://blog.ivansnow02.xyz/software-engineering/",
            "url": "https://blog.ivansnow02.xyz/software-engineering/",
            "title": "软件工程复习",
            "date_published": "2024-12-30T06:00:47.000Z",
            "content_html": "<h2 id=\"判定表\"><a class=\"anchor\" href=\"#判定表\">#</a> 判定表</h2>\n<table>\n<tbody>\n<tr>\n<td rowspan=\"4\">条件</td>\n<td>条件 1</td>\n<td rowspan=\"4\">条件取值的组合</td>\n</tr>\n<tr>\n<td>条件 2</td>\n</tr>\n<tr>\n<td>...</td>\n</tr>\n<tr>\n<td>条件 n</td>\n</tr>\n<tr>\n<td rowspan=\"4\">动作</td>\n<td>动作 1</td>\n<td rowspan=\"4\">动作</td>\n</tr>\n<tr>\n<td>动作 2</td>\n</tr>\n<tr>\n<td>...</td>\n</tr>\n<tr>\n<td>动作 n</td>\n</tr>\n</tbody>\n</table>\n<p><img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/9e320b3103f9cdf12fa33f99c4da01a1aebc8976179c2815a65bf6426d5783f8.png\" alt=\"picture 10\" /></p>\n<h2 id=\"判定树\"><a class=\"anchor\" href=\"#判定树\">#</a> 判定树</h2>\n<p><img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/6fffe564348fe5c6f28366aa66b24d86aa40e50a3387b91e3e4114f3cfa27743.png\" alt=\"picture 0\" /></p>\n<h2 id=\"sa画dfd\"><a class=\"anchor\" href=\"#sa画dfd\">#</a> SA 画 DFD</h2>\n<p><img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/8fbfc7fc45dd467a154a128ee55ca8c49e7daa3aac3fbf7960a6602a83496303.png\" alt=\"picture 1\" /></p>\n<h3 id=\"dfd步骤\"><a class=\"anchor\" href=\"#dfd步骤\">#</a> DFD 步骤</h3>\n<ol>\n<li>从顶层 DFD 开始，把整个系统视为加工处理。</li>\n<li>自上而下，逐步对系统分解：\n<ul>\n<li>每分解一次，增加系统的加工元素，进一步具体化每个加工的功能。</li>\n</ul>\n</li>\n<li>重复第 2 步，直到所有的加工元素都是足够简单，功能足够单一，视不必再分解为止。\n<ul>\n<li>不再分解的加工 ——“基本加工”</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"dfd原则\"><a class=\"anchor\" href=\"#dfd原则\">#</a> DFD 原则</h3>\n<ol>\n<li>父 / 子图平衡（I/O）\n<ul>\n<li>如果一张数据流图中的某个加工分解成另一张数据流图时，则上层图为父图，直接下层图为子图。把一个处理分解为一系列处理时，分解前和分解后的输入 / 输出数据流必须相同。</li>\n</ul>\n</li>\n<li>区分流程先后和层次。</li>\n<li>每个子图应该对应唯一的父加工。</li>\n<li>区分全局文件和外部项。</li>\n<li>画数据流而不是控制流。\n<ul>\n<li>数据流反映系统 “做什么”，不反映 “如何做”，因此箭头上的数据流名称只能是名词或名词短语。</li>\n</ul>\n</li>\n<li>一般不画物质流。\n<ul>\n<li>数据流反映能用计算机处理的数据，并不是实物。</li>\n</ul>\n</li>\n<li>每个加工至少有一个输入数据流和一个输出数据流，反映出此加工数据的来源与加工的结果。</li>\n<li>加工框编号。\n<ul>\n<li>子图及其所有的加工都应编号，便于引用和追踪。</li>\n</ul>\n</li>\n<li>掌握分解的速度。\n<ul>\n<li>一般一次引入 2~7 个加工处理。</li>\n</ul>\n</li>\n<li>外部实体之间不能有数据流。</li>\n</ol>\n<h2 id=\"uml\"><a class=\"anchor\" href=\"#uml\">#</a> UML</h2>\n<h3 id=\"uml用例图\"><a class=\"anchor\" href=\"#uml用例图\">#</a> UML 用例图</h3>\n<h4 id=\"用例图元素\"><a class=\"anchor\" href=\"#用例图元素\">#</a> 用例图元素</h4>\n<ul>\n<li>Actor：参与者<br />\n<img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/bbe9f9796883e8cdd12135e74791a496db152b44ab7504569f7b2ac6c7000a0c.png\" alt=\"picture 4\" /></li>\n<li>Use Case：用例<br />\n<img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/1c1351feb634b00db86c9d9864520582b5553fecc9da17eb51293be1c07a9463.png\" alt=\"picture 5\" /></li>\n<li>Communication Association：通信关联<br />\n<img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/aabf5cc7be128bcfd7c47d4e4ad3abf31aa7d5e2f6b8fdeaecaa597c4f71db62.png\" alt=\"picture 6\" /></li>\n</ul>\n<div class=\"note info no-icon\">\n<ul>\n<li>Use Case 说明系统需要提供什么而不是怎么提供</li>\n<li>用户并不关心你如何给他们提供所需要的功能</li>\n<li>Use Case 一般是用 “动宾” 短语命名</li>\n</ul>\n</div>\n<h4 id=\"用例图角色\"><a class=\"anchor\" href=\"#用例图角色\">#</a> 用例图角色</h4>\n<p>与系统发生交互作用的、系统之外的任何东西都是角色：</p>\n<ul>\n<li>可以是人</li>\n<li>也可以是机器</li>\n<li>角色不等同于使用者</li>\n<li>角色存在于系统外部</li>\n<li>角色不是活动的准确描述</li>\n<li>使用者是行使某个角色职责的系统的使用人员</li>\n<li>每个 Actor 都通过不同的方式使用系统，除非他们是相同的 Actor</li>\n<li>Actor 使用系统的每一种方式就是一个 Use Case</li>\n</ul>\n<h4 id=\"用例图步骤\"><a class=\"anchor\" href=\"#用例图步骤\">#</a> 用例图步骤</h4>\n<ol>\n<li>找出拟建系统以外的 Actor\n<ul>\n<li>与系统交互的人员</li>\n<li>与系统相连并交换信息的设备和其他系统</li>\n</ul>\n</li>\n<li>使用 Use Case 来描述 Actor 怎样使用系统以及系统向 Actor 提供什么功能\n<ul>\n<li>Use Case 表示从外部用户角度观察的系统功能</li>\n</ul>\n</li>\n<li>绘制 Use Case 图，并编写详细的 Use Case 描述\n<ul>\n<li>Use Case 图只能宏观地描述系统的功能</li>\n<li>每个功能的含义和具体实现步骤则以文本方式描述</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"用例图关联\"><a class=\"anchor\" href=\"#用例图关联\">#</a> 用例图关联</h4>\n<h5 id=\"include\"><a class=\"anchor\" href=\"#include\">#</a> Include</h5>\n<p><img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/7d07cd65f7fdc444d9718363ee93216f262a80d36c6f5937260da8c9df59a9d6.png\" alt=\"picture 7\" /></p>\n<ul>\n<li>Use Case 中的包含关系。</li>\n<li>通常发生在多个 Use Case 中，有可以提取出来的公共部分。</li>\n</ul>\n<div class=\"note info no-icon\">\n<p>如果用例 A 确实要调用到用例 B，那么，可以进一步分析：</p>\n<p>用例 A 是调用了用例 B 的所有流程呢，还是其中部分流程？</p>\n<ol>\n<li>如果是调用部分流程，此时可以把用例 B 中的那部分流程提取出来，形成用例 C，然后用例 A 和用例 B 都 include 用例 C。</li>\n<li>如果是调用所有流程，那么，用例 A 直接 include 用例 B 即可。</li>\n</ol>\n</div>\n<h5 id=\"extend\"><a class=\"anchor\" href=\"#extend\">#</a> Extend</h5>\n<ul>\n<li>UseCaseA 不知道 UseCaseB 和 UseCaseC 的存在</li>\n<li>UseCaseB 和 UseCaseC 却是知道 UseCaseA 并且知道如何在 UseCaseA 中作扩展的</li>\n</ul>\n<p><img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/c0ba883ab92da8f358ae138aecd0e9905684f57932395f6dd15ff0418b84aacd.png\" alt=\"picture 8\" /></p>\n<h5 id=\"泛化关系\"><a class=\"anchor\" href=\"#泛化关系\">#</a> 泛化关系</h5>\n<p><img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/software-engineering/bdb3e3b1b28dd1d7e3700884f822f94f4a8a86a02fb984d149c3ecf064e7cc7c.png\" alt=\"picture 9\" /></p>\n<ul>\n<li>当多个用例共同拥有一种类似的结构和行为的时候，将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。</li>\n<li>子用例继承了父用例所有的结构、行为和关系。</li>\n<li>在实际应用中很少使用泛化关系。</li>\n</ul>\n<h4 id=\"用例图规则\"><a class=\"anchor\" href=\"#用例图规则\">#</a> 用例图规则</h4>\n<ul>\n<li>主动角色画在图的左边</li>\n<li>被动角色画在图的右边</li>\n<li>每个 Use Case 必须为用户提供确切的功能</li>\n<li>Use Case 名称必须写在椭圆里面</li>\n<li>每一张图里不能有太多的 Use Case</li>\n<li>为每一个 Use Case 编号便于检索</li>\n<li>为 Use Case 建立目录（编号和名称）便于管理</li>\n<li>保持图面整洁</li>\n</ul>\n",
            "tags": [
                "computer science",
                "learning",
                "software engineering"
            ]
        }
    ]
}