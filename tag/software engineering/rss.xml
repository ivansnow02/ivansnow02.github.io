<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>IOyuk1Nya&#39;s Blog • Posts by &#34;software engineering&#34; tag</title>
        <link>https://blog.ivansnow02.xyz</link>
        <description>some notes about computer science</description>
        <language>zh-CN</language>
        <pubDate>Mon, 30 Dec 2024 14:00:47 +0800</pubDate>
        <lastBuildDate>Mon, 30 Dec 2024 14:00:47 +0800</lastBuildDate>
        <category>Compilers</category>
        <category>computer science</category>
        <category>learning</category>
        <category>coding</category>
        <category>algorithms</category>
        <category>data structure</category>
        <category>computer graphics</category>
        <category>Django</category>
        <category>Python</category>
        <category>Redis</category>
        <category>Java</category>
        <category>English</category>
        <category>test</category>
        <category>trash</category>
        <category>coursera</category>
        <category>vim</category>
        <category>Spring</category>
        <category>Math</category>
        <category>Linear Algebra</category>
        <category>tree</category>
        <category>Physics</category>
        <category>Discrete Mathematics</category>
        <category>software engineering</category>
        <item>
            <guid isPermalink="true">https://blog.ivansnow02.xyz/software-engineering/</guid>
            <title>软件工程复习</title>
            <link>https://blog.ivansnow02.xyz/software-engineering/</link>
            <category>computer science</category>
            <category>learning</category>
            <category>software engineering</category>
            <pubDate>Mon, 30 Dec 2024 14:00:47 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;判定表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判定表&#34;&gt;#&lt;/a&gt; 判定表&lt;/h2&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td rowspan=&#34;4&#34;&gt;条件&lt;/td&gt;
&lt;td&gt;条件 1&lt;/td&gt;
&lt;td rowspan=&#34;4&#34;&gt;条件取值的组合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;条件 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;条件 n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td rowspan=&#34;4&#34;&gt;动作&lt;/td&gt;
&lt;td&gt;动作 1&lt;/td&gt;
&lt;td rowspan=&#34;4&#34;&gt;动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动作 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动作 n&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/9e320b3103f9cdf12fa33f99c4da01a1aebc8976179c2815a65bf6426d5783f8.png&#34; alt=&#34;picture 10&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;判定树&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判定树&#34;&gt;#&lt;/a&gt; 判定树&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/6fffe564348fe5c6f28366aa66b24d86aa40e50a3387b91e3e4114f3cfa27743.png&#34; alt=&#34;picture 0&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;sa画dfd&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sa画dfd&#34;&gt;#&lt;/a&gt; SA 画 DFD&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/8fbfc7fc45dd467a154a128ee55ca8c49e7daa3aac3fbf7960a6602a83496303.png&#34; alt=&#34;picture 1&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;dfd步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dfd步骤&#34;&gt;#&lt;/a&gt; DFD 步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;从顶层 DFD 开始，把整个系统视为加工处理。&lt;/li&gt;
&lt;li&gt;自上而下，逐步对系统分解：
&lt;ul&gt;
&lt;li&gt;每分解一次，增加系统的加工元素，进一步具体化每个加工的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复第 2 步，直到所有的加工元素都是足够简单，功能足够单一，视不必再分解为止。
&lt;ul&gt;
&lt;li&gt;不再分解的加工 ——“基本加工”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dfd原则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dfd原则&#34;&gt;#&lt;/a&gt; DFD 原则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;父 / 子图平衡（I/O）
&lt;ul&gt;
&lt;li&gt;如果一张数据流图中的某个加工分解成另一张数据流图时，则上层图为父图，直接下层图为子图。把一个处理分解为一系列处理时，分解前和分解后的输入 / 输出数据流必须相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;区分流程先后和层次。&lt;/li&gt;
&lt;li&gt;每个子图应该对应唯一的父加工。&lt;/li&gt;
&lt;li&gt;区分全局文件和外部项。&lt;/li&gt;
&lt;li&gt;画数据流而不是控制流。
&lt;ul&gt;
&lt;li&gt;数据流反映系统 “做什么”，不反映 “如何做”，因此箭头上的数据流名称只能是名词或名词短语。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一般不画物质流。
&lt;ul&gt;
&lt;li&gt;数据流反映能用计算机处理的数据，并不是实物。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个加工至少有一个输入数据流和一个输出数据流，反映出此加工数据的来源与加工的结果。&lt;/li&gt;
&lt;li&gt;加工框编号。
&lt;ul&gt;
&lt;li&gt;子图及其所有的加工都应编号，便于引用和追踪。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;掌握分解的速度。
&lt;ul&gt;
&lt;li&gt;一般一次引入 2~7 个加工处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部实体之间不能有数据流。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;uml&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#uml&#34;&gt;#&lt;/a&gt; UML&lt;/h2&gt;
&lt;h3 id=&#34;uml用例图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#uml用例图&#34;&gt;#&lt;/a&gt; UML 用例图&lt;/h3&gt;
&lt;h4 id=&#34;用例图元素&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图元素&#34;&gt;#&lt;/a&gt; 用例图元素&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Actor：参与者&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/bbe9f9796883e8cdd12135e74791a496db152b44ab7504569f7b2ac6c7000a0c.png&#34; alt=&#34;picture 4&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Use Case：用例&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/1c1351feb634b00db86c9d9864520582b5553fecc9da17eb51293be1c07a9463.png&#34; alt=&#34;picture 5&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Communication Association：通信关联&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/aabf5cc7be128bcfd7c47d4e4ad3abf31aa7d5e2f6b8fdeaecaa597c4f71db62.png&#34; alt=&#34;picture 6&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;note info no-icon&#34;&gt;
&lt;ul&gt;
&lt;li&gt;Use Case 说明系统需要提供什么而不是怎么提供&lt;/li&gt;
&lt;li&gt;用户并不关心你如何给他们提供所需要的功能&lt;/li&gt;
&lt;li&gt;Use Case 一般是用 “动宾” 短语命名&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h4 id=&#34;用例图角色&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图角色&#34;&gt;#&lt;/a&gt; 用例图角色&lt;/h4&gt;
&lt;p&gt;与系统发生交互作用的、系统之外的任何东西都是角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以是人&lt;/li&gt;
&lt;li&gt;也可以是机器&lt;/li&gt;
&lt;li&gt;角色不等同于使用者&lt;/li&gt;
&lt;li&gt;角色存在于系统外部&lt;/li&gt;
&lt;li&gt;角色不是活动的准确描述&lt;/li&gt;
&lt;li&gt;使用者是行使某个角色职责的系统的使用人员&lt;/li&gt;
&lt;li&gt;每个 Actor 都通过不同的方式使用系统，除非他们是相同的 Actor&lt;/li&gt;
&lt;li&gt;Actor 使用系统的每一种方式就是一个 Use Case&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用例图步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图步骤&#34;&gt;#&lt;/a&gt; 用例图步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;找出拟建系统以外的 Actor
&lt;ul&gt;
&lt;li&gt;与系统交互的人员&lt;/li&gt;
&lt;li&gt;与系统相连并交换信息的设备和其他系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 Use Case 来描述 Actor 怎样使用系统以及系统向 Actor 提供什么功能
&lt;ul&gt;
&lt;li&gt;Use Case 表示从外部用户角度观察的系统功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绘制 Use Case 图，并编写详细的 Use Case 描述
&lt;ul&gt;
&lt;li&gt;Use Case 图只能宏观地描述系统的功能&lt;/li&gt;
&lt;li&gt;每个功能的含义和具体实现步骤则以文本方式描述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;用例图关联&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图关联&#34;&gt;#&lt;/a&gt; 用例图关联&lt;/h4&gt;
&lt;h5 id=&#34;include&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#include&#34;&gt;#&lt;/a&gt; Include&lt;/h5&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/7d07cd65f7fdc444d9718363ee93216f262a80d36c6f5937260da8c9df59a9d6.png&#34; alt=&#34;picture 7&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use Case 中的包含关系。&lt;/li&gt;
&lt;li&gt;通常发生在多个 Use Case 中，有可以提取出来的公共部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;note info no-icon&#34;&gt;
&lt;p&gt;如果用例 A 确实要调用到用例 B，那么，可以进一步分析：&lt;/p&gt;
&lt;p&gt;用例 A 是调用了用例 B 的所有流程呢，还是其中部分流程？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是调用部分流程，此时可以把用例 B 中的那部分流程提取出来，形成用例 C，然后用例 A 和用例 B 都 include 用例 C。&lt;/li&gt;
&lt;li&gt;如果是调用所有流程，那么，用例 A 直接 include 用例 B 即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h5 id=&#34;extend&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#extend&#34;&gt;#&lt;/a&gt; Extend&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;UseCaseA 不知道 UseCaseB 和 UseCaseC 的存在&lt;/li&gt;
&lt;li&gt;UseCaseB 和 UseCaseC 却是知道 UseCaseA 并且知道如何在 UseCaseA 中作扩展的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/c0ba883ab92da8f358ae138aecd0e9905684f57932395f6dd15ff0418b84aacd.png&#34; alt=&#34;picture 8&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;泛化关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#泛化关系&#34;&gt;#&lt;/a&gt; 泛化关系&lt;/h5&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/software-engineering/bdb3e3b1b28dd1d7e3700884f822f94f4a8a86a02fb984d149c3ecf064e7cc7c.png&#34; alt=&#34;picture 9&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当多个用例共同拥有一种类似的结构和行为的时候，将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。&lt;/li&gt;
&lt;li&gt;子用例继承了父用例所有的结构、行为和关系。&lt;/li&gt;
&lt;li&gt;在实际应用中很少使用泛化关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用例图规则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用例图规则&#34;&gt;#&lt;/a&gt; 用例图规则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;主动角色画在图的左边&lt;/li&gt;
&lt;li&gt;被动角色画在图的右边&lt;/li&gt;
&lt;li&gt;每个 Use Case 必须为用户提供确切的功能&lt;/li&gt;
&lt;li&gt;Use Case 名称必须写在椭圆里面&lt;/li&gt;
&lt;li&gt;每一张图里不能有太多的 Use Case&lt;/li&gt;
&lt;li&gt;为每一个 Use Case 编号便于检索&lt;/li&gt;
&lt;li&gt;为 Use Case 建立目录（编号和名称）便于管理&lt;/li&gt;
&lt;li&gt;保持图面整洁&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
