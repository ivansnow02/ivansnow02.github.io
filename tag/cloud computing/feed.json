{
    "version": "https://jsonfeed.org/version/1",
    "title": "IOyuk1Nya's Blog • All posts by \"cloud computing\" tag",
    "description": "some notes about computer science",
    "home_page_url": "https://blog.ivansnow02.xyz",
    "items": [
        {
            "id": "https://blog.ivansnow02.xyz/cloud-computing/",
            "url": "https://blog.ivansnow02.xyz/cloud-computing/",
            "title": "cloud_computing",
            "date_published": "2025-04-17T00:16:40.000Z",
            "content_html": "<h2 id=\"大数据与云计算\"><a class=\"anchor\" href=\"#大数据与云计算\">#</a> 大数据与云计算</h2>\n<h3 id=\"大数据时代\"><a class=\"anchor\" href=\"#大数据时代\">#</a> 大数据时代</h3>\n<h4 id=\"大数据定义\"><a class=\"anchor\" href=\"#大数据定义\">#</a> 大数据定义</h4>\n<p>指规模巨大，无法在合理时间内用主流 IT 系统进行采集、存储、管理、处理和分析，以支持决策的海量数据集。</p>\n<h4 id=\"大数据特征-4v1c\"><a class=\"anchor\" href=\"#大数据特征-4v1c\">#</a> 大数据特征 (4V+1C)</h4>\n<ul>\n<li><strong>Volume (量)</strong>: 数据量巨大 (PB 级常见)。</li>\n<li><strong>Velocity (速)</strong>: 数据产生速度快，需要快速处理。</li>\n<li><strong>Variety (类)</strong>: 格式多样 (结构化、半结构化、非结构化数据，如文本、音频、视频)。</li>\n<li><strong>Value (值)</strong>: 初始价值密度低，需要处理才能提取重要价值。</li>\n<li><strong>Complexity (复杂性)</strong>: 处理和分析难度大。</li>\n</ul>\n<h3 id=\"云计算大数据的计算\"><a class=\"anchor\" href=\"#云计算大数据的计算\">#</a> 云计算 —— 大数据的计算</h3>\n<h4 id=\"云计算和大数据关系\"><a class=\"anchor\" href=\"#云计算和大数据关系\">#</a> 云计算和大数据关系</h4>\n<ul>\n<li>类比: G = f (x)，其中目标 (G) 通过云计算 (f) 对大数据 (x) 进行处理来实现。</li>\n<li>云计算是处理大数据的<strong>手段</strong>。</li>\n<li>两者相互依存：没有大数据，不需要云计算；没有云计算，无法有效处理大数据。</li>\n</ul>\n<h4 id=\"云计算的起源与定义\"><a class=\"anchor\" href=\"#云计算的起源与定义\">#</a> 云计算的起源与定义</h4>\n<ul>\n<li>\n<p><strong>初始概念</strong>：像公用事业 (水、电) 一样提供海量资源池，按需付费；从拥有资源转向共享资源 (类似公共交通 vs 私家车)</p>\n</li>\n<li>\n<p><strong>定义</strong>:</p>\n<ul>\n<li><strong>长定义</strong>：一种商业计算模型，将任务分布在资源池上，提供按需的计算、存储和信息服务。</li>\n<li><strong>短定义</strong>：通过网络提供按需、动态可扩展、廉价的计算服务。</li>\n<li><strong>通用定义</strong>：一种分布式计算的商业模式，利用大量廉价机器构建可靠的海量资源池，通过网络按需访问。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"云计算的核心概念资源池\"><a class=\"anchor\" href=\"#云计算的核心概念资源池\">#</a> 云计算的核心概念：资源池</h4>\n<ul>\n<li>“云” = 大规模的 (通常是<strong>廉价</strong>) 服务器集群。</li>\n<li>资源被池化、虚拟化，并通过软件进行管理以实现可靠性和自我维护。</li>\n<li>计算能力通过互联网作为商品提供。</li>\n<li>用户动态按需访问资源，专注于业务逻辑。</li>\n</ul>\n<h4 id=\"云计算的关键特征-7个\"><a class=\"anchor\" href=\"#云计算的关键特征-7个\">#</a> 云计算的关键特征 (7 个)</h4>\n<ul>\n<li><strong>超大规模</strong></li>\n<li><strong>虚拟化</strong></li>\n<li><strong>高可靠性</strong></li>\n<li><strong>通用性</strong></li>\n<li><strong>高可伸缩性</strong></li>\n<li><strong>按需服务</strong></li>\n<li><strong>极其廉价</strong> (规模经济)</li>\n</ul>\n<h4 id=\"云计算的商业特征\"><a class=\"anchor\" href=\"#云计算的商业特征\">#</a> 云计算的商业特征</h4>\n<ul>\n<li>是一种商业模式 / 产业技术，不仅仅是学术研究。</li>\n<li>注重<strong>实用性</strong>和<strong>经济性</strong>。</li>\n<li>整合了成熟技术：互联网、分布式计算、虚拟化、自治管理。</li>\n</ul>\n<h3 id=\"云计算发展现状\"><a class=\"anchor\" href=\"#云计算发展现状\">#</a> 云计算发展现状</h3>\n<h4 id=\"服务模式分层\"><a class=\"anchor\" href=\"#服务模式分层\">#</a> 服务模式分层</h4>\n<ul>\n<li><strong>IaaS (基础设施即服务)</strong>: 基础计算 / 存储 / 网络 (例如 Amazon EC2/S3, 阿里云 ECS)。面向系统开发者。(通用)</li>\n<li><strong>PaaS (平台即服务)</strong>: 应用运行环境 (例如 Google App Engine, Azure, Hadoop)。面向应用开发者。</li>\n<li><strong>SaaS (软件即服务)</strong>: 即用型应用程序 (例如 Salesforce CRM, Alexa Web)。面向最终用户。(专用)</li>\n</ul>\n<h4 id=\"部署模式\"><a class=\"anchor\" href=\"#部署模式\">#</a> 部署模式</h4>\n<ul>\n<li><strong>公有云</strong>：对公众开放，由提供商管理。</li>\n<li><strong>私有云</strong>：为单个组织服务，自行管理或由第三方管理。</li>\n<li><strong>混合云</strong>：公有云和私有云的结合。</li>\n</ul>\n<h3 id=\"云计算实现机制\"><a class=\"anchor\" href=\"#云计算实现机制\">#</a> 云计算实现机制</h3>\n<h4 id=\"分层架构\"><a class=\"anchor\" href=\"#分层架构\">#</a> 分层架构</h4>\n<p><img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/2db4b87c98ac660c18ff0692c97fa3d9a38c07d91a211efd95943e9761f63d90.png\" alt=\"picture 0\" /></p>\n<ul>\n<li><strong>物理资源层</strong>：计算机、存储、网络、数据库、软件。</li>\n<li><strong>资源池层</strong>：对物理资源进行分组 (计算池、存储池、网络池、数据池、软件池)。</li>\n<li><strong>管理中间件层</strong>：管理资源、任务、用户、安全。(关键组件)。包括用户 / 任务 / 资源 / 安全管理子模块 (负载均衡、故障处理、监控、认证 / 授权、计费等)。</li>\n<li><strong>SOA (面向服务的架构) 层</strong>：将能力暴露为标准的 Web 服务 (接口、注册、发现、调用、工作流)。</li>\n</ul>\n<h3 id=\"云计算优势\"><a class=\"anchor\" href=\"#云计算优势\">#</a> 云计算优势</h3>\n<h4 id=\"成本效益\"><a class=\"anchor\" href=\"#成本效益\">#</a> 成本效益</h4>\n<ul>\n<li>解决传统 IT 成本上升问题 (管理、电力 / 冷却)</li>\n<li><strong>规模经济</strong>：大型数据中心单位成本显著降低 (网络、存储、管理)</li>\n<li><strong>优化选址</strong>：部署在电力廉价 (水电)、气候凉爽、土地成本低的地区</li>\n<li><strong>自动化</strong>：降低人力成本</li>\n<li><strong>高利用率</strong>：云计算利用率约 80%，而传统 IT 仅 10-15%，总成本节省超过 30 倍</li>\n</ul>\n<h4 id=\"用户收益\"><a class=\"anchor\" href=\"#用户收益\">#</a> 用户收益</h4>\n<ul>\n<li>低规格的客户端设备即可满足需求。</li>\n<li>按需付费模式使得用户能以可承受的价格获得强大的资源。</li>\n<li>无需购买 / 维护软件或担心硬件升级。</li>\n<li>节省资源，环境友好。</li>\n</ul>\n<h4 id=\"核心架构思想\"><a class=\"anchor\" href=\"#核心架构思想\">#</a> 核心架构思想</h4>\n<ul>\n<li>“团结就是力量” - 许多廉价的商用机器协同工作，提供大规模、可靠、高性能的服务 (类比：鱼群 vs 鲨鱼)。</li>\n</ul>\n<h2 id=\"复习题-习题\"><a class=\"anchor\" href=\"#复习题-习题\">#</a> 复习题 (习题)</h2>\n<ul>\n<li>\n<p><strong>大数据是如何形成的</strong><br />\n数据产生方式的改变；人类的活动越来越依赖数据</p>\n</li>\n<li>\n<p><strong>新摩尔定律 (Jim Gray 版本) 的含义</strong></p>\n<ul>\n<li>全球信息量呈指数增长：每 18 个月产生的新数据量等同于此前累积的全部数据总和</li>\n<li>强调数据规模爆炸式扩大，说明对存储、计算和分析能力提出了更高要求</li>\n<li>反映信息技术和社会活动对数据生成与处理的双重推动作用</li>\n</ul>\n</li>\n<li>\n<p><strong>云计算的特征</strong></p>\n<ul>\n<li>虚拟化：对计算、存储、网络资源进行抽象与隔离，提高利用率与灵活性。</li>\n<li>按需服务：动态分配与释放资源，用户只为实际使用付费。</li>\n<li>商用硬件：使用廉价大规模服务器构建资源池，降低总体成本。</li>\n<li>通用性：支持多种应用场景与工作负载。</li>\n<li>可靠性：通过冗余、故障检测与自动恢复保障服务可用。</li>\n<li>可伸缩性：根据负载变化快速横向或纵向扩展资源。</li>\n</ul>\n</li>\n<li>\n<p><strong>云计算的分类</strong></p>\n<ul>\n<li>服务模型\n<ul>\n<li>IaaS（基础设施即服务）</li>\n<li>PaaS（平台即服务）</li>\n<li>SaaS（软件即服务）</li>\n</ul>\n</li>\n<li>部署模式\n<ul>\n<li>公有云：第三方提供商面向公共的云服务。</li>\n<li>私有云：组织内部或委托第三方私有部署。</li>\n<li>混合云：公有云与私有云结合，兼顾灵活性与安全性。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>云计算的架构层次</strong></p>\n<ol>\n<li>物理层：物理服务器、存储、网络设备等硬件资源。</li>\n<li>资源池层：通过虚拟化将物理资源划分为计算池、存储池、网络池等。</li>\n<li>中间件层：负责资源管理、调度、监控、安全和计费等核心功能。</li>\n<li>服务 / SOA 层：以标准化 API 或 Web 服务形式向用户暴露能力。</li>\n</ol>\n</li>\n<li>\n<p><strong>云计算相对于传统 IT 的成本优势</strong></p>\n<ul>\n<li>规模经济：大规模数据中心降低单位硬件和运维成本。</li>\n<li>按需付费：避免闲置资源浪费，费用与使用量挂钩。</li>\n<li>自动化运维：集中管理、自动部署和弹性伸缩减少人力成本。</li>\n<li>高资源利用率：多租户共享提高硬件利用率，进一步降低总体投入。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式计算\"><a class=\"anchor\" href=\"#分布式计算\">#</a> 分布式计算</h2>\n<h3 id=\"分布式计算概述\"><a class=\"anchor\" href=\"#分布式计算概述\">#</a> 分布式计算概述</h3>\n<h4 id=\"基本概念\"><a class=\"anchor\" href=\"#基本概念\">#</a> 基本概念</h4>\n<ul>\n<li><strong>集中式计算</strong>:\n<ul>\n<li>所有数据和任务集中在一台计算机上处理。</li>\n<li>该计算机负责管理和处理所有数据 / 任务，并提供服务给用户。</li>\n</ul>\n</li>\n<li><strong>分布式计算</strong>:\n<ul>\n<li>利用多台计算机联合完成任务。</li>\n<li>通过网络通信，按规则分配工作量和数据，协作完成处理任务。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"集中式-vs-分布式对比\"><a class=\"anchor\" href=\"#集中式-vs-分布式对比\">#</a> 集中式 vs 分布式对比</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对比项</th>\n<th style=\"text-align:left\">集中式计算</th>\n<th style=\"text-align:left\">分布式计算</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>定义</strong></td>\n<td style=\"text-align:left\">计算资源集中一处处理管理</td>\n<td style=\"text-align:left\">计算资源分散多处处理管理</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>资源分配</strong></td>\n<td style=\"text-align:left\">计算机集中处理管理所有资源</td>\n<td style=\"text-align:left\">资源分散在多台计算机上管理分配</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数据共享</strong></td>\n<td style=\"text-align:left\">数据集中存储，只能由该计算机访问共享</td>\n<td style=\"text-align:left\">数据可分布在多台计算机上，可共享访问</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>处理能力</strong></td>\n<td style=\"text-align:left\">受单机硬件限制</td>\n<td style=\"text-align:left\">通过任务分配给多台计算机提高处理能力</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>可靠性 / 安全性</strong></td>\n<td style=\"text-align:left\">单点故障 / 攻击影响整个系统</td>\n<td style=\"text-align:left\">单个计算机故障 / 攻击，其他计算机仍可继续计算任务</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>成本</strong></td>\n<td style=\"text-align:left\">通常需大型机 / 高性能服务器，成本高</td>\n<td style=\"text-align:left\">可利用廉价计算机集群，成本相对较低</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分布式计算优点\"><a class=\"anchor\" href=\"#分布式计算优点\">#</a> 分布式计算优点</h4>\n<ul>\n<li><strong>高效性</strong>：利用多机处理能力，提高效率和吞吐量。</li>\n<li><strong>可扩展性</strong>：通过增加节点扩展计算能力。</li>\n<li><strong>容错性</strong>：通过备份和任务处理节点实现容错和高可靠性。</li>\n<li><strong>低成本</strong>：利用廉价计算资源降低成本。</li>\n<li><strong>数据局部性</strong>：利用计算节点附近数据，减少传输开销。</li>\n</ul>\n<h4 id=\"集中式计算优点\"><a class=\"anchor\" href=\"#集中式计算优点\">#</a> 集中式计算优点</h4>\n<ul>\n<li><strong>简单性</strong>：统一管理，简化计算和管理复杂性。</li>\n<li><strong>稳定性</strong>：单计算机保证计算和管理的稳定可靠性。</li>\n<li><strong>统一性</strong>：统一管理控制数据和任务流程规则。</li>\n<li><strong>安全性</strong>：单计算机管理保护数据和任务安全机密性。</li>\n<li><strong>性能优化</strong>：单计算机优化资源使用，提高效率和性能。</li>\n</ul>\n<h4 id=\"分布式计算应用场景\"><a class=\"anchor\" href=\"#分布式计算应用场景\">#</a> 分布式计算应用场景</h4>\n<ul>\n<li>大规模数据处理 (搜索引擎、数据挖掘、机器学习)</li>\n<li>高性能计算 (科学计算、模拟、仿真)</li>\n<li>分布式存储 (分布式文件系统、分布式数据库)</li>\n<li>实时数据处理 (流计算、实时推荐)</li>\n<li>区块链技术 (比特币、以太坊)</li>\n</ul>\n<h4 id=\"分布式计算原理-分而治之\"><a class=\"anchor\" href=\"#分布式计算原理-分而治之\">#</a> 分布式计算原理 (分而治之)</h4>\n<ul>\n<li><strong>『分』</strong>: 将复杂庞大任务划分为小任务。</li>\n<li><strong>『计算』</strong>: 子任务分配到不同节点并行执行。</li>\n<li><strong>『合』</strong>: 汇总各节点结果得到最终结果。</li>\n<li><strong>难点</strong>：任务划分、多节点通信方式。</li>\n</ul>\n<h4 id=\"分布式计算步骤\"><a class=\"anchor\" href=\"#分布式计算步骤\">#</a> 分布式计算步骤</h4>\n<ol>\n<li><strong>设计分布式计算模型</strong>：决定组件如何运行、通信、管理节点。</li>\n<li><strong>分布式任务分配</strong>：解决任务能否 / 如何分配到各节点。</li>\n<li><strong>编写并执行分布式程序</strong>：使用特定框架 / 模型转化算法为实现，保证集群高效运行。</li>\n</ol>\n<h3 id=\"分布式计算的理论基础\"><a class=\"anchor\" href=\"#分布式计算的理论基础\">#</a> 分布式计算的理论基础</h3>\n<h4 id=\"acid原则-本地事务管理-内部一致性\"><a class=\"anchor\" href=\"#acid原则-本地事务管理-内部一致性\">#</a> ACID 原则 (本地事务管理、内部一致性)</h4>\n<ul>\n<li><strong>原子性 (Atomicity)</strong>: 操作要么全成功，要么全失败，无中间状态。</li>\n<li><strong>一致性 (Consistency)</strong>: 事务处理前后，不改变数据库原本的一致性约束。(<strong>核心目标</strong>)</li>\n<li><strong>隔离性 (Isolation)</strong>: 并发事务间独立，互不干扰。 (手段：写锁、读锁、范围锁)</li>\n<li><strong>持久性 (Duration)</strong>: 事务生效后，对数据库的改变永久保存。(手段: Commit Logging)</li>\n<li><strong>困难</strong>: &quot;写入磁盘&quot; 非原子操作。</li>\n<li><strong>手段</strong>：原子性、隔离性、持久性</li>\n<li><strong>目标</strong>：一致性</li>\n</ul>\n<h4 id=\"acid原则缺点\"><a class=\"anchor\" href=\"#acid原则缺点\">#</a> ACID 原则缺点</h4>\n<ul>\n<li><strong>性能开销</strong>：锁定、日志记录影响并发处理能力。</li>\n<li><strong>扩展性</strong>：强制一致性，难扩展到大规模分布式系统多节点。</li>\n<li><strong>难以维护</strong>：事务失败回滚复杂，需协调多组件交互。</li>\n</ul>\n<h4 id=\"cap理论-分布式事务-外部一致性\"><a class=\"anchor\" href=\"#cap理论-分布式事务-外部一致性\">#</a> CAP 理论 (分布式事务、外部一致性)</h4>\n<ul>\n<li><strong>定义</strong>：分布式系统最多同时满足以下三项中的两项：\n<ul>\n<li><strong>一致性 (Consistency)</strong>: 所有节点访问同一份最新数据副本。</li>\n<li><strong>可用性 (Availability)</strong>: 每次请求都能获取非错响应 (不保证最新数据)。</li>\n<li><strong>分区容错性 (Partition tolerance)</strong>: 网络分区时，系统仍能继续运行。(分布式系统<strong>必须</strong>满足)</li>\n</ul>\n</li>\n<li><strong>起源</strong>: Eric Brewer 提出猜想 (2000)，Seth Gilbert &amp; Nancy Lynch 证明 (2002)。</li>\n</ul>\n<h4 id=\"cap理论阐述\"><a class=\"anchor\" href=\"#cap理论阐述\">#</a> CAP 理论阐述</h4>\n<ul>\n<li><strong>正常流程</strong>: N1, N2 数据一致 (V0)，均可用。网络正常，分区容错性满足。<br />\n<img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/ba463d4a4ff080a698df315fb702b123581ee2092460774bda2d0e38707f857b.png\" alt=\"picture 1\" /></li>\n<li><strong>网络分区时</strong>: N1 与 N2 网络断开。用户向 N2 请求读数据。<br />\n<img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/d1bfad52c77f0fdf4296748c1eace3c380925327d9d5fa39c7148afaa7056aef.png\" alt=\"picture 2\" />\n<ul>\n<li><strong>选择一 (牺牲一致性 C, 保留可用性 A)</strong>: N2 无法同步 N1 的新数据 V1，响应旧数据 V0 给用户。(AP)</li>\n<li><strong>选择二 (牺牲可用性 A, 保留一致性 C)</strong>: N2 阻塞等待，直到网络恢复、数据同步 M 完成，再响应最新数据 V1。(CP)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"cap权衡\"><a class=\"anchor\" href=\"#cap权衡\">#</a> CAP 权衡</h4>\n<ul>\n<li><strong>(1) CA w/o P</strong>: 放弃分区容错性。假设节点间通信永远可靠。不是真正的分布式系统。(例: Oracle RAC 使用共享磁盘避免网络分区)</li>\n<li><strong>(2) CP w/o A</strong>: 放弃可用性。保证强一致性，分区发生时可能导致请求超时或错误。(例: HBase RegionServer 宕机期间数据不可用)</li>\n<li><strong>(3) AP w/o C</strong>: 放弃 (强) 一致性。保证高可用，分区发生时节点用本地数据提供服务，可能导致数据不一致。(例: Redis 分区后各节点返回本地数据) (<strong>主流选择</strong>)</li>\n</ul>\n<h4 id=\"base理论\"><a class=\"anchor\" href=\"#base理论\">#</a> BASE 理论</h4>\n<ul>\n<li><strong>定义</strong>：对 CAP 中一致性和可用性权衡的结果，核心思想是即使无法做到强一致性，但应用可采用适合方式达到<strong>最终一致性</strong>。</li>\n<li><strong>Basically Available (基本可用)</strong>: 系统在分区、部分节点故障时，仍能保证核心功能可用。</li>\n<li><strong>Soft State (软状态)</strong>: 系统状态允许在不同节点间存在中间状态，不要求实时一致。</li>\n<li><strong>Eventually Consistent (最终一致性)</strong>: 系统中所有数据副本经过一段时间后，最终能够达到一致状态。</li>\n<li><strong>核心思想</strong>：牺牲强一致性换取高可用性和灵活性，适用于对一致性要求不高的场景。</li>\n</ul>\n<h4 id=\"base与acid对比\"><a class=\"anchor\" href=\"#base与acid对比\">#</a> BASE 与 ACID 对比</h4>\n<ul>\n<li><strong>ACID</strong>: 传统数据库设计理念，追求<strong>强一致性</strong>模型。</li>\n<li><strong>BASE</strong>: 大型分布式系统设计理念，通过牺牲强一致性获得<strong>高可用性</strong>。</li>\n</ul>\n<h4 id=\"一致性散列\"><a class=\"anchor\" href=\"#一致性散列\">#</a> 一致性散列</h4>\n<ul>\n<li><strong>问题背景</strong>：分布式集群存储数据，如何将对象散列到不同机器？</li>\n<li><strong>简单散列</strong>:  <code>server = hash(key) mod N</code>  (N 为机器数)。</li>\n<li><strong>再散列问题 (Rehashing)</strong>: 当服务器数量 N 变化 (增 / 减机器) 时， <code>hash % N</code>  结果大多会改变，导致<strong>大部分 KV 对需要迁移</strong>。</li>\n</ul>\n<h4 id=\"一致性散列算法-consistent-hashing\"><a class=\"anchor\" href=\"#一致性散列算法-consistent-hashing\">#</a> 一致性散列算法 (Consistent Hashing)</h4>\n<ul>\n<li><strong>定义</strong>：将整个哈希值空间 (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mi mathvariant=\"normal\">.</mi><mi>g</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><mn>0</mn><mtext> </mtext><msup><mn>2</mn><mn>128</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">e.g., 0 ~ 2^{128}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">.</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mspace nobreak\"> </span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">128</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>) 组织成虚拟圆环。</li>\n<li><strong>映射</strong>：将服务器和对象 Key 都通过哈希函数映射到环上。</li>\n<li><strong>归属</strong>：对象存储在沿环顺时针遇到的第一个服务器上。</li>\n<li><strong>应用</strong>：高流量动态网站的分布式缓存 (Redis, MemCache) 实现请求动态均衡。</li>\n<li><strong>容错性</strong>：节点宕机 (Node C)，只影响其负责的数据 (对象 C)，这些数据重定位到下一个节点 (Node D)。对象 A, B, D 不受影响。<br />\n<img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/428f0ecf55bd42a436e91cc034293b84cfd67d15efac7a4fd4abd858c7b661df.png\" alt=\"picture 3\" /></li>\n<li><strong>扩展性</strong>：增加节点 (Node X)，只影响新节点与其前一个节点之间的数据 (对象 C 需重定位到 Node X)。对象 A, B, D 不受影响。<br />\n<img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/acc3b19003815406bc1bbbc8c30e4e6584b9cdb23a07e9c478cdb0addffa9d35.png\" alt=\"picture 4\" /></li>\n<li><strong>虚拟节点</strong>：为解决物理节点哈希分布不均问题，将每个物理服务器映射为多个虚拟节点分散在环上，使数据分布更均匀。权重高的服务器可分配更多虚拟节点。<br />\n<img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/80742fb29ae26c125bdce4328491077f6a95838dc11adbd7d055a5219b88e114.png\" alt=\"picture 5\" /></li>\n</ul>\n<h3 id=\"分布式系统概述\"><a class=\"anchor\" href=\"#分布式系统概述\">#</a> 分布式系统概述</h3>\n<h4 id=\"基础知识-大数据驱动\"><a class=\"anchor\" href=\"#基础知识-大数据驱动\">#</a> 基础知识 (大数据驱动)</h4>\n<ul>\n<li><strong>驱动力</strong>：大数据技术需求推动分布式系统发展。</li>\n<li><strong>演变</strong>：源于互联网公司大规模分布式存储系统需求。</li>\n<li><strong>扩展方式</strong>:\n<ul>\n<li><strong>纵向扩展 (Scale Up)</strong>: 传统方式，使用更强服务器 (小型机 -&gt; 中型机 -&gt; 大型机)，成本高、稳定。</li>\n<li><strong>横向扩展 (Scale Out)</strong>: 使用大量廉价普通服务器通过网络连接，成本低、故障率高。</li>\n</ul>\n</li>\n<li><strong>挑战与解决</strong>:\n<ul>\n<li>故障率高 -&gt; 软件实现自动容错、保证数据一致性。</li>\n<li>增加服务器 -&gt; 软件实现自动负载均衡，系统处理能力线性扩展。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"实例apache-hadoop\"><a class=\"anchor\" href=\"#实例apache-hadoop\">#</a> 实例：Apache Hadoop</h4>\n<ul>\n<li><strong>定义</strong>: Apache 基金会开发的分布式存储与计算框架。</li>\n<li><strong>创始人</strong>: Doug Cutting (就职 Yahoo 期间开发，现 Cloudera)。</li>\n<li><strong>思想来源</strong>: Google 论文公开的 GFS, MapReduce, Bigtable 思想。</li>\n<li><strong>发展简史</strong>:\n<ul>\n<li>2003-2004: Doug Cutting 基于 Google 论文实现 Nutch (DFS + MapReduce 微缩版)。</li>\n<li>2005 秋: Nutch 子项目引入 Apache 基金会。</li>\n<li>2006.3: MapReduce 和 NDFS (后改名 HDFS) 纳入 Hadoop 项目。</li>\n</ul>\n</li>\n<li><strong>核心组件</strong>:\n<ul>\n<li><strong>HDFS (Hadoop Distributed File System)</strong>: 提供高可靠、高扩展、高吞吐率的分布式数据存储服务。</li>\n<li><strong>MapReduce</strong>: 并行、分布式计算框架，易使用、高容错、高扩展。</li>\n</ul>\n</li>\n<li><strong>云计算服务模型</strong>: Hadoop 通常属于 <strong>PaaS</strong> (平台即服务) 层，运行在 IaaS (如 AWS EC2/S3, 阿里云 ECS) 之上。</li>\n</ul>\n<h3 id=\"分布式系统的进阶\"><a class=\"anchor\" href=\"#分布式系统的进阶\">#</a> 分布式系统的进阶</h3>\n<h4 id=\"分布式存储系统-5个子方向\"><a class=\"anchor\" href=\"#分布式存储系统-5个子方向\">#</a> 分布式存储系统 (5 个子方向)</h4>\n<ol>\n<li><strong>结构化存储</strong>：关系型数据库 (MySQL)。强一致性 (银行系统)，支持随机访问 (SQL, 索引)。</li>\n<li><strong>非结构化存储</strong>：分布式文件系统 (GFS, HDFS)。存储海量数据 (网页)，配合批量处理。高扩展、高吞吐。不支持随机访问，不适用低延时、实时应用。</li>\n<li><strong>半结构化存储</strong>: NoSQL, KV Store (对象存储)。解决非结构化存储随机访问性能差问题。通常<strong>抛弃 ACID</strong> 换取性能和扩展性。</li>\n<li><strong>In-memory 存储</strong>: Memcached, Redis。数据存内存，读写高性能。</li>\n<li><strong>NewSQL</strong>: Google Spanner。兼备 RDBMS (SQL, ACID) 和 NoSQL (扩展能力)。(目前工业界支持较少)</li>\n</ol>\n<h4 id=\"分布式计算系统\"><a class=\"anchor\" href=\"#分布式计算系统\">#</a> 分布式计算系统</h4>\n<ul>\n<li>\n<p><strong>分布式计算 vs 并行计算</strong>:</p>\n<ul>\n<li><strong>并行计算</strong>：目标是<strong>高性能</strong> (投入更多机器，数据量不变，计算更快)。无内置 &quot;容错&quot; 概念。</li>\n<li><strong>分布式计算</strong>：目标是<strong>高可扩展性</strong> (投入更多机器，处理更大规模数据)。核心是<strong>容错</strong>。</li>\n</ul>\n</li>\n<li>\n<p><strong>分布式计算系统 (5 个子方向)</strong>:</p>\n<ol>\n<li><strong>传统基于消息的系统</strong>: MPI (Message Passing Interface)。框架灵活，约束少，<strong>不支持容错</strong> (或有限)。(MPICH2, OpenMPI)</li>\n<li><strong>MapReduce 家族系统</strong>: MapReduce, Spark。程序结构有严格约束 (Map, Reduce 等高层操作)，抽象为 DAG。可扩展至超大规模集群，<strong>具备容错机制</strong>，但节点同步效率可能低。</li>\n<li><strong>图计算系统</strong>: Pregel (BSP 模型), GraphLab (GAS 模型)。专门处理图结构数据。</li>\n<li><strong>基于状态的系统</strong>: Piccolo, DistBelief, Parameter Server。适用于需要维护和同步全局状态的应用 (如大规模机器学习)。</li>\n<li><strong>实时流处理系统</strong>: Apache Storm。高效实时处理流式数据，关注<strong>实时性</strong>。在连续数据窗口内执行 SQL 类操作。</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"1-传统基于消息的系统-mpi\"><a class=\"anchor\" href=\"#1-传统基于消息的系统-mpi\">#</a> 1. 传统基于消息的系统 (MPI)</h5>\n<ul>\n<li><strong>基本思想</strong>：程序分多个进程，进程间传递消息和数据。</li>\n<li><strong>进程位置</strong>：可在同机不同线程、不同机器进程、甚至不同操作系统进程。</li>\n<li><strong>通信模型</strong>:\n<ul>\n<li><strong>点对点通信</strong>：两进程间直接通信 (发送、接收)。</li>\n<li><strong>集合通信</strong>：多进程间数据收集与分发 (广播、聚集、散布)。</li>\n</ul>\n</li>\n<li><strong>示例</strong>:  <code>scatter</code>  (发散：将根进程数据分发给各进程),  <code>gather</code>  (收集：将各进程数据收集到根进程)。</li>\n</ul>\n<h5 id=\"2-mapreduce家族系统-mapreduce-spark\"><a class=\"anchor\" href=\"#2-mapreduce家族系统-mapreduce-spark\">#</a> 2. MapReduce 家族系统 (MapReduce, Spark)</h5>\n<ul>\n<li><strong>MapReduce</strong>:\n<ul>\n<li><strong>批处理模型</strong>。</li>\n<li>数据<strong>存储在磁盘</strong>上，适合大规模数据批处理。</li>\n<li>磁盘 I/O 较多。</li>\n</ul>\n</li>\n<li><strong>Spark</strong>:\n<ul>\n<li>支持<strong>流处理和批处理</strong>两种模型。</li>\n<li>采用<strong>内存计算</strong>思想，更灵活、更快。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-图计算系统-pregelbsp-graphlabgas\"><a class=\"anchor\" href=\"#3-图计算系统-pregelbsp-graphlabgas\">#</a> 3. 图计算系统 (Pregel/BSP &amp; GraphLab/GAS)</h5>\n<ul>\n<li><strong>Pregel (BSP 模型 - Bulk Synchronous Parallel)</strong>:\n<ul>\n<li>计算任务分若干<strong>超级步 (Supersteps)</strong>。</li>\n<li>每步包含三个阶段: <strong>计算、通信、同步</strong>。</li>\n<li>所有节点完成计算和通信后，等待同步，再进入下一步。</li>\n<li><strong>同步通信模式</strong>：本轮计算结果在下一轮生效。</li>\n</ul>\n</li>\n<li><strong>GraphLab (GAS 模型 - Gather, Apply, Scatter)</strong>:\n<ul>\n<li>计算任务分三个阶段:\n<ul>\n<li><strong>Gather</strong>: 从邻居节点收集信息。</li>\n<li><strong>Apply</strong>: 根据收集的信息更新自身状态。</li>\n<li><strong>Scatter</strong>: 将更新后的状态信息发送给邻居节点。</li>\n</ul>\n</li>\n<li><strong>异步通信模式</strong>：本轮计算结果在本轮立即生效。算法收敛快，但可能存在数据不一致问题。</li>\n<li>可在单机或分布式环境运行。Pregel 只能在分布式环境。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"5-实时流处理系统-storm\"><a class=\"anchor\" href=\"#5-实时流处理系统-storm\">#</a> 5. 实时流处理系统 (Storm)</h5>\n<ul>\n<li><strong>定义</strong>：处理<strong>实时、连续、无界</strong>数据流的系统。</li>\n<li><strong>特点</strong>:\n<ul>\n<li><strong>简单编程模型</strong>：类似 MapReduce 降低并行批处理复杂性，Storm 降低实时处理复杂性。</li>\n<li><strong>多种编程语言</strong>：默认 Clojure, 支持 Java, Ruby, Python 等。</li>\n<li><strong>容错性</strong>：管理工作进程和节点故障。</li>\n<li><strong>横向扩展</strong>：计算在多线程、进程、服务器并行进行。</li>\n<li><strong>可靠的消息处理</strong>：保证消息至少被完整处理一次。失败时从源头重试。</li>\n<li><strong>快速</strong>：使用 ZeroMQ 作为底层消息队列，保证消息快速处理。</li>\n</ul>\n</li>\n<li><strong>Storm vs MapReduce/Spark (数据与计算流向)</strong>:\n<ul>\n<li><strong>MapReduce/Spark</strong>: <strong>计算传递给数据</strong>。节点存储 / 缓存数据集，任务提交给节点。批量处理持久化<strong>全量数据</strong>。</li>\n<li><strong>Storm</strong>: <strong>数据传递给计算</strong>。节点实现基本计算过程，数据项流经网络节点。动态处理大量生成<strong>小数据块</strong>。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分布式资源管理系统\"><a class=\"anchor\" href=\"#分布式资源管理系统\">#</a> 分布式资源管理系统</h4>\n<ul>\n<li><strong>需求背景</strong>:\n<ul>\n<li>多种计算框架 (MapReduce, Spark, Storm, MPI) 可能并存。</li>\n<li>希望部署到<strong>公共集群</strong>，共享资源，统一管理。</li>\n</ul>\n</li>\n<li><strong>目标</strong>：提高资源利用率、降低运维成本、方便数据共享。</li>\n<li><strong>典型代表</strong>: Mesos, YARN。</li>\n</ul>\n<h5 id=\"统一管理调度平台特点\"><a class=\"anchor\" href=\"#统一管理调度平台特点\">#</a> 统一管理调度平台特点</h5>\n<ol>\n<li><strong>支持多种计算框架</strong>：平台本身不耦合特定框架。</li>\n<li><strong>扩展性</strong>：平台自身不应成为框架水平扩展的瓶颈。</li>\n<li><strong>容错性</strong>：在保持原有框架容错性基础上，平台自身也应具备良好容错性。</li>\n<li><strong>高资源利用率</strong>:\n<ul>\n<li><strong>静态资源分配 (问题)</strong>: 每个框架分配固定集群，利用率低 (e.g., 10-30%)。</li>\n<li><strong>资源统一管理 (解决)</strong>: 统一管理调度各种框架，提升整体资源利用率 (e.g.,&gt;70%)。</li>\n</ul>\n</li>\n<li><strong>细粒度的资源分配</strong>:\n<ul>\n<li><strong>粗粒度共享 (Coarse-Grained)</strong>: 整个节点分配给一个框架 / 任务。</li>\n<li><strong>细粒度共享 (Fine-Grained)</strong>: 直接按任务实际需求 (CPU, 内存) 分配资源。(Mesos 方式)</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"apache-hadoop-yarn-yet-another-resource-negotiator\"><a class=\"anchor\" href=\"#apache-hadoop-yarn-yet-another-resource-negotiator\">#</a> Apache Hadoop YARN (Yet Another Resource Negotiator)</h5>\n<ul>\n<li><strong>背景</strong>：下一代 MapReduce (MRv2)，为解决 MRv1 扩展性差、不支持多计算框架问题。完全重写。</li>\n<li><strong>架构</strong>:\n<ul>\n<li><strong>ResourceManager (RM)</strong>: 全局资源管理器 (Master)。负责资源分配与调度。功能简单，不易成瓶颈。</li>\n<li><strong>NodeManager (NM)</strong>: 节点管理器 (Slave)。负责启动 / 监控 Container，上报资源使用情况给 RM。</li>\n<li><strong>ApplicationMaster (AM)</strong>: 每个应用程序对应一个 AM。负责向 RM 申请资源，与 NM 交互启动 / 监控任务。<strong>(有具体应用的调度功能)</strong></li>\n<li><strong>Container</strong>: YARN 中资源分配的基本单位 (CPU, 内存等)。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"apache-mesos\"><a class=\"anchor\" href=\"#apache-mesos\">#</a> Apache Mesos</h5>\n<ul>\n<li><strong>架构</strong>:\n<ul>\n<li><strong>Mesos Master</strong>: 保存 Framework 和 Slave 状态。使用 Zookeeper 解决单点故障。<strong>全局资源调度器</strong>。</li>\n<li><strong>Mesos Slave (Agent)</strong>: 运行任务，向 Master 汇报状态，运行 Executor。</li>\n<li><strong>Framework</strong>: 计算框架，包含 Scheduler (向 Master 注册，接收资源 offer) 和 Executor (在 Slave 上运行具体任务，e.g., Hadoop TaskTracker)。</li>\n</ul>\n</li>\n<li><strong>资源分配流程 (两层调度)</strong>:\n<ol>\n<li>Agent 向 Master 汇报空闲资源。</li>\n<li>Master 根据策略将资源 Offer (e.g., &lt;Agent1, 4 CPU, 4GB RAM&gt;) 提供给某个 Framework (e.g., Framework 1)。</li>\n<li>Framework Scheduler 回复 Master 是否接受 Offer，并告知要在该资源上运行的任务列表及资源需求。</li>\n<li>Master 将任务信息发送给 Agent。</li>\n<li>Agent 分配资源给 Framework 的 Executor，Executor 启动任务。</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"mesos与yarn比较\"><a class=\"anchor\" href=\"#mesos与yarn比较\">#</a> Mesos 与 YARN 比较</h5>\n<ol>\n<li><strong>框架担任的角色</strong>:\n<ul>\n<li><strong>Mesos</strong>: 计算框架需<strong>完全融入</strong> Mesos (部署 Scheduler 和 Executor)。添加新框架需部署。</li>\n<li><strong>YARN</strong>: 框架仅是<strong>应用程序库</strong>。无需事先部署框架。YARN 运行和使用更方便。</li>\n</ul>\n</li>\n<li><strong>调度机制 (均为双层调度)</strong>:\n<ul>\n<li><strong>Mesos</strong>: <strong>资源推送</strong>。Master 将资源 Offer 推给 Framework，由 Framework 决定是否接受及如何使用。<strong>Mesos 本身不知应用资源需求</strong>。</li>\n<li><strong>YARN</strong>: <strong>资源请求</strong>。ApplicationMaster 向 YARN (RM) 汇报任务资源需求。<strong>YARN 根据需求为应用分配资源</strong>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"课后习题\"><a class=\"anchor\" href=\"#课后习题\">#</a> 课后习题</h3>\n<ol>\n<li>分布式计算的定义和特征是什么？</li>\n<li>什么是 ACID 原则？</li>\n<li>什么是 CAP 理论？</li>\n<li>什么是 BASE 理论？</li>\n<li>如何理解最终一致性？</li>\n<li>各类分布式存储、分布式计算的区别与联系是什么？</li>\n</ol>\n<h3 id=\"课外思考\"><a class=\"anchor\" href=\"#课外思考\">#</a> 课外思考</h3>\n<ol>\n<li>为什么日常生活中接触到的分布式系统越来越多了？</li>\n<li>CAP 定理中几个关键因素为什么不能同时保证？不同组合有什么应用场景？</li>\n<li>了解区块链背景后，说说你理解的区块链作为一种分布式系统背后的全新理念。</li>\n</ol>\n",
            "tags": [
                "computer science",
                "learning",
                "cloud computing"
            ]
        }
    ]
}