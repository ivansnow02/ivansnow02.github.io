<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.ivansnow02.xyz</id>
    <title>IOyuk1Nya&#39;s Blog • Posts by &#34;cloud computing&#34; tag</title>
    <link href="https://blog.ivansnow02.xyz" />
    <updated>2025-04-17T00:16:40.000Z</updated>
    <category term="coding" />
    <category term="algorithms" />
    <category term="computer science" />
    <category term="learning" />
    <category term="Compilers" />
    <category term="Django" />
    <category term="Python" />
    <category term="computer graphics" />
    <category term="trash" />
    <category term="Redis" />
    <category term="Java" />
    <category term="English" />
    <category term="test" />
    <category term="vim" />
    <category term="cloud computing" />
    <category term="Math" />
    <category term="Linear Algebra" />
    <category term="software engineering" />
    <category term="Spring" />
    <category term="Physics" />
    <category term="Discrete Mathematics" />
    <category term="data structure" />
    <category term="coursera" />
    <category term="tree" />
    <entry>
        <id>https://blog.ivansnow02.xyz/cloud-computing/</id>
        <title>cloud_computing</title>
        <link rel="alternate" href="https://blog.ivansnow02.xyz/cloud-computing/"/>
        <content type="html">&lt;h2 id=&#34;大数据与云计算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大数据与云计算&#34;&gt;#&lt;/a&gt; 大数据与云计算&lt;/h2&gt;
&lt;h3 id=&#34;大数据时代&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大数据时代&#34;&gt;#&lt;/a&gt; 大数据时代&lt;/h3&gt;
&lt;h4 id=&#34;大数据定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大数据定义&#34;&gt;#&lt;/a&gt; 大数据定义&lt;/h4&gt;
&lt;p&gt;指规模巨大，无法在合理时间内用主流 IT 系统进行采集、存储、管理、处理和分析，以支持决策的海量数据集。&lt;/p&gt;
&lt;h4 id=&#34;大数据特征-4v1c&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大数据特征-4v1c&#34;&gt;#&lt;/a&gt; 大数据特征 (4V+1C)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Volume (量)&lt;/strong&gt;: 数据量巨大 (PB 级常见)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Velocity (速)&lt;/strong&gt;: 数据产生速度快，需要快速处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Variety (类)&lt;/strong&gt;: 格式多样 (结构化、半结构化、非结构化数据，如文本、音频、视频)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value (值)&lt;/strong&gt;: 初始价值密度低，需要处理才能提取重要价值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complexity (复杂性)&lt;/strong&gt;: 处理和分析难度大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;云计算大数据的计算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算大数据的计算&#34;&gt;#&lt;/a&gt; 云计算 —— 大数据的计算&lt;/h3&gt;
&lt;h4 id=&#34;云计算和大数据关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算和大数据关系&#34;&gt;#&lt;/a&gt; 云计算和大数据关系&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;类比: G = f (x)，其中目标 (G) 通过云计算 (f) 对大数据 (x) 进行处理来实现。&lt;/li&gt;
&lt;li&gt;云计算是处理大数据的&lt;strong&gt;手段&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;两者相互依存：没有大数据，不需要云计算；没有云计算，无法有效处理大数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云计算的起源与定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算的起源与定义&#34;&gt;#&lt;/a&gt; 云计算的起源与定义&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始概念&lt;/strong&gt;：像公用事业 (水、电) 一样提供海量资源池，按需付费；从拥有资源转向共享资源 (类似公共交通 vs 私家车)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;长定义&lt;/strong&gt;：一种商业计算模型，将任务分布在资源池上，提供按需的计算、存储和信息服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;短定义&lt;/strong&gt;：通过网络提供按需、动态可扩展、廉价的计算服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通用定义&lt;/strong&gt;：一种分布式计算的商业模式，利用大量廉价机器构建可靠的海量资源池，通过网络按需访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云计算的核心概念资源池&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算的核心概念资源池&#34;&gt;#&lt;/a&gt; 云计算的核心概念：资源池&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;“云” = 大规模的 (通常是&lt;strong&gt;廉价&lt;/strong&gt;) 服务器集群。&lt;/li&gt;
&lt;li&gt;资源被池化、虚拟化，并通过软件进行管理以实现可靠性和自我维护。&lt;/li&gt;
&lt;li&gt;计算能力通过互联网作为商品提供。&lt;/li&gt;
&lt;li&gt;用户动态按需访问资源，专注于业务逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云计算的关键特征-7个&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算的关键特征-7个&#34;&gt;#&lt;/a&gt; 云计算的关键特征 (7 个)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;超大规模&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可靠性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通用性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可伸缩性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按需服务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;极其廉价&lt;/strong&gt; (规模经济)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云计算的商业特征&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算的商业特征&#34;&gt;#&lt;/a&gt; 云计算的商业特征&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;是一种商业模式 / 产业技术，不仅仅是学术研究。&lt;/li&gt;
&lt;li&gt;注重&lt;strong&gt;实用性&lt;/strong&gt;和&lt;strong&gt;经济性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;整合了成熟技术：互联网、分布式计算、虚拟化、自治管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;云计算发展现状&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算发展现状&#34;&gt;#&lt;/a&gt; 云计算发展现状&lt;/h3&gt;
&lt;h4 id=&#34;服务模式分层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务模式分层&#34;&gt;#&lt;/a&gt; 服务模式分层&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IaaS (基础设施即服务)&lt;/strong&gt;: 基础计算 / 存储 / 网络 (例如 Amazon EC2/S3, 阿里云 ECS)。面向系统开发者。(通用)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PaaS (平台即服务)&lt;/strong&gt;: 应用运行环境 (例如 Google App Engine, Azure, Hadoop)。面向应用开发者。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SaaS (软件即服务)&lt;/strong&gt;: 即用型应用程序 (例如 Salesforce CRM, Alexa Web)。面向最终用户。(专用)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;部署模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#部署模式&#34;&gt;#&lt;/a&gt; 部署模式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;公有云&lt;/strong&gt;：对公众开放，由提供商管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私有云&lt;/strong&gt;：为单个组织服务，自行管理或由第三方管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;混合云&lt;/strong&gt;：公有云和私有云的结合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;云计算实现机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算实现机制&#34;&gt;#&lt;/a&gt; 云计算实现机制&lt;/h3&gt;
&lt;h4 id=&#34;分层架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分层架构&#34;&gt;#&lt;/a&gt; 分层架构&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/2db4b87c98ac660c18ff0692c97fa3d9a38c07d91a211efd95943e9761f63d90.png&#34; alt=&#34;picture 0&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;物理资源层&lt;/strong&gt;：计算机、存储、网络、数据库、软件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源池层&lt;/strong&gt;：对物理资源进行分组 (计算池、存储池、网络池、数据池、软件池)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理中间件层&lt;/strong&gt;：管理资源、任务、用户、安全。(关键组件)。包括用户 / 任务 / 资源 / 安全管理子模块 (负载均衡、故障处理、监控、认证 / 授权、计费等)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOA (面向服务的架构) 层&lt;/strong&gt;：将能力暴露为标准的 Web 服务 (接口、注册、发现、调用、工作流)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;云计算优势&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算优势&#34;&gt;#&lt;/a&gt; 云计算优势&lt;/h3&gt;
&lt;h4 id=&#34;成本效益&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#成本效益&#34;&gt;#&lt;/a&gt; 成本效益&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;解决传统 IT 成本上升问题 (管理、电力 / 冷却)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规模经济&lt;/strong&gt;：大型数据中心单位成本显著降低 (网络、存储、管理)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化选址&lt;/strong&gt;：部署在电力廉价 (水电)、气候凉爽、土地成本低的地区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化&lt;/strong&gt;：降低人力成本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高利用率&lt;/strong&gt;：云计算利用率约 80%，而传统 IT 仅 10-15%，总成本节省超过 30 倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用户收益&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用户收益&#34;&gt;#&lt;/a&gt; 用户收益&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;低规格的客户端设备即可满足需求。&lt;/li&gt;
&lt;li&gt;按需付费模式使得用户能以可承受的价格获得强大的资源。&lt;/li&gt;
&lt;li&gt;无需购买 / 维护软件或担心硬件升级。&lt;/li&gt;
&lt;li&gt;节省资源，环境友好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;核心架构思想&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#核心架构思想&#34;&gt;#&lt;/a&gt; 核心架构思想&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;“团结就是力量” - 许多廉价的商用机器协同工作，提供大规模、可靠、高性能的服务 (类比：鱼群 vs 鲨鱼)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;复习题-习题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复习题-习题&#34;&gt;#&lt;/a&gt; 复习题 (习题)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;大数据是如何形成的&lt;/strong&gt;&lt;br /&gt;
数据产生方式的改变；人类的活动越来越依赖数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新摩尔定律 (Jim Gray 版本) 的含义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全球信息量呈指数增长：每 18 个月产生的新数据量等同于此前累积的全部数据总和&lt;/li&gt;
&lt;li&gt;强调数据规模爆炸式扩大，说明对存储、计算和分析能力提出了更高要求&lt;/li&gt;
&lt;li&gt;反映信息技术和社会活动对数据生成与处理的双重推动作用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;云计算的特征&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟化：对计算、存储、网络资源进行抽象与隔离，提高利用率与灵活性。&lt;/li&gt;
&lt;li&gt;按需服务：动态分配与释放资源，用户只为实际使用付费。&lt;/li&gt;
&lt;li&gt;商用硬件：使用廉价大规模服务器构建资源池，降低总体成本。&lt;/li&gt;
&lt;li&gt;通用性：支持多种应用场景与工作负载。&lt;/li&gt;
&lt;li&gt;可靠性：通过冗余、故障检测与自动恢复保障服务可用。&lt;/li&gt;
&lt;li&gt;可伸缩性：根据负载变化快速横向或纵向扩展资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;云计算的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务模型
&lt;ul&gt;
&lt;li&gt;IaaS（基础设施即服务）&lt;/li&gt;
&lt;li&gt;PaaS（平台即服务）&lt;/li&gt;
&lt;li&gt;SaaS（软件即服务）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部署模式
&lt;ul&gt;
&lt;li&gt;公有云：第三方提供商面向公共的云服务。&lt;/li&gt;
&lt;li&gt;私有云：组织内部或委托第三方私有部署。&lt;/li&gt;
&lt;li&gt;混合云：公有云与私有云结合，兼顾灵活性与安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;云计算的架构层次&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物理层：物理服务器、存储、网络设备等硬件资源。&lt;/li&gt;
&lt;li&gt;资源池层：通过虚拟化将物理资源划分为计算池、存储池、网络池等。&lt;/li&gt;
&lt;li&gt;中间件层：负责资源管理、调度、监控、安全和计费等核心功能。&lt;/li&gt;
&lt;li&gt;服务 / SOA 层：以标准化 API 或 Web 服务形式向用户暴露能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;云计算相对于传统 IT 的成本优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规模经济：大规模数据中心降低单位硬件和运维成本。&lt;/li&gt;
&lt;li&gt;按需付费：避免闲置资源浪费，费用与使用量挂钩。&lt;/li&gt;
&lt;li&gt;自动化运维：集中管理、自动部署和弹性伸缩减少人力成本。&lt;/li&gt;
&lt;li&gt;高资源利用率：多租户共享提高硬件利用率，进一步降低总体投入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式计算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式计算&#34;&gt;#&lt;/a&gt; 分布式计算&lt;/h2&gt;
&lt;h3 id=&#34;分布式计算概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式计算概述&#34;&gt;#&lt;/a&gt; 分布式计算概述&lt;/h3&gt;
&lt;h4 id=&#34;基本概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本概念&#34;&gt;#&lt;/a&gt; 基本概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;集中式计算&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;所有数据和任务集中在一台计算机上处理。&lt;/li&gt;
&lt;li&gt;该计算机负责管理和处理所有数据 / 任务，并提供服务给用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式计算&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;利用多台计算机联合完成任务。&lt;/li&gt;
&lt;li&gt;通过网络通信，按规则分配工作量和数据，协作完成处理任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;集中式-vs-分布式对比&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#集中式-vs-分布式对比&#34;&gt;#&lt;/a&gt; 集中式 vs 分布式对比&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;对比项&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;集中式计算&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分布式计算&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;计算资源集中一处处理管理&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;计算资源分散多处处理管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;资源分配&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;计算机集中处理管理所有资源&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;资源分散在多台计算机上管理分配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;数据共享&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据集中存储，只能由该计算机访问共享&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据可分布在多台计算机上，可共享访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;处理能力&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;受单机硬件限制&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通过任务分配给多台计算机提高处理能力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;可靠性 / 安全性&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单点故障 / 攻击影响整个系统&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单个计算机故障 / 攻击，其他计算机仍可继续计算任务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;成本&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;通常需大型机 / 高性能服务器，成本高&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可利用廉价计算机集群，成本相对较低&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;分布式计算优点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式计算优点&#34;&gt;#&lt;/a&gt; 分布式计算优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高效性&lt;/strong&gt;：利用多机处理能力，提高效率和吞吐量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：通过增加节点扩展计算能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错性&lt;/strong&gt;：通过备份和任务处理节点实现容错和高可靠性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;低成本&lt;/strong&gt;：利用廉价计算资源降低成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据局部性&lt;/strong&gt;：利用计算节点附近数据，减少传输开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;集中式计算优点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#集中式计算优点&#34;&gt;#&lt;/a&gt; 集中式计算优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;简单性&lt;/strong&gt;：统一管理，简化计算和管理复杂性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性&lt;/strong&gt;：单计算机保证计算和管理的稳定可靠性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一性&lt;/strong&gt;：统一管理控制数据和任务流程规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt;：单计算机管理保护数据和任务安全机密性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能优化&lt;/strong&gt;：单计算机优化资源使用，提高效率和性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分布式计算应用场景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式计算应用场景&#34;&gt;#&lt;/a&gt; 分布式计算应用场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;大规模数据处理 (搜索引擎、数据挖掘、机器学习)&lt;/li&gt;
&lt;li&gt;高性能计算 (科学计算、模拟、仿真)&lt;/li&gt;
&lt;li&gt;分布式存储 (分布式文件系统、分布式数据库)&lt;/li&gt;
&lt;li&gt;实时数据处理 (流计算、实时推荐)&lt;/li&gt;
&lt;li&gt;区块链技术 (比特币、以太坊)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分布式计算原理-分而治之&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式计算原理-分而治之&#34;&gt;#&lt;/a&gt; 分布式计算原理 (分而治之)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;『分』&lt;/strong&gt;: 将复杂庞大任务划分为小任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;『计算』&lt;/strong&gt;: 子任务分配到不同节点并行执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;『合』&lt;/strong&gt;: 汇总各节点结果得到最终结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;难点&lt;/strong&gt;：任务划分、多节点通信方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分布式计算步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式计算步骤&#34;&gt;#&lt;/a&gt; 分布式计算步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;设计分布式计算模型&lt;/strong&gt;：决定组件如何运行、通信、管理节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式任务分配&lt;/strong&gt;：解决任务能否 / 如何分配到各节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写并执行分布式程序&lt;/strong&gt;：使用特定框架 / 模型转化算法为实现，保证集群高效运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;分布式计算的理论基础&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式计算的理论基础&#34;&gt;#&lt;/a&gt; 分布式计算的理论基础&lt;/h3&gt;
&lt;h4 id=&#34;acid原则-本地事务管理-内部一致性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#acid原则-本地事务管理-内部一致性&#34;&gt;#&lt;/a&gt; ACID 原则 (本地事务管理、内部一致性)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子性 (Atomicity)&lt;/strong&gt;: 操作要么全成功，要么全失败，无中间状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性 (Consistency)&lt;/strong&gt;: 事务处理前后，不改变数据库原本的一致性约束。(&lt;strong&gt;核心目标&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性 (Isolation)&lt;/strong&gt;: 并发事务间独立，互不干扰。 (手段：写锁、读锁、范围锁)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性 (Duration)&lt;/strong&gt;: 事务生效后，对数据库的改变永久保存。(手段: Commit Logging)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;困难&lt;/strong&gt;: &amp;quot;写入磁盘&amp;quot; 非原子操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手段&lt;/strong&gt;：原子性、隔离性、持久性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;acid原则缺点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#acid原则缺点&#34;&gt;#&lt;/a&gt; ACID 原则缺点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性能开销&lt;/strong&gt;：锁定、日志记录影响并发处理能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;：强制一致性，难扩展到大规模分布式系统多节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;难以维护&lt;/strong&gt;：事务失败回滚复杂，需协调多组件交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cap理论-分布式事务-外部一致性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cap理论-分布式事务-外部一致性&#34;&gt;#&lt;/a&gt; CAP 理论 (分布式事务、外部一致性)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：分布式系统最多同时满足以下三项中的两项：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一致性 (Consistency)&lt;/strong&gt;: 所有节点访问同一份最新数据副本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性 (Availability)&lt;/strong&gt;: 每次请求都能获取非错响应 (不保证最新数据)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区容错性 (Partition tolerance)&lt;/strong&gt;: 网络分区时，系统仍能继续运行。(分布式系统&lt;strong&gt;必须&lt;/strong&gt;满足)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;起源&lt;/strong&gt;: Eric Brewer 提出猜想 (2000)，Seth Gilbert &amp;amp; Nancy Lynch 证明 (2002)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cap理论阐述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cap理论阐述&#34;&gt;#&lt;/a&gt; CAP 理论阐述&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;正常流程&lt;/strong&gt;: N1, N2 数据一致 (V0)，均可用。网络正常，分区容错性满足。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/ba463d4a4ff080a698df315fb702b123581ee2092460774bda2d0e38707f857b.png&#34; alt=&#34;picture 1&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络分区时&lt;/strong&gt;: N1 与 N2 网络断开。用户向 N2 请求读数据。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/d1bfad52c77f0fdf4296748c1eace3c380925327d9d5fa39c7148afaa7056aef.png&#34; alt=&#34;picture 2&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择一 (牺牲一致性 C, 保留可用性 A)&lt;/strong&gt;: N2 无法同步 N1 的新数据 V1，响应旧数据 V0 给用户。(AP)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择二 (牺牲可用性 A, 保留一致性 C)&lt;/strong&gt;: N2 阻塞等待，直到网络恢复、数据同步 M 完成，再响应最新数据 V1。(CP)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cap权衡&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cap权衡&#34;&gt;#&lt;/a&gt; CAP 权衡&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(1) CA w/o P&lt;/strong&gt;: 放弃分区容错性。假设节点间通信永远可靠。不是真正的分布式系统。(例: Oracle RAC 使用共享磁盘避免网络分区)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(2) CP w/o A&lt;/strong&gt;: 放弃可用性。保证强一致性，分区发生时可能导致请求超时或错误。(例: HBase RegionServer 宕机期间数据不可用)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;(3) AP w/o C&lt;/strong&gt;: 放弃 (强) 一致性。保证高可用，分区发生时节点用本地数据提供服务，可能导致数据不一致。(例: Redis 分区后各节点返回本地数据) (&lt;strong&gt;主流选择&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;base理论&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#base理论&#34;&gt;#&lt;/a&gt; BASE 理论&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：对 CAP 中一致性和可用性权衡的结果，核心思想是即使无法做到强一致性，但应用可采用适合方式达到&lt;strong&gt;最终一致性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Basically Available (基本可用)&lt;/strong&gt;: 系统在分区、部分节点故障时，仍能保证核心功能可用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Soft State (软状态)&lt;/strong&gt;: 系统状态允许在不同节点间存在中间状态，不要求实时一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eventually Consistent (最终一致性)&lt;/strong&gt;: 系统中所有数据副本经过一段时间后，最终能够达到一致状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：牺牲强一致性换取高可用性和灵活性，适用于对一致性要求不高的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;base与acid对比&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#base与acid对比&#34;&gt;#&lt;/a&gt; BASE 与 ACID 对比&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ACID&lt;/strong&gt;: 传统数据库设计理念，追求&lt;strong&gt;强一致性&lt;/strong&gt;模型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BASE&lt;/strong&gt;: 大型分布式系统设计理念，通过牺牲强一致性获得&lt;strong&gt;高可用性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一致性散列&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一致性散列&#34;&gt;#&lt;/a&gt; 一致性散列&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题背景&lt;/strong&gt;：分布式集群存储数据，如何将对象散列到不同机器？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单散列&lt;/strong&gt;:  &lt;code&gt;server = hash(key) mod N&lt;/code&gt;  (N 为机器数)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再散列问题 (Rehashing)&lt;/strong&gt;: 当服务器数量 N 变化 (增 / 减机器) 时， &lt;code&gt;hash % N&lt;/code&gt;  结果大多会改变，导致&lt;strong&gt;大部分 KV 对需要迁移&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一致性散列算法-consistent-hashing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一致性散列算法-consistent-hashing&#34;&gt;#&lt;/a&gt; 一致性散列算法 (Consistent Hashing)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：将整个哈希值空间 (&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;128&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;e.g., 0 ~ 2^{128}-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0085em;vertical-align:-0.1944em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.1667em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace nobreak&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;128&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.6444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;) 组织成虚拟圆环。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;映射&lt;/strong&gt;：将服务器和对象 Key 都通过哈希函数映射到环上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;归属&lt;/strong&gt;：对象存储在沿环顺时针遇到的第一个服务器上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用&lt;/strong&gt;：高流量动态网站的分布式缓存 (Redis, MemCache) 实现请求动态均衡。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错性&lt;/strong&gt;：节点宕机 (Node C)，只影响其负责的数据 (对象 C)，这些数据重定位到下一个节点 (Node D)。对象 A, B, D 不受影响。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/428f0ecf55bd42a436e91cc034293b84cfd67d15efac7a4fd4abd858c7b661df.png&#34; alt=&#34;picture 3&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;：增加节点 (Node X)，只影响新节点与其前一个节点之间的数据 (对象 C 需重定位到 Node X)。对象 A, B, D 不受影响。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/acc3b19003815406bc1bbbc8c30e4e6584b9cdb23a07e9c478cdb0addffa9d35.png&#34; alt=&#34;picture 4&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟节点&lt;/strong&gt;：为解决物理节点哈希分布不均问题，将每个物理服务器映射为多个虚拟节点分散在环上，使数据分布更均匀。权重高的服务器可分配更多虚拟节点。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/80742fb29ae26c125bdce4328491077f6a95838dc11adbd7d055a5219b88e114.png&#34; alt=&#34;picture 5&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式系统概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式系统概述&#34;&gt;#&lt;/a&gt; 分布式系统概述&lt;/h3&gt;
&lt;h4 id=&#34;基础知识-大数据驱动&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基础知识-大数据驱动&#34;&gt;#&lt;/a&gt; 基础知识 (大数据驱动)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;驱动力&lt;/strong&gt;：大数据技术需求推动分布式系统发展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;演变&lt;/strong&gt;：源于互联网公司大规模分布式存储系统需求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展方式&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;纵向扩展 (Scale Up)&lt;/strong&gt;: 传统方式，使用更强服务器 (小型机 -&amp;gt; 中型机 -&amp;gt; 大型机)，成本高、稳定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;横向扩展 (Scale Out)&lt;/strong&gt;: 使用大量廉价普通服务器通过网络连接，成本低、故障率高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挑战与解决&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;故障率高 -&amp;gt; 软件实现自动容错、保证数据一致性。&lt;/li&gt;
&lt;li&gt;增加服务器 -&amp;gt; 软件实现自动负载均衡，系统处理能力线性扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实例apache-hadoop&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实例apache-hadoop&#34;&gt;#&lt;/a&gt; 实例：Apache Hadoop&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;: Apache 基金会开发的分布式存储与计算框架。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创始人&lt;/strong&gt;: Doug Cutting (就职 Yahoo 期间开发，现 Cloudera)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;思想来源&lt;/strong&gt;: Google 论文公开的 GFS, MapReduce, Bigtable 思想。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发展简史&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;2003-2004: Doug Cutting 基于 Google 论文实现 Nutch (DFS + MapReduce 微缩版)。&lt;/li&gt;
&lt;li&gt;2005 秋: Nutch 子项目引入 Apache 基金会。&lt;/li&gt;
&lt;li&gt;2006.3: MapReduce 和 NDFS (后改名 HDFS) 纳入 Hadoop 项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心组件&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HDFS (Hadoop Distributed File System)&lt;/strong&gt;: 提供高可靠、高扩展、高吞吐率的分布式数据存储服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MapReduce&lt;/strong&gt;: 并行、分布式计算框架，易使用、高容错、高扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云计算服务模型&lt;/strong&gt;: Hadoop 通常属于 &lt;strong&gt;PaaS&lt;/strong&gt; (平台即服务) 层，运行在 IaaS (如 AWS EC2/S3, 阿里云 ECS) 之上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式系统的进阶&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式系统的进阶&#34;&gt;#&lt;/a&gt; 分布式系统的进阶&lt;/h3&gt;
&lt;h4 id=&#34;分布式存储系统-5个子方向&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式存储系统-5个子方向&#34;&gt;#&lt;/a&gt; 分布式存储系统 (5 个子方向)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;结构化存储&lt;/strong&gt;：关系型数据库 (MySQL)。强一致性 (银行系统)，支持随机访问 (SQL, 索引)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非结构化存储&lt;/strong&gt;：分布式文件系统 (GFS, HDFS)。存储海量数据 (网页)，配合批量处理。高扩展、高吞吐。不支持随机访问，不适用低延时、实时应用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;半结构化存储&lt;/strong&gt;: NoSQL, KV Store (对象存储)。解决非结构化存储随机访问性能差问题。通常&lt;strong&gt;抛弃 ACID&lt;/strong&gt; 换取性能和扩展性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In-memory 存储&lt;/strong&gt;: Memcached, Redis。数据存内存，读写高性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NewSQL&lt;/strong&gt;: Google Spanner。兼备 RDBMS (SQL, ACID) 和 NoSQL (扩展能力)。(目前工业界支持较少)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;分布式计算系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式计算系统&#34;&gt;#&lt;/a&gt; 分布式计算系统&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分布式计算 vs 并行计算&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;并行计算&lt;/strong&gt;：目标是&lt;strong&gt;高性能&lt;/strong&gt; (投入更多机器，数据量不变，计算更快)。无内置 &amp;quot;容错&amp;quot; 概念。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式计算&lt;/strong&gt;：目标是&lt;strong&gt;高可扩展性&lt;/strong&gt; (投入更多机器，处理更大规模数据)。核心是&lt;strong&gt;容错&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分布式计算系统 (5 个子方向)&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;传统基于消息的系统&lt;/strong&gt;: MPI (Message Passing Interface)。框架灵活，约束少，&lt;strong&gt;不支持容错&lt;/strong&gt; (或有限)。(MPICH2, OpenMPI)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MapReduce 家族系统&lt;/strong&gt;: MapReduce, Spark。程序结构有严格约束 (Map, Reduce 等高层操作)，抽象为 DAG。可扩展至超大规模集群，&lt;strong&gt;具备容错机制&lt;/strong&gt;，但节点同步效率可能低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图计算系统&lt;/strong&gt;: Pregel (BSP 模型), GraphLab (GAS 模型)。专门处理图结构数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于状态的系统&lt;/strong&gt;: Piccolo, DistBelief, Parameter Server。适用于需要维护和同步全局状态的应用 (如大规模机器学习)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时流处理系统&lt;/strong&gt;: Apache Storm。高效实时处理流式数据，关注&lt;strong&gt;实时性&lt;/strong&gt;。在连续数据窗口内执行 SQL 类操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;1-传统基于消息的系统-mpi&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-传统基于消息的系统-mpi&#34;&gt;#&lt;/a&gt; 1. 传统基于消息的系统 (MPI)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本思想&lt;/strong&gt;：程序分多个进程，进程间传递消息和数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程位置&lt;/strong&gt;：可在同机不同线程、不同机器进程、甚至不同操作系统进程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信模型&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;点对点通信&lt;/strong&gt;：两进程间直接通信 (发送、接收)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合通信&lt;/strong&gt;：多进程间数据收集与分发 (广播、聚集、散布)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;:  &lt;code&gt;scatter&lt;/code&gt;  (发散：将根进程数据分发给各进程),  &lt;code&gt;gather&lt;/code&gt;  (收集：将各进程数据收集到根进程)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-mapreduce家族系统-mapreduce-spark&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-mapreduce家族系统-mapreduce-spark&#34;&gt;#&lt;/a&gt; 2. MapReduce 家族系统 (MapReduce, Spark)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MapReduce&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;批处理模型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;数据&lt;strong&gt;存储在磁盘&lt;/strong&gt;上，适合大规模数据批处理。&lt;/li&gt;
&lt;li&gt;磁盘 I/O 较多。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spark&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;支持&lt;strong&gt;流处理和批处理&lt;/strong&gt;两种模型。&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;内存计算&lt;/strong&gt;思想，更灵活、更快。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-图计算系统-pregelbsp-graphlabgas&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-图计算系统-pregelbsp-graphlabgas&#34;&gt;#&lt;/a&gt; 3. 图计算系统 (Pregel/BSP &amp;amp; GraphLab/GAS)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pregel (BSP 模型 - Bulk Synchronous Parallel)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;计算任务分若干&lt;strong&gt;超级步 (Supersteps)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;每步包含三个阶段: &lt;strong&gt;计算、通信、同步&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;所有节点完成计算和通信后，等待同步，再进入下一步。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步通信模式&lt;/strong&gt;：本轮计算结果在下一轮生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GraphLab (GAS 模型 - Gather, Apply, Scatter)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;计算任务分三个阶段:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Gather&lt;/strong&gt;: 从邻居节点收集信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Apply&lt;/strong&gt;: 根据收集的信息更新自身状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scatter&lt;/strong&gt;: 将更新后的状态信息发送给邻居节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步通信模式&lt;/strong&gt;：本轮计算结果在本轮立即生效。算法收敛快，但可能存在数据不一致问题。&lt;/li&gt;
&lt;li&gt;可在单机或分布式环境运行。Pregel 只能在分布式环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;5-实时流处理系统-storm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-实时流处理系统-storm&#34;&gt;#&lt;/a&gt; 5. 实时流处理系统 (Storm)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：处理&lt;strong&gt;实时、连续、无界&lt;/strong&gt;数据流的系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;简单编程模型&lt;/strong&gt;：类似 MapReduce 降低并行批处理复杂性，Storm 降低实时处理复杂性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多种编程语言&lt;/strong&gt;：默认 Clojure, 支持 Java, Ruby, Python 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错性&lt;/strong&gt;：管理工作进程和节点故障。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;横向扩展&lt;/strong&gt;：计算在多线程、进程、服务器并行进行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠的消息处理&lt;/strong&gt;：保证消息至少被完整处理一次。失败时从源头重试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速&lt;/strong&gt;：使用 ZeroMQ 作为底层消息队列，保证消息快速处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Storm vs MapReduce/Spark (数据与计算流向)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MapReduce/Spark&lt;/strong&gt;: &lt;strong&gt;计算传递给数据&lt;/strong&gt;。节点存储 / 缓存数据集，任务提交给节点。批量处理持久化&lt;strong&gt;全量数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Storm&lt;/strong&gt;: &lt;strong&gt;数据传递给计算&lt;/strong&gt;。节点实现基本计算过程，数据项流经网络节点。动态处理大量生成&lt;strong&gt;小数据块&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分布式资源管理系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分布式资源管理系统&#34;&gt;#&lt;/a&gt; 分布式资源管理系统&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;需求背景&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;多种计算框架 (MapReduce, Spark, Storm, MPI) 可能并存。&lt;/li&gt;
&lt;li&gt;希望部署到&lt;strong&gt;公共集群&lt;/strong&gt;，共享资源，统一管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：提高资源利用率、降低运维成本、方便数据共享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;典型代表&lt;/strong&gt;: Mesos, YARN。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;统一管理调度平台特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#统一管理调度平台特点&#34;&gt;#&lt;/a&gt; 统一管理调度平台特点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;支持多种计算框架&lt;/strong&gt;：平台本身不耦合特定框架。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;：平台自身不应成为框架水平扩展的瓶颈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错性&lt;/strong&gt;：在保持原有框架容错性基础上，平台自身也应具备良好容错性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高资源利用率&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态资源分配 (问题)&lt;/strong&gt;: 每个框架分配固定集群，利用率低 (e.g., 10-30%)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源统一管理 (解决)&lt;/strong&gt;: 统一管理调度各种框架，提升整体资源利用率 (e.g.,&amp;gt;70%)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;细粒度的资源分配&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;粗粒度共享 (Coarse-Grained)&lt;/strong&gt;: 整个节点分配给一个框架 / 任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;细粒度共享 (Fine-Grained)&lt;/strong&gt;: 直接按任务实际需求 (CPU, 内存) 分配资源。(Mesos 方式)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;apache-hadoop-yarn-yet-another-resource-negotiator&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#apache-hadoop-yarn-yet-another-resource-negotiator&#34;&gt;#&lt;/a&gt; Apache Hadoop YARN (Yet Another Resource Negotiator)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;背景&lt;/strong&gt;：下一代 MapReduce (MRv2)，为解决 MRv1 扩展性差、不支持多计算框架问题。完全重写。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;架构&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ResourceManager (RM)&lt;/strong&gt;: 全局资源管理器 (Master)。负责资源分配与调度。功能简单，不易成瓶颈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NodeManager (NM)&lt;/strong&gt;: 节点管理器 (Slave)。负责启动 / 监控 Container，上报资源使用情况给 RM。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationMaster (AM)&lt;/strong&gt;: 每个应用程序对应一个 AM。负责向 RM 申请资源，与 NM 交互启动 / 监控任务。&lt;strong&gt;(有具体应用的调度功能)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Container&lt;/strong&gt;: YARN 中资源分配的基本单位 (CPU, 内存等)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;apache-mesos&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#apache-mesos&#34;&gt;#&lt;/a&gt; Apache Mesos&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;架构&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mesos Master&lt;/strong&gt;: 保存 Framework 和 Slave 状态。使用 Zookeeper 解决单点故障。&lt;strong&gt;全局资源调度器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mesos Slave (Agent)&lt;/strong&gt;: 运行任务，向 Master 汇报状态，运行 Executor。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Framework&lt;/strong&gt;: 计算框架，包含 Scheduler (向 Master 注册，接收资源 offer) 和 Executor (在 Slave 上运行具体任务，e.g., Hadoop TaskTracker)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源分配流程 (两层调度)&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;Agent 向 Master 汇报空闲资源。&lt;/li&gt;
&lt;li&gt;Master 根据策略将资源 Offer (e.g., &amp;lt;Agent1, 4 CPU, 4GB RAM&amp;gt;) 提供给某个 Framework (e.g., Framework 1)。&lt;/li&gt;
&lt;li&gt;Framework Scheduler 回复 Master 是否接受 Offer，并告知要在该资源上运行的任务列表及资源需求。&lt;/li&gt;
&lt;li&gt;Master 将任务信息发送给 Agent。&lt;/li&gt;
&lt;li&gt;Agent 分配资源给 Framework 的 Executor，Executor 启动任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;mesos与yarn比较&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mesos与yarn比较&#34;&gt;#&lt;/a&gt; Mesos 与 YARN 比较&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;框架担任的角色&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mesos&lt;/strong&gt;: 计算框架需&lt;strong&gt;完全融入&lt;/strong&gt; Mesos (部署 Scheduler 和 Executor)。添加新框架需部署。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;YARN&lt;/strong&gt;: 框架仅是&lt;strong&gt;应用程序库&lt;/strong&gt;。无需事先部署框架。YARN 运行和使用更方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调度机制 (均为双层调度)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mesos&lt;/strong&gt;: &lt;strong&gt;资源推送&lt;/strong&gt;。Master 将资源 Offer 推给 Framework，由 Framework 决定是否接受及如何使用。&lt;strong&gt;Mesos 本身不知应用资源需求&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;YARN&lt;/strong&gt;: &lt;strong&gt;资源请求&lt;/strong&gt;。ApplicationMaster 向 YARN (RM) 汇报任务资源需求。&lt;strong&gt;YARN 根据需求为应用分配资源&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;课后习题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#课后习题&#34;&gt;#&lt;/a&gt; 课后习题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;分布式计算的定义和特征是什么？&lt;/li&gt;
&lt;li&gt;什么是 ACID 原则？&lt;/li&gt;
&lt;li&gt;什么是 CAP 理论？&lt;/li&gt;
&lt;li&gt;什么是 BASE 理论？&lt;/li&gt;
&lt;li&gt;如何理解最终一致性？&lt;/li&gt;
&lt;li&gt;各类分布式存储、分布式计算的区别与联系是什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;课外思考&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#课外思考&#34;&gt;#&lt;/a&gt; 课外思考&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;为什么日常生活中接触到的分布式系统越来越多了？&lt;/li&gt;
&lt;li&gt;CAP 定理中几个关键因素为什么不能同时保证？不同组合有什么应用场景？&lt;/li&gt;
&lt;li&gt;了解区块链背景后，说说你理解的区块链作为一种分布式系统背后的全新理念。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;云计算架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算架构&#34;&gt;#&lt;/a&gt; 云计算架构&lt;/h2&gt;
&lt;h3 id=&#34;云计算的本质&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算的本质&#34;&gt;#&lt;/a&gt; 云计算的本质&lt;/h3&gt;
&lt;h4 id=&#34;革命性概念it作为服务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#革命性概念it作为服务&#34;&gt;#&lt;/a&gt; 革命性概念：IT 作为服务&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：云计算将所有 IT 资源包装成服务进行销售，类似电力公用事业（引用 Nicholas Carr《大转换》）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类比&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;蒸汽技术&lt;/strong&gt;：难以远程传输，本地供给。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发电厂&lt;/strong&gt;：集中生产，远程供应，形成规模效应。人们放弃自有发电机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云计算&lt;/strong&gt;：集中化 IT 资源，提供新的技术和商业模式。人们可放弃自有 IT 资产，不必因资产由他人掌握而不安。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;社会影响&lt;/strong&gt;：云计算不仅影响各行业，还引发伦理道德乃至政治问题（如数据主权、隐私、算法影响、跨境数据管理）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带来的机遇 / 平等性&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;低门槛发布软件触达全球用户。&lt;/li&gt;
&lt;li&gt;无需高昂初始投资即可使用先进平台。&lt;/li&gt;
&lt;li&gt;降低对设备和位置的依赖。&lt;/li&gt;
&lt;li&gt;支持多租户。&lt;/li&gt;
&lt;li&gt;依托云商架构获得高可靠性 / 可用性。&lt;/li&gt;
&lt;li&gt;弹性伸缩应对需求波动。&lt;/li&gt;
&lt;li&gt;按需增长支持企业持续发展。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云计算系统工程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算系统工程&#34;&gt;#&lt;/a&gt; 云计算系统工程&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;挑战&lt;/strong&gt;：将大量计算资源组织在一起协同工作，需要系统性管理方法解决问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键问题&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;如何在扩大规模的同时保证性能近线性增长？&lt;/li&gt;
&lt;li&gt;如何在组件可能故障时保证系统整体稳定运行？&lt;/li&gt;
&lt;li&gt;如何快速重组资源以新架构适应不同业务需求变化？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云数据中心&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云数据中心&#34;&gt;#&lt;/a&gt; 云数据中心&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;建设考量&lt;/strong&gt;：需考虑持续性、能耗、安全、冷却、带宽、管理等，需自动化管理机制（故障检测定位、自动开关机）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模式&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统模式&lt;/strong&gt;：建机房、布线、放置连接机器。规模受建筑限制（如微软都柏林数据中心）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于集装箱模式&lt;/strong&gt;: Google 首创，用集装箱作机房单元（可容纳上千台服务器），可堆叠 / 并排形成巨大数据中心（如华为 AIO 集装箱数据中心）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云的工作负载模式-掌握&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云的工作负载模式-掌握&#34;&gt;#&lt;/a&gt; 云的工作负载模式 (掌握)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时开时停&lt;/strong&gt;：使用一段时间后停止，按用量计费，停止时释放资源。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/44de281b321a1697a53e5577db31418deb2ebde5610637b44dbf6fe27cb8d4cb.png&#34; alt=&#34;picture 6&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用量迅速增长&lt;/strong&gt;: IT 资源使用量随时间推移持续增长。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/62b318e28767d15643014374e548551f4c9a77c8df009a3cafa6044024f1f9a4.png&#34; alt=&#34;picture 7&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;瞬时暴涨&lt;/strong&gt;：特定时间点用量出现暴涨和暴跌。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/0f11ec53e41381d290463835e0f15120fe66fb315902664ebe9a8fcd44fd7f08.png&#34; alt=&#34;picture 8&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;周期性增减&lt;/strong&gt;: IT 资产用量呈现周期性增长和消减。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/0ef43a8d9467db51f32345f5b8c8d4a98c4dbf67cf1d796f831b030f088b0cae.png&#34; alt=&#34;picture 9&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;云计算的架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云计算的架构&#34;&gt;#&lt;/a&gt; 云计算的架构&lt;/h3&gt;
&lt;h4 id=&#34;计算架构的进化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#计算架构的进化&#34;&gt;#&lt;/a&gt; 计算架构的进化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;演进路径&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;中央集权架构 (终端 + 主机)&lt;/li&gt;
&lt;li&gt;客户机 / 服务器 (C/S) 架构&lt;/li&gt;
&lt;li&gt;中间层架构 (三层架构)&lt;/li&gt;
&lt;li&gt;浏览器 / 服务器 (B/S) 架构&lt;/li&gt;
&lt;li&gt;C/S 与 B/S 混合架构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向服务的计算架构 (SOA)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;程序完成自身任务，同时暴露服务供其他程序通过统一接口调用。&lt;/li&gt;
&lt;li&gt;云计算将&lt;strong&gt;一切&lt;/strong&gt;作为服务（软件、IT 资源），是服务计算的极致体现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一般云计算架构的二维视角&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一般云计算架构的二维视角&#34;&gt;#&lt;/a&gt; 一般云计算架构的二维视角&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组成&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端&lt;/strong&gt;：呈现给客户的部分 (客户设备、网络、访问界面如 Web 浏览器)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后端 (云)&lt;/strong&gt;: 由各种组件构成 (服务器、存储、云管理软件等)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部结构&lt;/strong&gt;: (见图) 硬件 -&amp;gt; 基础架构 -&amp;gt; 管理软件 (YARN, MapReduce 等) -&amp;gt; 应用程序。强调并发、协调、容错、开放接口、数据密集、开放数据等特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;基础架构的分层结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基础架构的分层结构&#34;&gt;#&lt;/a&gt; 基础架构的分层结构&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;虚拟化层 (云的基石)&lt;/strong&gt;: 将硬件转换为一致的 IT 资源（计算、存储），便于云管理软件细致管理（分配、动态增减）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web 服务层 (无状态的云服务)&lt;/strong&gt;: 将云资源通过方便界面提供给用户使用（屏蔽底层虚拟机复杂性）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务总线层 / 通信中间件层 (云与用户的桥梁)&lt;/strong&gt;: 封装服务，分离用户与虚拟化层，连接 Web 服务与用户。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户机用户界面层 (将云呈现给客户)&lt;/strong&gt;: 将应用程序呈现给客户（通常是 Web 门户）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;rest架构云计算的软件架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rest架构云计算的软件架构&#34;&gt;#&lt;/a&gt; REST 架构：云计算的软件架构&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;基础设施四层之间采用&lt;strong&gt;无状态、基于服务的 REST&lt;/strong&gt; (Representational State Transfer, 表征状态转移) 架构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基本思想&lt;/strong&gt;：面向&lt;strong&gt;资源&lt;/strong&gt;来抽象问题，与面向过程的编程有本质区别。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心概念&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源 (Resource)&lt;/strong&gt;: 信息或数据本身 (如文章内容)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表征 (Representation)&lt;/strong&gt;: 资源与用户交互时的表示形式 (如 HTML, PDF)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;状态 (State)&lt;/strong&gt;: 特定语境下才能产生的上下文信息 (如 “下一篇” 依赖 “当前篇”)。REST 强调&lt;strong&gt;无状态 (Stateless)&lt;/strong&gt;，即状态由客户端维护并在请求时告知服务端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转移 (Transfer)&lt;/strong&gt;: 服务端执行的、改变状态的动作 (如从 “当前篇” 转移到 “下一篇”)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;云栈和云体&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云栈和云体&#34;&gt;#&lt;/a&gt; 云栈和云体&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;云体 (Cloud Body)&lt;/strong&gt;: 云计算的&lt;strong&gt;物质基础&lt;/strong&gt;，软硬件环境资源集合（网络、服务器、存储器、交换机等通过网络连接）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云栈 (Cloud Stack) / 云平台&lt;/strong&gt;：在云体上建造的&lt;strong&gt;运行环境&lt;/strong&gt;，支持应用发布、运行、监控、调度、伸缩（如 Azure, App Engine, Cloud Foundry）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云计算 (Cloud Computing)&lt;/strong&gt;: 利用云体和云平台进行的&lt;strong&gt;计算或处理&lt;/strong&gt;。特点是按用量计费、资源可伸缩。包括云存储、云服务、在云上运行软件 / 算法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云 (Cloud)&lt;/strong&gt;: 云体、云栈、云计算的&lt;strong&gt;结合体&lt;/strong&gt;，有时也称为云端或云环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云栈-三层云栈架构-服务模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云栈-三层云栈架构-服务模式&#34;&gt;#&lt;/a&gt; 云栈 (三层云栈架构 - 服务模式)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;层次&lt;/strong&gt;：每一层提供一种抽象，越往上离物理现实越远，易用性越高。通过服务 / 功能实现抽象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常见三层&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IaaS (基础设施即服务)&lt;/strong&gt;: 提供基础计算 / 存储 / 网络资源（如 EC2/S3, 阿里云 ECS）。面向系统管理员 / 开发者。&lt;strong&gt;(通用)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PaaS (平台即服务)&lt;/strong&gt;: 提供应用程序运行环境（如 Google App Engine, Azure, Hadoop）。面向应用开发者。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SaaS (软件即服务)&lt;/strong&gt;: 提供特定应用软件功能（如 Salesforce CRM, Alexa Web）。面向最终用户。&lt;strong&gt;(专用)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;云体&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#云体&#34;&gt;#&lt;/a&gt; 云体&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;与传统操作系统的对比&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;云环境&lt;/strong&gt;：计算资源可 &amp;gt; 1 CPU (多节点)，独立存储，提供通信通道。虚拟化提供灵活资源 (N 个 CPU)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传统 OS&lt;/strong&gt;: 应用使用 CPU、内存 / 磁盘，与其他程序通信。OS 提供进程 / 线程、内存管理、文件系统、IPC / 网络等抽象，并负责控制调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;软件定义的数据中心-sddc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#软件定义的数据中心-sddc&#34;&gt;#&lt;/a&gt; 软件定义的数据中心 (SDDC)&lt;/h3&gt;
&lt;h4 id=&#34;数据中心的历史&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据中心的历史&#34;&gt;#&lt;/a&gt; 数据中心的历史&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;演进&lt;/strong&gt;：集中 -&amp;gt; 分散 -&amp;gt; 再集中。新的集中模式（云）远超大型机时代。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶段&lt;/strong&gt;: 60 年代 (大型机) -&amp;gt; 80 年代 (微型计算机) -&amp;gt; 90 年代 (C/S 推动 DC 发展) -&amp;gt; 21 世纪 (IDC 出现，现代 DC)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;传统数据中心的问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#传统数据中心的问题&#34;&gt;#&lt;/a&gt; 传统数据中心的问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;机器过多&lt;/strong&gt;：手动配置（OS、网络、注册、用户分配、软件）劳动密集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用率过低&lt;/strong&gt;：服务器利用率常低于 10%，浪费资源和电力（&amp;gt;90% 成热量）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用迁移困难&lt;/strong&gt;：硬件升级换代导致应用迁移复杂（重配置、兼容性问题）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储需求增长快&lt;/strong&gt;：存储更新关键且复杂，设备异构性（厂商、接口）导致管理困难、不兼容。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;什么是软件定义数据中心-sddc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是软件定义数据中心-sddc&#34;&gt;#&lt;/a&gt; 什么是软件定义数据中心 (SDDC)？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;起源&lt;/strong&gt;：服务器虚拟化技术的延伸。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心&lt;/strong&gt;：将虚拟化范围从计算扩展到存储和网络，并提供软件工具管理这些虚拟化资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定义 (IBM)&lt;/strong&gt;: SDDC 将虚拟化的计算、存储、网络资源与标准化管理平台结合，跨虚拟化层实现管理标准化，支持基于策略的自动化，简化运营，更快以服务形式交付 IT 资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sddc-的分层模型与架构分析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sddc-的分层模型与架构分析&#34;&gt;#&lt;/a&gt; SDDC 的分层模型与架构分析&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;硬件基础设施&lt;/strong&gt;：服务器、存储、网络设备 (最好支持硬件虚拟化)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件抽象 (虚拟化层)&lt;/strong&gt;: 硬件能力抽象为统一管理的资源池 (虚拟机、虚拟存储、虚拟网络)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件定义 (控制层)&lt;/strong&gt;: 对计算、存储、网络资源集中管理，提供权限、备份、高可用等特性 (如 vCenter)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务的自动化配置 (编排层)&lt;/strong&gt;: 按预设步骤自动部署服务 (如 vCAC)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实践-openstack&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实践-openstack&#34;&gt;#&lt;/a&gt; 实践: OpenStack&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：云平台操作系统（分布式），统一管理多节点计算、存储、网络资源池，通过 Web 界面管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重要性&lt;/strong&gt;：市场需求大，人才缺口大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：提供实施简单、大规模扩展、丰富、标准统一的云计算管理平台。支持各类云环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OpenStack 组件&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Nova (计算)&lt;/strong&gt;: 核心，管理 VM 生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Horizon (仪表盘)&lt;/strong&gt;: Web GUI 界面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Keystone (身份)&lt;/strong&gt;: 认证与授权。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Neutron (网络)&lt;/strong&gt;: SDN 网络虚拟化管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cinder (块存储)&lt;/strong&gt;: 持久化块存储服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Swift (对象存储)&lt;/strong&gt;: 分布式对象存储 (类 S3)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Glance (镜像)&lt;/strong&gt;: 管理 VM 镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ceilometer (监控)&lt;/strong&gt;: 资源监控与计量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Heat (编排)&lt;/strong&gt;: 基于模板编排复合云应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安装实践&lt;/strong&gt;：使用 &lt;strong&gt;Packstack&lt;/strong&gt; 工具安装。步骤包括初始化配置、网络配置、主机名解析、YUM 源配置、安装 Packstack。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;课后习题-小结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#课后习题-小结&#34;&gt;#&lt;/a&gt; 课后习题 (小结)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;云计算中的工作负载有哪几种模式？它们的特征是什么？&lt;/li&gt;
&lt;li&gt;什么是 REST 设计风格？&lt;/li&gt;
&lt;li&gt;如何理解 “云栈” 和 “云体” 的概念？&lt;/li&gt;
&lt;li&gt;什么是软件定义的数据中心？它的特点是什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;课外思考-小结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#课外思考-小结&#34;&gt;#&lt;/a&gt; 课外思考 (小结)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;云计算的架构是如何演化的？&lt;/li&gt;
&lt;li&gt;如何理解 “软件定义一切” 的说法？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;动手实践-小结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#动手实践-小结&#34;&gt;#&lt;/a&gt; 动手实践 (小结)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;任务：通过 OpenStack 官网了解项目情况。&lt;/li&gt;
&lt;li&gt;任务：通过 Packstack 工具安装并体验 OpenStack。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;虚拟化技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化技术&#34;&gt;#&lt;/a&gt; 虚拟化技术&lt;/h2&gt;
&lt;h3 id=&#34;虚拟化的定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化的定义&#34;&gt;#&lt;/a&gt; 虚拟化的定义&lt;/h3&gt;
&lt;h4 id=&#34;虚拟化历史&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化历史&#34;&gt;#&lt;/a&gt; 虚拟化历史&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;起源&lt;/strong&gt;: 20 世纪 50 年代。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1959 年&lt;/strong&gt;: Christopher Strachey 提出 “大型高速计算机中的时间共享” 论文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：最初为满足分时系统需求，解决早期 OS 单任务问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;早期应用&lt;/strong&gt;: IBM 7044 是最早使用虚拟化技术的计算机之一，后大型机 / 小型机开始使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;x86架构中的虚拟化演进&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#x86架构中的虚拟化演进&#34;&gt;#&lt;/a&gt; x86 架构中的虚拟化演进&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;纯软件『全虚拟化』&lt;/strong&gt;: 无需硬件或 OS 修改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;『半虚拟化模式』&lt;/strong&gt;: 需修改客户机 OS 以提高性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;『硬件虚拟化』&lt;/strong&gt;: Intel VT/AMD-V 等技术，用硬件代替软件实现虚拟化。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;虚拟化概念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化概念&#34;&gt;#&lt;/a&gt; 虚拟化概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;广义&lt;/strong&gt;：对计算资源的&lt;strong&gt;抽象&lt;/strong&gt;，不仅仅是虚拟机。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;例&lt;/strong&gt;：虚拟内存技术，抽象物理内存，提供连续地址空间给应用，实际数据可分页 / 分段 / 交换到外存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;狭义 (通常指)&lt;/strong&gt;: 通过虚拟化技术将一台计算机虚拟为多台&lt;strong&gt;逻辑计算机 (虚拟机)&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;效果&lt;/strong&gt;：提高硬件利用率 (一台服务器承载多台服务器负载)，实现用户任务和数据隔离，增强安全性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;：一台计算机上运行多个逻辑计算机，各自运行不同 OS 和应用，相互独立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;虚拟化技术主要分类-4大类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化技术主要分类-4大类&#34;&gt;#&lt;/a&gt; 虚拟化技术主要分类 (4 大类)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;服务器虚拟化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;解决服务器利用率低 (&amp;lt;15%)、数量剧增、部署复杂问题。&lt;/li&gt;
&lt;li&gt;将多操作系统作为 VM 运行在单台物理服务器上。&lt;/li&gt;
&lt;li&gt;聚合服务器集群为整合资源池，提高效率，降低成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件定义的存储 (SDS)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;抽象内部磁盘 / 闪存为高性能存储池。&lt;/li&gt;
&lt;li&gt;以软件形式交付，提高运维效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络虚拟化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;以软件形式完整再现物理网络。&lt;/li&gt;
&lt;li&gt;提供与物理网络相同功能 / 保证，并具备虚拟化运维优势和硬件独立性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;桌面虚拟化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;快速向分支机构、外包 / 海外 / 移动员工交付虚拟桌面和应用。&lt;/li&gt;
&lt;li&gt;快速响应需求变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;虚拟化与云计算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化与云计算&#34;&gt;#&lt;/a&gt; 虚拟化与云计算&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;虚拟化技术促进了云计算概念的产生，是其&lt;strong&gt;主要支撑技术&lt;/strong&gt;之一。&lt;/li&gt;
&lt;li&gt;核心优势：提高硬件利用率、实现用户任务 / 数据隔离、增强安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;服务器虚拟化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#服务器虚拟化&#34;&gt;#&lt;/a&gt; 服务器虚拟化&lt;/h3&gt;
&lt;h4 id=&#34;基本概念与架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本概念与架构&#34;&gt;#&lt;/a&gt; 基本概念与架构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：使用控制程序 (VMM) 隐藏物理平台特性，提供抽象、统一、模拟的计算环境 (虚拟机)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户操作系统 (Guest OS)&lt;/strong&gt;: 运行在虚拟机中的操作系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟机监控器 (Virtual Machine Monitor, VMM / Hypervisor)&lt;/strong&gt;: 实现虚拟化的核心层。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主机操作系统 (Host OS)&lt;/strong&gt;: 运行 VMM 的操作系统 (仅限 Type II)。&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/f99549e9b0fc5567fb073c11b99468f1b75148b176c09df0bb4f4513623f77f4.png&#34; alt=&#34;picture 10&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;hypervisor-类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#hypervisor-类型&#34;&gt;#&lt;/a&gt; Hypervisor 类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Type I (裸金属架构)&lt;/strong&gt;: VMM/Hypervisor 直接运行在硬件之上。(例: Xen, ACRN)&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/52c9c93cf3f9c0be20e7668f15051e41094087a8d44385ac14e28b3839b7c060.png&#34; alt=&#34;picture 11&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：效率高，扩展性、健壮性、性能更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type II (寄居架构 / 托管架构)&lt;/strong&gt;: VMM/Hypervisor 运行在 Host OS 之上，VM 作为 Host OS 的一个进程。(例: KVM, VMware Fusion, VirtualBox, Parallels Desktop)&lt;br /&gt;
&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/c77396a3eed646d7bde7758786b0e05881af0c00c3a20aefe7310f4880d78029.png&#34; alt=&#34;picture 12&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：使用方便，与宿主 OS 兼容。桌面用户常用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;x86架构对虚拟化的限制-ring特权级&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#x86架构对虚拟化的限制-ring特权级&#34;&gt;#&lt;/a&gt; x86 架构对虚拟化的限制 (Ring 特权级)&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/6cb2051e27ed8f0359af546524df9d8a398999139a5d8f707eac3bbd4f25f4fa.png&#34; alt=&#34;picture 13&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;x86 Ring&lt;/strong&gt;: Ring 0 (最高权限，OS 内核), Ring 3 (最低权限，用户应用)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特权指令&lt;/strong&gt;：只能在 Ring 0 执行，直接访问硬件 / 内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用&lt;/strong&gt;：应用 (Ring 3) -&amp;gt; 内核 (Ring 0) 切换 -&amp;gt; 内核代码执行 -&amp;gt; 返回应用 (Ring 3)。(用户态 / 内核态切换)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟化难题&lt;/strong&gt;: Host OS/VMM 运行在 Ring 0。Guest OS 被置于非 Ring 0 (如 Ring 1 或 Ring 3) 运行。当 Guest OS 尝试执行特权指令时，因权限不足导致&lt;strong&gt;出错 (trap)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;vmm-实现-guest-os-访问硬件的三种技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vmm-实现-guest-os-访问硬件的三种技术&#34;&gt;#&lt;/a&gt; VMM 实现 Guest OS 访问硬件的三种技术&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全虚拟化 (Full Virtualization)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;半虚拟化 (Paravirtualization)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件辅助虚拟化 (Hardware-Assisted Virtualization)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;全虚拟化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#全虚拟化&#34;&gt;#&lt;/a&gt; 全虚拟化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心技术 (VMware, 1998)&lt;/strong&gt;: &lt;strong&gt;二进制翻译 (Binary Translation, BT)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/2b4e4788d9663b518c5874f9ca109730069ebf6fbac74aafde8e323f90908093.png&#34; alt=&#34;picture 14&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原理&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;VMM 捕获 Guest OS 的特权指令。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;翻译&lt;/strong&gt;：将捕获的指令翻译成可在用户态运行的指令序列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存&lt;/strong&gt;：翻译结果缓存，供后续使用。&lt;/li&gt;
&lt;li&gt;用户级指令直接在 CPU 上运行 (速度接近物理机)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;Guest OS 无需任何修改，不知道自己被虚拟化。&lt;/li&gt;
&lt;li&gt;VMM 与物理硬件完全解耦。&lt;/li&gt;
&lt;li&gt;是唯一&lt;strong&gt;无需硬件辅助或 OS 辅助&lt;/strong&gt;即可虚拟化敏感 / 特权指令的方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;半虚拟化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#半虚拟化&#34;&gt;#&lt;/a&gt; 半虚拟化&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/4eba6fa66c628d6a21347707088ace4542ece493d99457aef5fc76486923b448.png&#34; alt=&#34;picture 15&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：修改 &lt;strong&gt;Guest OS 内核&lt;/strong&gt;，将敏感 / 特权指令替换为对 VMM 的直接调用 (&lt;strong&gt;Hypercall&lt;/strong&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hypercall&lt;/strong&gt;: 类似于系统调用，由 Guest OS 主动发起，请求 Hypervisor 服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;VMM 与 VM 相互配合，性能优于全虚拟化（早期）。&lt;/li&gt;
&lt;li&gt;虚拟化代价 / 开销更低。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;需要修改 Guest OS，不支持未修改的 OS (如 Windows)。&lt;/li&gt;
&lt;li&gt;兼容性、可移植性差。&lt;/li&gt;
&lt;li&gt;内核深度修改导致生产环境技术支持和维护困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;硬件辅助虚拟化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#硬件辅助虚拟化&#34;&gt;#&lt;/a&gt; 硬件辅助虚拟化&lt;/h4&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/f924bb691dbc50bd69ecc6b53a3d35532a17d8a2650c38f09ccd90e6c18a443e.png&#34; alt=&#34;picture 16&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;背景&lt;/strong&gt;：解决软件虚拟化性能开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术&lt;/strong&gt;: Intel VT-x (VMX), AMD AMD-V。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心&lt;/strong&gt;: CPU 增加新的操作模式。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;根模式 (Root Mode)&lt;/strong&gt;: VMM/Hypervisor 运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非根模式 (Non-root Mode)&lt;/strong&gt;: 虚拟机 (Guest OS) 运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原理&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;Guest OS 在非根模式下执行。&lt;/li&gt;
&lt;li&gt;执行敏感 / 特权指令时，CPU 自动触发 &lt;strong&gt;VM-Exit&lt;/strong&gt;，控制权切换到根模式的 VMM。&lt;/li&gt;
&lt;li&gt;VMM 处理指令后，通过 &lt;strong&gt;VM-Enter&lt;/strong&gt; 将控制权交还给 Guest OS。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;Hypervisor 无需费力识别 / 翻译敏感指令，极大提升虚拟化性能。&lt;/li&gt;
&lt;li&gt;Guest OS 无需修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;虚拟化实现技术比较&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟化实现技术比较&#34;&gt;#&lt;/a&gt; 虚拟化实现技术比较&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;全虚拟化 (BT)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;半虚拟化 (Hypercall)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;硬件辅助虚拟化&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Guest OS 修改&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无须修改&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;需要修改&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无须修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;好&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;差&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;差 (相对)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;好 (早期)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;好&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;CPU 虚拟化&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;二进制代码翻译&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;超级调用&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;新指令 / 新操作模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;内存虚拟化&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;影子页表 (SPT)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;内存管理半虚拟化&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;嵌套页表 (NPT/EPT)&lt;/strong&gt; (硬件扩展)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;I/O 虚拟化&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设备模拟&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;半虚拟化驱动&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设备模型 (直接访问)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;商用虚拟机技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#商用虚拟机技术&#34;&gt;#&lt;/a&gt; 商用虚拟机技术&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;发布年份&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;技术特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;VMware&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1999&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Type I, Type II&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;商业产品先驱。支持 Type I (ESX Server) 和 Type II (Workstation)。提供完整虚拟化产品线 (桌面 / 应用 / 服务器)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;Xen&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2003&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Type I&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开源。早期以&lt;strong&gt;半虚拟化&lt;/strong&gt;为主。Linux 3.0 后稳定支持 Dom0/DomU。广泛部署 (硬件 / 车载等)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;KVM/QEMU&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2006/2003&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Type II&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;基于 Linux 内核的开源方案。&lt;strong&gt;硬件辅助虚拟化&lt;/strong&gt;为主 (硬件不支持时退回 QEMU 软件模拟)。目前广泛部署。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;ACRN&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2018&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Type I&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;嵌入式轻量级开源。代码量小 (~25K 行)。注重实时性 / 安全性，面向车载 / 物联网等场景。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;新型硬件虚拟化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#新型硬件虚拟化&#34;&gt;#&lt;/a&gt; 新型硬件虚拟化&lt;/h3&gt;
&lt;h4 id=&#34;背景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#背景&#34;&gt;#&lt;/a&gt; 背景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;GPU, FPGA 等新型硬件普及。&lt;/li&gt;
&lt;li&gt;现有虚拟化技术主要面向通用硬件 (x86) 和软件栈 (Linux/Win)，无法高效承载新型硬件。&lt;/li&gt;
&lt;li&gt;工业界 / 学术界探索新型硬件虚拟化方案，如 GPU/RDMA 直通独占式虚拟化。&lt;/li&gt;
&lt;li&gt;RDMA/FPGA 等虚拟化尚处早期。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;硬件虚拟化的代表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#硬件虚拟化的代表&#34;&gt;#&lt;/a&gt; 硬件虚拟化的代表&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;GPU 虚拟化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;性能 / 扩展性 / 可用性相对 CPU 滞后。&lt;/li&gt;
&lt;li&gt;传统方式: API 转发 (VMM 代理执行)，非完整硬件虚拟化，性能 / 扩展性不足。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发展&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;2013: AWS 推出商业化 GPU 实例。&lt;/li&gt;
&lt;li&gt;2014: 主流 GPU 平台硬件辅助全虚拟化方案出现 (NVIDIA GPUvm, Intel gVirt)。&lt;/li&gt;
&lt;li&gt;2017: Intel KVMGT (GPU 全虚拟化方案) 加入 Linux 内核 4.10。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FPGA 虚拟化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;FPGA 是可重配置计算资源，与现有虚拟化框架不兼容，使用场景趋向独占。&lt;/li&gt;
&lt;li&gt;FPGA 器件与开发生态 (工具链 / 库) 紧密耦合，特定型号需特定软件生成二进制文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挑战&lt;/strong&gt;：缺乏统一的二进制接口规范。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RDMA 虚拟化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;RDMA (远程直接内存访问): 通过 DMA 实现主机间内存直接访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用&lt;/strong&gt;：近年在 HPC 等领域探索 RDMA 硬件虚拟化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实践&lt;/strong&gt;: Microsoft Azure 尝试推出带 RDMA 网络支持的 VM 租赁服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NVM 虚拟化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;NVM (非易失性内存): 兼具内存高性能 (字节寻址) 和存储持久性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挑战&lt;/strong&gt;：价格高、容量小、使用方式多变。虚拟化支持并投入云环境仍处研究起步阶段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;硬件虚拟化的未来&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#硬件虚拟化的未来&#34;&gt;#&lt;/a&gt; 硬件虚拟化的未来&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;极端虚拟化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;宏观&lt;/strong&gt;：单机构建巨规模 / 巨型虚拟机 (因新型硬件增强单机能力)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;微观&lt;/strong&gt;：面向智能终端 / 极端受限环境的微型虚拟机 (便捷共享、高效抽象、按需重构、交互移动)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异构硬件的融合和归一化&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;基于 “软件定义” 原则，利用虚拟化融合 CPU, GPU, FPGA, RDMA 网卡，NVM, SSD 等异构硬件。&lt;/li&gt;
&lt;li&gt;实现异构硬件归一化管理，提供统一编程接口。&lt;/li&gt;
&lt;li&gt;根据应用需求动态选择后台执行硬件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多硬件和特性的聚合和抽象&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;现状&lt;/strong&gt;：虚拟化侧重 “一虚多”(单个物理资源 -&amp;gt; 多个虚拟资源)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未来&lt;/strong&gt;：利用新型硬件实现 “多虚一”，聚合多硬件 / 多特性，提升性能，突破单硬件物理极限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实践-xen-虚拟化技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实践-xen-虚拟化技术&#34;&gt;#&lt;/a&gt; 实践: Xen 虚拟化技术&lt;/h3&gt;
&lt;h4 id=&#34;xen-的历史&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#xen-的历史&#34;&gt;#&lt;/a&gt; Xen 的历史&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2003&lt;/strong&gt;: Ian Pratt (剑桥) 发表论文，提出基于&lt;strong&gt;半虚拟化&lt;/strong&gt;的 Xen 项目。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2005&lt;/strong&gt;: Xen 3.0 支持 Intel VT/IA64，可运行&lt;strong&gt;完全未修改&lt;/strong&gt;的操作系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2007&lt;/strong&gt;: Citrix 收购 XenSource。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;架构&lt;/strong&gt;: Type I Hypervisor (裸金属)，直接运行在硬件上。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hypervisor&lt;/strong&gt;: 最底层，直接与硬件交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Domain 0 (Dom0)&lt;/strong&gt;: 特权 VM，运行控制工具栈、物理设备驱动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Domain U (DomU)&lt;/strong&gt;: 普通客户 VM (Guest OS)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;xen-实际操作-概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#xen-实际操作-概述&#34;&gt;#&lt;/a&gt; Xen 实际操作 (概述)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;检查 CPU 是否支持 Xen 虚拟化。&lt;/li&gt;
&lt;li&gt;安装 Xen 相关软件包。&lt;/li&gt;
&lt;li&gt;创建虚拟机 (使用  &lt;code&gt;virt-manager&lt;/code&gt;  或命令行工具)。
&lt;ul&gt;
&lt;li&gt;选择虚拟化方法 (Paravirtualized / Fully virtualized)。&lt;/li&gt;
&lt;li&gt;配置 VM 名称、内存、CPU、存储、网络等。&lt;/li&gt;
&lt;li&gt;安装 Guest OS。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实践-kvm-虚拟化技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实践-kvm-虚拟化技术&#34;&gt;#&lt;/a&gt; 实践: KVM 虚拟化技术&lt;/h3&gt;
&lt;h4 id=&#34;kvm-简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#kvm-简介&#34;&gt;#&lt;/a&gt; KVM 简介&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全称&lt;/strong&gt;: Kernel Virtual Machine，Linux 内核提供的开源 Hypervisor，主流技术。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;要求&lt;/strong&gt;：主机 x86 架构 + &lt;strong&gt;硬件虚拟化支持&lt;/strong&gt; (Intel VT / AMD-V)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;架构&lt;/strong&gt;: Type II Hypervisor (寄居架构)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖&lt;/strong&gt;：需修改过的 QEMU (qemu-kvm) 作为虚拟机上层控制和界面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术&lt;/strong&gt;：以&lt;strong&gt;硬件辅助虚拟化&lt;/strong&gt;为主。硬件不支持时，退回 QEMU 软件模拟 (&lt;strong&gt;动态二进制翻译&lt;/strong&gt;实现 CPU 虚拟化)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：能在不改变 Linux/Windows 镜像下运行多 VM，可配置个性化硬件环境。支持多种操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;kvm-的基本安装操作-概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#kvm-的基本安装操作-概述&#34;&gt;#&lt;/a&gt; KVM 的基本安装操作 (概述)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;安装 KVM 及其依赖包 (qemu-kvm, libvirt, virt-manager 等)。&lt;/li&gt;
&lt;li&gt;启动  &lt;code&gt;libvirtd&lt;/code&gt;  服务，启动 Virtual Machine Manager ( &lt;code&gt;virt-manager&lt;/code&gt; ) 图形界面。&lt;/li&gt;
&lt;li&gt;配置桥接网络接口 (可选，使 VM 直接接入物理网络)。&lt;/li&gt;
&lt;li&gt;创建虚拟机:
&lt;ul&gt;
&lt;li&gt;在  &lt;code&gt;virt-manager&lt;/code&gt;  中新建 VM。&lt;/li&gt;
&lt;li&gt;选择安装方式 (本地 ISO / 网络 / 导入磁盘等)。&lt;/li&gt;
&lt;li&gt;配置 CPU、内存、存储、网络等。&lt;/li&gt;
&lt;li&gt;安装 Guest OS。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;docker简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker简介&#34;&gt;#&lt;/a&gt; Docker 简介&lt;/h3&gt;
&lt;h4 id=&#34;docker-为什么会出现-面临的问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-为什么会出现-面临的问题&#34;&gt;#&lt;/a&gt; Docker 为什么会出现？ (面临的问题)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;环境一致性问题&lt;/strong&gt;：开发环境 (笔记本)、测试环境、生产环境配置各异，导致 “在我机器上能跑” 但在其他环境跑不起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部署复杂性问题&lt;/strong&gt;：配置应用运行环境需安装多种软件和依赖包 (Java/Tomcat/MySQL/JDBC 等)，过程繁琐、易出错且跨平台 (Win/Linux) 需重配，应用移植麻烦。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交付标准化问题&lt;/strong&gt;：传统交付物是程序 / 字节码，需附加部署文件和详细环境说明，运维部署易出错。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;docker-是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-是什么&#34;&gt;#&lt;/a&gt; Docker 是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基于 &lt;strong&gt;Linux 容器技术&lt;/strong&gt;发展来的&lt;strong&gt;轻量级容器虚拟化技术&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：解决代码在本机能运行，但在其他机器部署运行失败的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现方式&lt;/strong&gt;：通过&lt;strong&gt;镜像 (Image)&lt;/strong&gt; 将程序运行所需的环境、系统、配置、数据等自下而上打包，实现应用跨平台无缝运行，打破 “程序即应用” 观念。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：提供系统平滑移植的&lt;strong&gt;标准化解决方案&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;docker-理念&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-理念&#34;&gt;#&lt;/a&gt; Docker 理念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;核心目标&lt;/strong&gt;: &lt;strong&gt;Build, Ship and Run Any App, Anywhere&lt;/strong&gt; (构建、发布、运行任意应用在任意地方)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;：通过应用组件的封装、分发、部署、运行等生命周期管理，使应用及其运行环境做到 “&lt;strong&gt;一次镜像，处处运行&lt;/strong&gt;”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效果&lt;/strong&gt;：实现跨平台、跨服务器部署，只需一次配置环境，一键部署，简化操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;docker-定义总结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-定义总结&#34;&gt;#&lt;/a&gt; Docker 定义总结&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;互联网行业热门技术，尤其在&lt;strong&gt;开发&lt;/strong&gt;和&lt;strong&gt;运维&lt;/strong&gt;方向，解决规模化、灵活化部署问题。&lt;/li&gt;
&lt;li&gt;用于解决&lt;strong&gt;运行环境&lt;/strong&gt;和&lt;strong&gt;配置问题&lt;/strong&gt;，方便做&lt;strong&gt;持续集成&lt;/strong&gt;，有助于整体发布的&lt;strong&gt;容器虚拟化技术&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;容器与虚拟机比较&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器与虚拟机比较&#34;&gt;#&lt;/a&gt; 容器与虚拟机比较&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;传统虚拟机技术&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;带环境安装的解决方案 (如 Win10 里跑 CentOS)。&lt;/li&gt;
&lt;li&gt;对应用程序透明，模拟完整系统。&lt;/li&gt;
&lt;li&gt;缺点: &lt;strong&gt;资源占用多&lt;/strong&gt; (需完整 OS)、&lt;strong&gt;冗余步骤多&lt;/strong&gt; (启动 OS)、&lt;strong&gt;启动慢&lt;/strong&gt; (分钟级)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器虚拟化技术 (Docker/LXC)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;操作系统层面&lt;/strong&gt;实现虚拟化，&lt;strong&gt;直接复用宿主机操作系统内核&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离进程&lt;/strong&gt;而非模拟完整 OS，将软件运行所需资源打包到隔离容器中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;: &lt;strong&gt;启动速度快&lt;/strong&gt; (秒级)，&lt;strong&gt;占用体积小&lt;/strong&gt; (MB 级 vs GB 级)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对比总结&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;虚拟机：虚拟硬件 -&amp;gt; 运行完整 Guest OS -&amp;gt; 运行应用。&lt;strong&gt;重&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;容器：直接运行于宿主内核 -&amp;gt; 隔离应用进程。&lt;strong&gt;轻&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;隔离性：虚拟机 &amp;gt; 容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;docker-能干嘛&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-能干嘛&#34;&gt;#&lt;/a&gt; Docker 能干嘛？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;技术职位变化&lt;/strong&gt;: Coder -&amp;gt; Programmer -&amp;gt; Software Engineer -&amp;gt; &lt;strong&gt;DevOps Engineer&lt;/strong&gt; (体现了开发运维一体化趋势)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一次构建、随处运行&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更快速的应用交付和部署&lt;/strong&gt;：打包应用及依赖成镜像，简化部署流程，节省配置测试时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更便捷的升级和扩缩容&lt;/strong&gt;：微服务架构下，容器如 “积木”，升级 / 扩容只需操作对应容器镜像 (分钟级甚至秒级)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更简单的系统运维&lt;/strong&gt;：应用容器化后，开发 / 测试 / 生产环境高度一致，减少环境问题，易于定位修复 BUG。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更高效的计算资源利用&lt;/strong&gt;：内核级虚拟化，无 Hypervisor 额外开销，单机可运行更多容器，提升物理资源利用率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;借鉴标准集装箱思想，Docker 用于&lt;strong&gt;运输软件&lt;/strong&gt; (封装应用和依赖)。&lt;/li&gt;
&lt;li&gt;适用于各种应用场景 (静态网站、用户数据库、Web 前端、消息队列、数据库等)。&lt;/li&gt;
&lt;li&gt;开发 -&amp;gt; 测试 -&amp;gt; 生产环境迁移，保证环境一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用企业&lt;/strong&gt;：微博、美团、蘑菇街等众多互联网公司广泛应用 Docker 进行私有云实践和业务部署。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;docker的安装&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker的安装&#34;&gt;#&lt;/a&gt; Docker 的安装&lt;/h3&gt;
&lt;h4 id=&#34;下载与准备&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#下载与准备&#34;&gt;#&lt;/a&gt; 下载与准备&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;官网&lt;/strong&gt;: &lt;a href=&#34;https://www.docker.com&#34;&gt;https://www.docker.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仓库&lt;/strong&gt;: &lt;a href=&#34;https://hub.docker.com&#34;&gt;https://hub.docker.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前提说明&lt;/strong&gt;: Docker 依赖 Linux 内核。在 Windows/Mac 上部署 Docker，实质是先安装一个 Linux 虚拟机，然后在虚拟机内运行 Docker。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统要求&lt;/strong&gt;: CentOS 7 (64-bit)，Linux 内核版本 &amp;gt;= 3.8。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查看内核&lt;/strong&gt;:  &lt;code&gt;uname -r&lt;/code&gt; ,  &lt;code&gt;cat /etc/redhat-release&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;docker-三要素&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-三要素&#34;&gt;#&lt;/a&gt; Docker 三要素&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;镜像 (Image)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;用于创建 Docker 容器。一个镜像可创建多个容器。&lt;/li&gt;
&lt;li&gt;本质是一个文件系统 (e.g.,  &lt;code&gt;centos:7&lt;/code&gt;  包含最小化 CentOS 7 系统)。&lt;/li&gt;
&lt;li&gt;类似 Java 的 &lt;strong&gt;类&lt;/strong&gt; (静态定义)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器 (Container)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;用 Docker 镜像创建的&lt;strong&gt;运行实例&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;类似虚拟化运行环境，应用程序 / 服务运行其中。&lt;/li&gt;
&lt;li&gt;类似 Java 的 &lt;strong&gt;对象实例&lt;/strong&gt; (运行时实体)。&lt;/li&gt;
&lt;li&gt;提供标准隔离环境 (启动 / 停止 / 删除)。&lt;/li&gt;
&lt;li&gt;看作&lt;strong&gt;简易版 Linux 环境&lt;/strong&gt; + 运行的应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仓库 (Repository)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;集中存放&lt;strong&gt;镜像文件&lt;/strong&gt;的场所。&lt;/li&gt;
&lt;li&gt;类似 Maven 仓库 (存 jar) 或 Github 仓库 (存 git 项目)。&lt;/li&gt;
&lt;li&gt;分&lt;strong&gt;公开仓库 (Public)&lt;/strong&gt; 和&lt;strong&gt;私有仓库 (Private)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;最大公开仓库: &lt;strong&gt;Docker Hub&lt;/strong&gt; (官方)。国内有阿里云、网易云等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;docker-平台架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-平台架构&#34;&gt;#&lt;/a&gt; Docker 平台架构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Client-Server 结构&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Docker Client&lt;/strong&gt;: 用户与 Docker 交互的命令行工具或 UI。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker Daemon (守护进程)&lt;/strong&gt;: 运行在主机上，接收并处理 Client 命令，管理容器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信&lt;/strong&gt;: Client 通过 Socket 与 Daemon 通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器&lt;/strong&gt;: Daemon 管理的运行时环境 (集装箱)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;docker-平台架构及通信原理简述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-平台架构及通信原理简述&#34;&gt;#&lt;/a&gt; Docker 平台架构及通信原理简述&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;用户使用 &lt;strong&gt;Docker Client&lt;/strong&gt; 与 &lt;strong&gt;Docker Daemon&lt;/strong&gt; 建立通信并发送请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker Daemon&lt;/strong&gt; 作为 Server 接收请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker Engine&lt;/strong&gt; 执行内部工作，每个工作是一个 &lt;strong&gt;Job&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;需要镜像时，从 &lt;strong&gt;Docker Registry&lt;/strong&gt; 下载，通过 &lt;strong&gt;Graph driver&lt;/strong&gt; 以 Graph 形式存储。&lt;/li&gt;
&lt;li&gt;需创建网络时，通过 &lt;strong&gt;Network driver&lt;/strong&gt; 创建配置容器网络。&lt;/li&gt;
&lt;li&gt;需限制资源或执行指令时，通过 &lt;strong&gt;Exec driver&lt;/strong&gt; 完成。&lt;/li&gt;
&lt;li&gt;底层通过 &lt;strong&gt;Libcontainer&lt;/strong&gt; (独立容器管理包) 实现对容器的具体操作 (Network/Exec driver 都调用它)。&lt;strong&gt;Namespace&lt;/strong&gt; 实现资源隔离，&lt;strong&gt;Cgroups&lt;/strong&gt; 实现资源控制。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;docker-安装步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-安装步骤&#34;&gt;#&lt;/a&gt; Docker 安装步骤&lt;/h4&gt;
&lt;h4 id=&#34;测试-hello-world&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#测试-hello-world&#34;&gt;#&lt;/a&gt; 测试 hello-world&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker run hello-world&lt;/code&gt; : 运行测试镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流程&lt;/strong&gt;：本地无镜像 -&amp;gt; 从 Docker Hub 拉取 -&amp;gt; 运行容器 -&amp;gt; 输出信息 -&amp;gt; 容器退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;底层原理-docker-为何比-vm-快&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#底层原理-docker-为何比-vm-快&#34;&gt;#&lt;/a&gt; 底层原理: Docker 为何比 VM 快？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;更少的抽象层&lt;/strong&gt;: Docker 无需 Hypervisor 实现硬件虚拟化，直接使用宿主机硬件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享宿主机内核&lt;/strong&gt;: Docker 容器共享宿主机 OS 内核，无需加载额外 OS 内核。避免了 VM 启动引导、加载 OS 内核等耗时过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;结果&lt;/strong&gt;: VM 创建是分钟级，Docker 容器创建是秒级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;docker常用命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker常用命令&#34;&gt;#&lt;/a&gt; Docker 常用命令&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/e350a74de6ee313b99b9080dc22f3bcce52541aa77e8f8c85a38830431330831.png&#34; alt=&#34;picture 17&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;帮助启动类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#帮助启动类&#34;&gt;#&lt;/a&gt; 帮助启动类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;systemctl start/stop/restart/status/enable docker&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker info&lt;/code&gt; : 查看 Docker 系统信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker version&lt;/code&gt; : 查看 Docker 版本信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker --help&lt;/code&gt; : 查看 Docker 帮助。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker COMMAND --help&lt;/code&gt; : 查看具体命令帮助。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;镜像命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#镜像命令&#34;&gt;#&lt;/a&gt; 镜像命令&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker images&lt;/code&gt;  /  &lt;code&gt;-a&lt;/code&gt;  /  &lt;code&gt;-q&lt;/code&gt;  /  &lt;code&gt;--digests&lt;/code&gt;  /  &lt;code&gt;--no-trunc&lt;/code&gt; : 列出本地镜像 (所有 / 仅 ID / 摘要 / 完整信息)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker search &amp;lt;image_name&amp;gt;&lt;/code&gt; : 在 Docker Hub 搜索镜像。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker pull &amp;lt;image_name&amp;gt;[:TAG]&lt;/code&gt; : 下载镜像 (默认 latest)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker rmi &amp;lt;image_name_or_id&amp;gt;&lt;/code&gt;  /  &lt;code&gt;-f&lt;/code&gt; : 删除未使用镜像 (强制删除)。可删除多个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker system df&lt;/code&gt; : 查看 Docker 资源占用 (镜像 / 容器 / 数据卷)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚悬镜像 (Dangling Image)&lt;/strong&gt;: 仓库名和 TAG 均为  &lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;  的镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;容器命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器命令&#34;&gt;#&lt;/a&gt; 容器命令&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker run [options] IMAGE [command] [arg...]&lt;/code&gt; : 新建并启动容器。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; : 交互模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; : 分配伪终端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; : 后台运行 (守护式容器)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker ps&lt;/code&gt;  /  &lt;code&gt;-a&lt;/code&gt;  /  &lt;code&gt;-q&lt;/code&gt; : 列出正在运行的容器 (所有 / 仅 ID)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exit&lt;/code&gt; : 退出&lt;strong&gt;并停止&lt;/strong&gt;容器 (交互式)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+P+Q&lt;/code&gt; : 退出容器但&lt;strong&gt;不停止&lt;/strong&gt; (交互式)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker start/restart/stop/kill &amp;lt;container_name_or_id&amp;gt;&lt;/code&gt; : 启动 / 重启 / 停止 / 强制停止容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker rm &amp;lt;container_name_or_id&amp;gt;&lt;/code&gt;  /  &lt;code&gt;-f&lt;/code&gt; : 删除已停止的容器 (强制删除运行中容器)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker logs [options] &amp;lt;container_name_or_id&amp;gt;&lt;/code&gt; : 查看容器日志 ( &lt;code&gt;-t&lt;/code&gt;  时间戳， &lt;code&gt;-f&lt;/code&gt;  跟随， &lt;code&gt;--tail N&lt;/code&gt;  最后 N 条)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker top &amp;lt;container_name_or_id&amp;gt;&lt;/code&gt; : 查看容器内运行的进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker inspect &amp;lt;container_name_or_id&amp;gt;&lt;/code&gt; : 查看容器内部细节 (JSON 格式)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec -it &amp;lt;container_id&amp;gt; /bin/bash&lt;/code&gt; : 进入正在运行的容器并执行命令 (exit 不停止容器)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker attach &amp;lt;container_id&amp;gt;&lt;/code&gt; : 重新附加到容器终端 (exit 会停止容器)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker cp &amp;lt;container_id:src_path&amp;gt; &amp;lt;host_dest_path&amp;gt;&lt;/code&gt; : 从容器内拷贝文件到宿主机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;docker镜像&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker镜像&#34;&gt;#&lt;/a&gt; Docker 镜像&lt;/h3&gt;
&lt;h4 id=&#34;镜像是什什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#镜像是什什么&#34;&gt;#&lt;/a&gt; 镜像是什什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;轻量级、可执行的独立软件包。&lt;/li&gt;
&lt;li&gt;包含运行应用所需的一切：代码、运行时、库、环境变量、配置文件。&lt;/li&gt;
&lt;li&gt;用于生成 Docker 容器实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分层的镜像&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分层的镜像&#34;&gt;#&lt;/a&gt; 分层的镜像&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker pull&lt;/code&gt;  过程显示镜像是一层一层下载的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;联合文件系统-unionfs&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#联合文件系统-unionfs&#34;&gt;#&lt;/a&gt; 联合文件系统 (UnionFS)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Docker 镜像由&lt;strong&gt;一层层文件系统&lt;/strong&gt;组成，这种层级文件系统即 UnionFS。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：分层、轻量级、高性能。支持将文件系统修改作为一次提交层层叠加。可将不同目录挂载到同一虚拟文件系统下，对外透明。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础&lt;/strong&gt;: UnionFS 是 Docker 镜像的基础。镜像通过&lt;strong&gt;分层继承&lt;/strong&gt;，基于基础镜像 (无父镜像) 制作应用镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;docker-镜像加载原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-镜像加载原理&#34;&gt;#&lt;/a&gt; Docker 镜像加载原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bootfs (boot file system)&lt;/strong&gt;: 包含 bootloader 和 kernel。Linux 启动时加载，完成后内核接管内存，bootfs 被卸载。&lt;strong&gt;各发行版一致，可共享&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rootfs (root file system)&lt;/strong&gt;: 位于 bootfs 之上，包含  &lt;code&gt;/dev&lt;/code&gt; ,  &lt;code&gt;/proc&lt;/code&gt; ,  &lt;code&gt;/bin&lt;/code&gt; ,  &lt;code&gt;/etc&lt;/code&gt;  等标准目录和文件。代表不同操作系统发行版 (Ubuntu, CentOS)。&lt;strong&gt;不同发行版有差别&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;精简 OS 的 rootfs 可以很小，只需基本命令 / 工具 / 库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;docker-镜像采用分层结构的好处&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-镜像采用分层结构的好处&#34;&gt;#&lt;/a&gt; Docker 镜像采用分层结构的好处&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;镜像特点&lt;/strong&gt;: Docker 镜像是&lt;strong&gt;只读&lt;/strong&gt;的。容器启动时，在镜像顶部加载一个&lt;strong&gt;可写层 (容器层)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分层优点&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享资源&lt;/strong&gt;：多个镜像若基于相同 Base 镜像构建，Host 只需存一份 Base 镜像。内存中也只需加载一份 Base 镜像，供所有容器共享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方便复制迁移与复用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;docker-镜像-commit-操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#docker-镜像-commit-操作&#34;&gt;#&lt;/a&gt; Docker 镜像 - commit 操作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker commit -m &amp;quot;message&amp;quot; -a &amp;quot;author&amp;quot; &amp;lt;container_id&amp;gt; &amp;lt;target_image_name&amp;gt;[:TAG]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;容器的当前状态&lt;/strong&gt; (包括其可写层的修改) 提交，生成一个新的镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;总结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总结&#34;&gt;#&lt;/a&gt; 总结&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Docker 镜像分层，支持通过扩展现有镜像创建新镜像 (类似 Java 继承)。&lt;/li&gt;
&lt;li&gt;新镜像是从 Base 镜像一层层叠加生成。每次安装软件，都在现有镜像基础上增加一层。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;容器数据卷-volume&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器数据卷-volume&#34;&gt;#&lt;/a&gt; 容器数据卷 (Volume)&lt;/h3&gt;
&lt;h4 id=&#34;是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#是什么&#34;&gt;#&lt;/a&gt; 是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用于&lt;strong&gt;持久化&lt;/strong&gt;容器数据，解决容器删除后数据丢失问题。&lt;/li&gt;
&lt;li&gt;是宿主机上的一个&lt;strong&gt;目录或文件&lt;/strong&gt;，通过 Docker 挂载到容器中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独立于联合文件系统 (UFS)&lt;/strong&gt;，生命周期独立于容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;容器内添加数据卷&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器内添加数据卷&#34;&gt;#&lt;/a&gt; 容器内添加数据卷&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker run -it -v /host_absolute_path:/container_path[:ro] &amp;lt;image_name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将宿主机目录与容器内目录绑定。两者内容&lt;strong&gt;实时同步&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:ro&lt;/code&gt;  表示只读挂载 (容器内不可写)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;容器数据卷的特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容器数据卷的特点&#34;&gt;#&lt;/a&gt; 容器数据卷的特点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;可在容器间&lt;strong&gt;共享或重用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;容器与宿主机间&lt;strong&gt;数据共享&lt;/strong&gt;，修改&lt;strong&gt;即时生效&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;数据卷的更改&lt;strong&gt;不包含&lt;/strong&gt;在镜像更新中 (commit 不会打包数据卷内容)。&lt;/li&gt;
&lt;li&gt;数据卷生命周期持续到&lt;strong&gt;没有容器使用它为止&lt;/strong&gt; (容器删除，数据卷&lt;strong&gt;不会&lt;/strong&gt;被删除)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;数据卷的继承和共享&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据卷的继承和共享&#34;&gt;#&lt;/a&gt; 数据卷的继承和共享&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker run -it --volumes-from &amp;lt;source_container_name&amp;gt; --name &amp;lt;new_container_name&amp;gt; &amp;lt;image_name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新容器 ( &lt;code&gt;u2&lt;/code&gt; ) 可以继承另一个容器 ( &lt;code&gt;u1&lt;/code&gt; ) 挂载的数据卷。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dockerfile-解析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dockerfile-解析&#34;&gt;#&lt;/a&gt; Dockerfile 解析&lt;/h3&gt;
&lt;h4 id=&#34;是什么-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#是什么-2&#34;&gt;#&lt;/a&gt; 是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用来&lt;strong&gt;构建 Docker 镜像&lt;/strong&gt;的文本文件。&lt;/li&gt;
&lt;li&gt;包含一系列&lt;strong&gt;命令和参数&lt;/strong&gt;构成的脚本。&lt;/li&gt;
&lt;li&gt;内容定义了镜像构建过程：执行代码、设置环境变量、安装依赖包、指定运行时环境、操作系统发行版等。&lt;/li&gt;
&lt;li&gt;Docker 通过读取 Dockerfile 指令自动构建镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dockerfile-镜像-容器的关系-类比&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dockerfile-镜像-容器的关系-类比&#34;&gt;#&lt;/a&gt; Dockerfile, 镜像，容器的关系 (类比)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dockerfile&lt;/strong&gt;: 软件原材料 (中药处方)。 &lt;strong&gt;面向开发&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker 镜像&lt;/strong&gt;：软件交付品 (抓好的中药)。 成为&lt;strong&gt;交付标准&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker 容器&lt;/strong&gt;：软件镜像的运行态 (熬出的中药汤)。 涉及&lt;strong&gt;部署与运维&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dockerfile-构建过程解析&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dockerfile-构建过程解析&#34;&gt;#&lt;/a&gt; Dockerfile 构建过程解析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基础知识&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;每条保留字指令&lt;strong&gt;必须为大写字母&lt;/strong&gt;且后跟至少一个参数。&lt;/li&gt;
&lt;li&gt;指令按&lt;strong&gt;从上到下顺序执行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;  表示注释。&lt;/li&gt;
&lt;li&gt;每条指令都会创建一个新的&lt;strong&gt;镜像层&lt;/strong&gt;并对镜像进行提交。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大致流程&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;Docker 从基础镜像运行一个容器。&lt;/li&gt;
&lt;li&gt;执行一条指令，对容器作出修改。&lt;/li&gt;
&lt;li&gt;执行类似  &lt;code&gt;docker commit&lt;/code&gt;  的操作，提交一个新的镜像层。&lt;/li&gt;
&lt;li&gt;Docker 再基于刚提交的镜像运行一个新容器。&lt;/li&gt;
&lt;li&gt;重复 2-4 步，直到所有指令执行完毕。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dockerfile-常用保留字指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dockerfile-常用保留字指令&#34;&gt;#&lt;/a&gt; Dockerfile 常用保留字指令&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FROM&lt;/strong&gt;: 指定基础镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MAINTAINER&lt;/strong&gt;: 镜像维护者姓名和邮箱 (已废弃，推荐用 LABEL)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WORKDIR&lt;/strong&gt;: 指定容器工作目录 (后续 RUN/CMD/ENTRYPOINT/COPY/ADD 指令在此目录下执行)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ENV&lt;/strong&gt;: 设置环境变量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VOLUME&lt;/strong&gt;: 定义匿名数据卷，用于数据保存和持久化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EXPOSE&lt;/strong&gt;: 声明容器运行时对外暴露的端口 (仅声明，实际端口映射在  &lt;code&gt;docker run -p&lt;/code&gt;  指定)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ADD&lt;/strong&gt;: 复制文件 / 目录到镜像。支持 URL，且&lt;strong&gt;自动解压&lt;/strong&gt; tar 压缩包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;COPY&lt;/strong&gt;: 类似 ADD，复制文件 / 目录到镜像。&lt;strong&gt;不支持 URL 和自动解压&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RUN&lt;/strong&gt;: 在&lt;strong&gt;镜像构建时&lt;/strong&gt;执行命令 (e.g., 安装软件)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CMD&lt;/strong&gt;: 指定&lt;strong&gt;容器启动时&lt;/strong&gt;默认执行的命令。Dockerfile 可有多个 CMD，只有最后一个生效。会被  &lt;code&gt;docker run&lt;/code&gt;  后面的命令覆盖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ENTRYPOINT&lt;/strong&gt;: 指定&lt;strong&gt;容器启动时&lt;/strong&gt;执行的命令。&lt;strong&gt;不会&lt;/strong&gt;被  &lt;code&gt;docker run&lt;/code&gt;  后面的命令覆盖，参数会传递给 ENTRYPOINT 指定的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;run-cmd-entrypoint-对比&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#run-cmd-entrypoint-对比&#34;&gt;#&lt;/a&gt; RUN, CMD, ENTRYPOINT 对比&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RUN&lt;/strong&gt;: 构建时执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CMD&lt;/strong&gt;: 容器启动时执行 (默认命令，可被覆盖)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ENTRYPOINT&lt;/strong&gt;: 容器启动时执行 (入口点，不可被覆盖，参数追加)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Note&lt;/strong&gt;: RUN 在构建时运行并提交到镜像；CMD 在构建时不执行，在容器启动时执行，指定默认命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;案例-自定义镜像-centosjava810&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#案例-自定义镜像-centosjava810&#34;&gt;#&lt;/a&gt; 案例：自定义镜像 centosjava8:1.0&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;需求&lt;/strong&gt;：基于 CentOS 7，安装 vim, ifconfig, JDK 8。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;步骤&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;准备基础环境 (CentOS 7 镜像，JDK tar 包)。&lt;/li&gt;
&lt;li&gt;编写 Dockerfile (使用 FROM, MAINTAINER, ENV, WORKDIR, RUN, ADD, CMD 指令)。&lt;/li&gt;
&lt;li&gt;构建镜像:  &lt;code&gt;docker build -t &amp;lt;image_name&amp;gt;:&amp;lt;tag&amp;gt; .&lt;/code&gt;  (注意最后的点表示 Dockerfile 路径)。&lt;/li&gt;
&lt;li&gt;运行容器:  &lt;code&gt;docker run -it &amp;lt;image_name&amp;gt;:&amp;lt;tag&amp;gt;&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;验证 (检查 java -version, ifconfig)。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚悬镜像-dangling-image&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚悬镜像-dangling-image&#34;&gt;#&lt;/a&gt; 虚悬镜像 (Dangling Image)&lt;/h3&gt;
&lt;h4 id=&#34;是什么-3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#是什么-3&#34;&gt;#&lt;/a&gt; 是什么？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;镜像列表中，仓库名 (REPOSITORY) 和标签 (TAG) 都显示为  &lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;  的镜像。&lt;/li&gt;
&lt;li&gt;通常是由于构建了新镜像，覆盖了旧镜像的 TAG 导致旧镜像失去引用名。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;查看&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查看&#34;&gt;#&lt;/a&gt; 查看&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker image ls -f dangling=true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;删除&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#删除&#34;&gt;#&lt;/a&gt; 删除&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker image prune&lt;/code&gt; : 删除所有虚悬镜像。&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="computer science" />
        <category term="learning" />
        <category term="cloud computing" />
        <updated>2025-04-17T00:16:40.000Z</updated>
    </entry>
</feed>
