[{"id":"2ed5c397762475d4e4b4f7ab2d780b9f","title":"操作系统复习","content":" 概论\n 操作系统的定义和功能\n 操作系统的定义\n\n一组计算机程序的集合，主要用以控制和管理 计算机的硬件和软件资源，合理地组织计算机的工作流程，向应用程序和用户提供方便、快捷、友好的使用接口\n\n 操作系统的功能\n\n进程管理\n存储管理\n文件管理\n设备管理\n\n 操作系统的特征\n\n并发\n共享\n虚拟\n异步\n\n 操作系统的发展\n\n手工操作时代\n早期单道批处理系统时代\n多道批处理系统时代\n\n 操作系统的分类\n 批处理操作系统\n\n主要特征\n\n用户脱机工作\n成批处理作业\n单/多道程序运行\n作业周转时间长\n\n\n\n 分时操作系统\n\n主要特征：\n\n同时性。允许各终端用户同时工作，系统分时响应用户请求（使用CPU并不同时）\n交互性。支持联机的操作方式，用户可以在终端上通过操作系统进行人-机对话，随时控制和调试程序，以交互的方式工作\n独立性。用户之间彼此独立的工作，好象独占一台计算机系统一样，互不干扰\n及时性。用户请求能在较短的时间内得到响应\n\n\n\n 实时操作系统\n\n系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行\n\n 个人计算机操作系统\n\n主要特点：\n\n图形用户接口\n开放性\n多媒体支持\n应用软件丰富\n操作系统管理性能高\n\n\n\n 网络操作系统\n\n除具备通常操作系统功能外，还具备联网功能，支持网络体系结构和各种网络通信协议，提供网络互连能力，支持可靠、有效、安全的数据传输\n主要采用客户机/服务器(C/S)工作方式\n\n客户机一般由微型计算机承担，主动从本地向服务器提出服务请求\n服务器接收客户机请求、处理请求的服务、返回服务结果。一般由高档微机、小、中、大型机承担\n\n\n对等模式：网络中的每台计算机同时具有客户端和服务器两种功能\n\n 分布式操作系统\n\n特点：\n\n计算机网络系统的高级形式，由多台计算机组成，计算机之间没有主次之分\n数据和控制及任务的分布性、整体性、资源共享的透明性、各节点的自制性和协同性\n\n\n\n 嵌入式操作系统\n\n\n指运行在嵌入式(计算机)环境中，对整个系统各种部件和资源进行统一协调、处理、指挥和控制的系统软件。它具有通常操作系统的基本功能\n\n\n与一般操作系统有很大不同，主要体现在微型化、可定制、实时性、可靠性、易移植、开发工具与使用环境密切相关等特点\n\n\n 操作系统的接口\n 程序接口\n\n系统调用：“系统调用”可以获得操作系统的底层服务，从而进一步使用或访问系统管理的各种软硬件资源。不同的操作系统提供的系统调用的种类、数量和名字不尽相同\nAPI（application programming interface）\n\n常用的Windows系统，微软公司只公布了相关的API，它是一种应用程序编程接口，是在操作系统系统调用的基础经过规范整理出来，面向社会公布的唯一的接口方式\n由于不是直接的系统调用，其效率有所损失。微软公司没有发布全部的API，也为开发程序带来了一定的难度\n\n\n系统调用 &amp; POSIX标准\n\n系统调用内部的具体实现与硬件相关，直接使用会产生问题：\n\n接口复杂，使用困难\n应用程序的跨平台可移植性受到很大限制\n\n\nPOSIX标准：专门规定内核的系统调用接口标准，操作系统若遵循此标准，则应用程序在不同操作系统之间就具有可移植性\n\nUnix/Linux遵循此标准\nWindows NT-based 系统不能直接支持新版POSIX接口\n\n\n\n\n系统调用的处理过程\n\n应用程序使用系统调用时会产生一条指令（陷入指令或访管指令），该指令中存放了对应系统调用的功能号，有时还附带传递给内核的参数：系统调用—功能号—入口地址表—入口地址\n处理机在执行到该访管指令时发出相应的中断信号给“陷阱处理机制”\n陷阱处理机制启动相关的内核函数完成该系统调用所要求的功能：保护CPU现场、获取功能号、根据功能号查找对应内核函数入口地址表、转到入口地址执行内核函数、内核函数执行完，中断处理结束\n恢复CPU现场，继续执行中断点的下一条指令\n\n\n注意：执行系统调用时，应用程序从用户态（目态）转到了核心态（管态），即执行内核函数时必须在核心态下运行，但访管指令本身是在用户态下执行的\n\n 操作接口\n\n命令界面（CLI，Command Line Interface ）\n\n简单命令的一般形式：命令 参数1 参数2 … 参数n\nWindows操作系统的基本命令：type、erase、attrib、copy、xcopy、dir、cd、md、rd、tree、ver等\n\n\n图形界面（ GUI，Graphics User Interface ）\n作业控制命令\n\n专为批处理作业的用户提供的，所以也称批处理用户接口。操作系统提供一个作业控制语言JCL（Job Control Language），它由一组作业控制语句、作业控制操作命令及相应语法规范组成\n用户利用作业控制语言书写批处理作业控制说明书，操作系统解释作业控制说明书，按其要求一步步地运行用户作业。\n\nDOS下的批处理命令是一种简单的作业控制语言（.bat）\nUNIX的Shell语言是现代计算机一种功能强大的作业控制语言\n\n\n\n\n\n 操作系统的设计实现方法\n 操作系统设计与开发\n\n操作系统设计与开发特点\n\n与硬件关联\n复杂程度高\n生产周期长\n\n\n操作系统的设计原则\n\n可靠性\n方便性\n高效率\n易维护性\n可扩充性\n开放性\n\n\n\n 操作系统的体系结构\n\n无结构操作系统\n模块化结构\n分层结构\n客户/服务器结构（微内核）\n虚拟机结构\n面向对象结构\n\n 进程管理\n 程序的执行方式\n 程序的顺序执行\n\n一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行\n\n程序设计中的顺序控制结构仅能控制程序内部指令的执行序列\n程序的顺序执行意味着运行时程序间的执行序列也是顺序的——一个程序执行完了，才能执行另一个程序\n\n\n顺序执行的特性：\n\n顺序性\n封闭性\n可再现性\n程序的顺序执行方式便于程序的编制与调试，但不利于充分利用计算机系统资源，运行效率低下\n\n\n\n 程序的并发执行与并行执行\n\n为了提高系统的运行效率，允许“同时”执行多个程序\n并行（parallel）：多个事件在同一时刻发生\n并发（concurrent）：多个事件在同一时期内发生\n显然，并行是并发的特例，程序并行执行的硬件前提是系统中有多个CPU\n并发的本质是一个CPU在多个程序运行过程中的时分复用\n并发执行的特性：\n\n间断性\n开放/交互性\n不可再现性\n进行并发程序设计时应当避免由于程序间开放交互引起的不可再现性而产生运行时错误\n\n\n\n 进程概念的引入\n\n程序（program）：静态的代码文件（*.exe）\n进程（process）：程序在某个数据集合上的一次执行，系统资源分配的基本单位\n作业（job）：批处理系统要装入系统运行处理的一系列程序步骤和数据\n\n 进程的特征与控制\n 进程的相关概念\n\n\n进程有以下特征\n\n结构性\n动态性\n独立性\n并发性\n\n\n\n进程分类：系统进程、用户进程\n\n\n进程上下文（process context）\n\n用户级上下文（user-level context）：进程的代码区、数据区、用户栈区和共享存储区\n系统级上下文（system-level context）：PCB、内存管理信息、进程环境块、系统栈\n寄存器上下文（register context）\n一个进程被系统调度而占有CPU时，会发生CPU在新老进程之间切换，切换的内容是进程上下文，进程运行是在进程的上下文中执行的\n一个典型的上下文切换过程\n\n1234567891011context_switch( ){\n   Push registers onto stack\n   Save ptrs to code and data.\n   Save stack pointer //以上语句保护当前进程上下文\n   Pick next process to execute //选中/调度新进程\n  //以下语句恢复所选中/调度的进程的上下文\n   Restore stack ptr of that process\n   Restore ptrs to code and data.\n   Pop registers\n   Return\n}\n\n\n 进程状态及转换\n\n进程的状态\n\n就绪状态（ready）：进程在内存中已经具备执行的条件，等待分配CPU\n运行状态（running）：进程占用CPU并正在执行\n阻塞状态（blocked）：也称为等待（waiting）状态——运行的进程由于发生某事件而放弃CPU\n\n\n\n\n\n有挂起功能的进程状态：\n\n挂起就绪（ready suspended）\n挂起阻塞（blocked suspended）\n进程在运行态也可以被挂起，转换为挂起就绪状态\n阻塞状态的进程被挂起后，若阻塞事件或I/O请求完成，则进程状态转换为挂起就绪状态——仍然是挂起状态\n创建进程时若没有足够的内存空间，则转入挂起就绪状态\n只有处于就绪态的进程才有可能被调度分配CPU运行\n\n\n\n 进程控制块PCB\n\n为了描述和控制进程运行的数据结构——进程控制块（Process Control Block），或称为进程描述符（Process Descriptor），进程存在的惟一标志\n\n进程标识信息——内部标识符（PID）和外部标识符（进程名）\n现场信息——进程运行时CPU的即时状态——各寄存器的值\n控制信息——程序和数据地址、进程同步和通信机制信息、进程的资源清单和链接指针，进程状态、进程优先级……\n\n\n操作系统根据PCB对进程进行控制和管理\n\n查询进程现行状态及优先级\n恢复现场\n相关进程同步、通信\n\n\n创建新进程时，建立/分配PCB，进程结束时回收PCB\nPCB由系统多个功能模块读写，须常驻内存，并进一步组织形成队列\n\n 进程控制\n\n\nCPU的运行模式\n\n核心态（内核态），也称为管态（supervisor mode），Ring 0：内核代码、设备驱动、特权指令、直接访问物理内存空间、设备端口\n用户态，也称为目态，Ring 3：普通指令、保护模式安全限制、访问映射的虚拟地址空间、系统许可的映射端口\n\n\n\n不同于进程切换，也不一定引起进程切换或状态转换\n\n\n一般来说，当发生中断或系统调用时，用户进程暂停，CPU模式从用户态切换到核心态，执行系统服务例程，此时进程仍在原上下文中运行，仅模式变化\n\n\n进程控制——系统对进程生命周期的各个环节进行控制\n\n进程控制的职能是对系统中的所有进程实行有效的管理——对一个进程进行创建、撤销或终止，以及在某些进程状态间的转换控制\n允许一个进程创建和控制另一个进程，前者为父进程，后者为子进程\n\n\n\n进程控制通常由 原语（primitive） 完成 。\n\n\n原语的特性：\n\n由若干条指令组成，实现某个特定功能，在执行过程中不可被中断的程序段\n不可分割的执行单位，不能并发执行\n是操作系统核心（不是由进程而是由一组程序模块所组成）的一个组成部分，且常驻内存\n通常在核心态/管态下执行\n\n\n\n进程控制原语\n\n创建进程：建立PCB、填入信息、插入就绪队列，操作系统创建进程主要步骤\n（1）命名进程：为新进程设置进程标志符；\n（2）从PCB集合中为新进程申请一个空PCB；\n（3）确定新进程的优先级；\n（4）为新进程的程序段、数据段和用户栈分配内存空间；如果进程中需要共享某个已在内存的程序段，则必须建立共享程序段的链接指针；\n（5）为新进程分配除内存外的其它各种资源；\n（6）初始化PCB，将新进程的初始化信息写入进程控制块；\n（7）如果就绪队列能够接纳新创建的进程，则将新进程插入到就绪队列；\n（8）通知操作系统的记账、性能监控等管理模块\n导致创建进程的事件：登录、作业调度、提供服务——系统内核直接调用创建原语创建新进程、应用请求——由用户调用操作系统提供的系统调用完成（Windows的API：CreateProcess）\n撤消与终止进程：进程完成后，应退出系统而消亡，系统及时收回占有的全部资源以便其它进程使用，撤销原语撤销的是PCB，而非进程的程序段\n阻塞与唤醒进程：进程阻塞是进程的自主行为，唤醒则是被动的\n挂起与激活进程：既可以由该进程自己调用，也可由其它进程或系统调用，但激活原语只能由其它进程或系统调用\n\n\n\n 进程的互斥与同步\n 竞争和协作\n\n竞争，会引发以下两种极端情况：\n\n死锁（deadlock）：一组进程都陷入永远等待的状态\n饥饿（starvation）：被调度程序长期忽视\n\n\n协作——同步（synchronization）\n\n一个进程的执行依赖于其协作进程的消息或信号\n\n\n竞争——互斥（mutual exclusion）\n\n互斥也是一种特殊的同步——以一定次序协调地使用共享资源\n\n\n\n 与时间有关的错误\n\nBernstein条件\n\nR(pi)={a1,a2,…,an}R(p_i)=\\{a_1,a_2,…,a_n\\}R(pi​)={a1​,a2​,…,an​}，程序pip_ipi​在执行期间引用的变量集\nW(pi)={b1,b2,…,bm}W(p_i)=\\{b_1,b_2,…,b_m\\}W(pi​)={b1​,b2​,…,bm​}，程序pip_ipi​在执行期间改变的变量集\n若两个程序的变量集交集之和为空集：R(p1)∩W(p2)∪R(p2)∩W(p1)∪W(p1)∩W(p2)={}R(p_1)∩W(p_2)∪R(p_2)∩W(p_1)∪W(p_1)∩W(p_2)=\\{   \\}R(p1​)∩W(p2​)∪R(p2​)∩W(p1​)∪W(p1​)∩W(p2​)={}，则并发进程的执行与时间无关\n\n\n若两个进程共享了数据集，则可能存在制约关系，形成交互的并发进程\n执行的相对速度无法相互控制，可能会出现所谓与时间有关的错误\n\n 临界资源与临界区\n\n临界资源：在某段时间内只能允许一个进程使用的资源(打印机、磁带机等硬件设备和变量、队列等数据结构)\n临界区：进程中访问临界资源的代码段，几个进程若共享同一临界资源，它们必须以互斥的方式使用这个临界资源\n临界区调度原则：\n1）一次至多一个进程能够执行其临界区代码；\n2）如果已有进程在临界区运行，其它试图进入的进程应等待；\n3）进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入\n选择临界区调度策略时，不能因为该原则而造成进程饥饿或死锁\n实现临界区管理有软件和硬件两种方式\n\n 软件方法管理临界区\n\n\n实施依据是内存访问的基本互斥性——对内存同一地址的并发访问将被存储管理器序列化，而访问的顺序并无需事先指定，不需要硬件、操作系统或程序设计语言的任何支持\n\n\nPeterson算法（1981年）\n\n为每个进程设置标志flag用于表示该进程是否有意访问临界资源（进入临界区），又设置标志turn用于表示临界资源此时是否有其它进程在访问\n只有在对方进程的访问标志flag为true并且turn也为该进程标识时，才表明对方进程在访问临界资源，需要等待对方进程访问完并释放资源后才能访问；否则本进程不需要等待对方进程即可访问临界资源\n\n\n\n软件方法管理临界区的标志算法比较容易出现标志逻辑混乱的情况，其根本原因在于管理临界区标志要用两条指令：\n\n一条指令是看对方的标志\n一条指令是设置自己的标志\n\n\n\n进程并发可能导致进程在执行这两条指令时被另一个进程中断\n\n\n保证进程在执行这两条指令时不被中断，即可很容易地进行临界区管理\n\n\n 硬件方式管理临界区\n\n禁止中断法\n\n在检查临界区标志的两条指令之前将中断关上，临界区访问完后系统才打开中断\n缺点：影响计算机效率、不能及时处理重要程序、对多CPU系统无效\n\n\n特殊指令法\n\n特殊的硬件指令保证几个动作的原子性——不会被中断，不受到其它指令的干扰\n“测试并设置（Test and Set）”指令TS，或者交换（exchange）指令SWAP / xchg\n\n\nTS指令：将布尔变量x与临界区关联起来——如果x为真，表示没有进程在临界区内，临界资源可用，并立即将x置为false，即阻止其它进程进入临界区，访问临界资源；若x为假，则表示有其它进程进入临界区，本进程需要等待。\n\n1234567bool TS (bool &amp; x) {\n  if (x == true) {\n    x = false;\n    return true;\n  }\n  else return false;\n}\n\nTS指令实现互斥：\n\n12345678bool x = true；\ncobegin\n  process Pi ( ) {\n    while (!TS(x));\n    临界区 i\n    x = true;\n  }\ncoend\n\n用交换指令实现互斥：\n\n1234567891011bool lock = false;\ncobegin\n  process Pi() {\n    bool ki = true;\n    do {\n      SWAP(ki, lock);\n    } while(ki);\n    临界区i\n    SWAP(ki, lock);\n  }\ncoend\n 进程同步机制\n常见的同步机制有锁、信号量、管程和消息传递\n 信号量机制\n\n在这一体制下，进程在某一特殊点上被迫停止执行（阻塞）直到接收到一个对应的特殊变量值，这种特殊变量就是信号量(semaphore)，除了赋初值外，信号量的值只能由P操作和V操作进行修改，进程通过P、V这两个特殊操作在信号量所关联的系统资源上实现同步与互斥\n信号量表示系统资源的实体\n具体实现时，信号量是一种记录型数据结构，有两个分量：一个是信号量的值，另一个是在信号量关联资源上阻塞的进程队列的队头指针\n\n信号量在操作系统中的主要作用是封锁临界区、进程同步和维护资源计数。\nP操作和V操作原语的功能：\n\nP(s)：将信号量s的值减 1，若结果小于0，则调用P(s)的进程被阻塞，并进入信号量s的阻塞队列中；若结果不小于0，则调用P(s)的进程继续运行\nV(s)：将信号量s的值加1，若结果不大于0，则调用V(s)的进程从该信号量阻塞队列中释放、唤醒一个处于等待状态的进程，将其转换为就绪状态，调用V(s)的进程继续运行；若结果大于0，则调用V(s)的进程继续运行\n\n\n信号量的数据类型以及P、V操作原语的定义\n\n123456789101112typedef struct semaphore {\n  int value;\n  struct pcb *list;\n};\nvoid P(semaphore &amp;s) {\n  s.value--;            \n  if (s.value &lt; 0)  block(s.list);\n}                     \nvoid V(semaphore &amp;s) {\n  s.value++;            \n  if (s.value &lt;= 0)  wakeup(s.list);\n}\n\nP操作意味进程申请一个资源，求而不得则阻塞进程，V操作意味着释放一个资源，若此时还有进程在等待获取该资源，则被唤醒\n若信号量的值为正数，该正数表示可对信号量可进行的P操作的次数，即可用的资源数。信号量的初值一般设为系统中相关资源的总数，对于互斥信号量，初值一般设为1\n若信号量的值为负，其绝对值表示有多个进程申请该资源而又不能得到，在阻塞队列等待，即在信号量阻塞队列中等待该资源的进程个数\n信号量机制实现进程互斥进入临界区\n\n12345678semaphore mutex = 1;\ncobegin\n  process Pi( ) {  \n     P(mutex);\n     临界区i\n     V(mutex);\n  }\ncoend\n 进程同步的经典问题\n 生产者-消费者问题\n\nnnn个生产者进程和mmm个消费者进程，连接在一块长度为kkk个单位的有界缓冲区上（故此问题又称有界缓冲问题）。其中，PiP_iPi​和CjC_jCj​都是并发进程，只要缓冲区未满，生产者PiP_iPi​生产的产品就可送入缓冲区；只要缓冲区不空，消费者进程CjC_jCj​就可从缓冲区取走并消耗产品\n\n在并发环境下生产者、消费者进程访问缓冲区的速度不协调、不匹配——不同步，或者没有做到互不影响地使用、更新缓冲区——互斥，所以会出现运行错误甚至是死锁\n信号量机制解决多个生产者-消费者、共享多个缓冲区的生产者-消费者问题\n\n123456789101112131415161718192021222324252627282930item B[k];//缓冲区，长度 k\nsemaphore empty = k;//可用的空缓冲区数\nsemaphore full = 0;//缓冲区内可用的产品数\nsemaphore m1 = m2 = 1;//互斥信号量\nint in = 0;//缓冲区放入位置\nint out = 0;//缓冲区取出位置\ncobegin\nprocess producer_i() {\n  while (true) {\n    produce( );//生产一个产品\n    P(empty);/申请空缓冲区\n    P(m1);//申请互斥使用缓冲区\n    append to B[in]; //产品放入缓冲\n    in = (in + 1) % k;     //更新缓冲区指针\n    V(m1);\n    V(full);\n  }\n}\nprocess consumer_j() {    \n  while (true) {\n    P(full);\n    P(m2); \n    take( ) from B[out];\n    out = (out + 1) % k;\n    V(m2);\n    V(empty);\n    consume();\n  }\n}\ncoend\n 读者-写者问题\n\n两组并发进程，读者和写者，共享一个文件F，要求：\n\n允许多个读者进程同时读文件\n只允许一个写者进程写文件\n任何一个写者进程在完成写操作之前不允许其它读者或写者工作\n写者执行写操作前，应让已有的写者和读者全部退出\n\n\n信号量机制解决读者-写者问题\n\n1234567891011121314151617181920int readcount = 0;  //读进程计数器\nsemaphore ws = 1, mutex = 1;\ncobegin\nprocess reader_i() {\n  P(mutex);\n  readcount++;\n  if(readcount == 1) P(ws); \n  V(mutex);\n  读文件;\n  P(mutex);\n  readcount--;\n  if(readcount == 0) V(ws);\n  V(mutex);\n}\nprocess writer_j() {\n  P(ws);\n  写文件;\n  V(ws);\n}\ncoend\n\n写者优先算法\n\n12345678910111213141516171819202122232425semaphore  rmutex, wmutex, S; // S在写者到达后封锁读者\nrmutex = 1; wmutex = 1; S = 1; \nint count = 0;\ncobegin\nprocess reader {\n  P(S);\n  P(rmutex)\n  if (count == 0) P(wmutex)；\n  count++;\n  V(rmutex);\n  V(S);\n  READ FILE;\n  P(rmutex)；\n  count--;\n  if (count == 0) V(wmutex);\n  V(rmutex);\n}\nprocess writer{\n  P(S);\n  P(wmutex)；\n  WRITE the FILE;\n  V(wmutex);\n  V(S);\n}\ncoend\n 哲学家就餐问题\n\n五个哲学家围坐在一张圆桌前，每个哲学家面前有一碗意大利面和一只叉子，哲学家的生活由思考和进餐两个活动组成，进餐时需要两只叉子，但每个哲学家只有两只叉子，所以他们需要共享叉子\n算法1：给所有哲学家编号，奇数号的哲学家必须首先拿左边的筷子，偶数号的哲学家则反之。\n\n1234567891011121314151617181920semaphore chopsticks [5];\nfor (int i = 0; i &lt; 5; i++) chopsticks[i] = 1;\ncobegin\nprocess philmac_i() {//i=0,1,2,3,4\n  while (true) {\n    think()；\n    if(i % 2 == 0) {\n      P(chopsticks[i])；\n      P(chopsticks[(i + 1) % 5])；\n    }\n    else{\n      P(chopsticks[(i + l) % 5]);\n      P(chopsticks[i]);\n    }\n    eat()；\n    V(chopsticks[i])；\n    V(chopsticks([i + 1] % 5))；\n  }\n}\ncoend\n\n算法2：通过发放令牌最多允许4个哲学家同时吃面\n\n1234567891011121314151617semaphore chopsticks[5] = {1, 1, 1, 1, 1};\nsemaphore token = 4;//4个令牌\nint i;\ncobegin\nprocess philmac_i() {//i=0,1,2,3,4 \n  while (true) {\n    think();\n    P(token);\n    P(chopsticks[i]);\n    P(chopsticks[(i + l) % 5]);\n    eat();\n    V(chopsticks[(i + l) % 5]);\n    V(chopsticks[i]);\n    V(token);\n  }\n}\ncoend\n\n管程解决哲学家就餐问题的算法：\n\n采用Hoare管程实现，算法思想是将哲学家的状态分为思考、饥饿、吃面，并且仅当哲学家左右两边的筷子都可用才允许他拿筷子，否则一只筷子也不拿\n 睡眠理发师问题\n\n理发店里有一个理发师，一把理发椅，N个供等候顾客休息的椅子。若无顾客，理发师躺在理发椅上睡觉。顾客到来时唤醒理发师，若理发师正在理发，新来的顾客坐在空闲的休息椅上等候，如果没有空椅子，顾客离开。\n进程Barber()和Customer()分别描述理发师和顾客，理发师和顾客之间是同步的关系，顾客之间是互斥关系，竞争理发师和休息椅。\n算法采用信号量机制，引入一个控制变量和3个信号量：\n\n控制变量waiting用来记录等候理发的顾客数，初值为0；\n信号量customers用来关联表达等候理发的顾客数，并用作阻塞理发师进程，初值为0；\n信号量barbers用来记录正在等候顾客的理发师数，并用作阻塞顾客进程，初值为0；\n信号量mutex用于互斥，初值为1。\n\n\n\n 进程通信\n进程通信（IPC：Inter-Process Communication）是进程之间数据的相互交换和信息的相互传递，是一种高级通信机制\n 消息传递通信\n\n进程将通信数据封装在消息中，消息通过消息缓冲区在进程之间互相传递\n消息是指进程之间以不连续的成组方式发送的信息\n消息缓冲区应包含消息发送进程标识、消息接收进程标识、指向下一个消息缓冲区的指针、消息长度、消息正文等。缓冲区构成了进程通信的一个基本单位\n\n 直接通信\n\n在直接通信方式下，发送进程将发送的数据封装到消息正文后，发送进程必须给出接收进程的标识，然后用发送原语将消息发送给接收进程\n收发消息的原语：\n\nsend（接收进程标识，消息队列首指针）\nreceive（发送进程标识，接收区首地址指针）\n\n\n在直接通信中隐含着发送进程与接收进程之间的同步问题\nsend()：\n\n查找接收进程的PCB，存在，则申请一个存放消息的缓冲区，若消息缓冲区已满，则返回到非同步错误处理程序入口，进行特殊处理\n若接收进程因等待此消息的到来而处于阻塞状态，则唤醒此进程。将存放消息的缓冲区连接到接收进程的消息队列上\n两种同步方式\n\n发送进程阻塞等待接收进程发回的确认信息\n发送进程发送完消息后，不阻塞等待接收进程的回送信息，而是继续执行；限定时间到仍未收到确认消息，重发或放弃\n\n\n\n\nreceive()：\n\n接收进程在其进程空间中确定一个接收区，复制/读取消息缓冲区中的内容，释放消息缓冲区\n若无消息可读，则阻塞接收进程至有消息发送来为止\n两种同步方式\n\n接收进程调用receive原语并一直阻塞等待发送来的消息，直到接收到消息——与发送进程的第二种同步方式匹配\n接收进程调用receive原语后，不阻塞等待发送来的消息，而是继续执行——与发送进程的第一种同步方式匹配\n\n\n\n\n\n 间接通信\n\n消息传递的间接通信方式是指发送进程与接收进程之间通过邮箱来进行通信，发送进程将消息发送到邮箱，接收进程从邮箱接收消息\n\n发送原语：send(mailboxname, message);\n接收原语：receive(mailboxname, message);\n\n\n与直接通信比较，间接通信灵活性更大，不需要发送进程与接收进程同步，是一种方便、可靠的进程通信方式\n\n 共享内存通信\n\n共享内存通信分为\n\n基于共享数据结构的通信方式——比较低效，只适于传递少量数据\n基于共享存储区的通信方式\n\n\n\n共享内存通信的实现过程如下：\n\n建立共享内存区——标识和长度等参数\n共享内存区的管理\n共享内存区的映射与断开\n\n\n允许多个进程将共享内存映射到自己的地址空间，进程对各自所映射的地址段的读写操作代码应纳入临界区管理\n\n 管道通信\n\n管道是连接读、写进程的一个特殊文件，允许进程按FIFO方式传送数据，也能使进程同步执行操作。发送进程以字符流形式把数据送入管道，接收进程从管道中接收数据\n管道的实质是一个共享文件（文件系统的高速缓冲区中），进程对管道应该互斥使用\n写进程把一定数量的数据写入pipe，就去睡眠等待，直到读进程取走数据后，将其唤醒\n命名管道（named pipe）用来在不同的地址空间之间进行通信，不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信，特别为服务器通过网络与客户端交互而设计，是一种永久通信机制\n每一个命名管道都有一个唯一的名字\n\n 进程调度\n\n由于进程总数一般多于CPU数，必然会出现竞争CPU的情况。进程调度的功能就是按一定策略、动态地把CPU分配给处于就绪队列中的某一进程执行\n两种基本的进程调度方式，抢占方式和非抢占方式，也称剥夺式（preemptive）和非剥夺式（non_preemptive） 调度\n剥夺原则有：优先权原则、短进程优先原则、时间片原则等\n可能引发进程调度的时机：\n\n正在运行的进程运行完毕；\n运行中的进程要求I/O操作；\n执行某种原语操作(如P操作)导致进程阻塞；\n比正在运行的进程优先级更高的进程进入就绪队列；\n分配给运行进程的时间片已经用完\n\n\n\n 进程调度模型\n\n三级调度\n\n高级调度（High-Level Scheduling），作业调度\n\n从后备作业中选若干个作业，分配必要的资源，建立相应的用户作业进程和系统服务进程（如输人、输出进程），将其程序和数据调入内存……\n\n\n中级调度（Intermediate-Level Scheduling），平衡调度\n\n在内存紧张时，将一些暂时不能运行的进程对换到外存。当内存有空间时，再将其重新调入内存\n\n\n低级调度（Low-Level Scheduling），进程调度\n\n根据一定的算法将CPU分派给就绪队列中的一进程\n最基本的、必须的一种调度\n\n\n\n\n\n\n 调度算法选择/评价准则\n\n调度算法也称为调度策略 ，评价调度算法的参数：\n\n处理器利用率（CPU utilization）= CPU有效工作时间 / CPU总的运行时间\n响应时间（response time）：交互环境下用户从键盘提交请求开始，到系统首次产生响应为止的时间；是分时和实时系统调度性能重要指标。\n周转时间（turnaround time）：Ti =Tf–TsT_i =  T_f – T_sTi​ =Tf​–Ts​，即：周转时间 = 完成时刻 - 提交时刻；批处理系统重要指标\n带权周转时间：Wi= 作业的周转时间Ti/系统为作业提供的服务时间TsiW_i = 作业的周转时间T_i / 系统为作业提供的服务时间Ts_iWi​= 作业的周转时间Ti​/系统为作业提供的服务时间Tsi​，显然带权周转时间总大于1 。实质是，周转时间与系统为其提供服务的时间之比\n平均作业周转时间：T=(ΣTi)/nT = (ΣT_i) / nT=(ΣTi​)/n\n平均作业带权周转时间：W=(ΣWi)/nW = (ΣW_i) / nW=(ΣWi​)/n\n系统吞吐量（throughput）：单位时间内完成的进程（任务/交易）数目\n公平性：不出现饥饿情况\n\n\n\n 调度算法\n 先来先服务（First-Come First-Served，FCFS）\n\n按进程就绪的先后顺序来调度，到达得越早，就越先执行\n获得CPU的进程，未遇到其它情况时，一直运行下去\n是一种非抢占式算法，简单易实现\n没有考虑执行时间长短、运行特性和资源的要求\nFCFS调度算法适用性\n\n对长作业非常有利，对短作业不利\n对CPU繁忙型的作业非常有利，对I/O繁忙型作业非常不利——进程I/O阻塞结束后需再次排队\n非抢占式算法，对响应时间要求高的进程不利\n平均作业周转时间与作业提交的顺序有关\n\n\n\n 短作业优先（Shortest-Job-First，SJF）\n\n以进入系统的作业所要求的CPU服务时间为标准，总选取估计所需CPU时间最短的作业优先投入运行。\n\n算法易于实现，效率不高，主要弱点是忽视了作业等待时间。\n对长作业不利，如果系统不断接收短作业，可能会出现饥饿现象。\n非抢占式算法，对响应时间要求高的进程不利。\nSJF的平均作业周转时间比FCFS要小，故它的调度性能比FCFS好。\n实现SJF调度算法需要知道作业所需运行时间，而要精确知道一个作业的运行时间是办不到的。\n\n\n\n 最短剩余时间优先（Shortest Remaining Time First，SRTF）\n\n若一就绪状态的新作业所需的CPU时间比当前正在执行的作业剩余任务所需CPU时间还短，SRTF将打断正在执行作业，将执行权分配给新作业\nSRTF将SJF算法改为抢占式，因此只要有新作业进入就绪队列，就可能会引发进程切换。\nSRTF调度算法适用性：\n\n长进程仍有可能出现饥饿现象\n必须计算运行、剩余时间，系统开销增大\n因抢占式调度，系统性能会比SJF要好\n\n\n\n 高响应比优先（Highest Response Ratio First，HRRF）\n\n是FCFS与SJF两种算法的折衷，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业等待过久，改善了调度性能，仍属于非抢占式算法\n\n响应比为作业的响应时间与作业所需运行时间之比，简化为：响应比 ＝ 1 +（已等待的时间 / 估计运行时间）\n\n\nHRRF算法适用性：\n\n由定义可知，短作业容易得到较高响应比，长作业在等待了足够长的时间后，也将获得足够高的响应比，因此不会发生饥饿现象\n需要经常计算作业的响应比，导致额外的开销\nHRRF算法的平均周转时间和平均带权周转时间都介于FCFS与SJF算法之间，比SJF算法差，比FCFS算法优\n虽然HRRF算法的平均周转时间和平均带权周转时间不及SJF算法，但是，在现实中其可以实现，结果也比较可靠\n如果在算法中引入抢占调度，则算法过程会更复杂。因为所有作业的响应比是动态变化的，抢占时间的计算需要解多个方程得到\n\n\n\n 优先权（Highest-Priority-First，HPF）\n\n根据进程的优先权进行进程调度，每次总是选取优先权高的进程调度，也称优先级调度算法，一般是抢占式调度\n\n优先权通常用一个整数表示，也叫优先数\n\nWindows系统中有0~31共32个优先级，31最高\nUnix系统中，使用数值-20~+19来表示优先级，-20优先级最高\n\n\n优先权可由系统或用户给定\n\n静态优先权\n动态优先权\n\n\n\n\n\n 时间片轮转（Round-Ribon，RR）\n\n调度程序把CPU分配给进程使用一个规定的时段，称为一个时间片（如100ms），就绪队列中的进程轮流获得CPU的一个时间片。当一个时间片结束时，系统剥夺该进程执行权，等候下一轮调度，属于抢占式调度\n\n时间片的长短，影响进程的进度\n需要从进程数、切换开销、系统效率和响应时间等方面综合考虑，确定时间片大小\n\n\n\n 多级反馈队列（Multilevel-Feed-Queue，MFQ）\n\n又称反馈循环队列，是一种基于时间片的进程多级队列调度算法的改进算法。系统设置多个就绪队列，最高级就绪队列的优先级最高，随着就绪队列级别的降低优先级依次下降，较高级就绪队列的进程获得较短的时间片\n不需事先知道各进程所需运行时间，因而可行性较高，同时综合考虑了进程的时间和优先权因素，既照顾了短进程，又照顾了长进程，是一种综合调度算法，被广泛应用于各种操作系统中\n\n 多CPU系统中的调度\n\n多处理器系统的作用是利用系统内的多个CPU来并行执行用户进程，以提高系统的吞吐量或用来进行冗余操作以提高系统的可靠性\n系统的多个处理器在物理上处于同一机壳中，有一个单一的系统物理地址空间，多个处理器共享系统内存、外设等资源\n多CPU系统的类型主要有两种：\n\n主-从模式，只有一个主处理器，运行操作系统，管理整个系统资源，并负责为各从处理器分配任务，从处理器有多个，执行预先规定的任务及由主处理器分配的任务。这种类型的系统无法做到负载平衡，可靠性不高，很少使用。\n对称处理器模式SMP（Symmetric MultiProcessor），所有处理器都是相同的、平等的，共享一个操作系统，每个处理器都可以运行操作系统代码，管理系统资源。是目前比较常见的多CPU系统类型。\n\n\n多处理器系统中，比较有代表性的进（线）程调度方式有以下几种方式：\n\n自调度\n\n设置一个公共的进程或线程的就绪队列\n不会出现处理器空闲\n处理器互斥访问该队列，容易形成系统瓶颈\n高速缓存的使用效率很低\n协作线程很难同时运行\n\n\n组调度/群调度（Gang Scheduling）\n专用处理器分配\n动态调度\n\n操作系统和进程共同进行调度\n\n\n\n\n\n 多核CPU中的调度\n\n多核处理器是指在一枚处理器中集成两个或多个计算引擎（内核/core），称为CMP（Chip multiprocessors）结构，可在特定的时钟周期内执行更多任务，通常采用共享二级Cache的结构\n对于多核CPU，优化操作系统任务调度算法是保证效率的关键\n\n全局队列调度（多数系统）\n局部队列调度\n\n\n中断处理——全局中断控制器也需要封装在芯片内部\n系统提供同步与互斥机制——需要利用硬件提供的“读－修改－写”的原子操作或其他同步互斥机制\n\n 死锁\n\n一个进程集合中的每个进程都在等待只能由该集合中的其它一个进程才能引发的事件，则称一组进程或系统此时发生了死锁\n死锁一旦发生，会使整个系统瘫痪而无法工作。因此，必须想办法解决死锁问题\n\n 死锁产生的原因\n\n并发进程对临界资源的竞争\n并发进程推进顺序不当\n\n 死锁产生的必要条件\n\n\n互斥条件（Mutual exclusion）：资源的使用是互斥的\n\n\n请求与保持条件（Hold and wait）：已经得到某些资源的进程可以再申请新的资源。\n\n\n不剥夺条件（No pre-emption）：系统或其它进程不能剥夺进程已经获得的资源。\n\n\n环路等待条件（Circular wait）：系统中若干进程间形成等待环路\n\n\n只要破坏上述几个条件之一，即可防止死锁\n\n破坏第1个条件，使资源可同时访问而不是互斥使用，可行性较差\n破坏第2个条件，进程必须获得所需的所有资源才能运行——静态分配，严重降低资源利用效率。\n破坏第3个条件，采用剥夺式调度方法，只适用于CPU和内存分配\n破坏条件4，采用层次分配策略——按此策略分配资源时系统不会发生死锁\n资源按序分配策略：进程不得在占用资源rj(1≤j≤m)r_j(1≤j≤m)rj​(1≤j≤m)后再申请ri(i&lt;j)r_i(i&lt;j)ri​(i&lt;j)\n\n\n\n进程-资源分配图\n\n圆圈表示进程，资源类用方框表示，框中的圆点代表单个该类资源，有向边连接进程和资源\n申请边从进程指向资源类方框，表示进程正在等待资源；分配边从单个资源圆点指向进程，表示进程已经获得资源\n\n\n\n\n根据进程-资源分配图定义个得出如下结论：\n\n如果进程-资源分配图中无环路，则此时系统没有发生死锁\n如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程\n如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件\n\n\n\n进程-资源分配图可用以下步骤化简：\n\n在资源分配图中，找出一个既非等待又非孤立的进程结点PiP_iPi​，由于PiP_iPi​可获得它所需要的全部资源，且运行完后释放它所占有的全部资源，故可在资源分配图中消去PiP_iPi​所有的申请边和分配边，使之成为既无申请边又无分配边的孤立结点；\n将PiP_iPi​所释放的资源分配给申请它们的进程，即在资源分配图中将这些进程对资源的申请边改为分配边；\n重复前两步骤，直到找不到符合条件的进程结点。\n\n\n\n经过化简后，若能消去资源分配图中的所有边，使所有进程都成为孤立结点，则称该图是可完全化简的，否则为不可化简的\n\n\n系统为死锁状态的充分条件是：当且仅当该状态的进程-资源分配图是不可完全简化的——死锁定理。\n\n\n 死锁的避免\n\n死锁避免法是通过资源分配算法分析系统是否存在一个并发进程的状态序列，在确定不会进程循环等待的情况下，才将资源真正分配给进程，以保证并发进程不会产生死锁。\n死锁避免法能支持更高的进程并发度，动态地决定是否给进程分配资源——如果进程的资源请求方案会导致死锁，系统拒绝执行，反之，如果一个资源的分配会导致死锁，系统拒绝分配。\n\n 银行家调度算法\n\n\nDijkstra在1965年提出了避免死锁的银行家调度算法，该算法是以银行系统所采用的借贷策略（尽可能放贷、尽快回收资金）为基础而建立的算法模型。在此模型中，进程相当于贷款客户，系统资源相当于资金，调度程序相当于银行家（贷款经理）。\n\n\n进程约束条件：\n\n进程必须事先声明其资源需求\n进程每次提出部分资源申请并获得分配\n进程获得所需资源，执行完毕后，必须及时归还所占资源\n\n\n\n系统约束条件：\n\n若进程所请求得最大资源数不超过系统所有的资源总数，则系统一定分配资源给进程；\n系统保证在有限的时间内使资源不足而等待的进程获得资源\n\n\n\n思路\n\n在某一时刻，各进程已获得所需的部分资源。有一进程提出新的资源请求，系统将剩余资源试探性地分配给该进程。\n如果此时剩余资源能够满足余下的某些进程的需求，则将剩余资源分配给能充分满足的、资源需求缺口最大的进程，运行结束后释放的资源再并入系统的剩余资源集合。\n反复执行第2步，直到所有的进程都能够获得所需而运行结束。说明第1步的进程请求是可行的，系统处于安全状态，相应的进程执行序列称为系统的安全序列。\n如果所有的进程都试探过而不能将资源分配给进程，即不存在安全序列，则系统是不安全的。\n\n\n\n银行家算法所需的数据结构：假设系统中有n个进程，m类资源；\n\n系统当前资源剩余量向量Available[m] = &#123; R1，R2，……，Rm &#125;；\nn个进程对m类资源的需求声明矩阵Claim[n][m]，Claim[i][j]的值表示进程i对j类资源的总需求量；\nn个进程已获得的各类资源数量矩阵Possession[n][m]，Possession[i][j]的值k表示进程i已获得k个j类资源；\nn个进程的各类资源需求缺口矩阵Shortage[n][m] = Claim – Possession，Shortage[i][j]的值s表示进程i还需要（缺）s个j类资源；\n某进程i在某时刻发出的资源请求向量Request[m]，取值随具体情况而定。\n\n\n\n\n\n\n\n\n\n\n\n\n前4个数据结构及其取值确定了系统在某一时刻的状态，如果算法尝试资源分配方案能够使得所有进程安全运行完毕，则说明该状态安全，资源分配方案可行。\n\n\n银行家算法细化说明\n\n判断请求向量Request的有效性——超过相应进程总需求量则报错，超过系统目前剩余量则阻塞；\n就系统资源剩余量对Request进行试分配：\nAvailable[*] = Available[*] - Request[*]；\nPossession[i][*] = Possession[i][*] + Request[*]；\nShortage[i][*] = Shortage[i][*] - Request[*]；\n执行安全性测试算法，若安全则确认试分配方案，否则进程i阻塞；\n\n\n\n执行安全性测试算法细化说明：\n\n定义工作向量Rest[*] = Available[*]，进程集合Running&#123;*&#125;，布尔量possible = true；\n从Running集合中找出Pk，满足条件Shortage[k][*] &lt; Rest[*]；\n找到合格的进程Pk，则释放其占用资源（Rest[*] = Rest[*] + Possession[k][*]），将其从Running集合中去掉，重复步骤②；\n找不到合格的进程Pk，possible为false，退出安全性测试算法；\n最终检查Running集合，为空则返回安全，非空则不安全。\n\n\n\n银行家算法是一个很经典的死锁避免算法，理论性很强，看起来似乎很完美，但其实现要求进程不相关，并且事先要知道进程总数和各进程所需资源情况，所以可行性并不高。\n\n\n 检测与解除\n\n\n死锁的检测算法可以采用基于死锁定理的检测（进程-资源分配图化简），也可以采用类似于银行家算法中的安全性测试算法，如果算法退出时仍有未结束的进程，则系统不安全，那些未结束的进程就是死锁的进程。\n\n\n只不过死锁检测的不是试分配之后的系统状态，而是系统当前状态，需要考虑检查每个进程还需要的资源能否满足要求。\n\n\n在系统中，需要决定死锁检测的频率。如果检测太频繁，会花大量的时间检测死锁，浪费CPU的处理时间；如果检测的频率太低，死锁进程和系统资源被锁定的时间过长，资源浪费大。\n\n\n通常的方法是在CPU的使用率下降到一定的阈值时实施检测。当死锁发生次数多，死锁进程数增加到一定程度时，CPU的处理任务减少，CPU空闲时间增多。\n\n\n在系统成功地检测到死锁后，常用的死锁解除方法有以下几种：\n\n重启：重新启动死锁进程，甚至重启操作系统。\n撤销：撤销死锁进程，回收资源，优先选择占用资源最多或者撤销代价最小的，撤销一个不行就继续选择撤销进程，直至解除死锁。\n剥夺：剥夺死锁进程资源再分配，选择原则同上。\n回滚：根据系统保存的检查点，使进程或系统回退到死锁前的状态。\n\n\n\n 线程的基本概念\n","slug":"ComputerSystem","date":"2024-03-07T04:51:59.000Z","categories_index":"computer science","tags_index":"computer science,learning","author_index":"Ivan Snow"},{"id":"9eabaac45732ecdc3be940d0aaa9e3ce","title":"计算机组成原理复习","content":"\n\n\n 计算机系统概论\n 计算机的性能指标\n\n吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量。\n响应时间：表征从输入有效到系统产生响应之间的时间度量，例如微秒、纳秒。\n利用率：表示在给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。\n处理机字长：指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位。字长越长，表示计算的精度越高。\n总线宽度：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数。\n存储器容量：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。\n存储器带宽：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。\n主频/时钟周期：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频，主频的倒数称为CPU时钟周期（T），即T=1/f 。\nMIPS：平均每秒执行多少百万条定点指令数。\nFLOPS：每秒执行浮点操作的次数。\nCPU执行时间CPU执行时间CPU执行时间\n\nTCPU=IN×CPI×TCT_{CPU} = I_N \\times CPI \\times T_{C}TCPU​=IN​×CPI×TC​\nCPI=∑i=1nIiIN×CPIiCPI = \\sum_{i=1}^{n} \\frac{I_i}{I_N} \\times CPI_iCPI=∑i=1n​IN​Ii​​×CPIi​\n\n\n\n 计算机的硬件\n 运算器（ALU）\n\n功能：完成算术运算和逻辑运算。\n采用二进制的原因：\n\n容易实现\n运算规律简单\n抗干扰能力强，可靠性高\n为实现逻辑运算和逻辑判断提供了便利\n\n\n\n 存储器（Memory）\n\n功能：存储程序和数据，是计算机的主要组成部分。\n分类：\n\n按存储介质分类：半导体存储器、磁存储器、光存储器\n按存取方式分类：随机存储器（RAM）、只读存储器（ROM）、直接存储器（DMA）\n按存储容量分类：主存储器、辅助存储器\n\n\n\n 控制器（Control Unit）\n\n任务：从内存中取出解题步骤加以分析，然后执行某种操作。\n\n计算程序：解决某一问题的一串指令序列称为该问题的计算程序。\n指令形式 ：一条指令必须明确指示出从哪个单元中取数，并进行何种性质的操作；即指令由操作码和地址码组成，分别指出操作的性质和操作数的地址。\n控制器的基本任务：按照程序所排的指令序列，先从存储器中取出一条指令放到控制器中，对该指令的操作码由译码器进行分析判别，然后根据指令的性质，执行该指令，进行相应的操作；接着取出第二条指令，再执行第二条指令，依此类推。\n指令流（Instruction Stream）和数据流（Data Stream）：\n\n\n\n 适配器（adapter）和输入输出设备（I/O）\n\n适配器：相当于一个转换器，保证外围设备用计算机系统特性所要求的形式收发信息。\n常见有：网络适配器、显卡适配器等\n\n 总线（Bus）\n\n是构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路\n\n 冯.诺依曼结构计算机\n\n存储程序控制：要求计算机完成的功能，需要事先编制成相应的程序，并输入到存储器中，在控制器的控制下，有条不紊地工作。\n程序和数据都用二进制表示。\n程序由指令序列构成，任何一条指令都包含操作码和地址码。\n全机以CPU为中心，输入的信息在CPU控制下才能写入主存储器，输出的信息也只有在CPU控制下才能从主存储器中取出送至相应的输出设备。\n\n 计算机软件\n\n机器语言：使用1和0编制。计算机直接可以识别和执行。缺点：要熟悉指令系统、繁杂、容易出错、不易调试、只有专家使用。\n汇编语言：对机器指令采用助记符表示，能够用符号语言编写。简单直观、便于记忆。不能为计算机识别，使用汇编程序，把符号语言编写的程序翻译为机器代码。\n高级语言：按照实际需求规定一套基本符号以及由基本符号构成程序的规则。更加接近自然语言，直观通用、与具体机器无关。\n编译程序：把整个源程序翻译为机器代码或汇编代码的程序，它和运行系统一起组成编译系统。\n解释程序：对源程序逐行解释并立即执行的程序。\n操作系统：管理整个系统的软硬件资源，提高资源使用率，方便用户对计算机的使用。\n数据库管理系统：数据存储、处理、传输、查询、共享的管理程序\n\n 计算机系统的层次结构\n\n微程序设计级 -&gt; 一般机器级 -&gt; 操作系统级 -&gt; 汇编语言级 -&gt; 高级语言级\n\n 运算方法和运算器\n 数据与文字的表示方法\n 数据格式\n 定点数的表示方法\n\n小数点的位置固定，通常有纯小数和纯整数两种。\n\n 浮点数的表示方法\n\n对于任意进制数 N可表示：N=Re×mN=R^e \\times mN=Re×m（科学计数法），其中m是浮点数的尾数(纯小数、有效数字位数，精度)， e称为指数，为阶码(纯整数，小数点位置，范围) ，比例因子R为基数。在计算机中常为2、8、16。\n浮点数规格化表示(尾数):绝对值为&gt;=0.5(0除外)。形式为：0.1…，最高位1视为隐藏在小数点左侧，提高数据表示精度。\n指数表示：采用移码方式（加上一个固定的偏移值）。一个规格化的32位浮点数x的真值为：x=(−1)s×1.M×2E−127,e=E−127x=(-1)^s \\times 1.M \\times 2^{E-127},e=E-127x=(−1)s×1.M×2E−127,e=E−127\n机器零：当一个浮点的尾数为0，不论阶码为何值；或当阶码的值比阶码的最小值还小，不论尾数为何值，视为机器零\n\n 十进制数串的表示方法\n\n字符串的形式：一个字节存放一个十进制的数位或符号位。为了指明这样一个数，需要给出该数在主存中的起始地址和位数(串的长度)。主要用于非数值计算。\n压缩的十进制数串形式：一个字节存放两个十进制的数位。既节省存储空间，又便于直接完成算术运算，是广泛采用的较为理想的方法。\n\n 数的机器码表示\n 原码表示法\n\n定点小数原码定义：若x=x0.x1x2…xnx=x_0.x_1x_2…x_{n}x=x0​.x1​x2​…xn​，则[x]原={x0≤x&lt;11−x=1+∣x∣−1&lt;x≤0[x]_原=\\begin{cases} x &amp; 0\\leq x &lt;1 \\\\ 1-x=1+|x| &amp; -1&lt;x\\leq 0 \\end{cases}[x]原​={x1−x=1+∣x∣​0≤x&lt;1−1&lt;x≤0​\n定点整数原码定义：若x=x0x1x2…xnx=x_0x_1x_2…x_{n}x=x0​x1​x2​…xn​，则[x]原={x0≤x&lt;2n2n−x=2n+∣x∣−2n&lt;x≤0[x]_原=\\begin{cases} x &amp; 0\\leq x &lt;2^{n} \\\\ 2^n-x=2^n+|x| &amp; -2^{n}&lt;x\\leq 0 \\end{cases}[x]原​={x2n−x=2n+∣x∣​0≤x&lt;2n−2n&lt;x≤0​\n浮点数原码定义：阶码部分按照定点整数的方法进行编码，尾数部分按照定点小数的方法进行编码\n\n 补码表示法\n\n定点小数补码定义：若x=x0.x1x2…xnx=x_0.x_1x_2…x_{n}x=x0​.x1​x2​…xn​，则[x]补={x0≤x&lt;12+x=2−∣x∣−1&lt;x≤0(mod 2)[x]_补=\\begin{cases} x &amp; 0\\leq x &lt;1 \\\\ 2+x=2-|x| &amp; -1&lt;x\\leq 0 \\end{cases}(mod\\ 2)[x]补​={x2+x=2−∣x∣​0≤x&lt;1−1&lt;x≤0​(mod 2)\n定点整数补码定义：若x=x0x1x2…xnx=x_0x_1x_2…x_{n}x=x0​x1​x2​…xn​，则[x]补={x0≤x&lt;2n2n+1+x=2n+1−∣x∣−2n&lt;x≤0(mod 2n+1)[x]_补=\\begin{cases} x &amp; 0\\leq x &lt;2^{n} \\\\ 2^{n+1}+x=2^{n+1}-|x| &amp; -2^{n}&lt;x\\leq 0 \\end{cases}(mod\\ 2^{n+1})[x]补​={x2n+1+x=2n+1−∣x∣​0≤x&lt;2n−2n&lt;x≤0​(mod 2n+1)\n补码的表示范围\n\nn+1位补码小数的表示范围：1−2−n≤[x]补&lt;−11-2^{-n}\\leq [x]_补 &lt;-11−2−n≤[x]补​&lt;−1\nn+1位补码整数的表示范围：2n−1≤[x]补&lt;−2n2^n-1\\leq [x]_补 &lt;-2^n2n−1≤[x]补​&lt;−2n\n\n\n浮点数补码定义：阶码部分按照定点整数的方法进行编码，尾数部分按照定点小数的方法进行编码\n已知[x]补[x]_补[x]补​，求[x]原[x]_原[x]原​的方法：\n\n对于正数：[x]原=[x]补[x]_原=[x]_补[x]原​=[x]补​\n对于负数：[x]原=[[x]补]补[x]_原=[[x]_补]_补[x]原​=[[x]补​]补​\n\n\n已知[x]补[x]_补[x]补​，求[x/2]补[x/2]_补[x/2]补​，[x/4]补[x/4]_补[x/4]补​的方法：对[x]补连同符号位一起右移一位或二位，左边补一位或二位与原符号位相同的位。\n已知[x]补[x]_{\\text{补}}[x]补​，求[2x]补[2x]_{\\text{补}}[2x]补​，[4x]补[4x]_{\\text{补}}[4x]补​的方法：对[x]补[x]_补[x]补​连同符号位一起左移一位或二位，右边补一位或二位“0”\n\n 反码表示法\n\n定点小数反码定义：若x=x0.x1x2…xnx=x_0.x_1x_2…x_{n}x=x0​.x1​x2​…xn​，则[x]反={x0≤x&lt;1(2−2−n)+x−1&lt;x≤0[x]_反=\\begin{cases} x &amp; 0\\leq x &lt;1 \\\\ (2-2^{-n})+x &amp; -1&lt;x\\leq 0 \\end{cases}[x]反​={x(2−2−n)+x​0≤x&lt;1−1&lt;x≤0​\n定点整数反码定义：若x=x0x1x2…xnx=x_0x_1x_2…x_{n}x=x0​x1​x2​…xn​，则[x]反={x0≤x&lt;2n(2n+1−1)+x−2n&lt;x≤0[x]_反=\\begin{cases} x &amp; 0\\leq x &lt;2^{n} \\\\ (2^{n+1}-1)+x &amp; -2^{n}&lt;x\\leq 0 \\end{cases}[x]反​={x(2n+1−1)+x​0≤x&lt;2n−2n&lt;x≤0​\n浮点数反码定义：阶码部分按照定点整数的方法进行编码，尾数部分按照定点小数的方法进行编码\n\n 移码表示法\n\n设x=x0x1x2…xnx=x_0x_1x_2…x_{n}x=x0​x1​x2​…xn​，则[x]移=2n+x    2n&gt;x≥−2n[x]_移=2^{n}+x \\ \\ \\ \\  2^n&gt;x\\geq -2^n[x]移​=2n+x    2n&gt;x≥−2n\n\n 字符和字符串的编码\n 汉字的编码表示\n\n输入编码：数字编码、拼音码、字型编码等\n机内编码：一般用两个字节来实现\n输出编码：字模码\n\n 校验码\n\n奇偶校验码：在每个字符的最高位加一个奇偶校验位，使得每个字符的1的个数为奇数或偶数。\n循环冗余校验码：在每个字符的最高位加一个校验位，使得每个字符的1的个数为奇数或偶数。\n海明码：在每个字符的最高位加一个校验位，使得每个字符的1的个数为奇数或偶数。\n\n 定点加减法\n 定点补码加减法\n\n加法：[x+y]补=[x]补+[y]补(mod 2)[x+y]_补=[x]_补+[y]_补(mod\\ 2)[x+y]补​=[x]补​+[y]补​(mod 2)\n减法：[x−y]补=[x]补−[y]补=[x]补+[−y]补(mod 2)[x-y]_补=[x]_补-[y]_补=[x]_补+[-y]_补(mod\\ 2)[x−y]补​=[x]补​−[y]补​=[x]补​+[−y]补​(mod 2)\n\n 溢出概念与检测方法\n 溢出\n\n上溢：两个正数相加，结果大于机器所能表示的最大正数\n下溢：两个负数相加，结果小于机器所能表示的最小负数\n\n 检测方法\n\n双符号位检测法：溢出表达式\n- 溢出表达式：V=Sf1⊕Sf2V=S_{f1}\\oplus S_{f2}V=Sf1​⊕Sf2​\n- 不论溢出与否，最高符号位始终指示正确的符号\n单符号位检测法：溢出表达式\n- 溢出表达式：V=Cf⊕C0V=C_f\\oplus C_0V=Cf​⊕C0​\n- 当运算中，最高有效位有进位而符号位无进位，称为上溢；最高有效位无进位而符号位有进位，称为下溢\n\n 定点乘法\n 原码并行乘法\n\n[x×y]原=(xf⊕yf)×(0.yn−1…y1y0)×(0.xn−1…x1x0)[x\\times y]_原=(x_f\\oplus y_f)\\times (0.y_{n-1}\\dots y_1y_0)\\times (0.x_{n-1}\\dots x_1x_0)[x×y]原​=(xf​⊕yf​)×(0.yn−1​…y1​y0​)×(0.xn−1​…x1​x0​)\n\n 不带符号的阵列乘法器\n\n首先用“与”门，产生m×nm \\times nm×n个被加数 aibja_{i}b_{j}ai​bj​，其中 0≤i≤m−10 \\leq i \\leq m-10≤i≤m−1 和 0≤j≤n−10 \\leq j \\leq n-10≤j≤n−1；再用阵列全加器，快速相加，实现乘法。\n实现n位乘n位时，需要n(n−1)n(n-1)n(n−1)个全加器（FA）和n×nn \\times nn×n个“与”门\n\n 带符号的阵列乘法器\n\n带符号的阵列乘法器仍然以不带符号的阵列乘法器为基础；使用两个算前求补器，运算前把操作数变为正整数，而算后求补器则是：当两个输入操作数的符号不一致时，把运算结果变换成带符号的数。\n\n 定点除法\n 原码除法\n\n[x÷y]原=(xf⊕yf)+(0.yn−1…y1y0)÷(0.xn−1…x1x0)[x\\div y]_原=(x_f\\oplus y_f)+ (0.y_{n-1}\\dots y_1y_0)\\div (0.x_{n-1}\\dots x_1x_0)[x÷y]原​=(xf​⊕yf​)+(0.yn−1​…y1​y0​)÷(0.xn−1​…x1​x0​)\n不恢复余数法（加减交替法）\n\n若Ri+1≥0R_{i+1}≥0Ri+1​≥0，  则商“1”，下次做2Ri+1－Y2R_{i+1}－Y2Ri+1​－Y\n若Ri+1&lt;0R_{i+1}&lt;0Ri+1​&lt;0，则商为“0”，下次做2Ri+1+Y2R_{i+1}+Y2Ri+1​+Y\n\n\n\n 并行除法器\n\n可控加法/减法（CAS）单元\n\n 定点运算器的组成\n 逻辑运算\n 多功能算术/逻辑运算单元\n 先行进位发生器（CLA）\n\nCn+i=Gi+CnPiC_{n+i}=G_i+C_nP_iCn+i​=Gi​+Cn​Pi​\n\n 内部总线\n\n根据总线所处的位置，总线分为内部总线和外部总线\n按照总线的逻辑结构，总线分为单向、双向传输总线\n\n 定点运算器的基本结构\n\n运算器包括：ALU、阵列乘除器、寄存器、多路开关、三态缓冲器、数据总线等\n单总线结构的运算器：所有的部件都连接到同一总线上。所有的数据传输都是采用分时方式。\n双总线结构的运算器：两个操作数同时加到ALU进行运算，只需要一次操作控制，而且马上可以得到运算结果。\n三总线结构的运算器：ALU的两个输入端分别由两条总线供给，而ALU的输出则与第三条总线相连，因此，算术逻辑操作可以在一步的控制之内完成。\n\n 浮点运算方法和浮点运算器\n 浮点数的加减法\n 对阶\n\n先求两数阶码 ExE_xEx​ 和 EyE_yEy​之差，即△E=Ex－Ey△E = E_x－E_y△E=Ex​－Ey​\n对阶原则：阶码小的数向阶码大的数对齐；小阶的尾数右移△E△E△E 位\n\n 尾数求和运算\n\n尾数求和方法与定点加减法运算完全一样\n\n 规格化\n\n定义：12≤∣S∣&lt;1\\frac{1}{2}\\leq |S|&lt;121​≤∣S∣&lt;1\n\n\n正数：S=0.1s1s2…snS=0.1s_1s_2…s_nS=0.1s1​s2​…sn​\n负数：S=1.1s1s2…snS=1.1s_1s_2…s_nS=1.1s1​s2​…sn​\n\n\n向左规格化：左移一位,阶码减1\n向右规格化：两符号位不等，即结果的绝对值大于1。此时,将尾数运算的结果右移一位,阶码加1\n\n 舍入\n\n“0舍1入”法：如果右移时被丢掉数位的最高位为0则舍去，反之则将尾数的末位加“1”\n“恒置1”法：只要数位被移掉，就在尾数的末位恒置“1”\n\n 溢出处理\n\n浮点数的溢出是以其阶码溢出表现出来的\n\n阶码上溢——超过了阶码可能表示的最大值的正指数值,一般将其认为是＋∞和－∞。\n阶码下溢——超过了阶码可能表示的最小值的负指数值,一般将其认为是0。\n尾数上溢：两个同符号尾数相加产生了最高位向上的进位，进行“右规”\n尾数下溢：在尾数右移时，最低有效位从右端流出，要进行舍入处理\n\n\n\n 浮点乘、除法运算\n 浮点乘法\n\n阶码相加\n尾数相乘\n规格化：当Mx和My都不为0时，相乘后结果一定在下列范围内：1/4≤∣Mx×My∣＜11/4≤| M_x×M_y |＜11/4≤∣Mx​×My​∣＜1\n\n\n1/2≤∣Mx×My∣＜11/2 ≤| M_x×M_y |＜11/2≤∣Mx​×My​∣＜1时，尾数已经是规格化数。\n1/4≤∣Mx×My∣＜1/21/4≤| M_x×M_y |＜1/21/4≤∣Mx​×My​∣＜1/2时，需要左规一次\n\n 浮点除法\n\n尾数调整：为保证商的尾数是一个定点小数，首先需要检测∣Mx∣＜∣My∣|M_x | ＜|M_y |∣Mx​∣＜∣My​∣，如果不小于，则MxM_xMx​需要右移一位，由于x和y都是规格化的数，最多调整一次。\n阶码相减\n尾数相除\n\n 浮点运算流水线\n\nK级线性流水线的加速比：Ck=TLTk=n⋅kk+(n−1)C_k = \\frac{T_L}{T_k} = \\frac{n \\cdot k}{k + (n-1)}Ck​=Tk​TL​​=k+(n−1)n⋅k​\n建立时间：在流水线开始时有一段流水线填入时间，使得流水线填满。\n正常流动时间：流水线正常工作，各功能段源源不断满载工作。\n排空时间：在流水线第一条指令结束时，其他指令还需要一段释放时间。\n\n 多层次的存储器\n 存储器概述\n 存储器的分类\n\n按存储介质分类：半导体存储器、磁存储器、光存储器\n按存取方式分类：随机存储器、顺序/半顺序存储器\n按读写功能分类：只读存储器、读写存储器\n按信息可保存性分类：非永久性存储器、永久性存储器\n按系统作用分类：主/辅助存储器、高速缓冲/控制存储器\n\n 存储器的分级结构\n\n存储器的分级结构：高速缓冲存储器、主存储器、外存储器\nTTL存取速度快，集成度较低，功耗较大，成本较高，适于cache。\nMOS集成度高，功耗较低，价格便宜，适于主存。\n主存储器：简称“主存”，由MOS半导体存储器组成，存放处于活动状态的程序和有关数据。包括OS的常驻部分和当前在运行的程序和要处理的数据。容量在几百KB到几百MB，存取时间为几十到几百ns。\n外存储器：简称“外存”，大容量辅助存储器；磁表面存储器或光盘存储器；存放需联机保存但暂时不需要的程序和数据。容量从几十MB到几百GB，甚至更大。存取速度为若干ms。\n其他功能的存储器：如微程序控制器的控存、在显示和印刷输出设备中的字库和数据缓冲存储器。\n\n 主存储器的技术指标\n\n存储容量：存储器中可容纳的存储单元总数；单位：B(Byte), KB, MB, GB, TB, PB\n存取时间：又称访问时间，从启动一次存储器操作到完成该操作所经历的时间。\n存储周期：连续两次启动同一存储器操作需要的最小时间间隔。\n存储器带宽：单位时间存储器所存取的信息量；度量单位：位/秒、字节/秒；\n可靠性：在规定的时间内，存储器无故障的概率。用平均无故障时间MTBF\n功耗与集成度：耗电的多少；单个芯片存储容量；\n性能/价格比：衡量存储器经济性能好坏的综合性指标。性能包括前述的各项指标。\n\n SRAM存储器\n SRAM存储器的组成\n\n存储体\n地址译码器：把用二进制代码表示的地址转换成输出端的高电位，用来驱动相应的读写电路，以便选择所要访问的存储单元。地址译码器的输入信息来自CPU的地址寄存器（AR）\n\n单译码结构：地址译码器只有一个，译码器输出为字选线\n双译码结构：两个地址译码器，可减少选择线条数\n\n\n驱动器：一条X选择线要控制挂其上所有存储元电路，其所带的电容负载很大，为此需加驱动器。\nI/O电路：处于数据总线和被选用的单元之间，用于控制被选中的单元读出或写入，并具有放大信息作用。\n片选与读/写控制电路：当需要大容量的存储器时，需把存储器芯片按照一定方式连接而成。在地址选择时，首先要选片，此片所连接的地址线才有效。通常用地址译码器的输出和一些控制信号来形成片选信息。\n\n 存储器的读写周期\n\n读周期: 读周期与读出时间是两个不同的概念。读出时间是从给出有效地址到外部数据总线上稳定地出现所读出的数据信息所经历的时间。读周期时间则是存储片进行两次连续读操作时所必须间隔的时间，它总是大于或等于读出时间。\n写周期：实现写操作，要求CS‾\\overline{CS}CS和WE‾\\overline{WE}WE同时有效，有效期间地址和数据信号不能变化；为了保证CS‾\\overline{CS}CS和WE‾\\overline{WE}WE变为无效前能把数据可靠的写入，数据必须提前一段时间在数据总线上稳定存在；而在WE‾\\overline{WE}WE变为高电平后再经过一段时间地址信号才允许改变。\n\n 存储器与CPU连接\n 存储容量扩充的方法\n\n位扩展法：只加大字长，而存储器的字数与存储器芯片字数一致，即字变长，字数不变。数据线条数增加，地址线条数不变。\n字扩展法：字数变多，字长不变，地址线增加，数据线不变； 芯片的地址线、数据线、读写控制线并联，由片选信号区分各片地址。\n字位同时扩展法：需要容量M×NM \\times NM×N存储器，使用的芯片为l×kl \\times kl×k，则需要芯片个数为Ml×Nk\\frac{M}{l} \\times \\frac{N}{k}lM​×kN​\n\n 地址分配与片选逻辑\n\n存储器寻址逻辑\n\n芯片内的寻址系统(二级译码)\n芯片外的地址分配与片选逻辑\n\n\n\n 连接方式\n\n扩展位数\n扩展单元数\n连接控制线\n\n DRAM存储器\n DRAM芯片的逻辑结构\n\n增加了行地址锁存器和列地址锁存器。由于DRAM存储器容量很大，地址线宽度相应要增加，这势必增加芯片地址线的管脚数目。为避免这种情况，采取的办法是分时传送地址码。若地址总线宽度为10位，先传送地址码A0～A9，由行选通信号RAS‾\\overline{RAS}RAS打入到行地址锁存器；然后传送地址码A10～A19，由列选通信号CAS‾\\overline{CAS}CAS打入到列地址锁存器。芯片内部两部分合起来，地址线宽度达20位，存储容量为1M×4位。\n增加了刷新计数器和相应的控制电路。DRAM读出后必须刷新，而未读写的存储元也要定期刷新，而且要按行刷新，所以刷新计数器的长度等于行地址锁存器。刷新操作与读/写操作是交替进行的，所以通过2选1多路开关来提供刷新行地址或正常读/写的行地址。\n\n DRAM 的读/写周期\n DRAM的刷新\n\n刷新周期：从上一次对整个存储器刷新结束到下一次对整个存储器全部刷新一遍为止，这一段时间间隔称为~。\n集中刷新方式：把刷新间隔分为两部分，前一部分进行读/写周期或维持周期，后一部分只进行刷新操作。因为刷新时期不能进行读写操作，称为死时间。本方式适用于高速存储器。\n分散刷新方式：\n\n各刷新周期分散安排在2ms内\n每隔一段时间刷新一行\n\n\n\n 高级的DRAM结构\n\nFPM-DRAM：快速页模式动态存储器，它是根据程序的局部性原理来实现的。读周期和写周期中，为了寻找一个确定的存储单元地址，首先由低电平的行选通信号RAS‾\\overline{RAS}RAS确定行地址，然后由低电平的列选信号CAS‾\\overline{CAS}CAS确定列地址。下一次寻找操作，也是由RAS‾\\overline{RAS}RAS选定行地址，CAS‾\\overline{CAS}CAS选定列地址，依此类推。快速页模式允许在选定的行中对每一个列地址进行连续快速的读操作或写操作。\nCDRAM（Enhanced DRAM）芯片：在DRAM芯片上集成一个SRAM实现的小容量高速缓冲器，以改善芯片性能\n\n DRAM主存读/写的正确性校验\n\nDRAM通常用做主存储器，其读写操作的正确性与可靠性至关重要。为此除了正常的数据位宽度，还增加了附加位，用于读/写操作正确性校验。增加的附加位也要同数据位一起写入DRAM中保存。\n\n 只读存储器和闪速存储器\n 只读存储器（Read Only Memory）\n 掩模ROM\n 可编程ROM\n\nEPROM\nE2^22PROM\n\n FLASH存储器（Flash Memory）\n FLASH存储器的基本操作\n\n编程操作：所有存储元的原始状态均为“1”，要写0，就在控制栅上加正电压，为浮空栅补充电子；\n读取操作：当MOS晶体管导通时，电源VD提供从漏极D到源极S的电流，读出电路检测到电流则表示“1”，无电流，表示“0”；\n擦除操作：采用电擦除，在源极加上正电压。\n\n 并行存储器\n 双端口存储器DPRAM(Dual-Port RAM)\n\n同一个存储器具有两组相互独立的读写控制线路。\n当两个端口的地址不同时，在两个端口上进行读写操作，一定不会发生冲突。\n当两个端口同时存取同一存储单元时，便发生读写冲突，为此设置BUSY‾\\overline{BUSY}BUSY标志。由存储器的仲裁逻辑决定对哪个端口优先进行读写操作，而对另一个被延迟的端口置BUSY‾\\overline{BUSY}BUSY标志，即暂时关闭此端口。\n\n 多模块交叉存储器\n 存储器的模块化组织\n\n顺序方式：\n\n优点：某个模块出现故障时，不影响其他模块工作；存储器的容量扩充比较方便\n缺点：各个模块串行工作，存储器的带宽受到限制\n\n\n交叉方式：连续地址分布在相邻不同模块内，而同一个模块内的地址不连续\n\n优点：对连续字的成块传送，容易实现多模块流水式的并行存取，能大大提高存储器带宽\n缺点：某个模块出现故障时，会影响其他模块工作；存储器的容量扩充比较困难\n\n\n\n 多模块交叉存储器的基本结构\n\n四个模块都有自己的读写控制电路、地址寄存器和数据寄存器，各自以等同的方式与CPU传送信息\nCPU同时访问四个模块，由存储器控制部件控制它们分时使用数据总线。对于一个存储模块，从CPU给出访存命令直到读出信息仍然使用一个存储周期，而对于CPU来说，可以在一个存取周期内连续访问四个模块，各个模块的读写过程将重叠进行，使存储器成为并行存储器结构。\n\n 定量分析\n\n设模块字长等于数据总线宽度，模块存取一个字的存储周期为T，总线传送周期为τ，存储器的交叉模块数为m，为了实现流水线方式存取，应满足：T=mτT=mτT=mτ（m=T/τm=T/τm=T/τ为交叉存取度），交叉存储器要求其模块数必须大于或等于m，以保证启动某模块后经mτ时间再次启动该模块时，它的上次存取操作已经完成。\n以交叉方式连续读取n个字所需的时间为： t1=T+(n−1)τt_1=T+(n-1)τt1​=T+(n−1)τ\n而顺序方式存储器连续读取n个字所需时间为:t2=nTt_2=nTt2​=nT\n\n cache 存储器\n cache的基本原理\n\nCPU与cache间的数据交换是以字为单位\ncache与主存间的数据交换是以块为单位\n当CPU读取主存的一个字时，便发送字的内存地址给cache和主存，此时cache的控制逻辑依据地址判断此字当前是否在cache中：若是，则此字立即传送给CPU，若非，则用主存读周期把此字从主存中读出送到CPU，同时将含有这个字的整个数据块从主存读出送到cache中\n\n 相联存储器（CAM）\n\n定义：按内容寻址的存储器CAM（Content Addressed Memory）亦称相联存储器，除按地址随机读写外，还有比较功能，可按信息内容寻址，存储器查询速度快。\n特点：根据任一存储项内容作为地址来进行存取。用来寻址存储器的字段叫做关键字（键）。\n\n cache的命中率\n\n设在一段程序执行期间，cache完成存取次数为NcN_cNc​，主存完成存取次数为NmN_mNm​，h定义为命中率，则有：h=Nc/(Nc+Nm)h= N_c/(N_c+N_m)h=Nc​/(Nc​+Nm​)\n平均访问时间：ta=htc+(1−h)tmt_a=ht_c+(1-h)t_mta​=htc​+(1−h)tm​\n访问效率：e=tc/ta=tc/(htc)+(1−h)tm=1/h+(1−h)re=t_c/t_a =t_c/(ht_c)+(1-h)t_m=1/h+(1-h)re=tc​/ta​=tc​/(htc​)+(1−h)tm​=1/h+(1−h)r\ntct_ctc​：命中时cache的访问时间\ntmt_mtm​：未命中时主存的访问时间\nr=tm/tcr=t_m/t_cr=tm​/tc​：主存慢于cache的倍率\n\n 主存与cache的地址映射\n 全相联方式\n\n全相联的地址映射规则：\n\n主存与缓存分成相同大小的数据块。\n主存的某一数据块可以装入缓存的任意一块的空间中。\n\n\n转换公式\n\n主存地址长度＝(s+w)位\n寻址单元数＝2s+w2^{s+w}2s+w个字或字节\n块大小＝行大小＝2w2^w2w个字或字节\n主存的块数＝2s2^s2s\n标记大小＝s位\ncache的行数＝不由地址格式确定\n\n\n特点：\n\n优点：冲突概率小，Cache的利用高。\n缺点：比较器难实现，需要一个访问速度很快代价高的相联存储器\n\n\n适用于小容量的Cache\n\n 直接相联方式\n\n\n直接相联的地址映射规则\n\n主存第BjB_jBj​块内容拷贝到Cache的LiL_iLi​行\ni = j mod m\nm = 2r2^r2r n = 2s2^s2s\n\n\n\n转换公式\n\n主存地址长度＝(s+w)位\n寻址单元数＝2s+w2^{s+w}2s+w个字或字节\n块大小＝行大小＝2w2^w2w个字或字节\n主存的块数＝2s2^s2s\ncache的行数＝m＝2r2^r2r\n标记大小＝(s-r)位\n\n\n\n特点：\n\n优点：硬件实现很简单，不需要相联访问存储器；访问速度也比较快，实际上不进行地址变换\n缺点：块的冲突率比较高\n\n\n\n适用于大容量的Cache\n\n\n 组相联映射方式\n\n组相联的映象规则\n\n将cache分成u组，每组v行，m=uvm=uvm=uv\n主存块存放在哪个组是固定的，存到该组哪一行是灵活的，组号q=jmoduq=j mod uq=jmodu\n组间采用直接相联方式，组内采用全相联方式\n\n\n转换公式\n\n主存地址长度＝(s+w)位\n寻址单元数＝2s+w2^{s+w}2s+w个字或字节\n块大小＝行大小＝2w2^w2w个字或字节\ncache的组数＝u＝2d2^d2d\n标记大小＝(s-d)位\n\n\n\n cache的替换算法\n 最不经常使用算法LFU（Least Frequently Used）\n\n将一段时间内被访问次数最少的那行数据换出。\n每行设置一个计数器，新行从0开始计数，每访问一次，计数器增1；替换时，把计数值最小的行换出，同时将这些特定行的计数器清零。\n缺点：计数周期是特定行两次替换之间的间隔，不能严格反映近期访问的情况。\n\n 近期最少使用算法LRU（Least Recently Used）\n\n将近期内长久未被访问过的行换出。\n每行设置一个计数器，每命中一次，命中行计数器清零，其它各行计数器增1；替换时，将计数值最大的行换出。保护了刚拷贝到cache的新数据行。\n\n 随机替换\n\n从特定的行位置中随机（Random）地选出一行换出即可。\n优点：硬件上容易实现，速度快。\n缺点：可能刚替换出的行马上又要使用，命中率低。\n\n cache的写操作策略\n 写回法\n\n当写cache命中时，只修改cache的内容，而不立即写入主存；当写cache未命中时，把此块替换到cache中修改；写主存统一留到此行被换出时进行。\n实现：每行设置一个修改位，标示是否被修改过。\n本方式可明显减少写主存次数，提高存取速度，但存在不一致性的隐患。\n\n 全写法\n\n当写cache命中时，cache和主存同时写修改；当写cache未命中时，直接写入主存。但是否把修改过的主存块取到cache中，有两种选择：一是取主存块到cache并为它分配一行位置；另一是不取主存块到cache。\n特点：cache和主存的内容一致，且不需设置修改位和判断逻辑，但写操作没有高速缓冲功能，效率低。\n\n 写一次法\n\n写cache命中与未命中时和写回法基本相同，只是在第一次写命中时要同时写入主存。因第一次写cache命中时要启动一个存储写周期。\n\n 指令系统\n 指令系统的发展与性能要求\n 复杂指令集计算机（CISC）\n\nCISC是通过减少INI_NIN​值来减少TcpuT_{cpu}Tcpu​的\nCISC的主要特点：\n\n指令系统复杂，表现在：指令数多，一般大于100条；寻址方式多，一般大于4种；指令格式多，一般大于4种\n绝大多数指令需要多个机器时钟周期方可完成\n各种指令都可访问存储器\n采用微程序控制\n有专用寄存器\n难以用优化编译生成高效的目标代码程序\n\n\n\n 精简指令集计算机（RISC）\n\nRISC是通过减少CPICPICPI值，简化结构来减少TcpuT_{cpu}Tcpu​的\nRISC的主要特点：\n\n精简指令系统：指令条数少，一般小于100条，基本寻址方式少，一般23种，指令格式少，一般23种，指令长度一致(32位)\n以寄存器-寄存器方式工作，除了Load/Store指令访问存储器外，其余指令只访问寄存器\n除了Load/Store指令访问存储器外，所有指令在一个机器时钟周期完成，并采用流水线技术\n使用较多的通用寄存器，一般至少32个，不允许有专用寄存器\n大多采用硬联线控制，少用或不用微程序实现\n\n\n\n 指令格式\n 指令字长度\n\n指令的长度是指一条指令所包含二进制代码的位数，取决于操作码长度和操作数地址个数及每个地址的长度。\n机器字长：计算机能直接处理的二进制数据的位数。\n\n 操作码\n\n作用：指定指令是执行什么性质的操作。不同的指令用操作码字段的不同编码表示。\n定长编码：便于译码，扩展性差\n变长编码：能缩短指令平均长度\n\n 地址码\n\n作用：常用于指定参与操作的操作数地址。\n根据指令中操作数地址的个数，将指令划分为：\n\n零地址指令：指令中只有操作码，没有地址码。\n一地址指令：单操作数指令。该指令常以AC中数作为被操作数，指令中地址码字段所指明的数为操作数，操作结果又放回AC：(AC) OP (A) -&gt; AC\n二地址指令：双操作数指令，两地址指明被操作数和操作数地址，其中A1兼做结果地址：(A1) OP (A2) -&gt; (A1)\n三地址指令：三个地址分别指明被操作数、操作数以及结果存放地址：(A1) OP (A2) -&gt; (A3)\n\n\n\n 操作数类型\n\n地址数据:地址实际上也是一种形式的数据。\n数值数据:计算机中普遍使用的三种类型的数值数据。\n字符数据:文本数据或字符串，目前广泛使用ASCII码。\n逻辑数据:一个单元中由几位二进制bit项组成，每个bit的值可以是1或0。当数据以这种方式看待时，称为逻辑型数据。\n\n 指令和数据的寻址方式\n 指令的寻址方式\n 顺序寻址方式\n\n程序指令按顺序存放在内存中，执行时按顺序从内存中取出所要执行的指令。\n程序计数器（指令指针寄存器，指令计数器）PC（Program Counter）存放正在执行的指令地址（要执行的下一指令地址）。\n\n 跳跃寻址方式\n\n程序要执行的下条指令地址不是由PC给出，而是由本指令的地址码给出。\n用途：实现程序转移或构成循环程序。\n\n 操作数寻址方式\n 隐含寻址（Implied Addressing）\n\n不明显指定操作数的地址，而是在指令中隐含着操作数的地址。比如单地址指令格式的第二操作数由AC隐含指定。\n\n 立即寻址（Immediate Addressing）\n\n特点：地址字段指出的不是操作数地址，而是操作数本身。\n优点：无需访问内存，指令的执行时间很短。\n缺点：操作数的范围受限。\n适用范围：用于操作数固定的指令中，主要用于给寄存器或存储器赋初值。\n\n 直接寻址（Direct Addressing）\n\n特点：地址字段直接指出操作数在内存中地址。\n优点：简单。\n缺点：寻址空间受限。\n\n 间接寻址（Indirect Addressing）\n\n特点：地址字段中的D是操作数地址的指针\n优点：寻址空间大。\n缺点：需多次访问主存。\n说明：两次访存影响执行速度，现已不大使用。\n\n 寄存器寻址（Register Addressing）和寄存器间接寻址（Register Indirect Addressing）\n\n寄存器寻址方式:寄存器中存放的是操作数。\n寄存器间接寻址方式:寄存器中存放的不是操作数，而是操作数在内存中的地址。\n区别：\n\n寄存器中前者存的是操作数，后者是操作数地址。\n前者不需要访问内存，速度相对快；寻址空间小；后者需要访问内存，速度相对慢；寻址空间大。\n\n\n联系：地址字段中给出的都是寄存器的编号。\n\n 相对寻址方式（Relative Addressing）\n\n特点：把PC的内容加上指令格式中形式地址D而形成操作数的有效地址E。\n\n 基址寻址方式（Base-Register Addressing）\n\n特点：把基址寄存器的内容加上指令格式中D而形成操作数的E。\n用途：可用于扩大寻址能力。\n\n 变址寻址方式（Index Addressing）\n\n特点：把某个变址寄存器的内容加上指令格式中D而形成操作数的E。\n用途：用于实现程序块的有规律变化。\n\n 块寻址方式（Block Addressing）\n\n用途：用在I/O指令中，以实现外存储器或外围设备同内存之间的数据块传送，还适用于内存的数据块搬家。\n指定数据块长度的三种方法：\n\n指令中划出字段指出长度；\n指令中指出数据块的首尾地址；\n由块结束字符指出数据块的长度。\n\n\n\n 段寻址方式（Segment Addressing）\n\n方法：E由段寄存器的内容加上段内偏移地址而形成。\n应用：微型机采用段寻址方式，20位物理地址为16位段地址左移四位加上16位偏移量。\n分类：\n\n段内直接寻址；\n段内间接寻址；\n段间直接寻址；\n段间间接寻址；\n\n\n\n 堆栈寻址方式\n\n堆栈：是一组能存入和取出数据的暂时存储单元。\n区别：对数据的存取方法或寻址方式不同。\n分类：串联堆栈和存储器堆栈。\n\n串联堆栈（硬堆栈，下压堆栈）：由CPU中的一组专门寄存器组成,容量有限、读出具有破坏性；\n存储器堆栈（软堆栈）：在主存储器中划分出一部分区域来作为堆栈。容量可任意、可同时建立多个堆栈、可用对存储器寻址的任一指令来对堆栈中数据寻址\n\n\n\n 典型指令\n 指令的分类\n\n数据传送指令：主要用于主存和寄存器、寄存器和寄存器之间的数据传送。主要有：取数、存数、传送、成组传送、字节交换、清除累加器和堆栈操作指令等。\n算术运算指令：主要用于定点或浮点的算术运算、向量运算。主要有：二进制定点加、减、乘、除指令；浮点加、减、乘、除指令，求反、求补、算术移位指令。\n逻辑运算指令：主要用于无符号数的位操作、代码转换、判断及运算。主要有：逻辑加、乘、异或、移位等。\n程序控制指令：转移指令一般分为：条件转移、无条件转移、转子程序、返回主程序、中断返回指令等。条件转移的条件有进位标志位©、结果为零标志(Z) 、负标志(N) 、溢出标志(V) 和奇偶标志(P) 等。\n输入输出指令：主要用来启动外围设备，检查测试外围设备的工作状态，并实现外围设备和CPU之间、外围设备与外围设备之间的信息传送。\n字符串处理指令：常用在文字编辑中对字符串进行处理。包括：字符串传送、转换、比较、查找、抽取和替换等。\n特权指令：是具有特殊权限的指令，只用于操作系统或其他系统软件，一般不直接提供用户使用。主要用于系统资源的分配和管理：改变系统工作方式，检测用户的访问权限、修改虚拟存储器管理的段表、页表，完成任务的创建和切换。\n其他指令：状态寄存器置位、复位、测试、暂停、空操作，以及其它系统控制用的特殊指令。\n\n 中央处理器\n CPU的功能\n\n指令控制：程序的顺序控制。\n操作控制：管理并产生每条指令的操作信号，并把它们送到相应部件，控制这些部件按要求进行动作。\n时间控制：对各种操作实施时间上的定时。\n数据加工：对数据进行算术和逻辑运算处理。\n\n CPU的基本组成\n 运算器\n\n由ALU、AC、DR和PSW组成；是数据加工处理部件；在控制器的指挥下运行。\n运算器的主要功能：\n\n执行算术运算；\n执行逻辑运算，并进行逻辑测试。\n\n\n定点运算器的结构：\n\n单总线结构的运算器\n双总线结构的运算器\n三总线结构的运算器\n\n\n\n 控制器\n\n组成：PC、指令寄存器（IR） 、指令译码器（ID）、时序产生器和操作控制器；\n作用： “决策机构” ，协调和指挥整个系统的操作。\n功能：\n\n取指令，并指出下一条指令的位置。\n对指令译码或测试，产生相应操作控制信号，以启动规定的动作。\n指挥并控制CPU、内存和I/O设备之间数据流动的方向。\n\n\n\n 操作控制器（微命令发生器）\n\n组合逻辑型：常规控制器或硬布线控制器，采用组合逻辑技术实现。\n\n优点：速度快；\n缺点：设计、调试、维修困难，难实现设计自动化。\n\n\n存储逻辑型：微程序控制器，采用存储逻辑来实现，即微操作信号代码化，使得每条指令转化为一段微程序并存入一个专门的存储器中。\n\n优点：设计规整，调试、维修以及更改、扩充指令方便，易于设计自动化。\n缺点：指令执行速度比组合逻辑型慢。\n\n\n\n 指令计数器PC\n\n功能：指示指令在M中的位置\n顺序执行：PC+1\n转移执行：PC先加1，再加上转移地址\n\n 指令寄存器IR\n\n功能：存放当前指令的操作码和地址码\n\n 状态寄存器PSW\n\n功能：指示程序运行方式，反映程序运行结果。\n\n 时序线路\n\n功能：控制操作时间和操作时刻。\n\n 指令周期\n 指令周期的基本概念\n\n指令周期：取出并执行一条指令的时间。\nCPU周期/机器周期（工作周期）：常用从内存中读取一个指令字的最短时间来规定机器周期。\nT周期/节拍脉冲 处理操作的最基本单位。\n\n 用方框图语言表示指令周期\n\n方框：代表一个CPU周期，方框中的内容表示数据通路的操作或某种控制操作；\n菱形：表示某种判别或测试，在时间上不单占一个CPU周期，而是依附于紧接它的前面一个方框的CPU周期；\n箭头：表示CPU执行顺序；\n~ ：公操作符号，表示一条指令执行完毕后，CPU所开始执行的一些操作——如中断处理、通道处理等，其中取指令也可认为是公操作。\n\n 时序产生器和控制方式\n 时序信号的作用和体制\n\n作用：控制操作时间和操作时刻。\n基本体制：电位-脉冲制。\n\n 时序信号产生器\n\n时钟源（主时钟）：通常由石英晶体震荡器和与非门组成的正反馈振荡电路组成。\n\n作用：提供频率稳定且电平匹配的方波时钟脉冲信号，为整个机器提供基准信号。\n时钟源在机器上电后立即开始产生具有一定占空比的时钟脉冲序列，直到关电源为止，中间不允许有任何间断。\n\n\n环形脉冲发生器（节拍信号发生器）：产生一组有序的间隔相等或不等的脉冲序列，以便通过译码电路产生最后所需要的节拍脉冲。\n节拍脉冲和读写时序译码逻辑：根据环形脉冲发生器产生的脉冲，通过与门和与非门电路产生节拍。同时和微程序控制器中产生的读/写/对内存/对I/O设备等操作信号融合，实现对内存和外设的读写操作。（时序信号还不是微操作信号，而只是协调各部件工作的同步信号）\n启停控制逻辑：根据计算机的需要，可靠地开放和封锁脉冲，控制时序信号的发生和停止，实现对整个机器的正确启动与停止。必须保证启动时输出的第一个脉冲和停止时输出的最后一个脉冲都是完整的脉冲。\n\n 控制方式\n 同步控制方式(固定时序控制方式)\n\n已定的指令在执行时所需的机器周期和时钟周期数都是固定不变的。\n\n采用完全统一的机器周期执行各种不同的指令；一刀切\n采用不定长机器周期；\n中央控制与局部控制相结合。\n\n\n特点：有明显时序划分，时钟周期固定，各步操作的衔接、各部件之间的数据传送受严格同步定时控制。\n优点：时序关系简单，时序划分规整，控制不复杂；控制逻辑易于集中，容易实现，便于管理。\n缺点：时间安排不合理，会造成简单指令较多的空闲时间，影响指令执行速度，不利于发挥计算机高速运算的潜力。\n应用场合：用于CPU和设备内部、系统总线操作(各挂接部件速度相近，传送时间确定，传送距离较近)。\n\n 异步控制方式（可变时序控制方式）\n\n各项操作按需安排时间，不受统一时序控制\n特点：无统一时钟周期划分，各操作间的衔接和各部件之间的信息交换采用异步应答方式。\n优点：时间安排紧凑、合理、效率高；\n缺点：控制复杂，不容易实现。\n应用场合：用于异步总线操作(各挂接部件速度差异大，传送时间不确定，传送距离较远)。\n\n 联合控制方式\n\n大部分操作安排在固定的机器周期中，对某些时间难以确定的操作则以执行部件的“回答”信号作为本次操作的结束。\n特点：同步方式引入异步应答。\n优点：不浪费很多时间，控制上又不是很复杂。\n\n 微程序控制器\n 基本术语\n\n微操作：一条指令的功能是通过执行一系列操作控制步完成的；这些控制步中的基本操作称为微操作。\n微命令：微命令是微操作的控制信号，而微操作是微命令的操作内容。\n微指令：可以同时执行的一组微命令组成一条微指令，完成一个基本运算或传送功能。也将微指令称作控制字（CW），其中每一位代表一个微命令。\n微程序：完成指定任务的微指令序列称为微程序。一条机器指令其功能可由一段微程序解释完成。\n微地址：微指令在控制存储器中的单元地址\n\n 组成原理\n 主要部件\n 控制存储器CM\n\n功能：存放微程序，是微程序控制器的核心部件。\nCM属于CPU，不属于主存储器\n\n 微指令寄存器µIR\n\n功能：存放当前微指令的内容。\n微命令字段：提供一步操作所需的微命令。\n微地址字段：\n\n指明后续微地址的形成方式\n提供微地址的给定部分\n\n\n\n 微地址形成电路\n\n功能：提供两类微地址\n微程序入口地址：由机器指令操作码形成。\n后续微地址：由微地址字段、现行微地址、运行状态等形成\n\n 工作过程\n\n取机器指令：CM→取指微指令µIR→微命令字段译码器→微命令主存→机器指令IRCM\\xrightarrow{\\text{取指微指令}}µIR\\xrightarrow{\\text{微命令字段}}译码器\\xrightarrow{\\text{微命令}}主存\\xrightarrow{\\text{机器指令}}IRCM取指微指令​µIR微命令字段​译码器微命令​主存机器指令​IR\n转微程序入口：IR→操作码微地址形成电路→入口µAR→CM→首条微指令µIRIR\\xrightarrow{\\text{操作码}}微地址形成电路\\xrightarrow{\\text{入口}}µAR\\rightarrow CM\\xrightarrow{\\text{首条微指令}}µIRIR操作码​微地址形成电路入口​µAR→CM首条微指令​µIR\n执行首条微指令：µIR→微命令字段译码器→微命令操作部件µIR\\xrightarrow{\\text{微命令字段}}译码器\\xrightarrow{\\text{微命令}}操作部件µIR微命令字段​译码器微命令​操作部件\n取后续微指令：{微地址字段现行微地址运行状态→微地址形成电路→后续微地址µAR→CM→后续微指令µIR\\begin{cases}微地址字段\\\\现行微地址\\\\运行状态\\end{cases}\\rightarrow微地址形成电路\\xrightarrow{\\text{后续微地址}}µAR\\rightarrow CM\\xrightarrow{\\text{后续微指令}}µIR⎩⎪⎪⎨⎪⎪⎧​微地址字段现行微地址运行状态​→微地址形成电路后续微地址​µAR→CM后续微指令​µIR\n执行后续微指令：同3.\n返回（微程序执行完，返回CM（存放取指微指令的固定单元））\n\n 微指令\n\n操作控制部分：又称“微操作码字段”，用来发出管理和指挥全机工作的控制信号，其中每一位都表示一个微命令。\n顺序控制部分：又称“微地址码字段”，用来决定产生下一条微指令的地址\n\n 总结：\n\n微程序控制器的工作过程实质就是：在微程序控制器的控制下，计算机执行机器指令的过程。具体可分为：\n\n执行取指令的公操作机器开始运行时，自动地将取指微程序的入口微地址送入µAR，并从CM中读出微指令，送往µIR，当取指微程序执行完以后，从主存中取出的机器指令就已经存入IR中了。\n由机器指令的操作码字段OP通过“地址转移逻辑”产生出该机器指令所对应的微程序的入口微地址，并送入µAR。\n从CM中逐条取出相应的微指令并执行。\n执行完对应于一条机器指令的一段微程序之后，又回到取指微程序的入口地址，继续第（1）步，以完成取下一条机器指令的公操作。\n\n\n\n 微程序时序安排\n\n为了保证整个机器控制信号的同步，可以将一个微指令周期时间设计得恰好和CPU周期时间相等。\n\n 机器指令与微指令的关系\n\n一条机器指令对应一段微程序，此微程序是由若干条微指令序列组成的。\n指令、程序、地址对应于内存储器；微指令、微程序、微地址对应于控制存储器。\n一个CPU周期对应于一条微指令指令周期。方框图就是微程序流程图。\n\n 微程序设计技术\n 微指令格式\n 垂直型微指令\n\n一条微指令定义并执行一种基本操作\n优点：微指令短、简单、规整，便于编写微程序。\n缺点：微程序长，执行速度慢；工作效率低。\n\n 水平型微指令\n\n一条微指令定义并执行几种并行的基本操作\n优点:微程序短，执行速度快。\n缺点：微指令长，编写微程序困难。\n\n 混合型微指令\n\n在垂直型的基础上增加一些不太复杂的并行操作\n微指令不长，便于编写\n微程序不长，执行速度加快\n\n 编码方法\n 直接编码\n\n微命令按位给出\n不需译码，产生微命令的速度快\n信息的表示效率低\n微指令中通常只有个别位采用直接控制法\n\n 分段直接编译法\n\n微命令由字段编码直接给出\n微命令分组原则：同类操作中互斥的微命令放同一字段\n微操作分类：\n\n相容性：在同时或同一CPU周期内可以并行执行。\n相斥性：在同时或同一CPU周期内不能并行执行。\n\n\n编码较简单\n操作唯一\n一条微指令能同时提供若干微命令，便于组织各种操作\n\n 微地址形成方式\n 增量方式\n\n以顺序执行为主，辅以各种常规转移方式\n\n顺序：现行微地址+1\n跳步：现行微地址+2\n无条件转移：现行微指令给出转移微地址\n条件转移：现行微指令给出转移微地址和转移条件\n\n\n\n 多路转移方式（断定方式）\n\n由直接给定和测试断定相结合形成微地址\n\n 流水线CPU\n 并行处理技术\n\n时间并行：时间重叠，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。\n空间并行：资源重复，以“数量取胜”来提高计算机的处理速度。当前的空间并行主要体现在多CPU和多计算机系统，在单处理机系统中也得到广泛的应用。\n时间+空间并行：时间重叠和资源重复的综合应用。\n\n 流水CPU的结构\n 流水计算机的系统组成\n\n程序和数据存放在主存中：主存采用多体交叉存储器，CPU与主存之间添加一个高速cache来弥补两者速度差异。\n指令部件本身构成一个流水线：取指令、指令译码、计算操作数地址、取操作数等几个过程段组成；\n指令队列：一个FIFO的寄存器队列，用来存放经过译码的指令和取来的数据，也是一条流水线；\n执行部件：具有多个算术逻辑运算部件，这些部件本身又用流水线方式构成，一般采用的实现方法：\n\n将执行部件分为定点执行部件和浮点执行部件两个可并行执行部分，分别处理定点运算指令和浮点运算指令；\n在浮点执行部件中，又有浮点加法部件和浮点乘/除部件，它们可同时执行不同的指令；\n浮点运算部件都以流水线方式工作。\n\n\n\n 流水线分类\n\n指令流水线：指令步骤的并行，将指令流的处理过程划分为取指令、指令译码、取操作数、执行、写回等几个并行处理的过程段。\n算术流水线：运算操作步骤的并行，如流水加法器、流水乘法器、流水除法器等。\n处理机流水线：宏流水线，指程序步骤的并行；由一串级联的处理机构成流水线的各个过程段，每台处理机负责某一特定的任务。\n\n 流水线中主要问题\n 资源相关冲突\n\n多条指令进入流水线后在同一机器时钟周期内争用同一个功能部件所发生的冲突。\n解决方法：\n\n后继指令停顿一拍后再启动。\n增加相应资源。\n\n\n\n 数据相关冲突\n\n有i和j两条指令，i指令在前，j指令在后，则三种不同类型的数据相关的含义为\n\nRAW读写（先写后读）：指令j试图在指令i写入寄存器前就读出该寄存器内容，这样，指令j就会错误地读出该寄存器旧的内容。\nWAR写读（先读后写）：指令j试图在指令i读出寄存器之前就写入该寄存器，这样，指令i就错误地读得该寄存器新的内容。\nWAW写写（先写后写）：指令j试图在指令i写寄存器之前就写入该寄存器，这样，两次写的先后次序被颠倒，就会错误地使由指令i写入的值成为该寄存器内容。\n\n\n解决办法主要用软件和硬件技术：\n\n时间推后法\n旁路技术或相关专用通路技术：定向传递（设置若干运算结果缓冲寄存器，暂时保留运算结果，便于后续指令直接使用，称为“向前”或定向传送技术）\n\n\n\n 控制相关冲突\n\n由转移指令引起。当执行转移指令时，依据转移条件的产生结果，可能为顺序取下条指令；也可能转移到目标地址取指令，从而使流水线断流。\n解决方法：\n\n延迟转移法：由编译程序重排指令序列来实现。基本思想是“先执行再转移”；在不转移时，使延迟的时间得到有效利用。\n转移预测法：用硬件方法实现，依据指令过去的行为来预测将来的行为。通过使用转移取和顺序取两路指令预取队列以及目标指令cache，可将转移预测提前到取指阶段进行，以获得良好的效果。\n\n\n\n RISC CPU\n RISC CPU的特点\n\nRISC的三个要素是：\n\n一个有限的简单的指令集；\nCPU配备大量的通用寄存器；\n强调对指令流水线的优化。\n\n\n基于三要素的RISC机器的特征是：\n\n使用等长指令，目前的典型长度是4个字节。\n寻址方式少且简单，一般为2—3种，最多不超过4种，绝不出现存储器间接寻址方式。\n只有取数指令、存数指令访问存储器。指令中最多出现RS型指令，绝不出现SS型指令。\n指令集中的指令数目一般少于100种，指令格式一般少于4种。\n指令功能简单，控制器多采用硬布线方式，以期更快的执行速度。\n平均而言，所有指令的执行时间为一个处理时钟周期。\n指令格式中用于指派整数寄存器的个数不少于32个，用于指派浮点数寄存器的个数不少于16个。\n强调通用寄存器资源的优化使用。\n支持指令流水并强调指令流水的优化使用。\nRISC技术的复杂性在于它的编译程序，因此软件系统开发时间比CISC机器长。\n\n\n\n CPU性能评价\n\nCPU性能：CPU执行程序所用的时间\n速度评价标准：MIPS和MFLOPS\n\nMIPS=指令条数（IN）执行时间（Te）×106=时钟频率（fc）CPI×106MIPS=\\frac{指令条数（I_N）}{执行时间（T_e）\\times10^6}=\\frac{时钟频率（f_c）}{CPI\\times10^6}MIPS=执行时间（Te​）×106指令条数（IN​）​=CPI×106时钟频率（fc​）​\nMFLOPS=浮点运算次数（IFN）执行时间（Te）×106MFLOPS=\\frac{浮点运算次数（I_{FN}）}{执行时间（T_e）\\times10^6}MFLOPS=执行时间（Te​）×106浮点运算次数（IFN​）​\n\n\n\n 总线系统\n 总线的概念和结构形态\n 总线的概念\n\n是构成计算机系统的互联机构，是多个系统功能部件（运算器、控制器、存储器、输入/输出设备）之间进行数据传送的公共通路。\n由传输信息的电路和管理信息传输的协议组成。\n总线往往是计算机数据交换的中心，总线的结构、技术和性能都直接影响着计算机系统的性能和效率。\n\n 总线分类\n\n内部总线：CPU内部连接各寄存器及运算部件之间的总线。\n系统总线：CPU同计算机系统的其他高速功能部件(存储器、通道等)间互相连接的总线。\nI/O总线：中、低速I/0设备间互相连接的总线。\n\n 总线结构\n 总线通道\n\n按照信号类型可分为数据总线、控制总线和地址总线。只是逻辑上的划分。\n\n数据总线宽度是决定连接到总线上的设备可能获得的最大性能的决定因素之一，也是影响系统性能的关键因素之一。\n地址总线是标明发送或接收数据的设备编号信号线。其宽度决定了总线上连接设备的能力。\n控制总线用于控制总线设备对数据线和地址线的使用控制信号主要完成设备之间进行信息交换时的定时和命令。其中定时信号表明有效地址和数据出现在总线上的时间。命令信号定义总线上所要完成的操作。\n\n\n\n 总线上的设备\n\n主设备能够申请总线使用权，而从设备不具有总线使用权。\n\n 总线接口\n\n是连接功能部件和总线的桥梁，它完成功能部件的信号和总线信号之间的协调和转换，因此具有对总线和设备两个方面的工作。\n\n 总线连接的主要优点\n\n多个部件之间采用总线连接方式，可大大降低部件间互连的复杂性，大幅度减少连线数量。\n由于多个部件之间连接的多个控制接口变成了每个部件与总线间的一个连接接口，连接接口的器材量大幅度减少。\n如果设备之间没有或者很少有多个部件同时进行信息交换，采用总线方式连接这些部件可有效发挥总线连接的优点。\n\n 总线特性\n\n物理特性：总线的物理连接方式，包括总线的根数、总线的插头、插座形状、引脚线排列方式等。\n功能特性：描述总线中每一根线的功能。\n电气特性：定义每一根线上信号的传递方向及有效电平范围。一般规定送入CPU的信号叫输入信号、从CPU发出的信号叫输出信号。\n时间特性：定义每根线在什么时间有效，即规定总线上各信号有效的时序关系。\n\n 总线的连接方式\n 单总线结构\n\n特点：使用一条单一的系统总线来连接CPU、主存和I/O设备。\n要求：连到总线上的逻辑部件必须高速运行。\n单总线系统中，对输入/输出设备的操作，完全和主存的操作方法一样来处理。\n某些外围设备也可以指定地址。此时外围设备通过与CPU中的控制部件交换信息的方式占有总线。\n\n 双总线结构\n\n在CPU和主存之间专门设置了一组高速的存储总线，使CPU通过专用总线与内存交换信息，减轻了系统总线负担；同时内存与外设之间仍使用系统总线实现DMA操作，而不必经过CPU。\n\n 三总线结构\n\n在双总线的基础上增加了I/O总线形成的。其中系统总线是CPU、主存和通道(IOP)之间进行数据传送的公共通路；而I/O总线是多个外部设备与通道进行数据传送的公共通路。\n通道(Channel)是一台具有特殊功能的处理器(IOP)，分担了一部分CPU的功能，以实现对外设的统一管理及外设与主存之间的数据传送，提高了CPU的效率，但以花费更多的硬件为代价。\n\n 总线结构对计算机系统性能的影响\n\n最大存储容量：单总线系统中，必须为外围设备保留某些地址，最大存储容量小于由计算机地址总线宽度所决定的可能的地址总数；而双总线的存储容量不受外围设备多少的影响。\n指令系统：双总线系统中对存储总线和系统总线必须有不同的指令系统；而在单总线系统中对内存和外设采用相同的指令，不同之处仅在于使用不同的地址。\n\n 总线的内部结构\n\n数据传送总线：由地址线、数据线、控制线组成；为减少布线，数据线和地址线常采用多路复用方式。\n仲裁总线：总线请求线和总线授权线。\n中断和同步总线：用于处理带优先级的中断操作，包括中断请求线和中断认可线。\n公用线：包括时钟信号线、电源线、地线、系统复位线以及加电或断电的时序信号线等。\n\n 总线接口\n 信息的传送方式\n 基本概念\n\n码元：信息传输通道中，携带数据信息的信号单元。\n波特率（码元传输率）：每秒钟通过信道传输的码元数。是传输信道频宽的指标。\n码元时间：波特率的倒数，即传输一位码元的时间。\n\n 串行传送\n\n只用一条传输线，且采用脉冲传送。\n在串行传送时，按照顺序来传送表示一个数码的所有二进制位的脉冲信号，每次一位。\n当使用脉冲信号传递连续的“1”或“0”数码时，必须采用某种时序格式，以便使接收设备能加以识别，通常采用“位时间”（即一个二进制位在传输线上占用的时间长度），一般低位在前，高位在后。\n在串行传送时，被传送的数据需要在发送部件进行并—串变换，即拆卸，在接收部件进行串—并变换，称为装配。\n\n 并行传送\n\n每个数据位单独占用一条传输线。这样每一条线分别代表了二进制数的不同位值。\n一般采用电位传送。出于速度和效率上的考虑，系统总线都采用“并行传送”方式。\n\n 分时传送\n\n一是采用总线复用方式，如在传输线上既传输数据又传送地址，为此必须划分时间片来实现传送任务；\n二是共享总线的部件分时使用总线。\n\n 接口的基本概念\n\nI/O设备适配器，广义上讲，接口指CPU和主存、外围设备之间通过总线进行连接的逻辑部件。接口在它动态连接的部件间起“转换器”的作用，以实现彼此间的信息传送。\n接口通常具有的功能:\n\n控制：靠程序的指令信息来控制外围设备的动作。\n缓冲：作为缓冲器，用以补偿各种设备在速度上的差异。\n状态：监视外围设备的工作状态并保存状态信息，供CPU询问外围设备时进行分析。\n转换：完成任何要求的数据转换。\n整理：完成一些特别的功能，如修改字计数器或当前AR。\n程序中断：外围设备向CPU请求某种动作时，接口即发生一个中断请求信号到CPU。\n\n\n适配器必须有的两个接口：\n\n和系统总线的接口，其数据交换一定是并行方式；\n和外设的接口，可能是并行或串行；\n\n\n\n 总线的仲裁、定时和数据传送模式\n 总线的仲裁\n 集中式仲裁\n\n仲裁电路集中在一起，通常由一个模块实现。每功能模块有两条线连到中央仲裁器：一条为送往仲裁器的总线请求信号线BR，一条是仲裁器送出的总线授权信号线BG。\n\n 链式查询方式\n\n特点： 共用一条总线授权线，总线授权信号BG串行地从一个I/O接口传送到下一个I/O接口，如果该接口没有请求，则继续往下查询；如果有总线请求，则BG信息不再向下查询，该接口获得总线控制权。\n共用一个BS线表示当前总线是否被使用着。各设备的优先级是按照BG线上离中央仲裁器的远近来确定。\n优点：只用很少几根线就能按一定优先次序实现总线仲裁，且可方便地扩充设备。\n缺点：对询问链电路故障敏感，优先级固定而不能调整、速度慢。\n\n 计数器定时查询方式\n\n总线上任一设备要求使用总线时，通过BR线发出总线请求。中央仲裁器接到请求信号以后，在BS线为“0”的情况下让计数器开始计数，计数值通过一组地址线发向设备，每个设备接口都有一个设备地址判别电路，当地址线上的计数值与请求总线的设备地址一致时，该设备置“1”BS线，获得总线使用权，此时中止计数查询。\n比较：少了一条BG线，可改变优先次序，对电路的故障不如链式敏感，但增加了主控线数，控制较复杂。\n优点：设备优先级可以改变，仲裁策略灵活性高。\n\n 独立请求方式\n\n每一共享总线的设备均有一对BRi_ii​和BGi_ii​，当设备要使用总线时，便发出总线请求信号，中央仲裁器有一个排队电路，根据一定的优先次序决定首先响应哪个设备的请求，给设备以授权信号。\n优点：响应时间最快；对优先次序的控制相当灵活（可以预先固定、也可以通过程序来改变，还可屏蔽某个设备的总线请求）。\n对于单CPU系统总线，中央仲裁器又称总线控制器，是CPU的一部分，而按照目前的总线标准，中央仲裁器一般是单独功能模块。\n\n 分布式仲裁\n\n不需要中央仲裁器，每个主方都有自己的仲裁号和仲裁器；当总线申请时，把各自唯一的仲裁号发到共享的总线上，每个仲裁器把仲裁线上的号和自己的号比较，如果总线上的号大，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜的仲裁号留在仲裁总线上。\n\n 总线的定时\n 同步定时\n\n事件出现在总线上的时刻由总线时钟信号来确定\n优点：规定明确、统一、模块间配合简单一致。\n缺点：主从模块时间配合属强制性同步，必须在限定时间内完成规定的要求，并且对所有模块都用同一限时，势必造成对不相同速度的部件而言，必须按最慢的速度部件来设计公共时钟，严重影响总线工作效率\n适用范围：仅适合总线长度较短、各个功能模块存取时间比较接近的情况。\n\n 异步定时\n\n建立在应答式或互锁机制基础之上，后一事件出现在总线上的时刻取决于前一事件的出现。\n优点：不需要统一的公共时钟，总线周期的长度可变，不把响应时间强加到功能模块上，允许快速和慢速的功能模块都能连接到同一总线上，给设计者以充分的灵活和选择余地。\n缺点：增加了总线的复杂性和成本。\n\n 总线数据传送模式\n\n读、写操作：读操作是由从方到主方的数据传送；写操作是由主方到从方的数据传送。一般，主方先以一个总线周期发出命令和从方地址，经过一定的延时再开始数据传送总线周期。为了提高总线利用率，减少延时损失，主方完成寻址总线周期后可让出总线控制权，以使其他主方完成更紧迫的操作。然后再重新竞争总线，完成数据传送总线周期。\n块传送操作：只需给出块的起始地址，然后对固定块长度的数据一个接一个地读出或写入。对于CPU（主方）—存储器（从方）而言的块传送，常称为猝发式传送，其块长一般固定为数据线宽度（存储器字长）的4倍。例如一个64位数据线的总线，一次猝发式传送可达256位。这在超标量流水中十分有用。\n写后读、读修改写操作：这是两种组合操作。只给出地址一次（表示同一地址），或进行先写后读操作，或进行先读后写操作。前者用于校验目的，后者用于多道程序系统中对共享存储资源的保护。这两种操作和猝发式操作一样，主方掌管总线直到整个操作完成。\n广播、广集操作：一般而言，数据传送只在一个主方和一个从方之间进行。但有的总线允许一个主方对多个从方进行写操作，这种操作称为广播。与广播相反的操作称为广集，它将选定的多个从方数据在总线上完成AND或OR操作，用以检测多个中断源。\n\n HOST总线和PCI总线\n 多总线结构\n\nPCI是一个与处理器无关的高速外围总线，是一个层间总线，采用同步时序协议和集中式仲裁策略，并具有自动配置能力。\n系统中一般有三种总线：\n\nHOST总线：有CPU总线、系统总线、主存总线等多种名称。不仅用来连接主存，还用来连接多个CPU。\nPCI总线：连接各种高速的PCI设备，设备可以是主、从或主从。允许有多条PCI总线，使用HOST桥和HOST总线相连，使用PCI/ PCI桥和PCI总线相连，用于扩充整个系统的PCI总线负载能力。\nLAGACY总线：ISA、EISA、MCA等性能较低的传统总线，支持中、低速I/O设备。\n\n\n桥：用来连接两条总线，使彼此间相互通信，又是一个总线转换部件，可以把一条总线的地址空间映射到另一个总线的地址空间上，从而使系统中任意一个总线主设备都能看到同样一份地址表。\n\n 外围设备\n 外围设备概述\n 外围设备的一般功能\n\n外围设备的定义：计算机系统中，除CPU和主存之外的部件都可看作外设；\n外围设备的功能：在计算机和其他机器或与用户之间提供联系。\n外围设备的基本组成：\n\n存储介质：用于信息的保存；\n驱动装置：用于移动存储介质，使之正常工作；\n控制电路：用于使该外设与外界（如CPU）的信息传递\n\n\n\n 外围设备的分类\n\n输入/出设备；\n外存设备；\n数据通信设备；\n过程控制设备；\n\n 磁盘存储设备\n 磁记录原理\n\n磁表面存储器：用磁性材料薄薄地涂在金属铝或塑料表面作载磁体来存储信息。\n磁表面存储器的优点：\n\n存储容量大，位价格低；\n记录介质可以重复使用；\n记录信息可以长期保存而不丢失；\n非破坏性读出，读出时不需要再生信息。\n\n\n磁表面存储器的缺点：\n\n存取速度较慢，机械结构复杂；\n非接触式读写，对工作环境要求较高。\n\n\n在磁表面存储器中，信息的读写是利用磁头来进行的；\n\n磁头：由软磁材料做铁芯，绕有读写线圈的电磁铁。\n\n\n写操作\n\n原理：电-磁变换；\n利用磁头写线圈中的脉冲电流，在磁表面每个存储元上形成不同的磁化状态；\n\n\n读操作\n\n原理：磁-电变换；\n利用磁头读线圈，将磁表面每个存储元上的不同剩磁状态转换成电信号读出\n\n\n\n 磁盘的组成\n\n硬盘的逻辑结构组成\n\n磁记录介质\n磁盘控制器\n磁盘驱动器\n\n\n\n 硬磁盘的分类\n\n按盘片结构分\n\n可换盘片式\n固定盘片式\n\n\n按磁头分\n\n可移动磁头\n固定磁头\n\n\n温彻斯特磁盘机\n\n可移动磁头固定盘片的磁盘机；\n密封组合式的硬磁盘；磁头、盘片、电机等部件组装成一个不可随意拆卸的整体。\n工作时，高速旋转在盘面上形成的气垫将磁头平稳浮起。\n优点：防尘性能好，可靠性高，对使用环境要求不高。\n\n\n\n 硬磁盘驱动器和控制器\n\n磁盘驱动器\n\n定位驱动系统\n主轴系统\n数据转换系统\n\n\n磁盘控制器：主机与磁盘驱动器之间的接口\n\n 磁盘上信息的分布\n\n记录面\n\n磁盘片表面；\n一个盘片有上下两个记录面。\n\n\n磁道\n\n记录面上一系列同心圆；\n最外圈为0磁道 ，依次为1、2、……、N磁道；\n每个磁道的存储容量均相同；\n不同盘片的相同磁道构成一个柱面；\n\n\n扇区\n\n同心圆上的一段磁道区域；\n每个扇区的存储容量也相同。\n\n\n一个硬盘由多个盘片构成的磁盘组来记录信息；\n\n每个盘片包括两个记录面；\n每个记录面表面通常有几十到几百个磁道来记录信息；\n每个磁道又分为若干个扇区。\n\n\n磁盘组的信息记录顺序是按照柱面来组织的：第0面第0道-&gt;第1面第0道-&gt;……-&gt;第N面第0道-&gt;第0面第1道-&gt;第1面第1道-&gt;……-&gt;第N面第1道-&gt;……\n硬盘上信息地址由记录面号、磁道号、扇区号三个部分组成。\n索引 ：磁道的起始位置。为便于进行读/写操作\n\n 磁盘存储器的技术指标\n 存储密度\n\n道密度\n\n沿磁盘半径方向单位长度上的磁道数；\n单位：道/英寸。\n\n\n位密度\n\n磁道单位长度上能记录的二进制代码位数；\n单位：位/英寸。\n注意：每个磁道的位密度均不相同，有最高、最低位密度。\n0磁道的位密度为最低位密度；\n\n\n面密度\n\n位密度和道密度的乘积；\n单位：位/平方英寸。\n\n\n\n 存储容量\n\n存储容量=记录面数×每面磁道数×磁道容量\n非格式化容量：磁记录表面可以利用的磁化单元总数。\n格式化容量\n\n按照某种特定的记录格式所能存储信息的总量，也就是用户可以真正使用的容量。\n格式化容量一般是非格式化容量的60%—70%。\n\n\n\n 平均存取时间\n\n平均存取时间等于平均找道时间与平均等待时间之和；\n\n定位时间（找道时间）：将磁头定位至所要求的磁道上所需的时间；\n等待时间：找道完成后，盘片将所要访问信息转到磁头下方的时间；\n\n\n平均找道时间：最大与最小找道时间的平均值，约为10~20ms；\n平均等待时间\n\n与磁盘转速有关，是磁盘旋转一周时间的一半。\n硬盘转速为7200转/分，故平均等待时间约为4ms。\n\n\n\n 数据传输率\n\n数据传输率与存储设备和主机接口逻辑有关。\n设磁盘旋转速度为每秒n转，磁道容量为N个字节，数据传输率Dr=n×NDr= n × NDr=n×N（字节/秒）\n设某磁道位密度为D字节/英寸，磁盘转速为v英寸/秒，则数据传输率Dr=D×vDr= D × vDr=D×v（字节/秒）\n\n 光盘和磁光盘存储设备\n\n光盘存储器\n\n采用聚焦激光束在盘式介质上非接触地记录高密度信息；\n以介质材料光学性质的变化来表示所存储信息的“1”或“0”。\n\n\n光盘存储器是以光道来记录信息的；光道是一条始于盘片中心的螺旋线。\n光盘的优点：存储容量大；\n光盘的缺点：存取时间长，数据传输率低。\n\n 显示设备\n 显示设备的分类\n\n按显示器件分类\n\n阴极射线管(CRT)显示器\n液晶显示器(LCD)\n等离子显示器等；\n\n\n按显示的内容分类\n\n字符显示器\n图形显示器\n图像显示器；\n\n\nCRT显示设备\n\n以扫描方式不同，分成光栅扫描和随机扫描两种显示器；\n以分辨率不同 ，分成高分辨率显示器和低分辨率显示器；\n以显示的颜色分类，有单色(黑白)显示器和彩色显示器；\n以荧光屏对角线长度分类，有14英寸、16英寸、19英寸等多种。\n\n\n\n 随机扫描和光栅扫描\n\n随机扫描\n\n电子束只在需要做图的地方扫描，而不必扫描全屏幕；\n这种扫描方式画图速度快，图像清晰；\n高质量的图形显示器(如分辨率为4096×4096)采用；\n其偏转系统与电视标准不一致，驱动系统较复杂，价格较贵。\n\n\n光栅扫描\n\n电子束从上至下顺序扫描整个屏幕；又可分为逐行扫描和隔行扫描两种方式；\n电视中采用的扫描方法；\n缺点是冗余时间多，分辨率不如随机扫描方式。\n\n\n\n 分辨率\n\n分辨率是指显示器所能表示的像素个数；\n\n像素是指组成图像的最小单位；\n像素越密，分辨率越高，图像显示越清晰；\n\n\nCRT显示器的分辨率取决于显象管荧光粉的粒度、荧光屏的尺寸和CRT电子束的聚焦能力；\n\n 灰度级\n\n灰度级\n\n在黑白显示器中所显示的像素点的亮暗差别；\n在彩色显示器中则表示为颜色的不同；\n灰度级越多，图像层次越清楚逼真；\n\n\n灰度级取决于每个像素对应刷新存储器单元的位数和CRT本身的性能。\n只有两级灰度的显示器称为单色显示器。\n图像显示器的灰度级一般在256级以上。\n\n 刷新和刷新存储器\n\n刷新：CRT显示器的电子束不断地重复扫描整个屏幕以稳定图像；\n刷新频率\n\n显示器每秒能够对整个屏幕的刷新次数。\n一般设置刷新频率为70Hz以上；\n电视中的标准是每秒刷新50Hz；\n\n\n刷新存储器\n\n存放图像信息用于刷新的存储器，也叫显示存储器；\n其存储容量由图像分辨率和灰度级决定；\n刷新存储器的存取周期必须满足刷新频率的要求。\n刷新存储器带宽=分辨率×颜色深度×刷新频率\n\n\n\n 显示适配器\n\n显示适配卡，也叫显卡\n\n显示器与主机之间的接口电路；\n负责将主机发送的待显示的信号送给显示器。\n\n\n显卡的主要构成部件\n\n图形处理器GPU：处理显示信息；\n显存：暂存显示芯片要处理的数据和处理完毕的数据；\n显卡BIOS：存放显示芯片与驱动程序之间的控制程序；\n印刷电路板（PCB）\n\n\n显卡不同标准：VGA、XGA、SVGA\n\n 输入设备和打印设备\n\n输入设备\n\n图形输入设备：键盘、鼠标、图形板和游动标\n图像输入设备 ：数码照相机、数码摄像机、扫描仪\n语音输入设备 ：语音识别器\n\n\n打印设备\n\n针式打印机、喷墨打印机、激光打印机\n\n\n\n 输入输出系统\n 外围设备的速度分级与信息交换方式\n 输入输出系统的功能\n\n为了得到高效可靠的数据传输，选择输入输出设备。\n在选定的输入输出设备和CPU之间进行数据交换。\n\n 输入输出设备和CPU交换数据的过程\n\n输入过程：\n\nCPU把一个地址值放在地址总线上，这一步将选择一个输入设备\nCPU等候输入设备的数据成为有效\nCPU从数据总线上读入数据，并放在一个相应的寄存器中\n\n\n输出过程：\n\nCPU把一个地址值放在地址总线上，这一步将选择一个输出设备\nCPU把数据放在数据总线上\n输出设备认为数据有效，从而把数据取走\n\n\n\n CPU和外围设备的定时\n\n速度极慢或简单的外围设备：对于这类设备CPU总是能足够快地作出响应，也可以说，CPU认为输入的数据一直有效，在这种情况下，CPU只要接受和发送数据就可以了。常用的有：机械开关，显示二极管等。\n慢速或中速的外围设备：CPU与这类设备之间的数据交换通常采用异步定时方式。在这种情况下，CPU和外设之间用问答信号进行定时的方式叫做应答式数据交换。\n高速外围设备：CPU和这类设备之间通常采用同步定时方式，一旦CPU和外设发生同步，他们之间的数据交换用时钟控制来进行。\n\n同步定时方式：CPU以等间隔的速率执行I/O指令。靠时钟脉冲控制进行。\nDMA方式\n\n\n\n CPU对外围设备的管理方式\n\n程序查询方式\n程序中断方式\n\n 程序查询方式\n 外设状态\n\n在接口中设置状态字表示这些状态。\n空闲：调用前，设备不工作；\n结束：调用后，设备完成工作。\n\n 优缺点\n\n优点：硬件开销小；\n缺点：实时处理能力差,并行程度低。\n\n 应用场合\n\n对CPU效率要求不高的场合，或诊断调试过程。\n\n 程序中断方式\n 中断基本概念\n 定义\n\nCPU暂时中止现行程序的执行，转去执行为某个随机事态服务的中断处理程序。处理完毕后自动恢复原程序的执行。\n\n 实质与特点\n\n实质：程序切换\n\n方法：保存断点，保护现场；恢复现场，返回断点\n时间：一条指令结束时切换。保证程序的完整性。\n\n\n特点：随机性\n\n 中断分类\n\n硬件中断与软中断\n内中断与外中断\n可屏蔽中断与非屏蔽中断\n向量中断与非向量中断\n\n 中断系统的组成\n\n软件：服务程序、中断向量表\n硬件：\n\n接口方面：请求、传递、判优逻辑\nCPU方面：响应逻辑\n\n\n\n 工作原理\n\n采用中断的方式可以使CPU和外围设备在一些操作上并行工作，来提高CPU效率。但是中断方式的操作复杂，并需要硬件支持。\n\n 在中断处理过程中需要注意的\n\nCPU只有在当前一条指令执行完毕后，才能响应中断，\n中断时的现场保存和返回时的现场恢复\n“中断屏蔽”触发器IM：0允许中断，1不接受中断\n中断处理过程由硬件和软件协作完成；中断周期和服务程序\n\n 中断全过程（外中断）\n 中断请求的提出与传递\n 如何产生中断请求\n\n外设工作完成：“完成”标志为1\nCPU允许请求：“屏蔽”标志为0\n\n 如何传送中断请求\n\n使用单独请求线\n使用公共请求线\n\n 中断判优\n 优先顺序\n\n故障、DMA、外中断\n\n CPU现行程序与外设请求的判优\n\nCPU设置允许中断标志\n\n1，开中断\n0，关中断\n\n\nCPU设置程序状态字的优先级字段\n\n＜外设请求优先级，响应\n≥外设请求优先级，不响应\n\n\n各外设请求的判优\n\n软件判优：由程序查询顺序确定优先级。可灵活修改优先级。\n硬件判优\n\n\n\n 中断响应\n 响应条件\n\n外设有请求，且未被屏蔽；\nCPU开中断；\n一条指令(非停机指令)结束；\n无故障、DMA等优先级更高的请求\n\n 如何获取中断服务程序的入口地址\n\n非向量中断：将服务程序入口组织在查询程序中；CPU响应时执行查询程序，查询中断源，转入相应服务程序。\n向量中断：将服务程序入口(中断向量)组织在中断向量表中；CPU响应时由硬件直接产生相应向量地址，按地址查表，取得服务程序入口，转入相应服务程序。\n\n中断向量：服务程序入口地址、服务程序状态字\n中断向量表：存放中断向量的表（一段存储区）\n向量地址：访问向量表的地址（指向中断向量的首址）\n\n\n\n 响应过程\n\n发响应信号INTA，进入中断周期\n关中断，保存断点\n获得中断号，转换为向量地址，查向量表\n取中断向量，转中断服务程序\n\n 中断处理\n\n单级中断：CPU响应后只处理一个中断源的请求，处理完毕后才能响应新的请求。\n多重中断：在某次中断服务过程中，允许响应处理更高级别的中断请求。\n\n 程序中断方式的标志触发器\n\n准备就绪的标志（RD）：一旦设备做好一次数据的接收或发送工作，便发出一个设备动作完毕信号，使RD标志为“1”，它就是程序查询方式中的Ready（就绪）标志。在中断方式中，该标志用作为中断源触发器，简称中断触发器。\n允许中断触发器（EI）：可以用程序指令来置位。EI为“1”时，某设备可以向CPU发出中断请求；EI为“0”时，不能向CPU发出中断请求，这意味着某中断的中断请求被禁止。设置EI标志的目的就是通过程序来控制是否允许某设备发出中断请求。\n中断请求触发器（IR）它暂存中断请求线上由设备发出的中断请求，当IR标志为“1”时，表示设备发出了中断请求。\n中断屏蔽触发器（IM）CPU是否受理中断的标志。IM标志为“0”时，CPU可以受理外界的中断请求，反之，IM标志为“1”时，CPU不受理外界的中断请求。\n\n DMA方式\n DMA的基本概念\n 定义\n\n直接依靠硬件实现主存与I/O间的数据传送，传送期间不需CPU程序干预\nI/O与主存，而不是I/O与CPU。\n早期由CPU控制传送；现在由DMA控制器控制传送，DMA控制器接管总线权，传送完毕再交还总线权。\n传送期间只要CPU不访存，可并行操作\n传送前和传送后需要程序干预。\n\n DMA流程\n\n程序准备：主程序实现初始化。\nDMA传送：硬件实现M↔\\leftrightarrow↔I/O的数据传送。\n善后处理：中断处理程序判断传送的正误。\n\n 应用场合\n\n用于高速、简单、批量数据传送\n\n DMA传送方式\n 停止CPU访问内存\n\n优点: 控制简单，它适用于数据传输率很高的设备进行成组传送。\n缺点: 在DMA控制器访内阶段，内存的效能没有充分发挥。\n\n 周期挪用方式\n\nI/O有DMA请求时，由DMA控制器挪用一个或几个主存周期来完成数据的传输，即在CPU指令周期中插入了DMA操作，有冲突时DMA优先。（用于I/O设备读写周期大于内存存储周期的情况）\n\n CPU与DMA交替访问存储器\n\n将一个CPU周期分为两个分周期，由CPU与DMA控制器轮流使用总线，也称为透明的DMA方式（硬件逻辑复杂）\n\n 基本的DMA控制器\n DMA控制器的基本组成\n\n内存地址计数器：用于存放内存中要交换的数据地址。在DMA工作前由程序设定，每传输一次地址自动加“1”\n字计数器：用于记录传送数据块的长度，通常用补码表示，在DMA工作前由程序设定，每传输一次字计数器自动加“1”，当计数器溢出时，表示传送完毕，向CPU发出中断\n数据缓冲寄存器：用于暂存每次传送的数据\nDMA请求标志：每当设备准备好一次传输时发出的一个控制信号，使DMA请求标志位置“1”，向“控制/状态”逻辑发出DMA请求，“控制/状态”逻辑向CPU发出总线使用权的请求HOLD；CPU响应该请求时，发回响应信号HLDA， “控制/状态”逻辑接收到此信号后发出DMA响应信号，使DMA请求标志复位，为交换下一个字作好准备。\n“控制/状态”逻辑：由控制和时序电路以及状态标志组成。用于修改内存地址计数器和字计数器，指定传送类型，并对DMA请求信号和CPU响应信号进行协调和同步。\n中断机构：当字计数器溢出时，一组数据交换完毕，由溢出信号发出中断申请。\n\n DMA数据传送过程\n\n可分为三阶段：传送前预处理、正式传送和传送后处理\n传送前预处理：执行几条I/O指令，完成设备状态测试、初始化地址计数器和字计数器，CPU返回原来的主程序继续执行\n当外设准备好时，发送DMA请求，由DMA控制器向CPU发出总线使用权的请求HOLD。CPU接受请求，根据不同的传递方式实现以数据块为单位的数据传输。\nDMA传送后处理进行的工作：结束时，DMA发送中断请求，CPU处理中断服务程序，处理DMA结束需要处理的工作——校验送入内存的数据是否正确、决定是否继续进行DMA传送、测试在传送过程中是否发生了错误。\n基本DMA控制器与系统的连接方式有两种方式：一种是公用的DMA请求方式，另一种是独立的DMA请求方式。\n\n 选择型和多路型DMA控制器\n\n选择型DMA控制器：物理上可以连接多个设备，逻辑上只允许连接一个设备，即某一段时间内只能为一个设备服务。\n多路型DMA控制器：允许各设备以字节为单位交叉传送，或以数据块为单位成组传送。\n\n 比较\n DMA与中断的相同点\n\n能响应随机请求；可并行操作\n\n DMA与中断的不同点\n\n中断：用程序实现中、低速I/O传送；能处理复杂事态；一条指令结束时响应请求。\nDMA：用硬件实现高速、简单I/O传送；一个总线周期结束响应请求。\n\n 通道方式\n 通道的基本概念\n\n通道是一个特殊功能的处理器，它有自己的指令和程序专门负责数据输入输出的传输控制，而CPU将“传输控制”的功能下放给通道后只负责“数据处理”功能。\n通道处理机虽然不是一台具有完整指令系统的处理机，但是可以把它看作是一台能够执行有限输入输出指令，并且能够被多台外围设备共享的小型DMA专用处理机。\n\n 通道的类型\n\n字节多路通道\n\n用于多台低速或中速的外围设备\n采用分时方式工作\n\n\n选择通道\n\n用于高速外围设备\n工作方式：一旦选中某一设备，通道就进入“忙”状态，直到该设备的数据传输工作全部结束为止。\n\n\n数组多路通道\n\n字节多路通道和选择通道的结合\n\n\n\n 通道的功能\n\n接受CPU的指令。\n读取并执行通道程序。\n控制数据传送。\n读取外设的状态信息，提供给CPU。\n发出中断请求。\n\n 外围处理机方式\n\n外围处理机是通道的进一步发展，其独立于主机工作，结构更接近一般的处理机（PC）。\n外围处理机分担中央处理机的输入输出任务，又称输入输出处理机、I／O处理机等，缩写为IOP或PPU。\n外围处理机主要用在除IBM公司以外的其他计算机公司研制的巨型、大型计算机系统中，甚至在有些中小型及微型计算机系统中也有输入输出处理机。\n\n 产生IOP的原因\n\n通道处理机实际上并不能看成是独立的处理机，因为它的指令(通道指令)系统很简单，只有面向外围设备的控制和数据传送的基本指令，而且没有大容量的存储器。在数据的输入输出过程中，通道处理机还需要由CPU来承担许多工作。\n\n","slug":"computer-organization","date":"2023-12-20T08:32:28.000Z","categories_index":"computer science","tags_index":"computer science,learning","author_index":"Ivan Snow"},{"id":"f4e7b85c05f341a057a04030682b62aa","title":"线性代数","content":"\n\n\n 1 线性方程组\n 1.1 线性方程组\n\n由于二元一次方程表示平面上的一条直线，所以将一次方程称为线性方程，将一次方程组称为线性方程组\n\n 1.2 矩阵及其初等变换\n 矩阵的定义\n\n\n由m×nm \\times nm×n个数aij(i=1,2,…,m;j=1,2,…,n)a_{ij}(i=1,2,\\dots,m;j=1,2,\\dots,n)aij​(i=1,2,…,m;j=1,2,…,n)排成的mmm行nnn列的数表，A=(a11a12…a1na21a22…a2n⋮⋮⋮am1am2…amn)A=\\begin{pmatrix} a_{11} &amp;a_{12} &amp;\\ldots&amp;a_{1n}\\\\a_{21} &amp; a_{22} &amp;\\ldots &amp;a_{2n}\\\\\\vdots &amp;\\vdots &amp;&amp; \\vdots\\\\a_{m1} &amp;a_{m2} &amp;\\ldots&amp; a_{mn}\\end{pmatrix}A=⎝⎜⎜⎜⎜⎛​a11​a21​⋮am1​​a12​a22​⋮am2​​………​a1n​a2n​⋮amn​​⎠⎟⎟⎟⎟⎞​称为mmm行nnn列矩阵，简称m×nm \\times nm×n矩阵。\n\n\n设 A=(aij)m×nA=(a_{ij} )^{m\\times n}A=(aij​)m×n，B=(bij)p×qB = (b_{ij} )^{p\\times q}B=(bij​)p×q，如果 m=pm = pm=p，n=qn = qn=q（此时称 A 与 B 是同型矩阵）且 aij=bija_{ij}=b_{ij}aij​=bij​ (i=1,…,m;j=1,…,ni=1,\\dots,m;j=1,\\dots,ni=1,…,m;j=1,…,n) 则称 A 与 B 相等，记作 A=BA = BA=B。\n\n\n 矩阵的初等变换\n\n称矩阵的下面三种变换分别为第一、第二、第三种初等行变换（类似定义三种初等列变换）：\n\n交换矩阵的某两行，记为ri↔rjr_i \\leftrightarrow r_jri​↔rj​\n以不等于０的数乘矩阵的某一行，记为k⋅rik \\cdot r_ik⋅ri​\n把矩阵的某一行乘上一个数加到另一行上， 记为ri+k⋅rjr_i + k \\cdot r_jri​+k⋅rj​\n\n\n行阶梯型矩阵\n\n台阶左下方元素全为零\n每个台阶上只有一行\n每个台阶上第一个元素不为零\n\n\n行最简阶梯型矩阵\n\n台阶左下方元素全为零\n每个台阶上只有一行\n每个台阶上第一个元素不为零\n台阶上的第一个元素为1,且其所在列其它元素全为零\n\n\n定理1.1：只用初等行变换必能将矩阵化为行阶梯形，从而再化为行最简形，行阶梯形不唯一，行最简形唯一\n如果矩阵A经过有限次初等变换变成矩阵B，就称矩阵A与B等价，记作A≅BA\\cong BA≅B\n\n 1.3 线性方程组的矩阵解法\n 定理1.2：非齐次线性方程组解的判定定理\n\n当T的台阶数为r+1时，方程组无解\n当T的台阶数为r时，方程组有解\n\n当r＝n（未知量个数）时，方程组有唯一解\n当r＜n时，方程组有无穷多解\n\n\n\n 定理1.3：齐次线性方程组解的判定定理\n\n当r＝n（未知量个数）时，方程组有唯一零解\n当r＜n时，方程组有无穷多解（非零解）\n\n 2 矩阵\n 2.1 矩阵的运算\n\n\n矩阵的加法：A=(aij)m×n,B=(bij)m×n,A+B=(a11+b11a12+b12⋯a1n+b1na21+b21a22+b22⋯a2n+b2n⋮⋮⋮am1+bm1am2+bm2⋯amn+bmn)A=(a_{ij})^{m\\times n},B=(b_{ij})^{m\\times n},A+B=\\begin{pmatrix} a_{11}+b_{11}&amp;a_{12}+b_{12} &amp; \\cdots &amp;a_{1n}+b_{1n}\\\\a_{21}+b_{21}&amp;a_{22}+b_{22}&amp;\\cdots &amp; a_{2n}+b_{2n}\\\\ \\vdots &amp; \\vdots &amp; &amp; \\vdots\\\\a_{m1}+b_{m1} &amp; a_{m2}+b_{m2} &amp; \\cdots &amp; a_{mn} + b_{mn}\\end{pmatrix}A=(aij​)m×n,B=(bij​)m×n,A+B=⎝⎜⎜⎜⎜⎛​a11​+b11​a21​+b21​⋮am1​+bm1​​a12​+b12​a22​+b22​⋮am2​+bm2​​⋯⋯⋯​a1n​+b1n​a2n​+b2n​⋮amn​+bmn​​⎠⎟⎟⎟⎟⎞​\n\n\n矩阵的数乘：kA=k(aij)m×n=(kaij)m×nkA=k(a_{ij})^{m\\times n}=(ka_{ij})^{m\\times n}kA=k(aij​)m×n=(kaij​)m×n\n\n\n矩阵的乘法：A=(aij)m×n,B=(bij)n×s,AB=(cij)m×sA=(a_{ij})^{m\\times n},B=(b_{ij})^{n\\times s},AB=(c_{ij})^{m\\times s}A=(aij​)m×n,B=(bij​)n×s,AB=(cij​)m×s，其中cij=ai1b1j+ai2b2j+⋯+ainbnj=∑k=1saikbkjc_{ij}=a_{i1}b_{1j}+a_{i2}b_{2j}+\\cdots+a_{in}b_{nj}=\\sum\\limits_{k=1}^sa_{ik}b_{kj}cij​=ai1​b1j​+ai2​b2j​+⋯+ain​bnj​=k=1∑s​aik​bkj​\n\n\nEmAm×n=Am×nEnE_mA^{m\\times n}=A_{m \\times n}E_nEm​Am×n=Am×n​En​\n\n\n有了矩阵的乘法，方程组的矩阵表示形式可以用矩阵形式表示为AX=BAX=BAX=B，其中A=(a11a12⋯a1na21a22⋯a2n⋮⋮⋮am1am2⋯amn)A=\\begin{pmatrix}a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}\\\\a_{21}&amp;a_{22}&amp;\\cdots&amp;a_{2n}\\\\\\vdots&amp;\\vdots&amp;&amp;\\vdots\\\\a_{m1}&amp;a_{m2}&amp;\\cdots&amp;a_{mn}\\end{pmatrix}A=⎝⎜⎜⎜⎜⎛​a11​a21​⋮am1​​a12​a22​⋮am2​​⋯⋯⋯​a1n​a2n​⋮amn​​⎠⎟⎟⎟⎟⎞​，X=(x1x2⋮xn)X=\\begin{pmatrix}x_1\\\\x_2\\\\\\vdots\\\\x_n\\end{pmatrix}X=⎝⎜⎜⎜⎜⎛​x1​x2​⋮xn​​⎠⎟⎟⎟⎟⎞​，B=(b1b2⋮bm)B=\\begin{pmatrix}b_1\\\\b_2\\\\\\vdots\\\\b_m\\end{pmatrix}B=⎝⎜⎜⎜⎜⎛​b1​b2​⋮bm​​⎠⎟⎟⎟⎟⎞​；A‾=(A∣B)\\overline A =(A|B)A=(A∣B)称为方程组的增广矩阵，对应齐次方程组可用矩阵形式表示为AX=OAX=OAX=O\n\n\n方阵的幂：Ak=A⋅A⋅A⋯A(k个A相乘)A^k=A\\cdot A\\cdot A\\cdots A(k个A相乘)Ak=A⋅A⋅A⋯A(k个A相乘)，规定A0=E,A1=AA^0=E,A^1=AA0=E,A1=A\n\n\n当A与B可交换时，有下面二项展开式：(A+B)n=Cn0AnB0+Cn1An−1B+⋯+CnnA0Bn(A+B)^n=C^0_nA^nB^0+C^1_nA^{n-1}B+\\dots+C^n_nA^0B^n(A+B)n=Cn0​AnB0+Cn1​An−1B+⋯+Cnn​A0Bn\n\n\n矩阵的转置：AT=(aji)n×mA^T=(a_{ji})^{n\\times m}AT=(aji​)n×m\n\n\n运算律\n\n乘法结合律：(AB)C=A(BC)(AB)C=A(BC)(AB)C=A(BC)\n乘法分配律：(A+B)C=AC+BC(A+B)C=AC+BC(A+B)C=AC+BC\n乘法分配律：A(B+C)=AB+ACA(B+C)=AB+ACA(B+C)=AB+AC\n数乘结合律：k(AB)=(kA)B=A(kB)k(AB)=(kA)B=A(kB)k(AB)=(kA)B=A(kB)\n加法交换律：A+B=B+AA+B=B+AA+B=B+A\n加法结合律：(A+B)+C=A+(B+C)(A+B)+C=A+(B+C)(A+B)+C=A+(B+C)\n数乘结合律：k(lA)=(kl)Ak(lA)=(kl)Ak(lA)=(kl)A\n数乘分配律：(k+l)A=kA+lA(k+l)A=kA+lA(k+l)A=kA+lA\n数乘分配律：k(A+B)=kA+kBk(A+B)=kA+kBk(A+B)=kA+kB\nAkAl=Ak+lA^kA^l=A^{k+l}AkAl=Ak+l\n(AB)2≠A2B2(AB)^2\\neq A^2B^2(AB)2=A2B2\n(A+B)2≠A2+2AB+B2(A+B)^2\\neq A^2+2AB+B^2(A+B)2=A2+2AB+B2\nA2−B2≠(A+B)(A−B)A^2-B^2\\neq (A+B)(A-B)A2−B2=(A+B)(A−B)\n(AB)T=BTAT(AB)^T=B^TA^T(AB)T=BTAT\n\n\n\n对称矩阵：AT=AA^T=AAT=A\n\n\n反对称矩阵：AT=−AA^T=-AAT=−A\n\n\n 2.2 可逆矩阵\n\n\n可逆矩阵的定义：若AAA是nnn阶方阵，存在一个nnn阶方阵BBB，使得AB=BA=EAB=BA=EAB=BA=E，则称AAA是可逆的，BBB称为AAA的逆矩阵，记作A−1A^{-1}A−1\n\n\n定理2.1 如果A可逆，则A的逆矩阵是唯一的\n\n\n可逆矩阵性质\n\n若AAA可逆，则A−1A^{-1}A−1可逆，且(A−1)−1=A(A^{-1})^{-1}=A(A−1)−1=A\n若AAA可逆，则ATA^TAT可逆，且(AT)−1=(A−1)T(A^T)^{-1}=(A^{-1})^T(AT)−1=(A−1)T\n若AAA可逆，则kAkAkA可逆，且(kA)−1=1kA−1(kA)^{-1}=\\frac{1}{k}A^{-1}(kA)−1=k1​A−1\n若AAA可逆，BBB可逆，则ABABAB可逆，且(AB)−1=B−1A−1(AB)^{-1}=B^{-1}A^{-1}(AB)−1=B−1A−1\n(A+B)−1≠A−1+B−1(A+B)^{-1}\\neq A^{-1}+B^{-1}(A+B)−1=A−1+B−1\n\n\n\n定理2.2 设 A是n阶方阵，如果A可逆，则线性方程组\n有惟一解，且解可表示为X=A−1BX=A^{-1}BX=A−1B\n\n\n用初等变换法求逆矩阵：\n\n把单位矩阵分别作第一、第二、第三种初等行变换得到的矩阵分别称为第一、第二、第三种初等矩阵\n性质：初等矩阵都是可逆的，且其逆矩阵仍是同一种初等矩阵Ei,j−1=Ei,j,E(i(k))−1=E(i(1k)),E(i,j(k))−1=E(i,j(−k))E_{i,j}^{-1}=E_{i,j},E_{(i(k))}^{-1}=E_{(i(\\frac{1}{k}))},E_{(i,j(k))}^{-1}=E_{(i,j(-k))}Ei,j−1​=Ei,j​,E(i(k))−1​=E(i(k1​))​,E(i,j(k))−1​=E(i,j(−k))​\n\n\n\n“左行右列”原则 对一个矩阵施行一次初等的左边乘以一个一次初等列相应的行变换，相当于在它初等矩阵；对一个矩阵施行变换，相当于在它的的初等矩阵。\n\n\n定理2.3  n阶方阵A可逆的充要条件是A可经过有限次初等行变换化成单位矩阵；即n阶方阵A可逆的充要条件是A行等价于单位矩阵E\n\n\n推论2.1\n\n方阵可逆的充要条件是可以分解为有限个初等矩阵的乘积\n方阵A可逆的充要条件齐次线性方程组AX=OAX=OAX=O只有零解\n方阵A可逆的充要条件非齐次线性方程组AX=BAX=BAX=B有惟一解\n\n\n\n定理2.4 方阵A可逆的充分必要条件是存在方阵B使得BA=EBA=EBA=E\n\n推论：方阵A可逆的充分必要条件是存在方阵B使得AB=EAB=EAB=E\n\n\n\n定理2.5 设A,BA,BA,B均为m×nm\\times nm×n阶矩阵，则：\n\nA,BA,BA,B行等价的充要条件是存在m阶可逆矩阵P，使得PA=BPA=BPA=B\nA,BA,BA,B等价的充要条件是存在m阶可逆矩阵P，n阶可逆矩阵Q，使得PAQ=BPAQ=BPAQ=B\n\n\n\n 2.3 分块矩阵\n\n分块矩阵的定义：把矩阵按照一定的规律分成若干个子矩阵，称为分块矩阵\n\n 3 行列式\n 3.1 行列式的定义及性质\n 定义：\n\n递归定义∣A∣=a11A11+a12A12+⋯+a1nA1n|A|=a_{11}A_{11}+a_{12}A_{12}+\\dots +a_{1n}A_{1n}∣A∣=a11​A11​+a12​A12​+⋯+a1n​A1n​\n\n 展开定理：\n\n∑k=1naikAik={∣A∣,i=k0,i≠k\\sum\\limits_{k=1}^na_{ik}A_{ik}= \\begin{cases}|A|,&amp;i=k\\\\0,&amp;i\\neq k\\end{cases}k=1∑n​aik​Aik​={∣A∣,0,​i=ki=k​\n∑k=1nakjAkj={∣A∣,i=k0,i≠k\\sum\\limits_{k=1}^na_{kj}A_{kj}= \\begin{cases}|A|,&amp;i=k\\\\0,&amp;i\\neq k\\end{cases}k=1∑n​akj​Akj​={∣A∣,0,​i=ki=k​\n即行列式等于其任一行（列）元素与其对应的代数余子式乘积之和（亦即行列式可按任一行或任一列展开）\n任一行（列）元素与另一行（列）元素所对应的代数余子式乘积之和为零（错行展开为零）\n\n 性质\n\n有一行(列)元素为零的行列式等于零\n行列式的加法（区别于矩阵加法）\n矩阵的三类初等变换对行列式的影响\n有两行(列)元素相同(或成倍数)的行列式等于零\n∣λA∣=λn∣A∣|\\lambda A|=\\lambda^n|A|∣λA∣=λn∣A∣\n∣AT∣=∣A∣|A^T|=|A|∣AT∣=∣A∣\n\n 乘法定理\n\n∣AB∣=∣A∣∣B∣|AB|=|A||B|∣AB∣=∣A∣∣B∣\n\n 3.2 行列式的求解\n\n化三角法\n降阶法\n范德蒙德行列式：Dn=∣11⋯1x1x2⋯xn⋮⋮⋮x1n−1x2n−1⋯xnn−1∣=∏1≤i&lt;j≤n(xj−xi)D_n=\\begin{vmatrix}1&amp;1&amp;\\cdots&amp;1\\\\x_1&amp;x_2&amp;\\cdots&amp;x_n\\\\\\vdots&amp;\\vdots&amp;&amp;\\vdots\\\\x_1^{n-1}&amp;x_2^{n-1}&amp;\\cdots&amp;x_n^{n-1}\\end{vmatrix}=\\prod\\limits_{1\\leq i&lt;j\\leq n}(x_j-x_i)Dn​=∣∣∣∣∣∣∣∣∣∣​1x1​⋮x1n−1​​1x2​⋮x2n−1​​⋯⋯⋯​1xn​⋮xnn−1​​∣∣∣∣∣∣∣∣∣∣​=1≤i&lt;j≤n∏​(xj​−xi​)\n爪形行列式\n\n 3.3行列式的应用\n 伴随矩阵\n\n\nAA∗=A∗A=∣A∣EAA^*=A^*A=|A|EAA∗=A∗A=∣A∣E\n\n\n方阵A可逆的充要条件是∣A∣≠0,A−1=1∣A∣A∗|A|\\neq 0, A^{-1}=\\frac{1}{|A|}A^*∣A∣=0,A−1=∣A∣1​A∗\n\n\n 克莱姆法则\n\n设D=∣A∣≠0D=|A|\\neq 0D=∣A∣=0，则线性方程组Ax=BAx=BAx=B有唯一解x=A−1B=1∣A∣A∗Bx=A^{-1}B=\\frac{1}{|A|}A^*Bx=A−1B=∣A∣1​A∗B\n设齐次线性方程组Ax=0Ax = 0Ax=0，如果系数矩阵行列式D=∣A∣≠0D=|A|\\neq 0D=∣A∣=0，则方程组Ax=0Ax = 0Ax=0只有零解。\n\n 4 向量空间\n 4.1 向量及其线性组合\n 向量的线性表示\n\n\n定义4.2 对于向量组A:α1,α2,…,αnA:\\alpha_1,\\alpha_2,\\dots,\\alpha_nA:α1​,α2​,…,αn​，表达式k1α1+k2α2+⋯+knαnk_1\\alpha_1+k_2\\alpha_2+\\dots+k_n\\alpha_nk1​α1​+k2​α2​+⋯+kn​αn​称为向量组AAA的一个线性组合，又如果β\\betaβ是向量组AAA的一个线性组合，即存在数λ1,λ2,…,λn\\lambda_1,\\lambda_2,\\dots,\\lambda_nλ1​,λ2​,…,λn​使得β=λ1α1+λ2α2+⋯+λnαn\\beta=\\lambda_1\\alpha_1+\\lambda_2\\alpha_2+\\dots+\\lambda_n\\alpha_nβ=λ1​α1​+λ2​α2​+⋯+λn​αn​，则称向量β\\betaβ能由向量组AAA线性表示，或称向量组AAA能线性表示向量β\\betaβ，而λ1,λ2,…,λn\\lambda_1,\\lambda_2,\\dots,\\lambda_nλ1​,λ2​,…,λn​称为向量β\\betaβ在向量组AAA下的线性表示系数，通常写成β=[α1,α2,…,αn][λ1λ2⋮λn]\\beta=\\begin{bmatrix}\\alpha_1,\\alpha_2,\\dots,\\alpha_n\\end{bmatrix}\\begin{bmatrix}\\lambda_1\\\\\\lambda_2\\\\\\vdots\\\\\\lambda_n\\end{bmatrix}β=[α1​,α2​,…,αn​​]⎣⎢⎢⎢⎢⎡​λ1​λ2​⋮λn​​⎦⎥⎥⎥⎥⎤​\n\n\n注意\n\n任一n元向量α=(α1,α2,…,αn)T\\alpha=(\\alpha_1,\\alpha_2,\\dots,\\alpha_n)^Tα=(α1​,α2​,…,αn​)T都可由n元单位向量组EnE_nEn​线性表示，即α=[En][α1α2⋮αn]\\alpha=\\begin{bmatrix}E_n\\end{bmatrix}\\begin{bmatrix}\\alpha_1\\\\\\alpha_2\\\\\\vdots\\\\\\alpha_n\\end{bmatrix}α=[En​​]⎣⎢⎢⎢⎢⎡​α1​α2​⋮αn​​⎦⎥⎥⎥⎥⎤​\n\n\n\n定理4.1 向量β\\betaβ可由向量组A:α1,α2,…,αnA:\\alpha_1,\\alpha_2,\\dots,\\alpha_nA:α1​,α2​,…,αn​线性表示\n\n按定义：存在数λ1,λ2,…,λn\\lambda_1,\\lambda_2,\\dots,\\lambda_nλ1​,λ2​,…,λn​使得β=λ1α1+λ2α2+⋯+λnαn\\beta=\\lambda_1\\alpha_1+\\lambda_2\\alpha_2+\\dots+\\lambda_n\\alpha_nβ=λ1​α1​+λ2​α2​+⋯+λn​αn​\n转换为方程组：方程组AX=βAX=\\betaAX=β有解\n用矩阵的秩：r(A)=r(A∣β)r(A)=r(A|\\beta)r(A)=r(A∣β)\n\n\n\n 向量组的等价\n\n\n定义：如果向量组A:α1,α2,…,αnA:\\alpha_1,\\alpha_2,\\dots,\\alpha_nA:α1​,α2​,…,αn​能线性表示向量组B:β1,β2,…,βmB:\\beta_1,\\beta_2,\\dots,\\beta_mB:β1​,β2​,…,βm​，且向量组BBB能线性表示向量组AAA，则称向量组AAA与向量组BBB等价，记作A≅BA\\cong BA≅B\n\n\n定理的4.2 如果向量组B:β1,β2,…,βqB:\\beta_1,\\beta_2,\\dots,\\beta_qB:β1​,β2​,…,βq​中的每个向量都可由向量组A:α1,α2,…,αpA:\\alpha_1,\\alpha_2,\\dots,\\alpha_pA:α1​,α2​,…,αp​线性表示，AX=BAX=BAX=B有解，B的列向量组能由A的列向量组线性表示，C的行向量组也能由B的行向量组线性表示\n\n\n定理 4.3 设矩阵A经过有限次初等行（列）变换为B，则A，B行（列）向量组等价。\n\n\n 4.2 向量组的线性相关性\n 一个n元向量组的线性相关性\n\n\n定义1：如果存在不全为零的数k1,k2,…,knk_1,k_2,\\dots,k_nk1​,k2​,…,kn​使得k1α1+k2α2+⋯+knαn=0k_1\\alpha_1+k_2\\alpha_2+\\dots+k_n\\alpha_n=0k1​α1​+k2​α2​+⋯+kn​αn​=0，则称向量组A:α1,α2,…,αnA:\\alpha_1,\\alpha_2,\\dots,\\alpha_nA:α1​,α2​,…,αn​线性相关，否则如果设k1α1+k2α2+⋯+knαn=0k_1\\alpha_1+k_2\\alpha_2+\\dots+k_n\\alpha_n=0k1​α1​+k2​α2​+⋯+kn​αn​=0，则必有k1=k2=⋯=kn=0k_1=k_2=\\dots=k_n=0k1​=k2​=⋯=kn​=0，则称向量组A:α1,α2,…,αnA:\\alpha_1,\\alpha_2,\\dots,\\alpha_nA:α1​,α2​,…,αn​线性无关\n\n\n等价定义：当n≥2n \\geq 2n≥2时，向量组A:α1,α2,…,αnA:\\alpha_1,\\alpha_2,\\dots,\\alpha_nA:α1​,α2​,…,αn​线性相关的充要条件是向量组AAA中至少有一个向量可由其余向量线性表示；向量组A:α1,α2,…,αnA:\\alpha_1,\\alpha_2,\\dots,\\alpha_nA:α1​,α2​,…,αn​线性无关的充要条件是向量组AAA中的任一向量都不能由其余向量线性表示\n\n\n结论1：n元向量组e1,e2,…,ene_1,e_2,\\dots,e_ne1​,e2​,…,en​线性无关。\n\n\n结论2：α,β\\alpha,\\betaα,β（非零）线性相关⇔\\Leftrightarrow⇔对应分量成比例。\n\n\n结论3：单个零向量线性相关,单个非零向量线性无关；包含零向量的任何向量组线性相关\n\n\n 线性相关与齐次线性方程组之间的关系\n\n\n定理4.4 向量组A:α1,α2,…,αnA:\\alpha_1,\\alpha_2,\\dots,\\alpha_nA:α1​,α2​,…,αn​线性相关（无关）的充要条件是齐次线性方程组AX=0AX=0AX=0有非零解（只有零解）\n\n\n定理4.5 设A是n阶方阵，则下列命题等价：\n\nA可逆\nAAA的列向量组线性无关\nAAA的行向量组线性无关\nAX=0AX=0AX=0只有零解\nr(A)=nr(A)=nr(A)=n\n∣A∣≠0|A|\\neq 0∣A∣=0\n\n\n\n推论\n\n向量个数m大于维数n必相关\n部分相关，则整体相关\n整体无关，则部分无关\n短的无关，则长的也无关\n长的相关，则短的也相关\n\n\n\n定理4.6 设向量组α1,α2,…,αm\\alpha_1,\\alpha_2,\\dots,\\alpha_mα1​,α2​,…,αm​线性无关，且α1,α2,…,αm,β\\alpha_1,\\alpha_2,\\dots,\\alpha_m,\\betaα1​,α2​,…,αm​,β线性相关，则β\\betaβ可由α1,α2,…,αm\\alpha_1,\\alpha_2,\\dots,\\alpha_mα1​,α2​,…,αm​线性表示，且表示法唯一\n\n\n 4.3 向量组的秩\n\n\n定义：向量组A:α1,α2,…,αmA:\\alpha_1,\\alpha_2,\\dots,\\alpha_mA:α1​,α2​,…,αm​的秩是向量组AAA中的极大无关向量组中向量的个数，记作r(A)r(A)r(A)\n\n\n定理4.7 向量组A:α1,α2,…,αmA:\\alpha_1,\\alpha_2,\\dots,\\alpha_mA:α1​,α2​,…,αm​线性无关的充要条件是r(A)=mr(A)=mr(A)=m，线性相关的充要条件是r(A)&lt;mr(A)&lt;mr(A)&lt;m\n\n\n定理4.8 设A=[α1,α2,…,αm]→rB=[β1,β2,…,βm]A=[\\alpha_1,\\alpha_2,\\dots,\\alpha_m]\\stackrel{r}{\\rightarrow}B=[\\beta_1,\\beta_2,\\dots,\\beta_m]A=[α1​,α2​,…,αm​]→rB=[β1​,β2​,…,βm​]即A与B行等价，则A的列向量组与B的列向量组有相同的线性关系，即方程组AX=0AX=0AX=0与BX=0BX=0BX=0同解，即r(A)=r(B)r(A)=r(B)r(A)=r(B)\n\n\n定理4.9 设向量组A:α1,α2,…,αqA:\\alpha_1,\\alpha_2,\\dots,\\alpha_qA:α1​,α2​,…,αq​可以由向量组B:β1,β2,…,βpB:\\beta_1,\\beta_2,\\dots,\\beta_pB:β1​,β2​,…,βp​线性表示，如果q&gt;pq&gt;pq&gt;p，则向量组AAA线性相关；如果AAA线性无关，那么q≤pq\\leq pq≤p\n\n推论4.3 等价的线性无关向量组所含的向量个数相同\n推论4.4 一个向量组的任意两个极大无关组所含向量个数相等\n推论4.5 设向量组V的秩rankV=r, 则V中任意r个线性无关的向量都是V的极大无关组\n推论4.6 设向量组的秩rankV=r, 则其中任意向量个数大于r的向量组都线性相关\n推论4.7 设向量组A:α1,α2,…,αqA:\\alpha_1,\\alpha_2,\\dots,\\alpha_qA:α1​,α2​,…,αq​可由B:β1,β2,…,βpB:\\beta_1,\\beta_2,\\dots,\\beta_pB:β1​,β2​,…,βp​线性表示，则r(A)≤r(B)r(A)\\leq r(B)r(A)≤r(B)\n推论4.8 等价的向量组有相同的秩\n\n\n\n定义4.6 （极大无关组的等价定义）设V是一个向量组，若向量组α1,α2,…,αr\\alpha_1,\\alpha_2,\\dots,\\alpha_rα1​,α2​,…,αr​是向量组V的一个极大无关组，则：\n\nV中有r个向量线性无关\nV中任意r+1个向量线性相关\n\n\n\n 4.4 矩阵的秩\n\n\n定理4.11 设A是n阶方阵，则下列命题等价：\n\nA可逆\nAAA的列向量组线性无关\nAAA的行向量组线性无关\nAX=0AX=0AX=0只有零解\nr(A)=nr(A)=nr(A)=n\n∣A∣≠0|A|\\neq 0∣A∣=0\n设Am×nA^{m\\times n}Am×n，则Ax=0只有零解的充要条件是A是列满秩矩阵，即r(A)=nr(A)=nr(A)=n\n\n\n\n定理4.12 r(AB)≤min(r(A),r(B))r(AB)\\leq min(r(A),r(B))r(AB)≤min(r(A),r(B))；r(A)≤r([A∣b])≤r(A)+1r(A)\\leq r([A|b])\\leq r(A)+1r(A)≤r([A∣b])≤r(A)+1\n\n\n定理4.13 矩阵A的秩r(A)=rr(A)=rr(A)=r的充要条件是A的一个r阶子式不为零，而所有的r+1阶子式都为零；当A所有的r+1阶子式都为零时，由行列式展开定理，A的所p(p&gt;p+1)p(p&gt;p+1)p(p&gt;p+1)阶子式都为零\n\n\n定义4.8(矩阵秩的等价定义) 称矩阵A的非零子式的最高阶数为矩阵A的秩\n\n\n秩的重要性质\n\n0≤r(Am×n)≤min{m,n}0 \\leq r(A^{m\\times n}) \\leq min\\{m,n\\}0≤r(Am×n)≤min{m,n}\nr(AT)=r(A)r(A^T)=r(A)r(AT)=r(A)\nr(PAQ)=r(A)=r(PA)=r(AQ)r(PAQ)=r(A)=r(PA)=r(AQ)r(PAQ)=r(A)=r(PA)=r(AQ)（P,Q可逆）\nmax{r(A),r(B)}≤r[AB]≤r(A)+r(B)max\\{r(A),r(B)\\}\\leq r\\begin{bmatrix}A\\\\B\\end{bmatrix}\\leq r(A)+r(B)max{r(A),r(B)}≤r[AB​]≤r(A)+r(B)\nmax{r(A),r(B)}≤r[A∣B]≤r(A)+r(B)max\\{r(A),r(B)\\}\\leq r\\begin{bmatrix}A|B\\end{bmatrix}\\leq r(A)+r(B)max{r(A),r(B)}≤r[A∣B​]≤r(A)+r(B)\nr(A)≤r([A∣b])≤r(A)+1r(A)\\leq r([A|b])\\leq r(A)+1r(A)≤r([A∣b])≤r(A)+1（b为列向量）\nr(AB)≤min{r(A),r(B)}r(AB)\\leq min\\{r(A),r(B)\\}r(AB)≤min{r(A),r(B)}\nr(A+B)≤r(A)+r(B)r(A+B)\\leq r(A)+r(B)r(A+B)≤r(A)+r(B)\nSylvester不等式：r(A)+r(B)−n≤r(AB)r(A)+r(B)-n\\leq r(AB)r(A)+r(B)−n≤r(AB)\nr(A∗)={nr(A)=n1r(A)=n−10r(A)&lt;n−1r(A^*)=\\begin{cases}n &amp;r(A)=n\\\\1&amp;r(A)=n-1\\\\0&amp;r(A)&lt;n-1\\end{cases}r(A∗)=⎩⎪⎪⎨⎪⎪⎧​n10​r(A)=nr(A)=n−1r(A)&lt;n−1​\n\n\n\n 4.5 向量空间\n 向量空间及其子空间\n\n\n定义 设V为n维向量的集合，如果集合V非空，且集合V对于向量的加法和数乘运算封闭，则称V为向量空间\n\nn维向量的全体是一个向量空间，记作RnR^nRn\n0维向量的全体是一个向量空间，记作{0}\\{0\\}{0}\n向量空间如果不是零空间必含有无穷多个向量\n\n\n\n定义 设有向量空间V1,V2V_1,V_2V1​,V2​，若V1⊂V2V_1\\subset V_2V1​⊂V2​，则称V1V_1V1​是V2V_2V2​的子空间,V总是RnR^nRn的子空间\n\n\n定义 设α1,α2,…,αm\\alpha_1,\\alpha_2,\\dots,\\alpha_mα1​,α2​,…,αm​是一向量组，称{x∣x=λ1α1+λ2α2+⋯+λmαm,λi∈R}\\{x|x=\\lambda_1\\alpha_1+\\lambda_2\\alpha_2+\\dots+\\lambda_m\\alpha_m,\\lambda_i \\in R\\}{x∣x=λ1​α1​+λ2​α2​+⋯+λm​αm​,λi​∈R}为该向量组张成的子空间，记作span(α1,α2,…,αm)span(\\alpha_1,\\alpha_2,\\dots,\\alpha_m)span(α1​,α2​,…,αm​)或L{α1,α2,…,αm}L\\{\\alpha_1,\\alpha_2,\\dots,\\alpha_m\\}L{α1​,α2​,…,αm​}；特别地，由矩阵A的列向量生成的向量空间称为A的列空间（或称像空间或称值域），记作R(A)R(A)R(A)\n\n\n 基底、维数、坐标\n\n\n定义 向量空间V≠{0}V≠\\{0\\}V={0}的一个最大无关组，又称V的一个基（或坐标系），V的基中向量的个数称为V的维数，记作dim(V)dim(V)dim(V)，零空间的维数为0\n\n\n定理4.14 （基的扩张定理）设α1,…,αm\\alpha_1,\\dots,\\alpha_mα1​,…,αm​是RnR^nRn的一组线性无关组，m&lt;nm&lt;nm&lt;n，则存在n-m个向量αm+1,…,αn\\alpha_{m+1},\\dots,\\alpha_nαm+1​,…,αn​，使得α1,…,αm,αm+1,…,αn\\alpha_1,\\dots,\\alpha_m,\\alpha_{m+1},\\dots,\\alpha_nα1​,…,αm​,αm+1​,…,αn​是RnR^nRn的一组基\n\n\n定义 设向量空间V的一个基为α1,α2,…,αm\\alpha_1,\\alpha_2,\\dots,\\alpha_mα1​,α2​,…,αm​，则对V中任意向量α\\alphaα可唯一地表示为α=λ1α1+λ2α2+⋯+λmαm\\alpha=\\lambda_1\\alpha_1+\\lambda_2\\alpha_2+\\dots+\\lambda_m\\alpha_mα=λ1​α1​+λ2​α2​+⋯+λm​αm​，称λ1,λ2,…,λm\\lambda_1,\\lambda_2,\\dots,\\lambda_mλ1​,λ2​,…,λm​为α\\alphaα在基α1,α2,…,αm\\alpha_1,\\alpha_2,\\dots,\\alpha_mα1​,α2​,…,αm​下的坐标\n\n\n定义 设r维向量空间的两个基α1,α2,…,αr\\alpha_1,\\alpha_2,\\dots,\\alpha_rα1​,α2​,…,αr​和β1,β2,…,βr\\beta_1,\\beta_2,\\dots,\\beta_rβ1​,β2​,…,βr​，则β1,β2,…,βr\\beta_1,\\beta_2,\\dots,\\beta_rβ1​,β2​,…,βr​可由α1,α2,…,αr\\alpha_1,\\alpha_2,\\dots,\\alpha_rα1​,α2​,…,αr​线性表示[β1,β2,…,βr]=[α1,α2,…,αr]P[\\beta_1,\\beta_2,\\dots,\\beta_r]=[\\alpha_1,\\alpha_2,\\dots,\\alpha_r]P[β1​,β2​,…,βr​]=[α1​,α2​,…,αr​]P，称P为从基α1,α2,…,αr\\alpha_1,\\alpha_2,\\dots,\\alpha_rα1​,α2​,…,αr​到基β1,β2,…,βr\\beta_1,\\beta_2,\\dots,\\beta_rβ1​,β2​,…,βr​的过渡矩阵，显然P可逆\n\n\n 4.6 线性方程组解的结构\n 线性方程组解的存在性定理\n\n\n非齐次方程组解的存在性定理：对于非齐次方程组Am×nx=BA^{m\\times n}x=BAm×nx=B\n\n有解⇔r(A)=r(A∣B)⇔\\Leftrightarrow r(A)=r(A|B)\\Leftrightarrow⇔r(A)=r(A∣B)⇔向量β\\betaβ可由A的列向量组α1,α2,…,αn\\alpha_1,\\alpha_2,\\dots,\\alpha_nα1​,α2​,…,αn​线性表示\n有唯一解⇔r(A)=r(A∣B)=n\\Leftrightarrow r(A)=r(A|B)=n⇔r(A)=r(A∣B)=n\n有无穷多解⇔r(A)=r(A∣B)&lt;n\\Leftrightarrow r(A)=r(A|B)&lt;n⇔r(A)=r(A∣B)&lt;n\n\n\n\n对于齐次方程组Am×nx=0A^{m\\times n}x=0Am×nx=0\n\n有唯一零解⇔r(A)=n⇔\\Leftrightarrow r(A)=n\\Leftrightarrow⇔r(A)=n⇔A的列向量组线性无关\n有无穷多解⇔r(A)&lt;n⇔\\Leftrightarrow r(A)&lt;n\\Leftrightarrow⇔r(A)&lt;n⇔A的列向量组线性相关\n推论1 当方程的个数小于未知量的个数时，方程组必有非零解\n\n\n\n 齐次线性方程组解的结构\n\n\n性质：\n\n若xi1,xi2xi_1,xi_2xi1​,xi2​是齐次线性方程组AX=0AX=0AX=0的解，则xi1+xi2xi_1+xi_2xi1​+xi2​也是AX=0AX=0AX=0的解\n若xi1xi_1xi1​是齐次线性方程组AX=0AX=0AX=0的解，则kxi1kxi_1kxi1​也是AX=0AX=0AX=0的解\n齐次线性方程组AX=0AX=0AX=0的解集是一个向量空间，称为齐次线性方程组的解空间，在解空间中，基的概念我们在这里称为基础解系\n\n\n\n基础解系：设ξ1,ξ2,…,ξn−r\\xi_1,\\xi_2,\\dots,\\xi_{n-r}ξ1​,ξ2​,…,ξn−r​是AX=0AX=0AX=0的解满足：\n\nξ1,ξ2,…,ξn−r\\xi_1,\\xi_2,\\dots,\\xi_{n-r}ξ1​,ξ2​,…,ξn−r​线性无关\nAX=0AX=0AX=0的任一解可由ξ1,ξ2,…,ξn−r\\xi_1,\\xi_2,\\dots,\\xi_{n-r}ξ1​,ξ2​,…,ξn−r​线性表示，则称ξ1,ξ2,…,ξn−r\\xi_1,\\xi_2,\\dots,\\xi_{n-r}ξ1​,ξ2​,…,ξn−r​是AX=0AX=0AX=0的一个基础解系。从而x=k1ξ1+k2ξ2+⋯+ktξtx=k_1\\xi_1+k_2\\xi_2+\\dots+k_t\\xi_tx=k1​ξ1​+k2​ξ2​+⋯+kt​ξt​是也是AX=0AX=0AX=0的解\n\n\n\n定理 设A是m×nm\\times nm×n矩阵，如果r(A)=r&lt;nr(A)=r&lt;nr(A)=r&lt;n，则齐次线性方程组AX=0AX=0AX=0的基础解系存在，且每个基础解系含有n−rn-rn−r个解向量\n\n推论 设A是m×nm\\times nm×n矩阵，如果r(A)=r&lt;nr(A)=r&lt;nr(A)=r&lt;n，则齐次线性方程组AX=0AX=0AX=0的任意n−rn-rn−r个线性无关的解向量均可构成基础解系\n\n\n\n 非齐次线性方程组解的结构\n\n\n性质：\n\n设η1,η2\\eta_1,\\eta_2η1​,η2​都是非齐次线性方程组AX=BAX=BAX=B的解，则η1−η2\\eta_1-\\eta_2η1​−η2​是AX=0AX=0AX=0的解\n设η\\etaη是非齐次线性方程组AX=BAX=BAX=B的解，ξ\\xiξ是AX=0AX=0AX=0的解，则η+ξ\\eta+\\xiη+ξ仍是AX=BAX=BAX=B的解\n设η∗\\eta^*η∗是非齐次线性方程组AX=BAX=BAX=B的一个解（固定），则对于AX=BAX=BAX=B的任一解xxx，x−η∗x-\\eta^*x−η∗是AX=0AX=0AX=0的解，从而存在kik_iki​使得x−η∗=∑i=1n−rkiξix-\\eta^*=\\sum\\limits_{i=1}^{n-r}k_i\\xi_ix−η∗=i=1∑n−r​ki​ξi​，即x=η∗+∑i=1n−rkiξix=\\eta^*+\\sum\\limits_{i=1}^{n-r}k_i\\xi_ix=η∗+i=1∑n−r​ki​ξi​，从而xxx是AX=BAX=BAX=B的解的充要条件是x=η∗+∑i=1n−rkiξix=\\eta^*+\\sum\\limits_{i=1}^{n-r}k_i\\xi_ix=η∗+i=1∑n−r​ki​ξi​\n\n\n\n定理 设η∗\\eta^*η∗是非齐次线性方程组AX=BAX=BAX=B的任一个解，则AX=BAX=BAX=B的通解为x=k1ξ1+k2ξ2+⋯+ktξt+η∗x=k_1\\xi_1+k_2\\xi_2+\\dots+k_t\\xi_t+\\eta^*x=k1​ξ1​+k2​ξ2​+⋯+kt​ξt​+η∗，其中ξ1,ξ2,…,ξt\\xi_1,\\xi_2,\\dots,\\xi_tξ1​,ξ2​,…,ξt​是AX=0AX=0AX=0的基础解系，k1,k2,…,ktk_1,k_2,\\dots,k_tk1​,k2​,…,kt​为任意常数\n\n\n重要结论 设AB=0AB=0AB=0，则r(A)+r(B)≤nr(A)+r(B)\\leq nr(A)+r(B)≤n\n\n\n 5 特征值与特征向量\n 5.1 特征值与特征向量的概念与性质\n 特征值与特征向量的概念\n\n定义 设A∈Cn×nA\\in C^{n\\times n}A∈Cn×n，如果存在数λ\\lambdaλ和非零向量ξ\\xiξ，使得Aξ=λξ  (1)A\\xi=\\lambda\\xi \\ \\  (1)Aξ=λξ  (1)，则称λ\\lambdaλ是矩阵A的一个特征值，ξ\\xiξ是A的属于特征值λ\\lambdaλ的一个特征向量，把(1)改写为(A−λE)ξ=0(A-\\lambda E)\\xi=0(A−λE)ξ=0，则(A−λE)ξ=0(A-\\lambda E)\\xi=0(A−λE)ξ=0有非零解ξ\\xiξ的充要条件是∣A−λE∣=0|A-\\lambda E|=0∣A−λE∣=0，即∣A−λE∣=0|A-\\lambda E|=0∣A−λE∣=0的根称为矩阵A的特征值，∣A−λE∣=0|A-\\lambda E|=0∣A−λE∣=0的根称为矩阵A的特征值方程，∣A−λE∣|A-\\lambda E|∣A−λE∣称为矩阵A的特征多项式，由代数基本定理，n次代数方程在复数域内必有n个根，从而矩阵A必有n个特征值，包括重根在内\n\n 特征值与特征向量的性质\n\nAAA与ATA^TAT有相同的特征值\n设n阶矩阵A的特征值为λ1,λ2,…,λn\\lambda_1,\\lambda_2,\\dots,\\lambda_nλ1​,λ2​,…,λn​，φ(z)=c0+c1z+c2z2+⋯+cmzm\\varphi (z) = c_0+c_1z+c_2z^2+\\dots+c_mz^mφ(z)=c0​+c1​z+c2​z2+⋯+cm​zm是一个n次多项式，则φ(A)=c0E+c1A+c2A2+⋯+cmAm\\varphi (A) = c_0E+c_1A+c_2A^2+\\dots+c_mA^mφ(A)=c0​E+c1​A+c2​A2+⋯+cm​Am的特征值为φ(λ1),φ(λ2),…,φ(λn)\\varphi (\\lambda_1),\\varphi (\\lambda_2),\\dots,\\varphi (\\lambda_n)φ(λ1​),φ(λ2​),…,φ(λn​)且对应的特征值相同\n设n阶可逆矩阵A的n个特征值为λ1,λ2,…,λn\\lambda_1,\\lambda_2,\\dots,\\lambda_nλ1​,λ2​,…,λn​，则A−1A^{-1}A−1的n个特征值为λ1−1,λ2−1,…,λn−1\\lambda_1^{-1},\\lambda_2^{-1},\\dots,\\lambda_n^{-1}λ1−1​,λ2−1​,…,λn−1​且对应的特征向量相同\n设n阶可逆矩阵A=[aij]A=[a_{ij}]A=[aij​]的n个特征值为λ1,λ2,…,λn\\lambda_1,\\lambda_2,\\dots,\\lambda_nλ1​,λ2​,…,λn​，则\nλ1+λ2+⋯+λn=tr(A)=a11+a22+⋯+ann\\lambda_1+\\lambda_2+\\dots+\\lambda_n=tr(A)=a_{11}+a_{22}+\\dots+a_{nn}λ1​+λ2​+⋯+λn​=tr(A)=a11​+a22​+⋯+ann​\nλ1λ2…λn=∣A∣\\lambda_1\\lambda_2\\dots\\lambda_n=|A|λ1​λ2​…λn​=∣A∣\n\n 5.2 方阵的对角化\n 相似变换\n\n\n定义 设A，B是n阶方阵，如果存在可逆矩阵P，使得P−1AP=BP^{-1}AP=BP−1AP=B，则称A与B相似，记作A∼BA\\sim BA∼B，显然相似是一个等价关系；特别地，如果A与对角矩阵相似，则称A可对角化，对A进行的矩阵变换P−1APP^{-1}APP−1AP称为A的相似对角形\n\n\n相似变换的性质\n\n相似关系是一种等价关系（满足三条）\n设A∼BA\\sim BA∼B，则rank(A)=rank(B)rank(A)=rank(B)rank(A)=rank(B)\n设A∼BA\\sim BA∼B，则∣A∣=∣B∣|A|=|B|∣A∣=∣B∣\n设A∼BA\\sim BA∼B，则tr(A)=tr(B)tr(A)=tr(B)tr(A)=tr(B)\n设A∼BA\\sim BA∼B，则∣λE−A∣=∣λE−B∣|\\lambda E-A|=|\\lambda E-B|∣λE−A∣=∣λE−B∣\n设A∼BA\\sim BA∼B，则A与B有相同的特征值\n设A∼BA\\sim BA∼B，则φ(A)∼φ(B)\\varphi (A)\\sim \\varphi (B)φ(A)∼φ(B)，其中φ(z)=c0+c1z+c2z2+⋯+cmzm\\varphi (z) = c_0+c_1z+c_2z^2+\\dots+c_mz^mφ(z)=c0​+c1​z+c2​z2+⋯+cm​zm是一个m次多项式\n设A∼BA\\sim BA∼B，且A可逆，则A−1∼B−1A^{-1}\\sim B^{-1}A−1∼B−1\n\n\n\n 矩阵可对角化的条件\n\n\n定理1 n阶矩阵A可对角化的充要条件是A有n个线性无关的特征向量\n\n\n定理2 不同特征值对应的线性无关的特征向量合并后仍是线性无关的\n\n推论（可对角化的充分条件） n阶矩阵A如有n个不同的特征值，则它有n个线性无关的特征向量，从而A可对角化.\n\n\n\n设n阶矩阵A的所有不同的特征值为λ1,λ2,…,λt\\lambda_1,\\lambda_2,\\dots,\\lambda_tλ1​,λ2​,…,λt​，则A的特征多项式可写成fA(λ)=∣λE−A∣=(λ−λ1)r1(λ−λ2)r2…(λ−λt)rtf_A(\\lambda)=|\\lambda E-A|=(\\lambda-\\lambda_1)^{r_1}(\\lambda-\\lambda_2)^{r_2}\\dots(\\lambda-\\lambda_t)^{r_t}fA​(λ)=∣λE−A∣=(λ−λ1​)r1​(λ−λ2​)r2​…(λ−λt​)rt​，其中rir_iri​为λi\\lambda_iλi​的代数重数，r1+r2+⋯+rt=nr_1+r_2+\\dots+r_t=nr1​+r2​+⋯+rt​=n，则A的属于λi\\lambda_iλi​的特征向量的个数至少为rir_iri​，也称λi\\lambda_iλi​是A的rir_iri​重特征值；特征值λi\\lambda_iλi​对应的线性无关的特征向量的最大个数为si=n−rank(λiE−A)s_i=n-rank(\\lambda_i E-A)si​=n−rank(λi​E−A)，称sis_isi​为λi\\lambda_iλi​的几何重数\n\n\n定理3 矩阵A的任一特征值λi\\lambda_iλi​的几何重数sis_isi​都不大于其代数重数rir_iri​，即1≤si≤ri1\\leq s_i\\leq r_i1≤si​≤ri​\n\n\n定理4 矩阵A可对角化的充要条件是A的每个不同特征值的代数重数与几何重数相等\n\n\n 6 实对称矩阵与实二次型\n 6.1 欧式空间\n\n\n定义6.1 （内积的定义） 设有n维向量α=(α1,α2,…,αn)T\\alpha=(\\alpha_1,\\alpha_2,\\dots,\\alpha_n)^Tα=(α1​,α2​,…,αn​)T，β=(β1,β2,…,βn)T\\beta=(\\beta_1,\\beta_2,\\dots,\\beta_n)^Tβ=(β1​,β2​,…,βn​)T，定义α\\alphaα与β\\betaβ的内积为[α,β]=α1β1+α2β2+⋯+αnβn[\\alpha,\\beta]=\\alpha_1\\beta_1+\\alpha_2\\beta_2+\\dots+\\alpha_n\\beta_n[α,β]=α1​β1​+α2​β2​+⋯+αn​βn​，称为欧式空间RnR^nRn的内积，其中αi,βi\\alpha_i,\\beta_iαi​,βi​为实数，定义了内积的实向量空间称为Euclid空间\n\n\n性质6.1 （内积的性质）\n\n[α,β]=[β,α][\\alpha,\\beta]=[\\beta,\\alpha][α,β]=[β,α]\n[kα,β]=k[α,β][k\\alpha,\\beta]=k[\\alpha,\\beta][kα,β]=k[α,β]\n[α+β,γ]=[α,γ]+[β,γ][\\alpha+\\beta,\\gamma]=[\\alpha,\\gamma]+[\\beta,\\gamma][α+β,γ]=[α,γ]+[β,γ]\n[α,α]≥0[\\alpha,\\alpha]\\geq 0[α,α]≥0，且[α,α]=0[\\alpha,\\alpha]=0[α,α]=0的充要条件是α=0\\alpha=0α=0\n\n\n\n定义6.2 （向量的长度） ∣∣α∣∣=[α,α]=α12+α22+⋯+αn2||\\alpha||=\\sqrt{[\\alpha,\\alpha]}=\\sqrt{\\alpha_1^2+\\alpha_2^2+\\dots+\\alpha_n^2}∣∣α∣∣=[α,α]​=α12​+α22​+⋯+αn2​​，称∣∣α∣∣||\\alpha||∣∣α∣∣为向量α\\alphaα的长度\n\n\n定理6.1 （Cauchy-Schwarz不等式） [α,β]2≤[α,α][β,β][\\alpha,\\beta]^2\\leq [\\alpha,\\alpha][\\beta,\\beta][α,β]2≤[α,α][β,β]，当且仅当α\\alphaα与β\\betaβ线性相关时取等号\n\n\n性质6.2 （向量长度的性质）\n\n非负性：∣∣α∣∣≥0||\\alpha||\\geq 0∣∣α∣∣≥0，且∣∣α∣∣=0||\\alpha||=0∣∣α∣∣=0的充要条件是α=0\\alpha=0α=0\n齐次性：∣∣kα∣∣=∣k∣⋅∣∣α∣∣||k\\alpha||=|k|\\cdot||\\alpha||∣∣kα∣∣=∣k∣⋅∣∣α∣∣\n三角不等式：∣∣α+β∣∣≤∣∣α∣∣+∣∣β∣∣||\\alpha+\\beta||\\leq ||\\alpha||+||\\beta||∣∣α+β∣∣≤∣∣α∣∣+∣∣β∣∣\n\n\n\n定义6.3 （单位向量） 如果∣∣α∣∣=1||\\alpha||=1∣∣α∣∣=1，则称α\\alphaα为n维单位向量，向量β=1∣∣α∣∣α\\beta=\\frac{1}{||\\alpha||}\\alphaβ=∣∣α∣∣1​α称为向量α\\alphaα的单位化向量\n\n\n定义6.4 （向量的夹角） 设α,β\\alpha,\\betaα,β是n维非零向量，定义α\\alphaα与β\\betaβ的夹角为0≤θ≤π0\\leq \\theta \\leq \\pi0≤θ≤π，使得cosθ=[α,β]∣∣α∣∣⋅∣∣β∣∣cos\\theta=\\frac{[\\alpha,\\beta]}{||\\alpha||\\cdot||\\beta||}cosθ=∣∣α∣∣⋅∣∣β∣∣[α,β]​，其中θ\\thetaθ称为向量α\\alphaα与β\\betaβ的夹角\n\n\n定义6.5 （向量的正交） 如果[α,β]=0[\\alpha,\\beta]=0[α,β]=0，则称向量α\\alphaα与β\\betaβ正交，记作α⊥β\\alpha\\perp\\betaα⊥β\n\n\n定义6.6 （规范正交基） 若一个不含零向量的向量组α1,α2,…,αr\\alpha_1,\\alpha_2,\\dots,\\alpha_rα1​,α2​,…,αr​中的向量两两正交[αi,αj]=0(i≠j)[\\alpha_i,\\alpha_j]=0(i\\neq j)[αi​,αj​]=0(i=j)，则称该向量组为正交向量组，若每个向量的长度为1，即∣∣αi∣∣=1(i=1,2,…,r)||\\alpha_i||=1(i=1,2,\\dots,r)∣∣αi​∣∣=1(i=1,2,…,r)，则称α1,α2,…,αr\\alpha_1,\\alpha_2,\\dots,\\alpha_rα1​,α2​,…,αr​为规范正交基；若该向量组是一个向量空间V的基，又分别称为V的正交基和规范正交基。例如，e1=(1,0,…,0)T,e2=(0,1,…,0)T,…,en=(0,0,…,1)Te_1=(1,0,\\dots,0)^T,e_2=(0,1,\\dots,0)^T,\\dots,e_n=(0,0,\\dots,1)^Te1​=(1,0,…,0)T,e2​=(0,1,…,0)T,…,en​=(0,0,…,1)T是RnR^nRn的一个规范正交基，再如，e1=(1,0,0)T,e2=(0,1,0)Te_1=(1,0,0)^T ,e_2=(0,1,0)^Te1​=(1,0,0)T,e2​=(0,1,0)T是V=x∈R3∣x=(x1,x2,0)T=span(e1,e2)V={x \\in R^3|x=(x_1,x_2,0)^T}=span(e_1,e_2)V=x∈R3∣x=(x1​,x2​,0)T=span(e1​,e2​)的一个规范正交基\n\n\n定理6.2 正交向量组必线性无关\n\n\n定义6.7 （施密特正交化过程） 设α1,α2,…,αn\\alpha_1,\\alpha_2,\\dots,\\alpha_nα1​,α2​,…,αn​是RnR^nRn中的一组线性无关向量，令β1=α1\\beta_1=\\alpha_1β1​=α1​，对于i=2,3,…,ni=2,3,\\dots,ni=2,3,…,n，令βi=αi−[αi,β1][β1,β1]β1−[αi,β2][β2,β2]β2−⋯−[αi,βi−1][βi−1,βi−1]βi−1\\beta_i=\\alpha_i-\\frac{[\\alpha_i,\\beta_1]}{[\\beta_1,\\beta_1]}\\beta_1-\\frac{[\\alpha_i,\\beta_2]}{[\\beta_2,\\beta_2]}\\beta_2-\\dots-\\frac{[\\alpha_i,\\beta_{i-1}]}{[\\beta_{i-1},\\beta_{i-1}]}\\beta_{i-1}βi​=αi​−[β1​,β1​][αi​,β1​]​β1​−[β2​,β2​][αi​,β2​]​β2​−⋯−[βi−1​,βi−1​][αi​,βi−1​]​βi−1​，则β1,β2,…,βn\\beta_1,\\beta_2,\\dots,\\beta_nβ1​,β2​,…,βn​是RnR^nRn的一组规范正交基，称为施密特正交化过程\n\n\n定义6.8 （正交矩阵） 若n阶方阵满足ATA=EA^TA=EATA=E，则称A为正交矩阵，等价定义：A是正交矩阵⇔AAT=E⇔A−1=AT⇔\\Leftrightarrow AA^T=E \\Leftrightarrow A^{-1}=A^T\\Leftrightarrow⇔AAT=E⇔A−1=AT⇔A的列组是规范正交组⇔\\Leftrightarrow⇔A的行组是规范正交组\n\n\n性质6.4\n\nA是正交矩阵，则A−1A^{-1}A−1和A*都是正交矩阵\nA，B都是正交矩阵，则AB也是正交矩阵\nA是正交矩阵，则∣A∣=1|A|=1∣A∣=1或−1-1−1\nP是正交矩阵，则∣∣Px∣∣=∣∣x∣∣||Px||=||x||∣∣Px∣∣=∣∣x∣∣，即正交矩阵不改变向量的长度\n\n\n\n 6.2 实对称矩阵对角化\n\n\n定理6.3 实对称矩阵的特征值必为实数\n\n\n定理6.4 对称矩阵不同特征值对应的特征向量必正交\n\n\n定理6.5 设A是一个n阶实对称矩阵，则必存在一个n阶正交矩阵Q，使得Q−1AQ=diag(λ1,λ2,…,λn)Q^{-1}AQ=diag(\\lambda_1,\\lambda_2,\\dots,\\lambda_n)Q−1AQ=diag(λ1​,λ2​,…,λn​)是一个对角矩阵，即实对称矩阵必可对角化\n\n\n推论6.6 对称矩阵特征值的重数必等于其几何重数，即等于其对应的最大无关特征向量的个数，即ni=n−r(λiE−A)⇔r(λiE−A)=n−nin_i=n-r(\\lambda_i E-A)\\Leftrightarrow r(\\lambda_i E-A)=n-n_ini​=n−r(λi​E−A)⇔r(λi​E−A)=n−ni​\n\n\n 6.3 二次型及其矩阵表示\n\n\n定义1 含有n个变量x1,x2,…,xnx_1,x_2,\\dots,x_nx1​,x2​,…,xn​的二次齐次多项式f(x1,x2,…,xn)=∑i=1n∑j=1naijxixjf(x_1,x_2,\\dots,x_n)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^na_{ij}x_ix_jf(x1​,x2​,…,xn​)=i=1∑n​j=1∑n​aij​xi​xj​称为二次型\n\n\n定义2 （二次型的矩阵表示） f=XTAXf=X^TAXf=XTAX，其中A为对称矩阵，也把二次型f称为对称矩阵A的二次型，对称矩阵A的秩称为二次型f的秩\n\n\n定义 只含平方项的二次型f=k1x12+k2x22+⋯+knxn2=(x1,…,xn)diag(k1,…,kn)(x1,…,xn)Tf=k_1x_1^2+k_2x_2^2+\\dots+k_nx_n^2=(x_1,\\dots,x_n)diag(k_1,\\dots,k_n)(x_1,\\dots,x_n)^Tf=k1​x12​+k2​x22​+⋯+kn​xn2​=(x1​,…,xn​)diag(k1​,…,kn​)(x1​,…,xn​)T称为标准型二次型（法式）\n\n\n 6.4 化二次型为标准型\n 非退化线性变换（可逆线性变换）\n\n\n定义 设X=(x1,x2,…,xn)TX=(x_1,x_2,\\dots,x_n)^TX=(x1​,x2​,…,xn​)T，Y=(y1,y2,…,yn)TY=(y_1,y_2,\\dots,y_n)^TY=(y1​,y2​,…,yn​)T，如果Y=CXY=CXY=CX，其中C是可逆矩阵，则称Y=CXY=CXY=CX为X=YX=YX=Y的可逆线性变换，当C为正交矩阵时，称Y=CXY=CXY=CX为X=YX=YX=Y的正交变换\n\n\n矩阵的合同 设A，B是n阶矩阵，如果存在可逆矩阵C，使得CTAC=BC^TAC=BCTAC=B，则称A与B合同，记作A≃BA\\simeq BA≃B，显然合同是一个等价关系\n\n\n定理 设A为对称矩阵，且A与B合同，则\n\nB=CTACB=C^TACB=CTAC仍为对称矩阵\nr(A)=r(B)r(A)=r(B)r(A)=r(B)\n\n\n\n矩阵合同的性质\n\n反身性：A≃AA\\simeq AA≃A\n对称性：A≃B⇔B≃AA\\simeq B \\Leftrightarrow B\\simeq AA≃B⇔B≃A\n传递性：A≃B,B≃C⇒A≃CA\\simeq B,B\\simeq C \\Rightarrow A\\simeq CA≃B,B≃C⇒A≃C\n\n\n\n 化二次型为标准形\n 正交变换法\n\n\n主轴定理 任给二次型f=∑i=1n∑j=1naijxixj(aij=aji)f=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^na_{ij}x_ix_j(a_{ij}=a_{ji})f=i=1∑n​j=1∑n​aij​xi​xj​(aij​=aji​)，总有正交变换X=PYX=PYX=PY，使得f=λ1y12+λ2y22+⋯+λnyn2f=\\lambda_1y_1^2+\\lambda_2y_2^2+\\dots+\\lambda_ny_n^2f=λ1​y12​+λ2​y22​+⋯+λn​yn2​，其中λ1,λ2,…,λn\\lambda_1,\\lambda_2,\\dots,\\lambda_nλ1​,λ2​,…,λn​是f的矩阵A的特征值\n\n\n注 正交变换化为标准形的优点：在几何中，可以保持曲线（曲面）的几何形状不变\n\n\n 6.5 正定二次型与正定矩阵\n 惯性定理\n\n\n定理 二次型必可化为规范形\n\n\n惯性定理 任何实二次型总可以经过一个适当的可逆线性变换化成规范形,规范形是唯一的。f=Z12+Z22+⋯+Zp2−Zp+12−⋯−Zr2f=Z_1^2+Z_2^2+\\dots+Z_p^2-Z_{p+1}^2-\\dots-Z_r^2f=Z12​+Z22​+⋯+Zp2​−Zp+12​−⋯−Zr2​，其中ppp是f的正惯性指数，rrr是f的秩，r−pr-pr−p为f的负惯性指数\n\n\n 正定二次型\n\n\n定义 设f(x1,x2,…,xn)=XTAXf(x_1,x_2,\\dots,x_n)=X^TAXf(x1​,x2​,…,xn​)=XTAX是实二次型（A为实对称矩阵），如果对于任意非零向量X=(x1,x2,…,xn)T∈RnX=(x_1,x_2,\\dots,x_n)^T\\in R^nX=(x1​,x2​,…,xn​)T∈Rn，恒有f(X)=XTAX&gt;0f(X)=X^TAX&gt;0f(X)=XTAX&gt;0，则称f为正定（半正定）二次型，称正定(半正定)二次型f的矩阵A为正定(半正定)矩阵。即二次型f(X)=XTAXf(X)=X^TAXf(X)=XTAX是正定二次型⇔\\Leftrightarrow⇔二次型的对称矩阵A是正定矩阵\n\n\n定理2 实二次型f=XTAXf=X^TAXf=XTAX是正定二次型⇔\\Leftrightarrow⇔标准形中n个系数全为正数\n\n\n推论 实对称矩阵A正定⇔\\Leftrightarrow⇔A的n个特征值全为正数⇔\\Leftrightarrow⇔存在可逆矩阵P，使得A=PTPA=P^TPA=PTP\n\n\n定理3 A正定⇔\\Leftrightarrow⇔A的任一顺序主子式大于0，即∣a11∣&gt;0,∣a11a12a21a22∣&gt;0,…,∣A∣&gt;0|a_{11}|&gt;0,\\begin{vmatrix}a_{11}&amp;a_{12}\\\\a_{21}&amp;a_{22}\\end{vmatrix}&gt;0,\\dots,|A|&gt;0∣a11​∣&gt;0,∣∣∣∣∣​a11​a21​​a12​a22​​∣∣∣∣∣​&gt;0,…,∣A∣&gt;0；A负定⇔\\Leftrightarrow⇔奇数阶顺序主子式为负，偶数阶顺序主子式为正，即(−1)r∣a11a12…a1ra21a22…a2r…………ar1ar2…arr∣&gt;0(r=1,2,…,n)(-1)^r\\begin{vmatrix}a_{11}&amp;a_{12}&amp;\\dots&amp;a_{1r}\\\\a_{21}&amp;a_{22}&amp;\\dots&amp;a_{2r}\\\\\\dots&amp;\\dots&amp;\\dots&amp;\\dots\\\\a_{r1}&amp;a_{r2}&amp;\\dots&amp;a_{rr}\\end{vmatrix}&gt;0(r=1,2,\\dots,n)(−1)r∣∣∣∣∣∣∣∣∣​a11​a21​…ar1​​a12​a22​…ar2​​…………​a1r​a2r​…arr​​∣∣∣∣∣∣∣∣∣​&gt;0(r=1,2,…,n)\n\n\n","slug":"linear-algebra","date":"2023-09-21T06:59:02.000Z","categories_index":"Math","tags_index":"learning,Math,Linear Algebra","author_index":"Ivan Snow"},{"id":"5e4b5390912265514d91e2e7f8d2f652","title":"Django公有配置","content":"\n\n\n\n\n\n\n\n\n摸了好久（\n BASE_DIR\n\n用于绑定当前项目的绝对路径（动态计算出来的），所有文件夹都可以依赖此路径\n\n DEBUG\n\n用于配置Django项目的启动模式，取值\n\nTrue 表示开发环境中使用开发调试模式（用于开发中）\nFalse 表示当前项目运行在生产环境中\n\n\n\n ALLOWED HOSTS\n\n设置允许访问到本项目的host头值\n\n[] 空列表，表示只有请求头中host为 127.0.0.1、localhost能访问本项目\tDEBUG = True 时有效\n['*'] 表示任何请求头的host都能访问到当前项目\n['192.168.32.1'，'127.0.0.1'] 表示只有当前两个host头的值能访问当前项目\n\n\n\n INSTALLED_APPS\n\n指定当前项目中安装的应用列表\n\n MIDDLEWARE\n\n用于注册中间件\n\n TEMPLATES\n\n用于指定模板的配置信息\n\n DATABASES\n\n用于指定数据库的配置信息\n\n LANGUAGE_CODE\n\n用于指定语言配置\n\n英文：“en-us”\n中文：“zh-Hans”\n\n\n\n TIME_ZONE\n\n用于指定当前服务器端时区\n\n世界标准时间：“UTC&quot;\n中国时区：“Asia/Shanghai&quot;\n\n\n\n ROOT_URLCONF\n\n用于配置主 url 配置'mysite1.urls'\nROOT_URLCONF = 'mysite1.urls'\n\nsettings.py 中也可以添加 开发人员 自定义的配置\n配置建议：名字尽量个性化- 以防覆盖掉公有配置例如：ALIPAY_KEY =‘xxxxxxxx'\nsettings.py中的所有配置项，都可以按需的在代码中引入from django.conf import settings\n","slug":"Django公有配置","date":"2023-08-14T08:56:34.000Z","categories_index":"Django","tags_index":"coding,Django,Python","author_index":"Ivan Snow"},{"id":"325341d7aca4ae9e9137504312678fc9","title":"数据结构理论复习","content":"\n\n\n 绪论\n 数据结构的定义\n\n数据是描述客观事物的数、字符以及所有能输入到计算机中并被计算机程序处理的符号的集合。\n数据元素是数据的基本单位（例如，A班中的每个学生记录都是一个数据元素），也就是说数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理\n数据项是具有独立含义的数据最小单位，也称为成员或域\n数据对象是性质相同的有限个数据元素的集合，它是数据的一个子集。\n数据结构是指所涉及的数据元素以及数据元素之间的关系，可以看作是相互之间存在着特定关系的数据元素的集合。\n数据元素之间的逻辑关系 =&gt; 数据的逻辑结构\n数据元素及其关系在计算机存储器中的存储方式 =&gt; 数据的存储结构（或物理结构）\n施加在该数据上的操作 =&gt; 数据运算\n\n 算法及其描述\n\n有穷性\n确定性\n可行性\n输入性\n输出性\n\n 算法时间性能分析\n\n求和定理\n求积定理\n\n 算法存储空间分析\n\n在对算法进行存储空间分析时，只考察临时变量所占空间\n\n 线性表\n 顺序表\n\n插入元素移动的平均次数为∑i=0npi(n−i)=1n+1×n(n+1)2=n2\\sum\\limits_{i=0}^n p_i (n-i)=\\frac{1}{n+1}\\times \\frac{n(n+1)}{2}=\\frac{n}{2}i=0∑n​pi​(n−i)=n+11​×2n(n+1)​=2n​\n删除元素移动的平均次数为∑i=0n−1pi(n−i−1)=1n×n(n−1)2=n−12\\sum\\limits_{i=0}^{n-1} p_i (n-i-1)=\\frac{1}{n}\\times \\frac{n(n-1)}{2}=\\frac{n-1}{2}i=0∑n−1​pi​(n−i−1)=n1​×2n(n−1)​=2n−1​\n\n 链表\n\n插入s-&gt;next = p-&gt;next; p-&gt;next = s;\n删除q = p-&gt;next; p-&gt;next = q-&gt;next; delete q;\n头插法建表s-&gt;next = head-&gt;next; head-&gt;next = s;\n\n 栈和队列\n 栈\n\n判断准则：输入序列为1,2,…,n,(p1,p2,…,pn)1,2,…,n,(p_1,p_2,…,p_n)1,2,…,n,(p1​,p2​,…,pn​)是1,2,…,n1,2,…,n1,2,…,n的一种排列，利用一个栈得到输出序列(p1,p2,…,pn)(p_1,p_2,…,p_n)(p1​,p2​,…,pn​)的充分必要条件是不存在这样的i、j、ki、j、ki、j、k满足i&lt;j&lt;ki&lt;j&lt;ki&lt;j&lt;k的同时也满足pj&lt;pk&lt;pip_j&lt;p_k&lt;p_ipj​&lt;pk​&lt;pi​。\n1∼n1\\sim n1∼n共产生1n+1C2nn\\frac{1}{n+1} C_{2n}^nn+11​C2nn​种合法出栈序列\n\n 队列\n 顺序队列\n\n队空条件：front == rear\n队满（上溢出）条件：rear == MaxSize - 1\n\n 循环队列\n\n元素出队：front = (front + 1) ％ MaxSize\n元素e进队：rear = (rear + 1) ％ MaxSize\n队空条件：front == rear\n队满条件：(rear + 1) % MaxSize == front\n\n 链队\n\n队空条件：front = rear = NULL\n\n 数组\n 数组的存储结构\n 一维数组\n\nLOC(ai)=LOC(a0)+i×k    (1≤i&lt;n)LOC(a_i)=LOC(a_0)+i×k \\ \\ \\ \\ (1≤i&lt;n)LOC(ai​)=LOC(a0​)+i×k    (1≤i&lt;n)\n\n 二维数组\n\n行优先：LOC(aij)=LOC(a00)+(i×n+j)×kLOC(a_{ij})=LOC(a_{00}) + (i×n + j)×kLOC(aij​)=LOC(a00​)+(i×n+j)×k\n列优先：LOC(aij)=LOC(a00)+(j×m+i)×kLOC(a_{ij})=LOC(a_{00}) + (j×m + i)×kLOC(aij​)=LOC(a00​)+(j×m+i)×k\n\n 对称矩阵的压缩存储\n\nk={i(i+1)2+ji≥j时(下三角+主对角线的元素)j(j+1)2+i当i&lt;j时(aij=aji)k=\\begin{cases}\\frac{i(i+1)}{2}+j &amp;i≥j时(下三角+主对角线的元素) \\\\ \\frac{j(j+1)}{2}+i &amp;当i&lt;j时(a_{ij}=a_{ji})\\end{cases}k={2i(i+1)​+j2j(j+1)​+i​i≥j时(下三角+主对角线的元素)当i&lt;j时(aij​=aji​)​\n\n 稀疏矩阵的三元组表示\n\n行号、列号、元素值\n\n 递归\n 递归算法转换为非递归算法\n 迭代转换法\n\n尾递归和单向递归是两种特殊类型的递归，可以采用迭代转换法将它们转换为非递归算法，即将其递归结构用循环结构来替代。\n尾递归是递归调用语句只有一个，而且是处于算法的最后\n单向递归是指执行过程总是朝着一个方向进行的，递归函数中虽然有一处以上的递归调用语句，但各次递归调用语句的参数只和主调用函数有关，参数相互之间无关\n\n 用栈模拟转换法\n\n\n不能采用迭代转换法的递归算法执行中往往涉及回溯，可以采用栈来保存暂时不能执行的子问题，或者使用栈保存中间结果，称为用栈模拟转换法\n123456789101112void nonrecursive(si)\t//非递归算法框架\n{  将大问题状态si进栈;\n   while (栈不为空)\n   {  退栈一个元素s;\n      if (s可以直接解决)\n         直接求该问题解;\n      else\n      {  根据递归过程将s转换为若干个相似子问题的状态sj;\n         将每个sj进栈;\n      }\n   }\n}\n\n\n 树和二叉树\n 树的基本术语\n\n结点的度：树中每个结点具有的子树数或者后继结点数称为该结点的度\n树的度：树中所有结点的度的最大值称之为树的度\n分支结点：度大于0的结点称为分支结点或非终端结点。度为1的结点称为单分支结点，度为2的结点称为双分支结点，依次类推\n叶子结点：度为零的结点称为叶子结点或终端结点\n结点层次：树具有一种层次结构，根结点为第一层，其孩子结点为第二层，如此类推得到每个结点的层次\n树的高度：树中结点的最大层次称为树的高度或深度\n\n 树的性质\n\n树中的结点数等于所有结点的度数加1\n度为m的树中第i层上至多有mi−1m^{i-1}mi−1个结点，这里应有i≥1\n高度为h的m次树至多有mh−1m−1\\frac{m^h-1}{m-1}m−1mh−1​个结点\n具有n个结点的m次树的最小高度为log⁡m[n(m−1)+1]\\log_m[n(m-1)+1]logm​[n(m−1)+1]\n\n 二叉树的定义\n\n在含n个结点的二叉树中，所有结点的度小于等于2，通常用n0n_0n0​表示叶子结点个数，n1n_1n1​表示单分支结点个数，n2n_2n2​表示双分支结点个数\n\n 满二叉树\n\n即一棵高度为h且有2h−12^{h}-12h−1个结点的二叉树称为满二叉树，只有度为0和度为2的结点，\n含n个结点的满二叉树的高度为log⁡2(n+1)\\log_2(n+1)log2​(n+1)，叶子结点个数为⌊n/2⌋+1\\lfloor n/2\\rfloor +1⌊n/2⌋+1，度为2的结点个数为⌊n/2⌋\\lfloor n/2 \\rfloor⌊n/2⌋\n\n 完全二叉树的特点\n\n叶子结点只可能出现在最下面两层中\n对于最大层次中的叶子结点，都依次排列在该层最左边的位置上\n如果有度为1的结点，只可能有一个，且该结点只有左孩子而无右孩子\n按层序编号后，一旦出现某结点（其编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点\n具有n个（n＞0）结点的完全二叉树的高度为⌊log⁡2(n+1)⌋\\lfloor \\log_2(n+1)\\rfloor⌊log2​(n+1)⌋或⌊log⁡2n⌋+1\\lfloor\\log_2n\\rfloor+1⌊log2​n⌋+1\n\n 二叉树性质\n\n非空二叉树上叶结点数等于双分支结点数加1。即n0=n2+1n_0=n_2+1n0​=n2​+1\n非空二叉树上第i层上至多有2i−12^{i-1}2i−1个结点，(i≥1)。\n高度为h的二叉树至多有2h−12^{h}-12h−1个结点（h≥1）\nn1n_1n1​只能是0或1，当n为偶数时，n1=1n_1=1n1​=1，当n为奇数时，n1=0n_1=0n1​=0\n\n 哈夫曼树\n\nWPL=∑i=1n0wi×liWPL=\\sum\\limits_{i=1}^{n_0}w_i\\times l_iWPL=i=1∑n0​​wi​×li​\n哈夫曼树中没有单分支结点\n对于具有n0n_0n0​个叶子结点的哈夫曼树，共有2n0−12n_0-12n0​−1个结点\n\n 哈夫曼编码\n\n规定哈夫曼树中的左分支为0，右分支为1\n从根结点到每个叶子结点所经过的分支对应的0和1组成的序列便为该结点对应字符的编码\n\n 树/森林与二叉树的转换及还原\n 一棵树到二叉树的转换\n\n加线：在各兄弟结点之间加一连线，将其隐含的“兄－弟”关系以“双亲－右孩子”关系显示表示出来\n抹线：对任意结点，除了其最左子树之外，抹掉该结点与其他子树之间的“双亲－孩子”关系\n调整：以树的根结点作为二叉树的根结点，将树根与其最左子树之间的“双亲－孩子”关系改为“双亲－左孩子”关系，且将各结点按层次排列，形成二叉树\n\n 特点\n\n根结点只有左子树而没有右子树\n左分支不变（左分支为最左孩子），兄弟变成右分支（右分支实为双亲的兄弟）\n树中分支结点个数为m，则二叉树中无右孩子的结点个数为m+1\n\n 一棵由树转换的二叉树还原为树\n\n加线：在各结点的双亲与该结点右链上的每个结点之间加一连线，以“双亲－孩子”关系显示表示出来\n抹线：抹掉二叉树中所有双亲结点与其右孩子之间的“双亲－右孩子”关系\n调整：以二叉树的根结点作为树的根结点，将各结点按层次排列，形成树\n\n 特点\n\n根结点不变\n左分支不变（左分支为最左孩子），右分支变成兄弟\n\n 森林与二叉树的转换及还原\n 森林转换为二叉树\n\n转换：将森林中的每一棵树转换成二叉树，设转换成的二叉树为bt1、bt2、…、btmbt_1、bt_2、…、bt_mbt1​、bt2​、…、btm​\n连接：将各棵转换后的二叉树的根结点相连\n调整：以bt1bt_1bt1​的根结点作为整个二叉树的根结点，将bt2bt_2bt2​的根结点作为bt1bt_1bt1​的根结点的右孩子，将bt3bt_3bt3​的根结点作为bt2bt_2bt2​的根结点的右孩子，…，如此这样得到一棵二叉树，即为该森林转换得到的二叉树\n\n 二叉树还原为森林\n\n抹线：抹掉二叉树根结点右链上所有结点之间的“双亲－右孩子”关系，分成若干个以右链上的结点为根结点的二叉树，设这些二叉树为bt1、bt2、…、btmbt_1、bt_2、…、bt_mbt1​、bt2​、…、btm​\n转换：分别将bt1、bt2、…、btmbt_1、bt_2、…、bt_mbt1​、bt2​、…、btm​二叉树各自还原成一棵树\n调整：将转换好的树构成森林\n\n 图\n 图的存储结构\n 邻接矩阵\n 邻接表\n\n对图中每个顶点i建立一个单链表，将顶点i的所有邻接点链起来\n每个单链表上添加一个表头结点（表示顶点信息）。并将所有表头结点构成一个数组，下标为i的元素表示顶点i的表头结点\n\n 特点\n\n邻接表表示不唯一\n对于有n个顶点和e条边的无向图，其邻接表有n个表头结点和2e个边结点；对于有n个顶点和e条边的有向图，其邻接表有n个表头结点和e个边结点\n用邻接表存储图时，确定任意两个顶点之间是否有边相连的时间为O(m)O(m)O(m)\n\n 查找\n 查找的基本概念\n\n静态查找表是只作查找操作的查找表，主要操作有查询某个“特定的”数据元素是否在查找表中，检索某个“特定的”数据元素及其属性\n动态查找表是在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素\n\n 顺序查找\n\nASL成功=∑i=0n−1pici=1n∑i=0n−1(i+1)=1n×n(n+1)2=n+12ASL_{成功}=\\sum\\limits_{i=0}^{n-1}p_ic_i=\\frac{1}{n}\\sum\\limits_{i=0}^{n-1}(i+1)=\\frac{1}{n}\\times\\frac{n(n+1)}{2}=\\frac{n+1}{2}ASL成功​=i=0∑n−1​pi​ci​=n1​i=0∑n−1​(i+1)=n1​×2n(n+1)​=2n+1​\nASL不成功=∑i=0n−1qin=nASL_{不成功}=\\sum\\limits_{i=0}^{n-1}q_in=nASL不成功​=i=0∑n−1​qi​n=n\nASL=ASL成功+ASL不成功    (p+q=1)ASL=ASL_{成功}+ASL_{不成功}\\ \\ \\ \\ (p+q=1)ASL=ASL成功​+ASL不成功​    (p+q=1)\n\n 折半查找\n\nASL成功=∑i=0n−1pi×level(ki)ASL_{成功}=\\sum\\limits_{i=0}^{n-1}p_i\\times level(k_i)ASL成功​=i=0∑n−1​pi​×level(ki​)\nASL不成功=∑i=−1n−1qi×(level(ui)−1)ASL_{不成功}=\\sum\\limits_{i=-1}^{n-1}q_i\\times (level(u_i)-1)ASL不成功​=i=−1∑n−1​qi​×(level(ui​)−1)\n满二叉树：ASL成功=∑i=0n−1pici=1n∑j=1h2j−1×j=n+1nlog⁡2(n+1)≈log⁡2(n+1)−1ASL_{成功}=\\sum\\limits_{i=0}^{n-1}p_ic_i=\\frac{1}{n}\\sum\\limits_{j=1}^h2^{j-1}\\times j=\\frac{n+1}{n}\\log_2(n+1)\\approx\\log_2(n+1)-1ASL成功​=i=0∑n−1​pi​ci​=n1​j=1∑h​2j−1×j=nn+1​log2​(n+1)≈log2​(n+1)−1\n\n 索引存储结构和分块查找\n 过程\n\n查找索引表（有序）：可以顺序查找块，也可以二分查找块。\n查找数据块（无序）：只能顺序查找块中元素。\n\n 性能（若有n个元素，每块中有s个元素（块数b=⌈n/s⌉b=\\lceil n/s \\rceilb=⌈n/s⌉））\n\n折半：ASLblk=ASLbn+ASLsq=log⁡2(b+1)−1+s+12≈log⁡2(ns+1)+s2ASL_{blk}=ASL_{bn}+ASL_{sq}=\\log_2(b+1)-1+\\frac{s+1}{2}\\approx \\log_2(\\frac{n}{s}+1)+\\frac{s}{2}ASLblk​=ASLbn​+ASLsq​=log2​(b+1)−1+2s+1​≈log2​(sn​+1)+2s​\n顺序：ASLblk‘=ASLbn+ASLsq=b+12+s+12=12(ns+s)+1ASL^`_{blk}=ASL_{bn}+ASL_{sq}=\\frac{b+1}{2}+\\frac{s+1}{2}=\\frac{1}{2}(\\frac{n}{s}+s)+1ASLblk‘​=ASLbn​+ASLsq​=2b+1​+2s+1​=21​(sn​+s)+1\n\n 二叉排序树\n\n查找序列（k1，k2，…，knk_1，k_2，…，k_nk1​，k2​，…，kn​）的查找树画法是，每一层只有一个结点，首先k1为根结点，再依次画出其他结点，若ki+1&lt;kik_{i+1}&lt;k_iki+1​&lt;ki​，则ki+1k_{i+1}ki+1​的结点作为kik_iki​结点的左孩子，否则作为右孩子\n\n 哈希表\n\n对于两个不同的关键字kik_iki​和kjk_jkj​（i≠ji≠ji=j）出现h(ki)=h(kj)h(k_i)=h(k_j)h(ki​)=h(kj​)，这种现象称为哈希冲突，同义词冲突\n\n 构造方法\n\n直接定址法 h(k)=k+ch(k)=k+ch(k)=k+c\n除留余数法 h(k)=k%ph(k)=k\\%ph(k)=k%p\n数字分析法\n\n 哈希冲突解决方法\n\n装填因子α是指哈希表中已存入的元素数n与哈希地址空间大小m的比值，即α=nmα=\\frac{n}{m}α=mn​\n\n 开放定址法\n\n线性探测法d0=h(k), di=(di−1+1)%m    (1≤i≤m−1)d_0=h(k),\\ d_i=(d_{i-1}+1)\\% m \\ \\ \\ \\ (1≤i≤m-1)d0​=h(k), di​=(di−1​+1)%m    (1≤i≤m−1)\n平方探测法d0=h(k), di=(d0±i2)%m    (1≤i≤m−1)d_0=h(k),\\ d_i=(d_0±i^2)\\% m\\ \\ \\ \\ (1≤i≤m-1)d0​=h(k), di​=(d0​±i2)%m    (1≤i≤m−1)\n\n 拉链法\n 排序\n 希尔排序（不稳定）\n\nd=n/2\n将排序序列分为d个组，在各组内进行直接插入排序\n递减d=d/2，重复② ，直到d=0为止\n\n 快速排序（不稳定）\n\n每趟使表的第1个元素放入适当位置（归位），将表一分为二，对子表按递归方式继续这种划分，直至划分的子表长为0或1（递归出口）\n\n 堆排序（不稳定）\n\n大根堆：对应的完全二叉树中，任意一个结点的关键字都大于或等于它的孩子结点的关键字\n最小关键字的元素一定是某个叶子结点\n堆排序的关键是构造堆，这里采用筛选算法建堆\n自顶向下筛选：从根结点R[low]开始向下依次查找较大的孩子结点\n所有筛选的时间复杂度为O(log⁡2n)O(\\log_2n)O(log2​n)\n\n 自底向上的二路归并排序\n 平衡归并\n\n有清晰的趟数（同一趟产生的归并段优先归并）\n归并树高度h=⌊log⁡2n⌋+1h=\\lfloor \\log_2n\\rfloor+1h=⌊log2​n⌋+1\n归并的趟数h−1h-1h−1\n\n","slug":"DataStructureNote","date":"2023-07-04T08:14:30.000Z","categories_index":"data structure","tags_index":"data structure,coding,algorithms","author_index":"Ivan Snow"},{"id":"4f12ac090a36ba71bea43af761b2b20a","title":"数据结构函数复习","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326#define INF 0x3f3f3f\nconst int MAXN = 1000;\n/**\n * 欧拉函数\n * @param n 一个整数\n * @return 质因数个数\n */\nint eular(int n) {\n    int r = 1;\n    for (int i = 2; i * i &lt;= n; ++i) {\n        if (n % i ==0) {\n            n /= i;\n            r *= i - 1;\n            while (n % i == 0) {\n                n /= i;\n                r *= i;\n            }\n        }\n    }\n    if (n &gt; 1) r *= n - 1;\n    return  r;\n}\n/**\n * 约瑟夫问题\n * @param n 总人数\n * @param m 出队报数\n */\nvoid joseph(int n, int m) {\n    list&lt;int&gt; l;\n    for (int i = 1; i &lt;= n; ++i) {\n        l.push_back(i);\n    }\n    auto it = l.begin();\n    while (l.size() &gt; 1) {\n        for (int j = 1; j &lt; m; ++j) {\n            ++it;\n            if (it == l.end()) it = l.begin();\n        }\n    it = l.erase(it);\n    if (it == l.end()) it = l.begin();\n    }\n    cout &lt;&lt; *it &lt;&lt; endl;\n}\n/**\n * 波兰表达式\n * @return 表达式结果\n */\ndouble poland() {\n    string s;\n    cin &gt;&gt; s;\n    switch (s[0]) {\n        case &#39;+&#39;: return poland() + poland();\n        case &#39;-&#39;: return poland() - poland();\n        case &#39;*&#39;: return poland() * poland();\n        case &#39;/&#39;: return poland() / poland();\n        default: return stod(s);\n    }\n}\n\nint cnt = 0;\n/**\n * 汉诺塔算法\n * @param n 编号\n * @param x x柱\n * @param y y柱\n * @param z z柱\n */\nvoid hanoi(int n, char x, char y, char z) {\n    if (n == 1) {\n        printf(&quot;%d %d %c=&gt;%c\\n&quot;, cnt++, n, x, z);\n    }\n    else {\n        hanoi(n - 1, x, z, y);\n        printf(&quot;%d %d %c=&gt;%c\\n&quot;, cnt++, n, x, z);\n        hanoi(n - 1, y, x, z);\n    }\n}\nstruct Edge {\n    int from, to, cost;\n    Edge(int u, int v, int w) : from(u), to(v), cost(w) {}\n    bool operator&lt; (const Edge&amp; x) const {\n        return cost &lt; x.cost;\n    }\n};\nstruct HeapNode {\n    int d, u; // d表示点u到MST的距离\n    bool operator&lt; (const HeapNode&amp; rhs) const {\n        return d &gt; rhs.d;\n    }\n    HeapNode(int d, int u) : d(d), u(u) {}\n};\nvector&lt;Edge&gt; edges; // edges存所有边\nvector&lt;int&gt; G[MAXN]; // G[i]是顶点i发出的所有边\n/**\n * for (int i = 0; i &lt; E; ++i) { // E是边数\n *  int u, v, cost;\n *  cin &gt;&gt; u &gt;&gt; v &gt;&gt; cost;  // 输入边的起点、终点和权值\n *  G[u].push_back(i);  // 存储边的索引\n *  edges.push_back(Edge(u, v, cost));\n *  G[v].push_back(i);  // 存储边的索引\n *  edges.push_back(Edge(v, u, cost));\n * }\n */\nbool done[MAXN]; // i是否已经加入了T\nint d[MAXN]; // 每个点到T的最小距离\n/**\n * Prim算法\n * @param V 顶点数\n * @return 最小生成树长度\n */\nint Prim(int V) {\n   priority_queue&lt;HeapNode&gt; Q;\n   int ans = 0;\n   for (int i = 0; i &lt; V; ++i) {\n       d[i] = INF;\n   }\n   d[0] = 0;\n   memset(done, 0, sizeof(done));\n   Q.emplace(0, 0);\n   while (!Q.empty()) {\n       HeapNode x = Q.top();\n       Q.pop();\n       int u = x.u;\n       if (done[u]) continue;\n       ans += x.d;\n       done[u] = true;\n       for (int i : G[u]) {\n           Edge&amp; e = edges[i];\n           if (d[e.to] &gt; e.cost) {\n               d[e.to] = e.cost;\n               Q.emplace(d[e.to], e.to);\n           }\n       }\n   }\n    return ans;\n}\n/**\n * 并查集\n */\nclass UnionFind{\nprivate:\n    vector&lt;int&gt; par; // 存储父节点\npublic:\n    UnionFind(int V) {\n        for (int i = 0; i &lt; V; ++i) {\n            par.emplace_back(i);\n        }\n    }\n    /**\n     * 查找根节点\n     * @param x 待查节点\n     * @return 根节点\n     */\n    int find(int x) {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    /**\n     * 合并\n     * @param x\n     * @param y\n     */\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            par[x] = y;\n        }\n    }\n    /**\n     * 判断是否连通\n     * @param x\n     * @param y\n     * @return 是否连通\n     */\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n/**\n * Kruskal算法\n * @param V 顶点数\n * @return 最小生成树长度\n */\nint Kruskal(int V) {\n    sort(edges.begin(), edges.end());\n    UnionFind UF = UnionFind(V);\n    int ans = 0;\n    for (Edge e : edges) {\n        if (!UF.same(e.from, e.to)) {\n            UF.unite(e.from, e.to);\n            ans += e.cost;\n        }\n    }\n    return ans;\n}\nint path[MAXN]; // 记录到顶点i的是哪条边\n/**\n * Dijkstra算法 计算所有顶点到顶点s的最短路径\n * @param s 顶点s\n * @param V 顶点数\n */\nvoid Dijkstra(int s, int V) {\n    priority_queue&lt;HeapNode&gt; Q;\n    for (int i = 0; i &lt; V; ++i) d[i] = INF;\n    d[s] = 0;\n    memset(done, 0 ,sizeof(done));\n    Q.emplace(0, s);\n    while (!Q.empty()) {\n        HeapNode x = Q.top();\n        Q.pop();\n        int u = x.u;\n        if (done[u]) continue;\n        done[u] = true;\n        for (int i : G[u]) {\n            Edge&amp; e = edges[i];\n            if (d[e.to] &gt; d[u] + e.cost) {\n                d[e.to] = d[u] + e.cost;\n                path[e.to] = i;\n                Q.emplace(d[e.to], e.to);\n            }\n        }\n    }\n}\nint dis[MAXN][MAXN]; // 距离矩阵\nint p[MAXN][MAXN]; // 路径数组\n/**\n * FloydWarshall算法 计算全源最短路径\n * @param V 顶点数\n */\nvoid FloydWarshall(int V) {\n    // 初始化距离数组\n    for (int i = 0; i &lt; V; ++i) {\n        for (int j = 0; j &lt; V; ++j) {\n            if (i == j) dis[i][j] = 0;\n            else dis[i][j] = INF;\n            p[i][j] = -1;\n        }\n    }\n    // 更新距离矩阵\n    for (Edge e : edges) {\n        if (dis[e.from][e.to] &gt; e.cost) {\n            dis[e.from][e.to] = e.cost;\n            p[e.from][e.to] = e.from;\n        }\n    }\n    // 计算最短路径\n    for (int k = 0; k &lt; V; ++k) {\n        for (int i = 0; i &lt; V; ++i) {\n            for (int j = 0; j &lt; V; ++j) {\n                if (dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][j] &gt; dis[i][k] + dis[k][j]) {\n                    dis[i][j] = dis[i][k] + dis[k][j];\n                    p[i][j] = p[k][j];\n                }\n            }\n        }\n    }\n}\n\n/**\n * 拓扑排序\n * @param V\n * @return 拓扑序列\n */\nvector&lt;int&gt; TopologicalSort(int V) {\n    int inDegree[MAXN];\n    vector&lt;int&gt; result;\n    queue&lt;int&gt; Q;\n    for (Edge e : edges) {\n        inDegree[e.to]++;\n    }\n    for (int i = 0; i &lt; V; ++i) {\n        if (inDegree[i] == 0) Q.emplace(i);\n    }\n    while (!Q.empty()) {\n        int u = Q.front();\n        Q.pop();\n        result.emplace_back(u);\n        for (int i : G[u]) {\n            Edge&amp; e = edges[i];\n            int v = e.to;\n            if (--inDegree[v] == 0) {\n                Q.emplace(v);\n            }\n        }\n    }\n}\n/**\n * 小根堆\n */\nclass MinHeap {\nprivate:\n    vector&lt;int&gt; a;\npublic:\n    /**\n     * 调整堆\n     * @param i 传入节点下标\n     */\n    void adjustHeap(int i) {\n        int n = a.size();\n        int lChild = i * 2 + 1;\n        int rChild = i * 2 + 2;\n        int minI = i;\n        if (lChild &lt; n &amp;&amp; a[lChild] &lt; a[minI]) {\n            minI = lChild;\n        }\n        if (rChild &lt; n &amp;&amp; a[rChild] &lt; a[minI]) {\n            minI = rChild;\n        }\n        if (minI != i) {\n            swap(a[minI], a[i]);\n            adjustHeap(minI);\n        }\n    }\n    /**\n     * 构造函数\n     * @param b 原始数组\n     */\n    MinHeap(const vector&lt;int&gt;&amp; b) {\n        a = b;\n        int n = b.size();\n        for (int i = n / 2 - 1; i &gt;= 0; --i) {\n            adjustHeap(i);\n        }\n    }\n};\n","slug":"数据结构函数复习","date":"2023-07-02T13:55:06.000Z","categories_index":"data structure","tags_index":"data structure,coding,algorithms","author_index":"Ivan Snow"},{"id":"5a1621912b73a3abad1cd8da411425b8","title":"哈夫曼树叶子结点的路径长度与权值的乘积之和","content":" 题目描述\n哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有叶子结点的路径长度与权值的乘积之和。\n 输入\n输入有多组数据。\n每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。\n 输出\n输出权值。\n 样例输入\n12342\n2 8 \n3\n5 11 30\n 样例输出\n1210\n62\n 题解\n123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;\nusing namespace std;\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;\nint main() {\n\tint n;\n\twhile (cin &gt;&gt; n) {\n\t\twhile (!q.empty()) {\n\t\t\tq.pop();\n\t\t}\n\t\tfor (int i = 0; i &lt; n; ++i) {\n\t\t\tint x;\n\t\t\tcin &gt;&gt; x;\n\t\t\tq.push(x);\n\t\t}\n\t\tint ans = 0;\n\t\twhile (q.size() &gt; 1) {\n\t\t\tint a = q.top();\n\t\t\tq.pop();\n\t\t\tint b = q.top();\n\t\t\tq.pop();\n\t\t\tans += a + b;\n\t\t\tq.push(a + b);\n\t\t}\n\t\tcout &lt;&lt; ans &lt;&lt; endl;\n\t}\n\treturn 0;\n}\n","slug":"哈夫曼树6-28","date":"2023-06-28T08:15:04.000Z","categories_index":"data structure","tags_index":"data structure,coding,tree","author_index":"Ivan Snow"},{"id":"0a6a591ef679e7bf2b14c8c862c44648","title":"二叉搜索树 Binary Search Tree","content":" 二叉搜索树 Binary Search Tree\n 定义\n二叉搜索树（二叉排序树或二叉查找树）：\n\n或者是一棵空树；\n或者是具有如下特性的二叉树\n\n若它的左子树不空，则左子树上所有节点\n的值均小于根节点的值；\n若它的右子树不空，则右子树上所有节点\n的值均大于等于根节点的值；\n它的左、右子树也都分别是二叉搜索树。\n\n\n\n 主要操作\n 查找某个数值\n若二叉搜索树为空，则查找不成功；否则：\n\n若给定值等于根节点的关键字，则查找成功；\n若给定值小于根节点的关键字，则继续在左子树上进行搜索；\n若给定值大于根节点的关键字，则继续在右子树上进行搜索。\n\n 插入某个数值\n插入操作在查找不成功时才进行；\n若二叉搜索树为空树，则新插入的节点为根节点；否则，新插入的节点必为一个叶子节点，其插入位置由查找过程得到。\n 删除某个数值\n删除一个节点后，仍是二叉排序树。可分三种情况讨论：\n\n\n被删除的节点是叶子：其双亲节点中相应指针域的值改为空\n \n\n\n被删除的节点只有左子树或者只有右子树：可以用结点p的左（右）子树替代结点p的子树，也就是直接用其左（右）孩子替代它（结点替代）。\n \n \n\n\n被删除的节点既有左子树，也有右子树：用左孩子的子孙里最大的节点取代被删除节点（间接删除）。\n  \n\n\n 代码实现\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct node { \n    int val;\n    node *lch, *rch;\n};\n\nbool find(node *p, int x) {\n    if (p == NULL) return false;\n    else if (x == p-&gt;val) return true;\n    else if (x &lt; p-&gt;val) return find(p-&gt;lch, x);\n    else return find(p-&gt;rch, x);\n}\n\nnode *insert(node *p, int x) {\n    if (p == NULL) { \n        node *q = new node;\n        q-&gt;val = x;\n        q-&gt;lch = q-&gt;rch = NULL;\n        return q; \n    }\n    else { \n        if (x &lt; p-&gt;val) p-&gt;lch = insert(p-&gt;lch, x);\n        else p-&gt;rch = insert(p-&gt;rch, x);\n        return p; \n    }\n}\n\nnode *remove(node *p, int x) { \n    if (p == NULL) return NULL;\n    else if (x &lt; p-&gt;val) p-&gt;lch = remove(p-&gt;lch, x);\n    else if (x &gt; p-&gt;val) p-&gt;rch = remove(p-&gt;rch, x);\n    else if (p-&gt;lch == NULL) { //第一种情况\n        node *q = p-&gt;rch;\n        delete p; \n        return q; \n    }\n    else if (p-&gt;lch-&gt;rch == NULL) {//第二种情况\n        node *q = p-&gt;lch;\n        q-&gt;rch = p-&gt;rch;\n        delete p; \n        return q; \n    }\n    else { //第三种情况 \n        node *q;\n        for (q = p-&gt;lch; q-&gt;rch-&gt;rch != NULL; q = q-&gt;rch);\n        node *r = q-&gt;rch;\n        q-&gt;rch = r-&gt;lch;\n        r-&gt;lch = p-&gt;lch;\n        r-&gt;rch = p-&gt;rch;\n        delete p;\n        return r;\n    }\n    return p;\n}\n 二叉排序树的查找性能\n\n\n给定含n个关键字的集合，假设所有关键字不相同，对应有n!个关键字序列，每个关键字序列构造一棵二叉排序树，所有这些二叉排序树中查找每个关键字的平均时间为O(log2n)O(log2n)O(log2n)。\n\n\n给定含n个关键字的关键字序列构造一棵二叉排序树。其中查找性能最好的是高度最小的二叉排序树，最好查找性能为O(log2n)O(log2n)O(log2n)。查找性能最坏的是高度为n的二叉排序树（单支树），最坏查找性能为O(n)O(n)O(n)。平均情况由具体的关键字序列来确定。所以常说二叉排序树的时间复杂度在O(log2n)O(log2n)O(log2n)和O(n)O(n)O(n)之间，就是指这种分析方法。\n\n\n查找序列（k1，k2，…，knk_1，k_2，…，k_nk1​，k2​，…，kn​）的查找树画法是，每一层只有一个结点，首先k1k_1k1​为根结点，再依次画出其他结点，若ki+1&lt;kik_{i+1}&lt;k_iki+1​&lt;ki​，则ki+1k_{i+1}ki+1​的结点作为kik_iki​结点的左孩子，否则作为右孩子。\n\n\n","slug":"BST","date":"2023-06-27T06:47:09.000Z","categories_index":"data structure","tags_index":"data structure,coding,algorithms","author_index":"Ivan Snow"},{"id":"92091d0d673d2f304a54eaf158ea4630","title":"拓扑排序 Topological Sort","content":" 拓扑排序 Topological Sort\n 拓扑序列 Topological Order\n拓扑序列是一个有向无环图（Directed Acyclic Graph，简称DAG）的所有顶点的线性序列。\n设G=(V，E)是一个具有n个顶点的有向图，V中顶点序列v1、v2、…、vnv_1、v_2、…、v_nv1​、v2​、…、vn​称为一个拓扑序列，当且仅当该顶点序列满足下列条件：若&lt;vi，vj&gt;&lt;v_i，v_j&gt;&lt;vi​，vj​&gt;是图中的有向边或者从顶点viv_ivi​到顶点vjv_jvj​有一条路径，则在序列中顶点viv_ivi​必须排在顶点vjv_jvj​之前。\n 过程\n\n从有向图中选择一个没有前驱（即入度为0）的顶点并且输出它。\n从图中删去该顶点，并且删去从该顶点发出的全部有向边。\n重复上述两步，直到剩余的图中不再存在没有前驱的顶点为止。\n\n 结果\n\n图中全部顶点都被输出，即得到包含全部顶点的拓扑序列，称为成功的拓扑排序。\n图中顶点未被全部输出，即只能得到部分顶点的拓扑序列，称为失败的拓扑排序，说明有向图中存在回路。\n\n 代码\n 基于BFS的拓扑排序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Edge {\n    int from, to, cost;\n    Edge(int u, int v, int w): from(u), to(v), cost(w) {}\n};\n\nvector&lt;Edge&gt; edges; // 存储所有边\nvector&lt;int&gt; G[MAXN]; // G[i] 存储顶点i发出的所有边\nint inDegree[MAXN]; // 存储每个顶点的入度\nvector&lt;int&gt; result;\n\nvoid TopologicalSort(int V) {\n    \n    queue&lt;int&gt; q;\n\n    // 统计每个顶点的入度\n    for (int i = 0; i &lt; edges.size(); ++i) {\n        int to = edges[i].to;\n        inDegree[to]++;\n    }\n\n    // 将入度为0的顶点入队\n    for (int i = 0; i &lt; V; ++i) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        result.push_back(u);\n\n        // 遍历顶点u发出的所有边\n        for (int i = 0; i &lt; G[u].size(); ++i) {\n            Edge&amp; e = edges[G[u][i]];\n            int v = e.to;\n\n            // 删除边(u, v)，更新顶点v的入度\n            if (--inDegree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n}\n 基于DFS的拓扑排序\n12345678910111213141516171819202122232425262728293031void TopSort(vector&lt;Edge&gt;&amp; edges, vector&lt;vector&lt;int&gt;&gt;&amp; G) {\n    stack&lt;int&gt; st;            // 定义一个栈\n    int ind[MAXV];            // 记录每个顶点的入度\n    memset(ind, 0, sizeof(ind));\n    \n    for (const Edge&amp; edge : edges) {\n        int to = edge.to;\n        ind[to]++;            // 顶点to的入度增1\n    }\n    \n    for (int i = 0; i &lt; G.size(); i++) {\n        if (ind[i] == 0) {\n            st.push(i);      // 将所有入度为0的顶点进栈\n        }\n    }\n    \n    while (!st.empty()) {\n        int i = st.top();\n        st.pop();             // 出栈一个顶点i\n        printf(&quot;%d &quot;, i);     // 输出拓扑序列中的一个顶点i\n        \n        for (int j : G[i]) {  // 遍历顶点i的所有邻接点\n            int w = edges[j].to;\n            ind[w]--;         // 顶点w的入度减1\n            \n            if (ind[w] == 0) {\n                st.push(w);   // 入度为0的邻接点w进栈\n            }\n        }\n    }\n}\n 分析\n使用邻接表进行拓扑排序的时间复杂度为O(V+E)O(V + E)O(V+E)。这是一种相对高效的算法，特别适用于稀疏图（边的数量较少）的拓扑排序问题。\n AOE网\n 定义\n若用一个带权有向图（DAG）描述工程的预计进度，以顶点表示事件，有向边表示活动，边e的权c(e)表示完成活动e所需的时间（比如天数），或者说活动e持续时间→\\to→AOE网。\n通常AOE网中只有一个入度为0的顶点，称为源点，和一个出度为0的顶点，称为汇点。\n在AOE网中，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径。完成整个工程的最短时间就是网中关键路径的长度。\n关键路径上的活动称为关键活动，或者说关键路径是由关键活动构成的。\n 事件的最早开始和最迟开始时间\n\n事件v的最早开始时间：规定源点事件的最早开始时间为0。定义图中任一事件v的最早开始时间ee(v)等于x、y、z到v所有路径长度的最大值\n\nee(v)={0v为源点max{ee(x)+a, ee(y)+b, ee(z)+c}否则ee(v) = \\begin{cases} 0 &amp;v为源点 \\\\ max\\{ee(x)+a,\\ ee(y) + b,\\ ee(z)+c\\} &amp;否则 \\end{cases}ee(v)={0max{ee(x)+a, ee(y)+b, ee(z)+c}​v为源点否则​\n\n\n事件v的最迟开始时间：定义在不影响整个工程进度的前提下，事件v必须发生的时间称为v的最迟开始时间le(v)应等于ee(y)与v到汇点的最长路径长度之差\n\nle(v)={ee(v)v为汇点min{le(x)−a, le(y)−b, le(z)−c}否则le(v) = \\begin{cases} ee(v) &amp;v为汇点 \\\\ min\\{le(x)-a,\\ le(y) - b,\\ le(z)-c\\} &amp;否则 \\end{cases}le(v)={ee(v)min{le(x)−a, le(y)−b, le(z)−c}​v为汇点否则​\n\n 活动的最早开始时间和最迟开始时间\n\n活动a的最早开始时间e(a)指该活动起点x事件的最早开始时间，即： e(a)=ee(x)e(a)=ee(x)e(a)=ee(x)\n活动a的最迟开始时间l(a)指终点y事件的最迟开始时间与该活动所需时间之差，即：l(a)=le(y)−cl(a)=le(y)-cl(a)=le(y)−c\n\n 关键活动\n对于每个活动a，求出d(a)=l(a)−e(a)d(a)=l(a)-e(a)d(a)=l(a)−e(a)，若d(a)为0，则称活动a为关键活动。 对关键活动来说，不存在富余时间。\n 使用拓扑排序求关键路径\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182struct Edge {\n    int from, to, cost;\n    Edge(int u, int v, int w): from(u), to(v), cost(w) {}\n};\n\nvector&lt;Edge&gt; edges; // 存储所有边\nvector&lt;int&gt; G[MAXN]; // G[i] 存储顶点i发出的所有边\nint inDegree[MAXN]; // 存储每个顶点的入度\nint earliest[MAXN]; // 存储每个顶点的最早开始时间\nint latest[MAXN]; // 存储每个顶点的最晚开始时间\n\nvoid addEdge(int u, int v, int w) {\n    edges.push_back(Edge(u, v, w));\n    int m = edges.size();\n    G[u].push_back(m - 1);\n    inDegree[v]++;\n}\n\nvoid calcEarliestTime(int n) {\n    memset(earliest, 0, sizeof(earliest));\n\n    queue&lt;int&gt; q;\n    for (int i = 0; i &lt; n; i++) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int i = 0; i &lt; G[u].size(); i++) {\n            Edge&amp; e = edges[G[u][i]];\n            int v = e.to;\n            int w = e.cost;\n            earliest[v] = max(earliest[v], earliest[u] + w);\n            inDegree[v]--;\n            if (inDegree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid calcLatestTime(int n) {\n    memset(latest, INF, sizeof(latest));\n    latest[n - 1] = earliest[n - 1];\n\n    queue&lt;int&gt; q;\n    q.push(n - 1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int i = 0; i &lt; G[u].size(); i++) {\n            Edge&amp; e = edges[G[u][i]];\n            int v = e.to;\n            int w = e.cost;\n            latest[u] = min(latest[u], latest[v] - w);\n            if (--inDegree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid findCriticalPath(int n) {\n    for (int i = 0; i &lt; edges.size(); i++) {\n        Edge&amp; e = edges[i];\n        int u = e.from;\n        int v = e.to;\n        int w = e.cost;\n        int earliestU = earliest[u];\n        int latestV = latest[v] - w;\n\n        if (earliestU == latestV) {\n            cout &lt;&lt; u &lt;&lt; &quot; -&gt; &quot; &lt;&lt; v &lt;&lt; &quot; : &quot; &lt;&lt; w &lt;&lt; &quot;\\n&quot;;\n        }\n    }\n}\n 分析\n因为使用了拓扑排序，时间复杂度为O(V+E)O(V+E)O(V+E)\n","slug":"TS","date":"2023-06-25T06:31:20.000Z","categories_index":"data structure","tags_index":"data structure,coding,algorithms","author_index":"Ivan Snow"},{"id":"ea135958f52dc15115556a781c9e36cf","title":"最短路径 Shortest Path","content":" 最短路径 Shortest Path\n加权有向图中每条路径都有值，其值是该路径上所有边的权值之和。最短路径 （Shortest Path）问题就是指求出两个给定顶点间权值最小的路径。\n 定义\n两个顶点s和t之间的一条最短路径 是从s到t的一条有向简单路径，而且此路径 具有以下的性质：不存在另一条这样的路径且有更小的权值。\n 最短路径树（Shortest-path trees， 简称SPT）\n给定一个图和一个指定的顶点s，则s的最短路径树是一个包含s以及由s可达的所有顶点的子图，它构成以s为根的一棵有向树，其中每条树路径都是图中的一条最短路径。最短路径树定义了从根到其它顶点的最短路径。\n 分类\n图中最短路径问题主要是以下三类:\n\n源点－汇点最短路径\n单源最短路径\n全源最短路径\n\n 算法\n求图中最短路径的算法常用的有：\n\nDijkstra算法\nFloyd-Warshall算法\nBellman-Ford算法\n\n###　基本操作\n 边松弛（edge relaxation）\n检查一条给定的边，是否可以通过该边，对到其所指顶点的最短路径进行更新。\n不妨设有条边e=(u,v)，它的长度是e.dist， d[i]表示源点到顶点i的最短距离，则松弛操作如下： if (d[v] &gt; d[u] + e.dist) d[v] = d[u] + e.dist 上式的意思就是：如果从源点到u的最短距离加上u到v的长度小于当前源点到v的最短距离，那么更新源点到v的最短距离。 边松弛体现在Dijkstra算法和Bellman-Ford算法中\n 路径松弛（path relaxation）\n检查一个给定顶点，是否可以使得连接另外两个给定顶点的最短路径进行更新。\n不妨设现在有一个顶点x，还有另外两个顶点s和t。考虑能否通过x，使得s到t的最短距离变的更小，能的话，就进行路径松弛：if (d[s][t] &gt; d[s][x] + d[x][t]) d[s][t] = d[s][x] + d[x][t]上式的意思是：如果s到x的最短距离加上x到t的最短距离小于s到t的最短距离，那么更新s到t的最短距离。路径松弛体现在Floyd-Warshall算法中。\n Dijkstra算法\nDijkstra算法计算单源最短路径，它的基本思想：开始把源点放在SPT中，然后，每次增加一条边来构造SPT，所取的边总是可以给出从源点到尚未在SPT中的一个顶点的最短路径。也就是说，按照顶点与起始顶点的距离（通过SPT）为顺序来加入顶点。即：每次选不在SPT中距离源点最近的点加\n入SPT。\n 具体步骤\n\n初始化：顶点集S只包含源点，即S={v}，顶点集U包含除v外的其他顶点。\n从U中选取一个顶点u，它是源点v到U中最短路径长度最小的顶点，然后把顶点u加入S中（此时求出了源点v到顶点u的最短路径长度）。\n以顶点u为新考虑的中间点，修改顶点u的出边邻接点j的最短路径长度，此时源点v到顶点j的最短路径有两条，即一条经过顶点u，一条不经过顶点u。\n重复步骤2和3，直到S包含所有的顶点即U为空。\n\n 基于堆的Dijkstra算法代码\n123456789101112131415161718192021222324252627282930313233343536struct Edge {\n    int from, to, dist;\n    Edge(int u, int v, int d) : from(u), to(v), dist(d) {}\n};\nstruct HeapNode { \n    int d, u; // d表示该点到源点的距离，u是该点的编号\n    bool operator&lt; (const HeapNode&amp; rhs) const {\n        return d &gt; rhs.d; \n    } // 小根堆\n};\nvector&lt;Edge&gt; edges; // edges存所有的边的信息\nvector&lt;int&gt; G[MAXN]; // G[i]是顶点i发出的所有边\nbool done[MAXN]; // 是否已经加入SPT\nint d[MAXN]; // 每个点到源点的最短路径\nint p[MAXN]; // 记录到顶点i的是哪条边\nvoid Dijkstra(int s, int V) { // 计算所有顶点到顶点s的最短路径\n    priority_queue&lt;HeapNode&gt; Q;\n    for(int i = 0; i &lt; V; ++i) d[i] = INF;\n    d[s] = 0; // 顶点s做源点\n    memset(done, 0, sizeof(done));\n    Q.push((HeapNode){0, s});\n    while (!Q.empty()) { \n        HeapNode x = Q.top(); Q.pop;\n        int u = x.u; // 把出队的队头元素的标号给u\n        if (done[u]) continue; // 已经在SPT中就跳过\n        done[u] = true; // 标记u在SPT中了\n        for (int i = 0; i &lt; G[u].size(); ++i) { \n            Edge&amp; e = edges[G[u][i]];\n            if (d[e.to] &gt; d[u] + e.dist) { \n                d[e.to] = d[u] + e.dist;\n                p[e.to] = G[u][i];\n                Q.push((HeapNode){d[e.to], e.to});\n            }\n        }\n    }\n}\n 注意\nDijkstra算法可以解决带有非负权值的单源最短路径问题，如果图中有负权值，则该算法不成立，因为它的前提是增加更多边时，路径的长度不会递减。\n 分析\n利用优先队列实现的Dijkstra算法的时间复杂度是O(ElogV)O(ElogV)O(ElogV)，因为它是在一个规模最大是V的优先队列中进行V个插入，V个删除最小值，以及E个减少键值的操作。\n Floyd-Warshall算法\nFloyd-Warshall算法计算全源最短路径，它的本质是动态规划，用d[i][j][k]表示i到j的最短距离，而且该路径上的顶点的标号都小于等于k(除了源点和汇点)，那么下面的式子明显成立：d[i][j][k] = min(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1])\ni到j中间标号最大是k的路径肯定是这样得到的：\n\ni到j，而且中间标号最大是k-1的最短路径，或者\ni到k，中间标号最大是k-1的最短路径加上了k到j，中间最大标号是k-1的最短路径。这两种情况里的小的就是要求的。\n\n这样就有了O(V3)O(V^3)O(V3)的算法：\n123456789101112131415161718192021222324252627282930313233343536int d[MAXN][MAXN]; // 距离矩阵\nint p[MAXN][MAXN]; // 路径数组\nvoid FloydWarshall(int V) {\n    // 初始化距离矩阵\n    for (int i = 0; i &lt; V; ++i) {\n        for (int j = 0; j &lt; V; ++j) {\n            if (i == j) {\n                d[i][j] = 0; // 同一顶点的距离为0\n            } else {\n                d[i][j] = INF; // 不直接相连的顶点的距离设为无穷大\n            }\n            p[i][j] = -1; // 初始化路径数组\n        }\n    }\n\n     // 根据边的信息更新距离矩阵\n    for (int i = 0; i &lt; edges.size(); ++i) {\n        Edge&amp; e = edges[i];\n        if (d[e.from][e.to] &gt; e.dist) {\n            d[e.from][e.to] = e.dist;\n            p[e.from][e.to] = e.from;\n        }\n    }\n    \n    // 计算最短路径\n    for (int k = 0; k &lt; V; ++k) {\n        for (int i = 0; i &lt; V; ++i) {\n            for (int j = 0; j &lt; V; ++j) {\n                if (d[i][k] != INF &amp;&amp; d[k][j] != INF &amp;&amp; d[i][j] &gt; d[i][k] + d[k][j]) {\n                    d[i][j] = d[i][k] + d[k][j]; // 更新最短路径\n                    p[i][j] = p[k][j];\n                }\n            }\n        }\n    }\n}\n Bellman-Ford算法\nBellman-Ford算法计算单源的最短路径。\n 基本思路\n为了计算一个从顶点s出发的最短路径，用d[i]表示源点s到i的最短路径，开始d[s] = 0，其它都是极大值，然后以任何顺序对每条边进行边松弛操作，完成V-1遍这样的操作，就可以得到各点到s的最短距离。\n我们可以用一个FIFO队列来保存这些顶点，每一遍处理的时候只检查这些顶点发出的边，对于沿着一条发出边 进行松弛时可能有效的所有顶点都放在一 个队列中，每次从队列中取一个顶点，并沿着它的所有边进行松弛。如果其中任何 一条边导致到达某个顶点的一条更短的路径，那么将该点放入队列中。\n 基于FIFO队列的Bellman-Ford算法\n1234567891011121314151617181920212223242526bool bellman_ford(int a) { \n    queue&lt;int&gt; Q; // FIFO队列\n    memset(inq, 0, sizeof(inq));\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 0; i &lt; n; ++i) d[i] = INF;\n    d[s] = 0;\n    inq[s] = true; // inq[i] = true，表示顶点i在队列里\n    Q.push(s);\n    while (!Q.empty()) { \n        int u = Q.front(); Q.pop();\n        inq[u] = false; //u出队了，就不在队列里了\n        for (int i = 0; i &lt; G[u].size(); i++) {\n            Edge&amp; e = edges[G[u][i]];\n            if (d[u] &lt; INF &amp;&amp; d[e.to] &gt; d[u] + e.dist) {\n                d[e.to] = d[u] + e.dist;\n                p[e.to] = G[u][i];\n                if (!inq[e.to]) { // 如果e.to不在队列里才入队，否则，不用再入队 \n                    Q.push(e.to); \n                    inq[e.to] = true;\n                 if (++cnt[e.to] &gt; n) return false; \n                }\n            } \n        } \n    }\n    return true;\n}\n 负环\n利用Bellman-Ford算法很容易来检查一个图是否存在负环。因为最多进行V-1遍所有边的松弛操作，所以V-1遍后看，是否有新的元素入队？有，就存在负环；否则，则没有。上述代码最后返回true就是无负环，返回false就是有负环。用FIFO队列不好判断哪些是一遍的操作，所以用了cnt数组，cnt[i]表示顶点i入队几次了，反正如果无负环，cnt[i]不会超过n，否则，最后必超过（可能是超过V-1遍操作后）。\nFloyd_Warshall算法也能判断图中是否有负环，只要最后检查是否有d[i][i]是负的。上面程序最坏情况下运行时间仍和VE成正比，对于稠密图，运行时间可能不比Floyd好，对于稀疏图则最快可能快V倍。注意Floyd只能求所有的最短路径，不会因为你是求某点出发的最短路径而可以减少运行时间。实战中利用FIFO队列实现的Bellman-Ford算法效果相当好。\n目前对于求有负环的最短路径是NP困难的。\n","slug":"SPT","date":"2023-06-24T02:56:20.000Z","categories_index":"data structure","tags_index":"data structure,coding,algorithms","author_index":"Ivan Snow"},{"id":"3bb7227ed966054de259b7b7501c2568","title":"最小生成树 Minimum Spanning Tree","content":" 最小生成树 Minimum Spanning Tree\n加权无向图的最小生成树（Minimum  Spanning Tree，简称MST）是一棵生成树，其权（所有边的权值之和）不会大于其它任何生成树的权。\n一个带权连通图G（假定每条边上的权值均大于零）可能有多棵生成树.\n每棵生成树中所有边上的权值之和可能不同。\n其中边上的权值之和最小的生成树称为图的最小生成树。\nMST算法有很多，但其中最知名的是Prim算法和Kruskal算法\n Prim算法\n 基本思路\n从任何一个顶点开始作一棵单顶点MST，再为之增加V-1条边，每次增加的边都是将MST上的一个顶点和尚未在此MST上的一个顶点相连接的最小边。\n假设G=(V，E)是一个具有n个顶点的带权连通图，T=(U，TE)是G的最小生成树，其中U是T的顶点集，TE是T的边集，则由G构造从起始点v出发的最小生成树T的步骤如下：\n\n初始化U={v}。以v到其他顶点的所有边为候选边。\n重复以下步骤n-1次，使得其他n-1个顶点被加入到U中：\n\n从候选边中挑选权值最小的边加入TE（所有候选边一定是连接两个顶点集U和V-U的边），设该边在V-U中的顶点是k，将顶点k加入U中。\n考察当前V-U中的所有顶点j，修改候选边：若(k，j)的权值小于原来和顶点j关联的候选边，则用(k，j)取代后者作为候选边。\n\n\n\n寻找最小边在这里使用小根堆\n 基于堆的Prim算法代码\n12345678910111213141516171819202122232425262728293031323334353637struct Edge {\n    int from, to, cost;\n    Edge(int u, int v, int w):from(u), to(v), cost(w) {}\n};\nstruct HeapNode {\n    int d, u; // d表示点u到MST的距离\n    bool operator&lt; (const HeapNode&amp; rhs) const {\n        return d &gt; rhs.d; // 小根堆\n    }\n};\nvector&lt;Edge&gt; edges; // edges存所有边\nvector&lt;int&gt; G[MAXN]; // G[i]是顶点i发出的所有边\nbool done[MAXN]; // i是否已经加入了MST\nint d[MAXN]; // 每个点到MST的最小距离\nint Prim() {\n    priority_queue&lt;HeapNode&gt; Q;\n    int ans = 0; // 总权值\n    for (int i = 0; i &lt; V; ++i) d[i] = INF; // V是图的节点数\n    d[0] = 0; // 从点0开始\n    memset(done, 0, sizeof(done));\n    Q.push((HeapNode){0, 0});\n    while (!Q.empty()) {\n        HeapNode x = Q.top(); Q.pop;\n        int u = x.u; // u为队头元素的序号\n        if (done[u]) continue; // 已经在MST中就跳过\n        ans += x.d; // 加上出队的队头元素到MST的距离\n        done[u] = true;\n        for (int i = 0; i &lt; G[u].size; ++i) { // 更新最小生成树的权值\n            Edge&amp; e = edges[G[u][i]]; // 顶点to能修改最小距离\n            if (d[e.to] &gt; e.cost) {\n                d[e.to] = e.cost;\n                Q.push((HeapNode){d[e.to], e.to});\n            }\n        }\n    }\n    return ans;\n}\n 注意\n本段代码用邻接表来存图，输入可以使用\n12345678for (int i = 0; i &lt; E; ++i) { // E是边数 \n    int u, v, cost;\n    cin &gt;&gt; u &gt;&gt; v &gt;&gt; cost;  // 输入边的起点、终点和权值\n    G[u].push_back(i);  // 存储边的索引\n    edges.push_back(Edge(u, v, cost));\n    G[v].push_back(i);  // 存储边的索引\n    edges.push_back(Edge(v, u, cost));\n}\n 分析\nPrim时间复杂度为O(VlogV+ElogV)O(VlogV + ElogV)O(VlogV+ElogV)。在稀疏图的情况下，E的数量通常远小于V2V^2V2，因此可以将时间复杂度近似为O(ElogV)O(ElogV)O(ElogV)。而在稠密图的情况下，E的数量接近V2V^2V2，时间复杂度会接近O(V2logV)O(V^2logV)O(V2logV)。\n Kruskal算法\n 基本思路\n以边的长度（从小到大）为顺序来处理，若一条边与前面加入到MST中的边未形成环，则将这样的边加入到MST中，增加了V-1条边后停止。也就是说开始是一个森林，每个顶点就是一棵独立的树，然后逐渐把这些树合并（通过一条最小边），最后形成的一棵树就是MST。\n假设G=(V，E)是一个具有n个顶点的带权连通图，T=(U，TE)是G的最小生成树，则构造最小生成树的步骤如下：\n\n置U的初值等于V（即包含有G中的全部顶点），TE的初值为空集（即图T中每一个顶点都构成一个分量）。\n将图G中的边按权值从小到大的顺序依次选取：若选取的边未使生成树T形成回路，则加入TE；否则舍弃，直到TE中包含n-1条边为止。\n\n如果把一棵树看成一个集合，那么对于新加入的边，要判断它的两个顶点是否已经在同一个集合了？是的话就跳过，处理下一条边；不是的话就把这条边加入到MST，同时把该边两顶点所处的两个集合合并。这个实际就是不相交集合（Disjoint Set）的并查(Union-Find)操作。\n Kruskal算法代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354struct edge { \n    int u, v, cost; \n};\n\nbool cmp(const edge&amp; e1, const edge&amp; e2) {\n    return e1.cost &lt; e2.cost;\n}\n\nedge es[MAX_E]; // 存储边的信息\nint par[MAX_V]; // 存储父节点\n\n// 初始化并查集\nvoid init_union_find(int V) {\n    for (int i = 0; i &lt; V; ++i) {\n        par[i] = i; // 初始时每个节点的父节点是自身\n    }\n}\n\n// 查找根节点\nint find(int x) {\n    if (par[x] == x) {\n        return x; // 根节点的父节点是自身\n    } else {\n        return par[x] = find(par[x]); // 路径压缩，将x的父节点设为根节点，加速后续查找\n    }\n}\n\n// 合并集合\nvoid unite(int x, int y) {\n    x = find(x); // 查找x的根节点\n    y = find(y); // 查找y的根节点\n    if (x != y) {\n        par[x] = y; // 将x的根节点设为y，合并两个集合\n    }\n}\n\n// 判断两个节点是否属于同一个集合\nbool same(int x, int y) {\n    return find(x) == find(y); // 若两个节点的根节点相同，则属于同一个集合\n}\n\nint Kruskal(int V, int E) { \n    sort(es, es + E, cmp); // 按权值从小到大排序\n    init_union_find(V); // 并查集初始化 \n    int res = 0;\n    for (int i = 0; i &lt; E; ++i) { \n        edge e = es[i];\n        if (!same(e.u, e.v)) { // u和v不属于一个集合\n        \tunite(e.u, e.v); // 合并u和v集合的元素\n        \tres += e.cost;\n        }\n    }\n    return res;\n}\n 分析\nKruskal算法的时间复杂度为O(ElogE+Eα(V))O(ElogE + Eα(V))O(ElogE+Eα(V))。在稀疏图的情况下，E的数量通常远小于V2V^2V2，因此可以将时间复杂度近似为O(ElogE)O(ElogE)O(ElogE)。而在稠密图的情况下，E的数量接近V2V^2V2，时间复杂度会接近O(Eα(V))O(Eα(V))O(Eα(V))。\n","slug":"MST","date":"2023-06-23T08:05:39.000Z","categories_index":"data structure","tags_index":"data structure,coding,algorithms","author_index":"Ivan Snow"},{"id":"3be01ecc0602fc98eccd555eb652a0f4","title":"机器人王国里的路径长度","content":" 题目描述\n在一个机器人王国里，围绕首都分N层构建卫星城市。以首都为圆心，以路相连分出两个卫星城在第一个层，然后每个卫星城又有路相连分出两个卫星城在下一层，但每条路的长度不同。第N层的卫星城不再分出新的卫星城。现在人类只探知到所有直接相连的城市间的路程，你能计算某个卫星城到达首都的路程吗？\n 输入\n第一行为N，表示机器人王国里有N层卫星城，N最大为10。从第二行开始，共2N+1−22^{N+1}-22N+1−2行，每行分别是城市的代号到其分出的卫星城的代号和它们间的路程。 代号用若干个字母表示，直连路程最大为100。最后一行是某卫星城的代号。\n 输出\n根据最后一行的卫星城代号，求该卫星城到首都的路程。\n 样例输入\n123456782\nA F 20\nB D 100\nG A 5\nG B 10\nA C 6\nB E 30\nD\n 样例输出\n1110\n 题解\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nstruct City {\n    string parent;\n    int distance;\n};\n\nint main() {\n    int N;\n    cin &gt;&gt; N;\n    int num_cities = (1 &lt;&lt; (N + 1)) - 2;\n    unordered_map&lt;string, City&gt; cities;\n\n    for (int i = 0; i &lt; num_cities; i++) {\n        string from, to;\n        int distance;\n        cin &gt;&gt; from &gt;&gt; to &gt;&gt; distance;\n        cities[to] = {from, distance};\n    }\n\n    string target;\n    cin &gt;&gt; target;\n\n    int total_distance = 0;\n    //反向追踪它的父键值，并累加它们的距离值，直到找不到目标键值为止\n    while (cities.find(target) != cities.end()) {\n        total_distance += cities[target].distance;\n        target = cities[target].parent;\n    }\n\n    cout &lt;&lt; total_distance &lt;&lt; endl;\n\n    return 0;\n}\n","slug":"robot-kingdom","date":"2023-06-20T13:09:12.000Z","categories_index":"data structure","tags_index":"data structure,coding,tree","author_index":"Ivan Snow"},{"id":"76e09a24f065289061dc76386548c213","title":"The Power of Robert Capa's The Falling Soldier","content":"Today, I would like to talk about one of the most famous and controversial war photographs ever taken: “The Falling Soldier” by Robert Capa.\n\nRobert Capa, born Endre Friedmann in 1913, was a Hungarian-born American photojournalist known for his courage and his motto: “If your pictures aren’t good enough, you’re not close enough.” He co-founded Magnum Photos, the first cooperative agency for freelance photographers. During his career, he covered several wars including the Spanish Civil War, World War II, and the First Indochina War. Tragically, he died in 1954 when he stepped on a landmine in Vietnam.\n“The Falling Soldier” is a black and white photograph taken on 1936, during the Spanish Civil War. It captures the exact moment a Republican soldier is shot in the head and falls backward, seemingly lifeless. The photograph became a symbol of the Republican cause and the horrors of war.\n“The Falling Soldier” is a powerful image that evokes various themes. The theme of death is prominent, as the photograph captures the instant of death, a rare and shocking occurrence in photography. It raises ethical questions about the role of photography in depicting death. The theme of war is also evident, as the image represents the brutality and violence of war and how it affects ordinary people caught in its crossfire. Finally, the theme of heroism is present, portraying the soldier as a hero who sacrificed his life for his cause.\nWhen I look at this photograph, I feel a mix of emotions. I feel sadness and anger, thinking about the unfairness of this soldier’s death and the many others who perished in war. I also feel amazed and curious, appreciating Capa’s incredible ability to capture such a momentous event with his camera.\nIn conclusion, Robert Capa’s “The Falling Soldier” is an iconic photograph that has left an indelible mark on the history of photojournalism. It is a powerful reminder of the horrors of war and the price paid by those who fight for their beliefs. The photograph’s authenticity may remain a point of debate, but its impact on the world cannot be denied. Thank you for listening.\n","slug":"TheFallingSoldier","date":"2023-06-10T12:43:08.000Z","categories_index":"English","tags_index":"English","author_index":"Ivan Snow"},{"id":"b7a12f40793785dcf055c9f5d18701da","title":"Why Students Should Be Encouraged To Lead A Healthy Lifestyle","content":"According to the World Health Organization, more than 80% of the world’s adolescents are insufficiently physically active. This alarming statistic shows that many students neglect their health in pursuit of academic excellence or other goals. However, health is not something that can be sacrificed or ignored. I believe that students should be encouraged to lead a healthy lifestyle by schools, families and society. While the physical benefits of doing so are widely recognized, I want to emphasize its positive effects on our mental health.\nHealth is the foundation of happiness. By engaging in regular exercise, eating a balanced diet, and getting sufficient sleep, one can not only prevent illnesses and boost the immune system, but also lower stress levels and anxiety. Moreover, a healthy lifestyle can enhance students’ academic performance, which is of utmost importance for us students. For instance, I used to sleep only 5 hours a day and rarely exercise when I was in high school.  Soon I suffered from a severe headache and lost concentration on my studies. As a result, my grades plummeted and this in turn made me more anxious and even harder to fall asleep. One day I decided to change the unhealthy lifestyle. I started to go to bed earlier and keep jogging. It really worked! I felt more energetic and confident than ever before.\nIn conclusion, leading a healthy lifestyle is not only beneficial for students’ physical health, but also for their mental well-being and academic performance. As far as I am concerned, at no time should we underestimate the benefits of leading a healthy lifestyle.\n","slug":"healthy-lifestyle","date":"2023-06-08T01:21:01.000Z","categories_index":"English","tags_index":"English","author_index":"Ivan Snow"},{"id":"aaaba9efa9b11264d3d9cfa935b26602","title":"物理复习","content":"\n\n\n 运动和力\n\n角加速度: β=dωdt=d2θdt2\\beta = \\frac{d \\omega}{d t}=\\frac{d^2 \\theta}{d t^2}β=dtdω​=dt2d2θ​\n切向加速度:\n\nat⃗=dvdtet⃗\\vec{a_t}=\\frac{dv}{dt} \\vec{e_t}at​​=dtdv​et​​\nat=dvdt=Rdωdt=Rβa_t=\\frac{dv}{dt}=R\\frac{d\\omega}{dt}=R\\betaat​=dtdv​=Rdtdω​=Rβ\n\n\n法向加速度:\n\nan⃗=dv2Ren⃗\\vec{a_n}=\\frac{dv^2}{R} \\vec{e_n}an​​=Rdv2​en​​\nan=v2R=ωv=ω2Ra_n=\\frac{v^2}{R}=\\omega v=\\omega ^2 Ran​=Rv2​=ωv=ω2R\n\n\n牛顿第二定律: F合⃗=ma⃗=dp⃗dt\\vec{F_{合}}=m\\vec{a}=\\frac{d\\vec{p}}{dt}F合​​=ma=dtdp​​\n\n 运动的守恒量和守恒定律\n\n动量定理: I=∫t1t2F⃗dt=p2⃗−p1⃗I = \\int _{t_1}^{t_2} \\vec{F} dt = \\vec {p_2}-\\vec{p_1}I=∫t1​t2​​Fdt=p2​​−p1​​\n平均冲力: F⃗ˉ=∫t1t2F⃗dtt2−t1=mv2⃗−mv1⃗t2−t1\\bar{\\vec{F}}=\\frac{\\int _{t_1}^{t_2} \\vec{F} dt}{t_2-t_1}=\\frac{m\\vec{v_2}-m\\vec{v_1}}{t_2-t_1}Fˉ=t2​−t1​∫t1​t2​​Fdt​=t2​−t1​mv2​​−mv1​​​\n角动量: L⃗=r⃗×p⃗\\vec{L}=\\vec{r}\\times \\vec{p}L=r×p​\n力矩: M⃗=r⃗×F⃗\\vec{M}=\\vec{r}\\times \\vec{F}M=r×F\n质点（系）角动量定理: M⃗=dL⃗dt\\vec{M}=\\frac{d \\vec{L}}{dt}M=dtdL​\n角动量守恒定律: L⃗=常量(M⃗=0)\\vec{L}=常量(\\vec{M}=0)L=常量(M=0)\n功: A=∫abF⃗⋅dr⃗A=\\int_a^b \\vec{F} \\cdot d\\vec{r}A=∫ab​F⋅dr\n质点系的动能定理: A外+A内=ΔEkA_外+A_内=\\Delta E_kA外​+A内​=ΔEk​\n质点系的功能原理: A外+A非保内=ΔEA_外+A_{非保内}=\\Delta EA外​+A非保内​=ΔE\n机械能守恒定律（条件: A外+A非保内=0A_外+A_{非保内}=0A外​+A非保内​=0）: E=Ek+Ep=常量E=E_k+E_p=常量E=Ek​+Ep​=常量\n\n 刚体的运动\n\n对定轴的力矩: MZ=rF⊥sinφM_Z=rF_\\perp sin\\varphiMZ​=rF⊥​sinφ\n定轴转动定律: MZ=Jα=JdωdtM_Z=J\\alpha=J\\frac{d\\omega}{dt}MZ​=Jα=Jdtdω​\n转动惯量:\n\nJ=∑iΔmiri2J=\\sum\\limits_{i} \\Delta m_i r_i^2J=i∑​Δmi​ri2​\nJ=∫r2dmJ=\\int r^2 dmJ=∫r2dm\n\n\n力矩的功: A=∫θ0θMdθA=\\int_{\\theta_0}^\\theta Md\\thetaA=∫θ0​θ​Mdθ\n刚体的转动动能: Ek=12Jω2E_k=\\frac{1}{2}J\\omega^2Ek​=21​Jω2\n刚体的重力势能: Ep=mghcE_p=mgh_cEp​=mghc​\n定轴转动的机械能: E=Ek+Ep=12Jω2+mghcE=E_k+E_p=\\frac{1}{2}J\\omega^2+mgh_cE=Ek​+Ep​=21​Jω2+mghc​\n绕定轴的角动量: LZ=JωL_Z=J\\omegaLZ​=Jω\n角动量定理: ∫t1t2MZdt=Jω2−Jω1\\int_{t_1}^{t_2}M_Z dt=J\\omega_2-J\\omega_1∫t1​t2​​MZ​dt=Jω2​−Jω1​\n角动量守恒定律: MZ=0,LZ=Jω=Jω0=常量M_Z=0,L_Z=J\\omega=J\\omega_0=常量MZ​=0,LZ​=Jω=Jω0​=常量\n\n 相对论基础\n\n洛伦兹变换: {x′=x−ut1−u2c2 y′=y z′=z t′=t−uxc21−u2c2\\begin{cases}x&#x27;=\\frac{x-ut}{\\sqrt{1-\\frac{u^2}{c^2}}}\\\\\\  y&#x27;=y\\\\\\  z&#x27;=z\\\\\\  t&#x27;=\\frac{t-\\frac{ux}{c^2}}{\\sqrt{1-\\frac{u^2}{c^2}}} \\end{cases}⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x′=1−c2u2​​x−ut​ y′=y z′=z t′=1−c2u2​​t−c2ux​​​\n相对论速度变换关系: {vx′=vx−u1−uvxc2 vy′=vy1−u2c21−uvxc2 vz′=vz1−u2c21−uvxc2\\begin{cases}v&#x27;_x=\\frac{v_x-u}{1-\\frac{uv_x}{c^2}}\\\\\\  v&#x27;_y=\\frac{v_y\\sqrt{1-\\frac{u^2}{c^2}}}{1-\\frac{uv_x}{c^2}}\\\\\\  v&#x27;_z=\\frac{v_z\\sqrt{1-\\frac{u^2}{c^2}}}{1-\\frac{uv_x}{c^2}}\\end{cases}⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​vx′​=1−c2uvx​​vx​−u​ vy′​=1−c2uvx​​vy​1−c2u2​​​ vz′​=1−c2uvx​​vz​1−c2u2​​​​\n时间延缓（运动时大于固有时）: t=t01−β2t=\\frac{t_0}{\\sqrt{1-\\beta^2}}t=1−β2​t0​​\n长度收缩（运动长度小于固有长度）: l=l01−β2l=l_0\\sqrt{1-\\beta^2}l=l0​1−β2​\n质速关系: m=m01−v2c2m=\\frac{m_0}{\\sqrt{1-\\frac{v^2}{c^2}}}m=1−c2v2​​m0​​\n相对论动量: p⃗=mv⃗=m0v⃗1−(vc)2\\vec{p}=m\\vec{v}=\\frac{m_0\\vec{v}}{\\sqrt{1-(\\frac{v}{c})^2}}p​=mv=1−(cv​)2​m0​v​\n动力学方程: F⃗=dp⃗dt=d(mv⃗)dt=ddt(m0v⃗1−(vc)2)\\vec{F}=\\frac{d\\vec{p}}{dt}=\\frac{d(m\\vec{v})}{dt}=\\frac{d}{dt}(\\frac{m_0\\vec{v}}{\\sqrt{1-(\\frac{v}{c})^2}})F=dtdp​​=dtd(mv)​=dtd​(1−(cv​)2​m0​v​)\n质量和能量的关系: E0=m0c2,E=mc2E_0=m_0c^2,E=mc^2E0​=m0​c2,E=mc2\n动能: Ek=mc2−m0c2=m0c2(11−v2c2−1)E_k=mc^2-m_0c^2=m_0c^2(\\frac{1}{\\sqrt{1-\\frac{v^2}{c^2}}}-1)Ek​=mc2−m0​c2=m0​c2(1−c2v2​​1​−1)\n动量和能量的关系: E2=c2p2+E02=c2p2+m02c4E^2=c^2p^2+E_0^2=c^2p^2+m_0^2c^4E2=c2p2+E02​=c2p2+m02​c4\n\n 机械振动\n\n表达式: x=Acos(ωx+φ0), ω=kmx=Acos(\\omega x+\\varphi_0),\\space\\omega=\\sqrt{\\frac{k}{m}}x=Acos(ωx+φ0​), ω=mk​​\n单摆: T=2πglT=2\\pi\\sqrt{\\frac{g}{l}}T=2πlg​​\n复摆: T=2πJmghT=2\\pi\\sqrt{\\frac{J}{mgh}}T=2πmghJ​​\n机械能守恒: E=12kA2E=\\frac{1}{2}kA^2E=21​kA2\n\n 机械波\n\n角频率: ω=2πν=2πT\\omega=2\\pi\\nu=\\frac{2\\pi}{T}ω=2πν=T2π​\n波速: u=λT=νλu=\\frac{\\lambda}{T}=\\nu\\lambdau=Tλ​=νλ\n波函数建立方法:\n\n建立坐标系，写出已知点O的振动方程: yO=Acos(ωt+φ)y_O=Acos(\\omega t+\\varphi)yO​=Acos(ωt+φ)\n求出波线上任一点P的振动方程: yP=Acos[ω(t±Δt)+φ]y_P=Acos[\\omega (t\\pm\\Delta t)+\\varphi]yP​=Acos[ω(t±Δt)+φ]\n写出平面简谐波的波函数: y(x,t)=Acos[ω(t±xu)+φ0]y(x,t)=Acos[\\omega (t\\pm\\frac{x}{u})+\\varphi_0]y(x,t)=Acos[ω(t±ux​)+φ0​]\n\n\n波动表达式: y(x,t)=Acos(ωt±2πλx+φ)y(x,t)=Acos(\\omega t \\pm \\frac{2\\pi}{\\lambda}x+\\varphi)y(x,t)=Acos(ωt±λ2π​x+φ)\n线元的动能: ΔEk=12ρlΔxω2A2sin2[ω(t−xu)+φ]\\Delta E_k=\\frac{1}{2}\\rho_l\\Delta x\\omega^2A^2sin^2[\\omega(t-\\frac{x}{u})+\\varphi]ΔEk​=21​ρl​Δxω2A2sin2[ω(t−ux​)+φ]\n线元的势能: ΔEp=12ρlΔxω2A2sin2[ω(t−xu)+φ]\\Delta E_p=\\frac{1}{2}\\rho_l\\Delta x\\omega^2A^2sin^2[\\omega(t-\\frac{x}{u})+\\varphi]ΔEp​=21​ρl​Δxω2A2sin2[ω(t−ux​)+φ]\n波的能量: ΔE=ΔEk+ΔEp=ρlΔxω2A2sin2[ω(t−xu)+φ]\\Delta E=\\Delta E_k+\\Delta E_p=\\rho_l\\Delta x\\omega^2A^2sin^2[\\omega(t-\\frac{x}{u})+\\varphi]ΔE=ΔEk​+ΔEp​=ρl​Δxω2A2sin2[ω(t−ux​)+φ]\n平均能量密度: wˉ=12ρω2A2\\bar{w}=\\frac{1}{2}\\rho\\omega^2A^2wˉ=21​ρω2A2\n能流强度: I⃗=12ρω2A2u⃗\\vec{I}=\\frac{1}{2}\\rho\\omega^2A^2\\vec{u}I=21​ρω2A2u\n波的干涉:\n\nP点的相位差: Δφ=φ2−φ1−2π(r2−r1λ)={2kπAmax=A1+A2(加强) 其它Amin&lt;A&lt;Amax (2k+1)πAmin=∣A1−A2∣(减弱) (k=0,±1,±2,…)\\Delta\\varphi=\\varphi_2-\\varphi_1-2\\pi(\\frac{r_2-r_1}{\\lambda})=\\begin{cases} 2k\\pi &amp;A_{max}=A_1+A_2(加强)\\\\\\ 其它 &amp;A_{min}&lt;A&lt;A_{max}\\\\\\ (2k+1)\\pi &amp;A_{min}=|A_1-A_2|(减弱) \\end{cases}\\ (k=0,\\pm1,\\pm2,\\ldots)Δφ=φ2​−φ1​−2π(λr2​−r1​​)=⎩⎪⎪⎨⎪⎪⎧​2kπ 其它 (2k+1)π​Amax​=A1​+A2​(加强)Amin​&lt;A&lt;Amax​Amin​=∣A1​−A2​∣(减弱)​ (k=0,±1,±2,…)\n同向相干波源(φ2=φ1, Δφ=2π(r1−r2)λ=2πλδ\\varphi_2=\\varphi_1,\\ \\Delta\\varphi=\\frac{2\\pi(r_1-r_2)}{\\lambda}=\\frac{2\\pi}{\\lambda}\\deltaφ2​=φ1​, Δφ=λ2π(r1​−r2​)​=λ2π​δ): δ=r1−r2={kλ合振幅最大 (2k+1)λ2合振幅最小 (k=0,±1,±2,…)\\delta=r_1-r_2=\\begin{cases} k\\lambda &amp;合振幅最大\\\\\\ (2k+1)\\frac{\\lambda}{2} &amp;合振幅最小 \\end{cases}\\ (k=0,\\pm1,\\pm2,\\ldots)δ=r1​−r2​={kλ (2k+1)2λ​​合振幅最大合振幅最小​ (k=0,±1,±2,…)\n\n\n驻波方程: y=(2A0cos2πxλ)cos(ωt)y=(2A_0cos\\frac{2\\pi x}{\\lambda})cos(\\omega t)y=(2A0​cosλ2πx​)cos(ωt)\n\n波腹: x=kλ2k=0,±1,…x=k\\frac{\\lambda}{2}\\quad k=0,\\pm1,\\ldotsx=k2λ​k=0,±1,…\n波节: x=(2k+1)λ4k=0,±1,…x=(2k+1)\\frac{\\lambda}{4}\\quad k=0,\\pm1,\\ldotsx=(2k+1)4λ​k=0,±1,…\n\n\n半波损失: 垂直疏到密\n\n 光学\n\n双缝干涉明暗条纹: {x=±kDλd(k=0,1,2,…) 明纹 x=±(2k+1)Dλ2d(k=0,1,2,…) 暗纹\\begin{cases} x=\\pm k\\frac{D\\lambda}{d} &amp;(k=0,1,2,\\ldots) \\ 明纹 \\\\\\ x=\\pm (2k+1)\\frac{D\\lambda}{2d} &amp;(k=0,1,2,\\ldots)\\ 暗纹 \\end{cases}{x=±kdDλ​ x=±(2k+1)2dDλ​​(k=0,1,2,…) 明纹(k=0,1,2,…) 暗纹​\n\n相邻明纹暗纹间距: Δx=Ddλ\\Delta x=\\frac{D}{d}\\lambdaΔx=dD​λ\n光强: I=I1+I2+2I1I2cosΔφΔφ=2πδλI=I_1+I_2+2\\sqrt{I_1I_2}cos\\Delta\\varphi\\quad \\Delta\\varphi = \\frac{2\\pi\\delta}{\\lambda}I=I1​+I2​+2I1​I2​​cosΔφΔφ=λ2πδ​\n\n\n等倾干涉条纹: δ=2dn2−n12sin2i+λ2={kλk=1,2,3,… 明纹 (2k+1)λ2k=0,1,2,… 暗纹\\delta=2d\\sqrt{n^2-n_1^2sin^2i}+\\frac{\\lambda}{2}=\\begin{cases} k\\lambda &amp;k=1,2,3,\\ldots \\ 明纹\\\\\\ (2k+1)\\frac{\\lambda}{2} &amp;k=0,1,2,\\ldots \\  暗纹\\end{cases}δ=2dn2−n12​sin2i​+2λ​={kλ (2k+1)2λ​​k=1,2,3,… 明纹k=0,1,2,… 暗纹​\n\n增透膜: 2nd=(2k+1)λ2k=0,1,2,…2nd=(2k+1)\\frac{\\lambda}{2}\\quad k=0,1,2,\\ldots2nd=(2k+1)2λ​k=0,1,2,…\n\n\n等厚干涉条纹: δ=2d+λ2={kλk=1,2,3,… 明纹 (2k+1)λ2k=0,1,2,… 暗纹\\delta=2d+\\frac{\\lambda}{2}=\\begin{cases} k\\lambda &amp;k=1,2,3,\\ldots \\ 明纹\\\\\\ (2k+1)\\frac{\\lambda}{2} &amp;k=0,1,2,\\ldots \\  暗纹\\end{cases}δ=2d+2λ​={kλ (2k+1)2λ​​k=1,2,3,… 明纹k=0,1,2,… 暗纹​\n\n相邻明纹/暗纹间距: l=λ2sinθ≈λ2θl=\\frac{\\lambda}{2sin\\theta}\\approx \\frac{\\lambda}{2\\theta}l=2sinθλ​≈2θλ​\n牛顿环半径: r={(2k−1)Rλ2k=1,2,3,… 明纹 kRλk=0,1,2,… 暗纹r=\\begin{cases}\\sqrt{\\frac{(2k-1)R\\lambda}{2}} &amp;k=1,2,3,\\ldots \\ 明纹\\\\\\  \\sqrt{kR\\lambda} &amp;k=0,1,2,\\ldots \\ 暗纹 \\end{cases}r={2(2k−1)Rλ​​ kRλ​​k=1,2,3,… 明纹k=0,1,2,… 暗纹​\n\n\n单缝的夫琅禾费衍射:\n\n条纹: δ=asinθ={±kλ暗纹 0中央明纹 ±(2k+1)λ2明纹k=1,2,3,…\\delta=asin\\theta=\\begin{cases} \\pm k\\lambda &amp; 暗纹\\\\\\ 0 &amp;中央明纹\\\\\\ \\pm(2k+1)\\frac{\\lambda}{2} &amp; 明纹\\end{cases}\\quad k=1,2,3,\\ldotsδ=asinθ=⎩⎪⎪⎨⎪⎪⎧​±kλ 0 ±(2k+1)2λ​​暗纹中央明纹明纹​k=1,2,3,…\n半角宽度: θk≈sinθk={±2kλ2a暗纹 λa中央明纹的半角宽度 ±(2k+1)λ2a明纹k=1,2,3,…\\theta_k\\approx sin\\theta_k=\\begin{cases}\\pm 2k \\frac{\\lambda}{2a}&amp; 暗纹\\\\\\  \\frac{\\lambda}{a}&amp; 中央明纹的半角宽度\\\\\\  \\pm(2k+1)\\frac{\\lambda}{2a}&amp; 明纹\\end{cases}\\quad k=1,2,3,\\ldotsθk​≈sinθk​=⎩⎪⎪⎨⎪⎪⎧​±2k2aλ​ aλ​ ±(2k+1)2aλ​​暗纹中央明纹的半角宽度明纹​k=1,2,3,…\n半宽度: x=Dθkx=D\\theta_kx=Dθk​\n\n\n圆孔的夫琅禾费衍射:\n\n第一级暗环衍射角: θ1≈sinθ1=0.61λr=1.22λd\\theta_1\\approx sin\\theta_1=0.61\\frac{\\lambda}{r}=1.22\\frac{\\lambda}{d}θ1​≈sinθ1​=0.61rλ​=1.22dλ​\n艾里斑线半径: R=1.22λdfR=1.22\\frac{\\lambda}{d}fR=1.22dλ​f\n分辨率: R=1θR=d1.22λR=\\frac{1}{\\theta_R}=\\frac{d}{1.22\\lambda}R=θR​1​=1.22λd​\n\n显微镜: R=1Δy=nsinu0.61λR=\\frac{1}{\\Delta y}=\\frac{nsinu}{0.61\\lambda}R=Δy1​=0.61λnsinu​\n\n\n\n\n光栅衍射:\n\n光栅方程: (a+b)sinθ=±kλ 明纹 (k=0,1,2,…)(a+b)sin\\theta=\\pm k\\lambda \\ 明纹 \\  (k=0,1,2,\\ldots)(a+b)sinθ=±kλ 明纹 (k=0,1,2,…)\n缺级: k=a+bak′k′=±1,±2,±3,…k=\\frac{a+b}{a}k&#x27;\\quad k&#x27;=\\pm1,\\pm2,\\pm3,\\ldotsk=aa+b​k′k′=±1,±2,±3,…\n最大级数: kmax=a+bλk_{max}=\\frac{a+b}{\\lambda}kmax​=λa+b​\n\n\nX射线的衍射:\n\n布拉格公式: 2dsinθ=kλk=1,2,3,…2dsin\\theta=k\\lambda\\quad k=1,2,3,\\ldots2dsinθ=kλk=1,2,3,…\n\n\n偏振:\n\n马吕斯定律: I2=I1cos2αI_2=I_1cos^2\\alphaI2​=I1​cos2α\n布儒斯特定律(起偏角iBi_BiB​叫布儒斯特角): taniB=n2n1tan i_B=\\frac{n_2}{n_1}taniB​=n1​n2​​\n入射角等于布儒斯特角时: iB+r=90∘i_B+r=90^\\circiB​+r=90∘，反射光只有垂直于入射面的振动，折射光仍为部分偏振光\n\n\n\n 静止电荷的电场\n\n\n电荷量：e=1.602×10−19ce = 1.602 \\times 10^{-19}ce=1.602×10−19c\n\n\n库仑定律：F12⃗=−F21⃗=14πε0q1q2r122er12⃗\\vec{F_{12}} = - \\vec{F_{21}} = \\frac{1}{4 \\pi \\varepsilon_0}\\frac{q_1q_2}{r_{12}^2} \\vec{e_{r_{12}}}F12​​=−F21​​=4πε0​1​r122​q1​q2​​er12​​​\n\n\n电场强度：E⃗=F⃗q0=14πε0qr2er⃗\\vec{E} = \\frac{\\vec{F}}{q_0} = \\frac{1}{4\\pi\\varepsilon_0}\\frac{q}{r^2}\\vec{e_r}E=q0​F​=4πε0​1​r2q​er​​\n\n\n电偶极矩（电矩）：Pe⃗=ql⃗\\vec{P_e}=q\\vec{l}Pe​​=ql\n\n\n连续带电体的电场\n\n体：E⃗=∫ρ4πε0r2er⃗dV\\vec{E}=\\int\\frac{\\rho}{4\\pi\\varepsilon_0r^2}\\vec{e_r}dVE=∫4πε0​r2ρ​er​​dV\n面：E⃗=∫σ4πε0r2er⃗dS\\vec{E}=\\int\\frac{\\sigma}{4\\pi\\varepsilon_0r^2}\\vec{e_r}dSE=∫4πε0​r2σ​er​​dS\n线：E⃗=∫λ4πε0r2er⃗dL\\vec{E}=\\int\\frac{\\lambda}{4\\pi\\varepsilon_0r^2}\\vec{e_r}dLE=∫4πε0​r2λ​er​​dL\n无限长带电直线：E=Ey=λ2πε0aE = E_y = \\frac{\\lambda}{2\\pi\\varepsilon_0a}E=Ey​=2πε0​aλ​\n均匀带电圆环：E=qx4πε0(R2+x2)32E=\\frac{qx}{4\\pi \\varepsilon_0(R^2+x^2)^{\\frac{3}{2}}}E=4πε0​(R2+x2)23​qx​\n均匀带电薄圆盘：E=ρ2ε0[1−x(R2+x2)12]E = \\frac{\\rho}{2\\varepsilon_0}[1-\\frac{x}{(R^2+x^2)^\\frac{1}{2}}]E=2ε0​ρ​[1−(R2+x2)21​x​]\n\n\n\n电场强度通量：ΨE=EScos⁡θ=∬SE⃗⋅dS⃗\\Psi_E=ES\\cos{\\theta}=\\iint\\limits_{S}\\vec{E}\\cdot d\\vec{S}ΨE​=EScosθ=S∬​E⋅dS\n\n\n高斯定理：\\oiintSE⃗⋅dS⃗=1ε0∑iqi\\oiint\\limits_{S}\\vec{E}\\cdot d\\vec{S} = \\frac{1}{\\varepsilon_0}\\sum\\limits_i q_iS∬​​E⋅dS=ε0​1​i∑​qi​\n\n\n电势：VM=WMq0=∫M∞E⃗⋅dl⃗V_M = \\frac{W_M}{q_0}=\\int_M^\\infin \\vec{E}\\cdot d\\vec{l}VM​=q0​WM​​=∫M∞​E⋅dl\n\n\n电势差：VMN=∫MNE⃗⋅dl⃗V_{MN} = \\int_M^N \\vec{E}\\cdot d\\vec{l}VMN​=∫MN​E⋅dl\n\n\n电势梯度：gradV=dVdnen⃗=−E⃗gradV = \\frac{dV}{dn}\\vec{e_n}=-\\vec{E}gradV=dndV​en​​=−E\n\n\n静电平衡时外表面电荷：E表⃗=σε0en⃗\\vec{E_表}=\\frac{\\sigma}{\\varepsilon_0}\\vec{e_n}E表​​=ε0​σ​en​​\n\n\n孤立导体电容：C=QVC=\\frac{Q}{V}C=VQ​\n\n\n电容的串联和并联：\n\n串联：1C串=1C1+1C2+⋯+1Cn=∑1Ci\\frac{1}{C_串}=\\frac{1}{C_1}+\\frac{1}{C_2}+\\dots+\\frac{1}{C_n}=\\sum\\frac{1}{C_i}C串​1​=C1​1​+C2​1​+⋯+Cn​1​=∑Ci​1​\n并联：C并=C1+C2+⋯+Cn=∑CiC_并=C_1+C_2+\\dots+C_n=\\sum C_iC并​=C1​+C2​+⋯+Cn​=∑Ci​\n\n\n\n平行板电容器：C=εrSdC=\\frac{\\varepsilon_rS}{d}C=dεr​S​\n\n\n电极化强度：P⃗=∑p⃗ΔV\\vec{P}=\\frac{\\sum \\vec{p}}{\\Delta V}P=ΔV∑p​​\n\n\n电极化强度与极化电荷的关系：∣∑p⃗∣=q′l=PSl→σ′=P|\\sum\\vec{p}|=q&#x27;l=PSl \\to \\sigma&#x27;=P∣∑p​∣=q′l=PSl→σ′=P\n\n\n电极化强度与总电场的关系：P⃗=χeε0E⃗\\vec{P}=\\chi_e\\varepsilon_0\\vec{E}P=χe​ε0​E\n\n\n电介质的介电常数(电容率)：ε=ε0εr=(1+χe)ε0\\varepsilon=\\varepsilon_0\\varepsilon_r=(1+\\chi_e)\\varepsilon_0ε=ε0​εr​=(1+χe​)ε0​\n\n\n有电介质时的高斯定理\n\n考虑自由电荷和极化电荷：\\oiintsE⃗⋅dS⃗=1ε0(∑q0+∑q′)\\oiint\\limits_s\\vec{E}\\cdot d\\vec{S}=\\frac{1}{\\varepsilon_0}(\\sum q_0+\\sum q&#x27;)s∬​​E⋅dS=ε0​1​(∑q0​+∑q′)\nΨD=\\oiintSD⃗⋅dS⃗=∑q0\\Psi_D=\\oiint\\limits_S\\vec{D}\\cdot d\\vec{S}=\\sum q_0ΨD​=S∬​​D⋅dS=∑q0​\n\n\n\n电位移矢量：D⃗=ε0E⃗+P⃗\\vec{D}=\\varepsilon_0\\vec{E}+\\vec{P}D=ε0​E+P\n\n各向同性均匀介质：D⃗=ε0εrE⃗=εE⃗\\vec{D}=\\varepsilon_0\\varepsilon_r\\vec{E}=\\varepsilon\\vec{E}D=ε0​εr​E=εE\n\n\n\n电容器静电能：W=12Q2C=12C(V1−V2)2=12Q(V1−V2)W=\\frac{1}{2}\\frac{Q^2}{C}=\\frac{1}{2}C(V_1-V_2)^2=\\frac{1}{2}Q(V_1-V_2)W=21​CQ2​=21​C(V1​−V2​)2=21​Q(V1​−V2​)\n\n\n电场能量密度：w=12εE2=12DE=12D2εw=\\frac{1}{2}\\varepsilon E^2=\\frac{1}{2}DE=\\frac{1}{2}\\frac{D^2}{\\varepsilon}w=21​εE2=21​DE=21​εD2​\n\n\n非均匀电场：W=∭V12DEdV=∭V12εE2dV=∭V12D2εdVW=\\iiint\\limits_V\\frac{1}{2}DEdV=\\iiint\\limits_V\\frac{1}{2}\\varepsilon E^2dV=\\iiint\\limits_V\\frac{1}{2}\\frac{D^2}{\\varepsilon}dVW=V∭​21​DEdV=V∭​21​εE2dV=V∭​21​εD2​dV\n\n\n 恒定电流的磁场\n\n\n电流：I=dqdtI=\\frac{dq}{dt}I=dtdq​\n\n\n电流密度：j⃗=dI⃗dS\\vec{j}=\\frac{d\\vec{I}}{dS}j​=dSdI​\n\n\n电源电动势：ε=∫BAEk⃗⋅dl⃗\\varepsilon=\\int_B^A\\vec{E_k}\\cdot d\\vec{l}ε=∫BA​Ek​​⋅dl\n\n\n磁感应强度大小：B=FmaxqvB=\\frac{F_{max}}{qv}B=qvFmax​​\n\n\n磁感应强度方向：矢量积Fmax⃗×v⃗\\vec{F_{max}} \\times \\vec{v}Fmax​​×v\n\n\n磁通量：Φ=∬SB⃗⋅dS⃗\\Phi = \\iint\\limits_S\\vec{B}\\cdot d\\vec{S}Φ=S∬​B⋅dS\n\n\n毕奥-萨伐尔定律：dB⃗=μ04πIdl⃗×er⃗r2d\\vec{B}=\\frac{\\mu_0}{4\\pi}\\frac{Id\\vec{l}\\times\\vec{e_r}}{r^2}dB=4πμ0​​r2Idl×er​​​\n\n真空磁导率：μ0=4π×10−7T⋅m⋅A−1\\mu_0=4\\pi \\times 10^{-7}T\\cdot m \\cdot A^{-1}μ0​=4π×10−7T⋅m⋅A−1\n任意载流导线：B⃗=∫dB⃗=∫μ04πIdl⃗×er⃗r2\\vec{B}=\\int d\\vec{B}=\\int\\frac{\\mu_0}{4\\pi}\\frac{Id\\vec{l}\\times\\vec{e_r}}{r^2}B=∫dB=∫4πμ0​​r2Idl×er​​​\n应用：\n\n直导线：B=μ0I2πaB=\\frac{\\mu_0I}{2\\pi a}B=2πaμ0​I​\n圆线圈：B=μ0NI2RB=\\frac{\\mu_0NI}{2R}B=2Rμ0​NI​\n无限长螺线管：B=μ0NIB=\\mu_0NIB=μ0​NI\n\n\n\n\n\n载流线圈磁矩：m⃗=NI⃗S⃗\\vec{m}=N\\vec{I}\\vec{S}m=NIS\n\n\n运动电荷产生的磁场：B⃗=μ04πqv⃗×er⃗r2\\vec{B}=\\frac{\\mu_0}{4\\pi}\\frac{q\\vec{v}\\times\\vec{e_r}}{r^2}B=4πμ0​​r2qv×er​​​\n\n\n磁场的高斯定理：\\oiintSB⃗⋅dS⃗=0\\oiint\\limits_S\\vec{B}\\cdot d\\vec{S}=0S∬​​B⋅dS=0\n\n\n安培环路定理：∮LB⃗⋅dl⃗=μ0∑I\\oint\\limits_L\\vec{B}\\cdot d\\vec{l}=\\mu_0\\sum IL∮​B⋅dl=μ0​∑I\n\n\n洛伦兹力：F⃗=qv⃗×B⃗\\vec{F}=q\\vec{v}\\times\\vec{B}F=qv×B\n\n\n霍尔效应：U=RHIBdU=R_H\\frac{IB}{d}U=RH​dIB​，RH=−1neR_H=-\\frac{1}{ne}RH​=−ne1​\n\n\n安培力：F⃗=∫LIdl⃗×B⃗\\vec{F}=\\int\\limits_LI\\vec{dl}\\times\\vec{B}F=L∫​Idl×B\n\n\n磁力矩：M⃗=m⃗×B⃗\\vec{M}=\\vec{m}\\times\\vec{B}M=m×B\n\n\n磁力的做功：A=IΔΦA=I\\Delta\\PhiA=IΔΦ\n\n\n有磁介质的安培环路定理：∮LH⃗⋅dl⃗=∑I\\oint\\limits_L\\vec{H}\\cdot d\\vec{l}=\\sum IL∮​H⋅dl=∑I，H⃗=B⃗μ0−M⃗\\vec{H}=\\frac{\\vec{B}}{\\mu_0}-\\vec{M}H=μ0​B​−M，B⃗=μ0μrH⃗\\vec{B}=\\mu_0\\mu_r\\vec{H}B=μ0​μr​H\n\n\n 电磁感应和电磁场理论\n\n法拉第电磁感应定律：ε=−dΦdt\\varepsilon=-\\frac{d\\Phi}{dt}ε=−dtdΦ​\n感应电动势：ε=−dΦdt=−ddt∬SB⃗⋅dS⃗\\varepsilon=-\\frac{d\\Phi}{dt}=-\\frac{d}{dt}\\iint\\limits_S\\vec{B}\\cdot d\\vec{S}ε=−dtdΦ​=−dtd​S∬​B⋅dS\n动生电动势：ε=∫L(v⃗×B⃗)⋅dl⃗\\varepsilon=\\int\\limits_L(\\vec{v}\\times\\vec{B})\\cdot d\\vec{l}ε=L∫​(v×B)⋅dl\n感生电场：∮LE⃗⋅dl⃗=−∬S∂B⃗∂t⋅dS⃗\\oint\\limits_L\\vec{E}\\cdot d\\vec{l}=-\\iint\\limits_S\\frac{\\partial\\vec{B}}{\\partial t}\\cdot d\\vec{S}L∮​E⋅dl=−S∬​∂t∂B​⋅dS\n\nεab=εi=dBdtS\\varepsilon_{ab}=\\varepsilon_i=\\frac{dB}{dt}Sεab​=εi​=dtdB​S\n\n\n自感电动势：ε=−LdIdt\\varepsilon=-L\\frac{dI}{dt}ε=−LdtdI​，L=NΦIL=\\frac{N\\Phi}{I}L=INΦ​\n互感电动势：ε21=−MdI1dt\\varepsilon_{21}=-M\\frac{dI_1}{dt}ε21​=−MdtdI1​​ ε12=−MdI2dt\\varepsilon_{12}=-M\\frac{dI_2}{dt}ε12​=−MdtdI2​​，M=Φ12I2=Φ21I1M=\\frac{\\Phi_{12}}{I_2}=\\frac{\\Phi_{21}}{I_1}M=I2​Φ12​​=I1​Φ21​​\n自感和互感的关系：M=kL1L2M=k\\sqrt{L_1L_2}M=kL1​L2​​\n磁场能量：Wm=12LI2=12∭VBHdVW_m=\\frac{1}{2}LI^2=\\frac{1}{2}\\iiint\\limits_VBHdVWm​=21​LI2=21​V∭​BHdV\n磁场能量密度：wm=WmV=12LI02V=12B2μ=12μH2=12BHw_m=\\frac{W_m}{V}=\\frac{1}{2}\\frac{LI_0^2}{V}=\\frac{1}{2}\\frac{B^2}{\\mu}=\\frac{1}{2}\\mu H^2=\\frac{1}{2}BHwm​=VWm​​=21​VLI02​​=21​μB2​=21​μH2=21​BH\n位移电流：Id=∬Sjd⃗⋅dS⃗=∬SdD⃗dt⋅dS⃗I_d=\\iint\\limits_S\\vec{j_d}\\cdot d\\vec{S}=\\iint\\limits_S\\frac{d\\vec{D}}{d t}\\cdot d\\vec{S}Id​=S∬​jd​​⋅dS=S∬​dtdD​⋅dS\n\n位移电流密度：jd⃗=1SdψDdt=dD⃗dt\\vec{j_d}=\\frac{1}{S}\\frac{d\\psi_D}{d t}=\\frac{d\\vec{D}}{d t}jd​​=S1​dtdψD​​=dtdD​\n\n\n全电流：It=I+IdI_t=I+I_dIt​=I+Id​\n\n∮LH⃗⋅dl⃗=∑It=∑I+Id=∬Sj⃗⋅dS⃗+∬S∂D⃗∂t⋅dS⃗\\oint\\limits_L\\vec{H}\\cdot d\\vec{l}=\\sum I_t=\\sum I+I_d=\\iint\\limits_S\\vec{j}\\cdot d\\vec{S}+\\iint\\limits_S\\frac{\\partial\\vec{D}}{\\partial t}\\cdot d\\vec{S}L∮​H⋅dl=∑It​=∑I+Id​=S∬​j​⋅dS+S∬​∂t∂D​⋅dS\n\n\n麦克斯韦方程组\n\n电场：\\oiintSD⃗⋅dS⃗=∭VρdV\\oiint\\limits_S\\vec{D}\\cdot d\\vec{S}=\\iiint\\limits_V\\rho dVS∬​​D⋅dS=V∭​ρdV\n磁场：\\oiintSB⃗⋅dS⃗=0\\oiint\\limits_S\\vec{B}\\cdot d\\vec{S}=0S∬​​B⋅dS=0\n变化电场：∮LH⃗⋅dl⃗=∬Sj⃗⋅dS⃗+∬S∂D⃗∂t⋅dS⃗\\oint\\limits_L\\vec{H}\\cdot d\\vec{l}=\\iint\\limits_S\\vec{j}\\cdot d\\vec{S}+\\iint\\limits_S\\frac{\\partial\\vec{D}}{\\partial t}\\cdot d\\vec{S}L∮​H⋅dl=S∬​j​⋅dS+S∬​∂t∂D​⋅dS\n变化磁场：∮LE⃗⋅dl⃗=−∬S∂B⃗∂t⋅dS⃗\\oint\\limits_L\\vec{E}\\cdot d\\vec{l}=-\\iint\\limits_S\\frac{\\partial\\vec{B}}{\\partial t}\\cdot d\\vec{S}L∮​E⋅dl=−S∬​∂t∂B​⋅dS\n\n\n\n 量子论\n\n光电效应\n\n光子能量：ε=hν\\varepsilon=h\\nuε=hν\n爱因斯坦方程：hν=12mv2+Ah\\nu=\\frac{1}{2}mv^2+Ahν=21​mv2+A\n遏制频率：ν0=Ah\\nu_0=\\frac{A}{h}ν0​=hA​\n截止电压：12mvm2=eUa\\frac{1}{2}mv_m^2=eU_a21​mvm2​=eUa​\n光的波粒二象性：p=hλp=\\frac{h}{\\lambda}p=λh​\n\n\n康普顿效应\n\n康普顿散射公式：Δλ=λ−λ0=hm0c(1−cos⁡φ)=2hm0csin⁡2φ2\\Delta\\lambda=\\lambda-\\lambda_0=\\frac{h}{m_0c}(1-\\cos\\varphi)=\\frac{2h}{m_0c}\\sin^2\\frac{\\varphi}{2}Δλ=λ−λ0​=m0​ch​(1−cosφ)=m0​c2h​sin22φ​\n\n\n玻尔氢原子理论\n\n基本假设：\n\n定态假设\n跃迁假设\n角动量量子化假设：L=mvr=nh2πL=mvr=n\\frac{h}{2\\pi}L=mvr=n2πh​\n\n\n计算\n\n半径：rn=ϵ0h2n2πme2=r1n2r_n=\\frac{\\epsilon_0h^2n^2}{\\pi m e^2}=r_1n^2rn​=πme2ϵ0​h2n2​=r1​n2\n轨道能量：En=−me48ϵ02h2n2=−E1n2E_n=-\\frac{me^4}{8\\epsilon_0^2h^2n^2}=-\\frac{E_1}{n^2}En​=−8ϵ02​h2n2me4​=−n2E1​​\n辐射频率：γnk=En−Ekh\\gamma_{nk}=\\frac{E_n-E_k}{h}γnk​=hEn​−Ek​​\n\n\n\n\n物质波\n\n德布罗意公式：λ=hp=hmv\\lambda=\\frac{h}{p}=\\frac{h}{mv}λ=ph​=mvh​，v=Eh=mc2hv=\\frac{E}{h}=\\frac{mc^2}{h}v=hE​=hmc2​\n\n\n不确定关系\n\n海森堡不确定关系：ΔxΔpx≥ℏ2\\Delta x\\Delta p_x\\geq\\frac{\\hbar}{2}ΔxΔpx​≥2ℏ​\n光子动量不确定度：Δp=∣−hΔλλ2∣=hλ2Δλ\\Delta p=|-\\frac{h\\Delta\\lambda}{\\lambda^2}|=\\frac{h}{\\lambda^2}\\Delta\\lambdaΔp=∣−λ2hΔλ​∣=λ2h​Δλ\n\n\n波函数：Ψ(x,t)=Ψ0e−i2π(vt−xλ)=Ψ0e−iℏ(Et−px)\\Psi(x,t)=\\Psi_0e^{-i2\\pi(vt-\\frac{x}{\\lambda})}=\\Psi_0e^{-\\frac{i}{\\hbar}(Et-px)}Ψ(x,t)=Ψ0​e−i2π(vt−λx​)=Ψ0​e−ℏi​(Et−px)\n\n必需满足的条件：\n\n单值性\n有限性\n连续性\n\n\n∣Ψ∣2|\\Psi|^2∣Ψ∣2：概率密度\n薛定谔方程：[−ℏ22m(∂2∂x2+∂2∂y2+∂2∂z2)+V(r⃗,t)]Ψ(r⃗,t)=iℏ∂Ψ(r⃗,t)∂t[-\\frac{\\hbar^2}{2m}(\\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}+\\frac{\\partial^2}{\\partial z^2})+V(\\vec{r},t)]\\Psi(\\vec{r},t)=i\\hbar\\frac{\\partial\\Psi(\\vec{r},t)}{\\partial t}[−2mℏ2​(∂x2∂2​+∂y2∂2​+∂z2∂2​)+V(r,t)]Ψ(r,t)=iℏ∂t∂Ψ(r,t)​\n\n\n\n","slug":"物理复习","date":"2023-06-07T09:36:59.000Z","categories_index":"Physics","tags_index":"learning,Physics","author_index":"Ivan Snow"},{"id":"447e8e440ec7ad6ce34c5cc0753cdacd","title":"数据结构题目02","content":" 1\n 题目描述\n给你若干个字符串，请编程输出每个字符串的子串个数。\n 输入\n若干个字符串，每个字符串占一行，字符串中不含空格，长度最大为1000。\n 输出\n对应每一行的字符串，输出该字符串子串的个数。\n 样例输入\n123abc\napple\nsoftware\n 样例输出\n1237\n16\n37\n 题解\n123456789#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() {\n    string s;\n    while(cin &gt;&gt; s){\n        cout &lt;&lt; s.length() * (s.length() + 1) / 2 + 1 &lt;&lt; endl;\n    }\n    return 0;\n}\n 2\n 题目描述\n给你一个目标串，请查找在给目标串中是否存在模式串，存在就输出第一个模式串在目标串中出现的位置。\n 输入\n占两行，第一行是目标串（长度小于1000），第二行为模式串（长度小于100）。\n 输出\n输出模式串在目标串中出现的位置，即模式串匹配到目标串时第一个字符在目标串的位置（注意从1开始描述字符开始位置），不能匹配时输出0\n 样例输入\n12appleorange\norange\n 样例输出\n16\n 题解\n12345678#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() {\n    string s, a;\n    cin &gt;&gt; s &gt;&gt; a;\n    cout &lt;&lt; s.find(a) + 1;\n    return 0;\n}\n 3\n 题目描述\n在一个N行N列的方阵(或称N阶方阵)中，从左上角到右下角这一斜线上有N个数据元素，这个斜线称为方阵的主对角线。给你一个方阵，请求方阵主对角线上数据的和。\n 输入\n第一行是N（N&lt;100），表示下边是一个N阶方阵。接下来N行N列用空格间隔放置正整数（int型）。\n 输出\nN阶方阵主对角线上数据的和。\n 样例输入\n12343\n1 2 3\n1 2 3\n1 2 3\n 样例输出\n16\n 题解\n12345678910111213141516#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() {\n    int n, sum = 0;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; n; j++){\n            int a;\n            cin &gt;&gt; a;\n            if (i == j){\n                sum += a;\n            }\n        }\n    cout &lt;&lt; sum;\n    return 0;\n}\n 4\n 题目描述\n给你一个N行N列的方格矩阵，从外圈按顺时针依次填写自然数，这会构成一个螺旋阵，你能编程实现吗？\n比如5行5列的情况如下：\n1\t2\t3\t4\t5\n16\t17\t18\t19\t6\n15\t24\t25\t20\t7\n14\t23\t22\t21\t8\n13\t12\t11\t10\t9\n 输入\n输入一个正整数数N（N&lt;100）。\n 输出\n输出符合题意的螺旋阵。\n 样例输入\n15\n 样例输出\n123451 2 3 4 5\n16 17 18 19 6\n15 24 25 20 7\n14 23 22 21 8\n13 12 11 10 9\n 题解\n123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() {\n    int n, c = 0, cnt = 1;\n    int a[101][101];\n    cin &gt;&gt; n;\n    while (cnt &lt;= n * n) {\n        //上方\n        for (int i = c; i &lt; n - c; i++) {\n            a[c][i] = cnt++;\n        }\n        //右方\n        for (int i = c + 1; i &lt; n - c; i++) {\n            a[i][n - c - 1] = cnt++;\n        }\n        //下方\n        for (int i = n - c - 2; i &gt;= c; i--) {\n            a[n - c - 1][i] = cnt++;\n        }\n        //左方\n        for (int i = n - c - 2; i &gt;= c + 1; i--) {\n            a[i][c] = cnt++;\n        }\n        c++;\n    }\n    for (int i = 0; i &lt; n; i++) {\n        for(int j = 0; j &lt; n; j++){\n            cout &lt;&lt; a[i][j]&lt;&lt;&#39; &#39;;\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n 5\n 题目描述\n有三根标为A,B,C的柱子，A柱子上从上到下按金字塔状依次叠放着n个半径从1厘米到n厘米的的圆盘，要把A上的所有盘子移动到柱子C上，中间可以临时放在B上，但每次移动每一根柱子上都不能出现大盘子在小盘子上方的情况，要求用最少的移动次数完成，请编程模拟每次移动。\n 输入\n占一行，为整数n（n&lt;64），表示盘子数。\n 输出\n把A上的所有盘子移动到柱子C上，每次只能移动一个盘子，输出移动每一次过程。每次移动占一行，第一个数表示第几步移动，第二个数是移动的盘子的半径，然后是从哪个柱子移动到哪个柱子。\n 样例输入\n12\n 样例输出\n1231 1 A-&gt;B\n2 2 A-&gt;C\n3 1 B-&gt;C\n 题解\n12345678910111213141516171819#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint cnt = 1;\nvoid Hanoi (int n, char x, char y, char z){\n    if (n == 1) {\n        printf(&quot;%d %d %c-&gt;%c\\n&quot;,cnt++,n,x,z);\n    }\n    else {\n        Hanoi(n - 1, x, z, y);\n        printf(&quot;%d %d %c-&gt;%c\\n&quot;,cnt++,n,x,z);\n        Hanoi(n - 1, y, x, z);\n    }\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    Hanoi(n, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);\n    return 0;\n}\n 6\n 题目描述\n已知一颗树的节点间关系，请编程实现该树的先根遍历。\n 输入\n若干行，每行描述了一组双亲节点和孩子节点的关系序偶对（每个节点用不同的大写字母表示，节点小于26个）。且数的度小于5。\n 输出\n该树的先根遍历序列，序列中每个字母用空格隔开。\n 样例输入\n1234B E\nB F\nA B\nA C\n 样例输出\n1A B E F C\n 题解\n12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct Node {\n    vector&lt;int&gt; sons;\n    Node(){}\n}node[26];\nint root = -1;\nvoid preOrder(int root) {\n    cout &lt;&lt; char(root + &#39;A&#39;) &lt;&lt; &#39; &#39;;\n    for (int i = 0; i &lt; node[root].sons.size(); i++){\n        preOrder(node[root].sons[i]);\n    }\n}\nint main() {\n    char p, c;\n    while(cin &gt;&gt; p &gt;&gt; c) {\n        if (p == EOF || c == EOF) break;\n        node[p - &#39;A&#39;].sons.push_back(c - &#39;A&#39;);\n        if (root == c - &#39;A&#39; || root == -1) {\n            root = p - &#39;A&#39;;\n        }\n    }\n    preOrder(root);\n    return 0;\n}\n 7\n 题目描述\n已知一颗树的节点间关系，请编程实现该树的后根遍历序列。\n 输入\n若干行，每行描述了一组双亲节点和孩子节点的关系序偶对（每个节点用不同的大写字母表示，节点小于26个）。且数的度小于5。\n 输出\n该树的后根遍历序列，序列中每个字母用空格隔开。\n 样例输入\n1234B E\nB F\nA B\nA C\n 样例输出\n1E F B C A\n 题解\n1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct Node {\n    vector&lt;int&gt; sons;\n    Node(){}\n}node[26];\nint root = -1;\nvoid postOrder(int root) {\n\n    for (int i = 0; i &lt; node[root].sons.size(); i++){\n        postOrder(node[root].sons[i]);\n    }\n    cout &lt;&lt; char(root + &#39;A&#39;) &lt;&lt; &#39; &#39;;\n}\nint main() {\n    char p, c;\n    while(cin &gt;&gt; p &gt;&gt; c) {\n        if (p == EOF || c == EOF) break;\n        node[p - &#39;A&#39;].sons.push_back(c - &#39;A&#39;);\n        if (root == c - &#39;A&#39; || root == -1) {\n            root = p - &#39;A&#39;;\n        }\n    }\n    postOrder(root);\n    return 0;\n}\n","slug":"DataStructureTest02","date":"2023-06-06T13:23:35.000Z","categories_index":"data structure","tags_index":"data structure,coding","author_index":"Ivan Snow"},{"id":"7635bd103b7f5e363b544fb0acb0f8cc","title":"思政复习","content":"\n[ ] 道德的（相对独立性）既表现为道德的历史继承性,也表现为道德对社会发展具有能动的反作用。\n[ ] （奉献社会）要求从业人员在工作岗位上兢兢业业地为社会和他人作贡献,是社会主义职业道德中最高层次的要求,体现了社会主义职业道德的最高目标指向。\n[ ] 加强道德修养,提升个人品德,应借鉴历史上思想家们所提出的学思并重、（省察克治、慎独自律、知行合一、积善成德）等各种积极有效的方法,并结合当今社会发展的需要身体力行,不断提高自己的道德素质和精神境界。\n[ ] 自觉把集体利益放在个人利益之上,在维护集体利益的前提下,实现个人的正当利益。这是已经具有较高社会主义道德觉悟的人能够达到的要求。\n[ ] （国务院）有权根据宪法和法律制定行政法规。\n[ ] 推进全面依法治国,法治社会建设是（基础工程）。\n[ ] 2020年11月,习近平在中央全面依法治国工作会议上的重要讲话中,用“（十一个坚持）”对全面依法治国进行了系统阐释、部署。\n[ ] 有力的法治保障体系,是全面依法治国的（重要依托）。\n[ ] 公正司法是全面依法治国的（重点）。\n[ ] 习近平总书记指出:“对新时代的中国青年来说,热爱祖国是立身之本、成才之基。”作为实现中国梦的见证者和参与者,当代大学生应以（国家富强、民族振兴、人民幸福）为己任。\n\n","slug":"思政复习","date":"2023-06-03T04:17:44.000Z","categories_index":"trash","tags_index":"learning,trash","author_index":"Ivan Snow"},{"id":"29eec2f1f6c8d3a5a334c25d61174c8e","title":"习近平复习","content":"\n中国特色社会主义的战略布局是（  四个全面 ）\n我国社会主要矛盾的变化\n\n没有改变我们对我国社会主义所处历史阶段的判断\n我国仍处于并将长期处于社会主义初级阶段的基本国情没有变\n我国是世界最大发展中国家的国际地位没有变\n\n\n坚持把马克思主义基本原理同（ 中国具体实际相结合、中华优秀传统文化 ）相结合，用马克思主义观察时代、把握时代、引领时代，继续发展当代中国马克思主义、21世纪马克思主义\n社会主义政治发展的必然要求是坚持（ 党的领导、人民当家作主、依法治国  ）的有机统一\n习近平新时代中国特色社会主义思想坚持以社会主义现代化建设进程中的实际问题、以我们正在做的事情为中心，着眼统揽（ 伟大斗争、伟大工程、伟大梦想  ），大智慧谋划大格局，大手笔续写大文章，是实践探索、经验总结、理论升华凝结而成的思想结晶\n世界百年未有之大变局表现在哪些方面？\n\n当前国际格局和国际体系正在发生深刻调整；\n全球治理体系正在发生深刻变革 ；\n国际力量对比正在发生近代以来最具革命性的变化 ；\n世界范围呈现出影响人类历史进程和趋向的重大态势\n\n\n2012年11月29日，习近平在参观《复兴之路》展览时首次提出中国梦，并引用三句诗诠释了近代以来中国人民寻梦、追梦、圆梦的历史进程。中华民族的明天，“（ 长风破浪会有时  ）”\n“两个一百年”的奋斗目标中第一个百年目标是（   建成更高水平的小康社会   ）\n综合分析国际国内形势和我国发展条件，党的十九大提出我们要全面建成小康社会，实现第一个百年奋斗目标，然后再乘势而上开启（  全面建设社会主义现代化国家   ）新征程。\n(  党的十二大  )首次把“小康”作为经济建设总的奋斗目标\n习近平指出：“全面建设社会主义现代化国家、基本实现社会主义现代化，既是（ 社会主义初级阶段  ）我国发展的要求，也是我国社会主义从初级阶段向更高阶段迈进的要求\n（  党的十九届五中全会  ）作出“全面建成小康社会胜利在望”的重要判断，将“全面建成小康社会”目标提升为“全面建设社会主义现代化国家”，确立全面建设社会主义现代化国家在“四个全面”战略布局中的引领地位\n坚持和发展中国特色社会主义的总任务是\n\n实现社会主义现代化和中华民族伟大复兴\n在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国\n中国梦是中华民族伟大复兴的形象表达\n\n\n中国梦的科学内涵是\n\n国家富强\n民族振兴\n人民幸福\n\n\n2020年，“十三五”规划目标任务胜利完成，（决战脱贫攻坚取得全面胜利、全面建成小康社会取得决定性成就），我国经济实力、科技实力、综合国力和人民生活水平跃上新的大台阶\n新时代坚持和发展中国特色社会主义的前进定力是什么？\n\n第一，坚持党的全面领导是坚持和发展中国特色社会主义的必由之路。\n第二，中国特色社会主义是实现中华民族伟大复兴的必由之路。\n第三，团结奋斗是中国人民创造历史伟业的必由之路。\n第四，贯彻新发展理念是新时代我国发展壮大的必由之路。\n第五，全面从严治党是党永葆生机活力、走好新的赶考之路的必由之路\n\n\n中国式现代化国家的重要特征是什么？\n\n第一，中国式现代化是人口规模巨大的现代化。\n第二，中国式现代化是全体人民共同富裕的现代化。\n第三，中国式现代化是物质文明和精神文明相协调的现代化。\n第四，中国式现代化是人与自然和谐共生的现代化。\n第五，中国式现代化是走和平发展道路的现代化。\n\n\n始终把群众作为智慧和力量的源泉，始终把（ 政治智慧的增长、政治素质的提升、群众基础的广泛）深深扎根于人民的创造性实践中\n党依靠人民，推进（改革开放、社会主义现代化建设  ）走出一条中国特色社会主义道路。\n以人民为中心是我们党（ 立党为公、执政为民 ）的生动体现，是全心全意为人民服务的时代彰显。\n不忘初心、牢记使命，说到底是为什么人、靠什么人的问题。以百姓心为心，与人民（ 同呼吸、共命运 、心连心），是党的初心，也是党的恒心。\n扎实推动共同富裕的重大举措\n\n第一，提高发展的平衡性、协调性、包容性。\n第二，着力扩大中等收入群体规模。\n第三，促进基本公共服务均等化。\n第四， 加强对高收入的规范和调节。\n第五，促进人民精神生活共同富裕。\n第六，促进农民农村共同富裕。\n\n\n（ 新发展格局 ）是根据我国发展阶段、环境、条件变化提出来的，是重塑我国国际合作和竞争新优势的战略抉择，是把握未来发展主动权的战略性布局和先手棋。\n经济改革的方向是要让（  市场 ）在资源配置中发挥决定性作用\n经济进入新常态后，伴随着经济增长速度的下降，推动（  供给侧改革  ）成为经济生活中的主旋律\n建设彰显优势、协调联动的（ 城乡区域  ）发展体系\n我国经济已由高速增长阶段转向（高质量发展阶段），正处在转变发展方式、优化经济结构、转换增长动力的攻关期。\n我国经济发展处于（ 增长速度换挡期 、结构调整阵痛期、前期刺激政策消化期 ）阶段，我国发展进入新常态。\n我国现代化经济体系的内容是什么？\n\n创新引领、协同发展的产业体系。\n统一开放、竞争有序的市场体系。\n体现效率、促进公平的收入分配体系。\n彰显优势、协调联动的城乡区域发展体系。\n资源节约、环境友好的绿色发展体系。\n多元平衡、安全高效的全面开放体系。\n\n\n供给侧结构性改革的必要性是什么?\n\n适应把握引领经济发展新常态的重大创新。\n适应国际金融危机发生后综合国力竞争新形势的主动选择。\n推动我国经济实现高质量发展的必然要求。\n\n\n（  2013 年 9 月和 10 月  ），习近平先后提出共建“丝绸之路经济带”和“21世纪海上丝绸之路”的重大倡议。\n（  引进来和走出去 ）是“一带一路”国际合作的重要内容，如同车之两轮、鸟之两翼。\n全面深化改革的总目标是\n\n完善和发展中国特色社会主义制度\n推进国家治理体系和治理能力现代化\n\n\n治理能力是运用国家制度管理国家各方面事务的能力，它包括（改革发展稳定、内政外交国防、治党治国治军 ）等各个方面各个领域的治理能力。\n绿水青山就是金山银山，阐述了（经济发展、生态环境保护）的关系\n要加快推进（ 绿色发展、循环发展、低碳发展 ），开创美丽中国建设新局面。\n党的二十大报告指出：“（ 尊重自然、顺应自然、保护自然  ），是全面建设社会主义现代化国家的内在要求。”\n全面深化改革的重点是（经济体制改革）\n全面建设社会主义国家的首要任务是（高质量发展）\n社会主义民主不是超越阶级的民主\n法治的保障作用（固根本、稳预期、利长远）\n体现社会主义民主政治的本质和核心的是：\n\n保障人民依法参加国家和社会事务管理\n国家法律制定必须体现人民意志\n国家一切权利属于人民\n\n\n\n","slug":"习近平复习","date":"2023-06-02T12:09:04.000Z","categories_index":"trash","tags_index":"learning,trash","author_index":"Ivan Snow"},{"id":"6a87345b9e9d401bf5be8abeba39da4e","title":"数据结构题目01","content":" 1\n 题目描述\n新年快到了，天勤准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。\n 输入\n第一行是测试数据的组数CN(Casenumber，1&lt;CN&lt;10000)CN(Case number，1&lt;CN&lt;10000)CN(Casenumber，1&lt;CN&lt;10000)，接着有CNCNCN行正整数N(1&lt;n&lt;32768)N(1&lt;n&lt;32768)N(1&lt;n&lt;32768)，表示会员人数。\n 输出\n对于每一个NNN，输出一行新朋友的人数，这样共有CNCNCN行输出。\n 样例输入\n1232\n25608\n24027\n 样例输出\n127680\n16016\n 题解\n12345678910111213141516171819202122232425262728#include &lt;iostream&gt;\nusing namespace std;\nint eular(int n) {\n    int r = 1;\n    for (int i = 2; i * i &lt;= n; i++) {\n        if ( n % i == 0) {\n            n /= i;\n            r *= i - 1;\n            while(n % i == 0){\n                n /= i;\n                r *= i;\n            }\n        }\n\n    }\n    if (n &gt; 1) r *= n - 1;\n    return r;\n}\nint main() {\n    int CN;\n    cin &gt;&gt; CN;\n    for (int i = 0; i &lt; CN; i++) {\n        int N; \n        cin &gt;&gt; N;\n        cout &lt;&lt; eular(N) &lt;&lt; endl;\n    }\n    return 0;\n}\n 2\n 题目描述\n给你一个正整数nnn，请问有多少个比nnn小的且与nnn互质的正整数？\n两个整数互质的意思是，这两个整数没有比111大的公约数。\n 输入\n输入包含多组测试数据。每组输入是一个正整数n(n≤1000000000)n(n \\leq 1000000000)n(n≤1000000000)。当n=0n=0n=0时，输入结束。\n 输出\n对于每组输入，输出比nnn小的且与nnn互质的正整数个数。\n 样例输入\n1237\n12\n0\n 样例输出\n126\n4\n 题解\n12345678910111213141516171819202122232425262728#include &lt;iostream&gt;\nusing namespace std;\nint eular(int n) {\n    int r = 1;\n    for (int i = 2; i * i &lt;= n; i++) {\n        if ( n % i == 0) {\n            n /= i;\n            r *= i - 1;\n            while(n % i == 0){\n                n /= i;\n                r *= i;\n            }\n        }\n\n    }\n    if (n &gt; 1) r *= n - 1;\n    return r;\n}\nint main() {\n    int n;\n    while(cin &gt;&gt; n){\n        if (n == 0) {\n            break;\n        }\n        cout &lt;&lt; eular(n)&lt;&lt;endl;\n    }\n    return 0;\n}\n 3\n 题目描述\nnnn个人围成一圈，按111到nnn的顺序编号。从第一个人开始报数（从111到mmm报数），凡报到mmm的人退出圈子，问最后留下的是原来的第几号。\n 输入\n首先输入两个正整数nnn和mmm，nnn表示nnn个人围一个圈子(n≥2)(n \\geq 2)(n≥2)，mmm表示从111报数到mmm的人退出圈子(1≤m)(1 \\leq m)(1≤m)。\n 输出\n最后剩下的人的编号。\n 样例输入\n12 3\n 样例输出\n12\n 题解\n12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nlist &lt;int&gt; l;\nvoid init(int n){\n    for (int i = 1; i &lt;= n; i++) {\n        l.push_back(i);\n    }\n}\nvoid doJ(int n, int m){\n    init(n);\n    list&lt;int&gt; :: iterator it = l.begin();\n    while(l.size() &gt; 1){\n        for(int j = 1;j &lt; m; j++){\n            it ++;\n            if(it == l.end()){\n                it = l.begin();\n            }\n        }\n        it = l.erase(it);\n        if(it == l.end()){\n            it = l.begin();\n        }\n    }\n    cout &lt;&lt; *it &lt;&lt; endl;\n}\nint main() {\n    int n,m;\n    cin &gt;&gt; n &gt;&gt; m;\n    doJ(n, m);\n    return 0;\n}\n 4\n 题目描述\n编写程序演示把一个101010进制整数转换为RRR进制的转换结果。\n 输入\n正整数NNN和RRR，空格分隔\nNNN是输入的十进制数，RRR需要转换的进制数，2≤R≤202 \\leq R \\leq 202≤R≤20\n 输出\n将101010进制整数转换为RRR进制的转换结果，超过999的数字符号显示为A、B、C……Z等字母。\n 样例输入\n110 16\n 样例输出\n1A\n 题解\n123456789101112131415161718#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstring decToR(int n, int r) {\n    string ans;\n    string digits = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;\n    while(n &gt; 0){\n        int m = n % r;\n        ans = digits[m] + ans;\n        n /= r;\n    }\n    return ans;\n}\nint main() {\n    int n, r;\n    cin &gt;&gt; n &gt;&gt; r;\n    cout &lt;&lt; decToR(n, r);\n    return 0;\n}\n 5\n 题目描述\n输入两个整数的求和式，比如1+2=，输出求和式和对应结果。请编程实现。\n 输入\n一个求和式，形如a+b=。\n 输出\n求和式及对应结果。\n 样例输入\n11+2=\n 样例输出\n11+2=3\n 题解\n12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint stoD(string s){\n    int a = 0, b = 0;\n    int i = 0;\n    while(s[i] != &#39;+&#39;){\n        a = 10 * a + (s[i] - &#39;0&#39;);\n        i ++;\n    }\n    i ++;\n    while(s[i] != &#39;=&#39;){\n        b = 10 * b + (s[i] - &#39;0&#39;);\n        i ++;\n    }\n    return a + b;\n}\nint main(){\n    string s;\n    cin &gt;&gt; s;\n    cout &lt;&lt; s &lt;&lt; stoD(s);\n    return 0;\n}\n 6\n 题目描述\n波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。\n 输入\n输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。\n 输出\n输出为一行，表达式的值(保留6位小数)。\n 样例输入\n1* + 11.0 12.0 + 24.0 35.0\n 样例输出\n11357.000000\n 题解\n12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ndouble operate() {\n    string s;\n    cin &gt;&gt; s;\n    switch (s[0]) {\n        case &#39;+&#39;:\n            return operate() + operate();\n        case &#39;-&#39;:\n            return operate() - operate();\n        case &#39;*&#39;:\n            return operate() * operate();\n        case &#39;/&#39;:\n            return operate() / operate();\n        default:\n            return stold(s);\n    }\n}\nint main() {\n    printf(&quot;%.6lf&quot;,operate());\n    return 0;\n}\n 7\n 题目描述\n上体育课的时候，老师已经把班级同学排成了两个队列，而且每个队列都是按照从底到高排好队，现在需要把两个队列合并，合并后需要保证还是从低到高排列。合并队列，你能编程实现吗？\n 输入\n第1行为nnn，表示开始排成的每个队列的长度。第2、3行是代表从小到大的nnn个整数，每行的整数间有一个空格间隔。\n 输出\n输出占一行，为从小到大的整数，每个整数间间隔一个空格。\n 样例输入\n1235\n1 3 5 8 15\n2 3 4 6 9\n 样例输出\n11 2 3 3 4 5 6 8 9 15\n 题解\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nqueue&lt;int&gt; a,b;\nqueue&lt;int&gt; merge(queue&lt;int&gt; a,queue&lt;int&gt; b) {\n    queue&lt;int&gt; c;\n    while (!a.empty() &amp;&amp; !b.empty()) {\n        if (a.front() &lt; b.front()) {\n            c.push(a.front());\n            a.pop();\n        }\n        else {\n            c.push(b.front());\n            b.pop();\n        }\n    }\n    while (!a.empty()) {\n        c.push(a.front());\n        a.pop();\n    }\n    while (!b.empty()) {\n        c.push(b.front());\n        b.pop();\n    }\n    return c;\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        a.push(x);\n    }\n    for (int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        b.push(x);\n    }\n    queue&lt;int&gt; c = merge(a,b);\n    for(int i = 0; i &lt; 2 * n; i++){\n        cout &lt;&lt; c.front() &lt;&lt; &#39; &#39;;\n        c.pop();\n    }\n    return 0;\n}\n","slug":"DataStructureTest01","date":"2023-05-31T08:37:34.000Z","categories_index":"data structure","tags_index":"data structure,coding","author_index":"Ivan Snow"},{"id":"333795d348e8e56df1fa020b8443f458","title":"栈与队列","content":"\n\n\n\n\n\n\n\n\n栈和队列可以说是最基本的数据结构了，它们都是在两端进行操作，其中栈在栈顶进行操作，被称为先进后出（LIFO），队列在队头和队尾进行操作，被称为先进先出（FIFO）\n\n 栈\n直接来看看API吧：\n API\n\n\n\npublic class Stack\n\n\n\n\n\nStack()\n构造一个空栈\n\n\nvoid push(Item item)\n入栈\n\n\nItem pop()\n出栈\n\n\nboolean isEmpty()\n判空\n\n\nint size()\n大小\n\n\n\n 链栈\n顾名思义，基于链表实现的栈\n其中的一个结点：\n1234private class Node {\n    Item item;\n    Node next;\n}\n完整代码：\n123456789101112131415161718192021public class LinkedStack&lt;Item&gt; {\n    private Node first = null;\n    private class Node {\n        Item item;\n        Node next;\n    }\n    public boolean isEmpty() { \n        return first == null; \n    }\n    public void push(Item item) {\n        Node oldfirst = first;\n        first = new Node();\n        first.item = item;\n        first.next = oldfirst;\n    }\n    public Item pop() {\n        Item item = first.item;\n        first = first.next;\n        return item;\n    }\n}\n 顺序栈\n基于数组（顺序表）实现的栈是顺序栈\n简单实现一个定长的栈：\n12345678910111213141516171819public class FixedCapacityStack&lt;Item&gt; {\n    private Item[] s;\n    private int N = 0;\n    public FixedCapacityStack(int capacity) { \n        s = (Item[]) new Object[capacity]; \n    } \n\n    public boolean isEmpty() { \n        return N == 0; \n    }\n\n    public void push(Item item) { \n        s[N++] = item; \n    }\n\n    public Item pop() { \n        return s[--N]; \n    }\n}\n但是定长的栈需要获取capacity，而这又需要客户端提供，然而大部分时间客户端是不知道所需的容量的。\n于是就有了动态长度的栈：\n ResizingArrayStack\n1234567891011121314151617181920212223public class ResizingArrayStack&lt;Item&gt; {\n    private Item[] s;\n    private int N = 0;\n    public ResizingArrayStack() { \n        s = (Item[]) new Object[1]; \n    } \n    public void push(Item item) {\n        if (N == s.length) resize(2 * s.length);\n        s[N++] = item;\n    }\n    public Item pop() { \n        return s[--N]; \n        s[N] = null;\n        if (N &gt; 0 &amp;&amp; N == s.length/4) resize(s.length/2);\n        return item;\n    }\n    private void resize(int capacity) {\n        Item[] copy = (Item[]) new Object[capacity];\n        for (int i = 0; i &lt; N; i++)\n            copy[i] = s[i];\n        s = copy;\n    }\n}\n此时pop和push操作的最坏时间复杂度也是O(N)O(N)O(N)。\n 迭代器\n我们可以为栈写一个迭代器：\n需要实现Iterator&lt;&gt;接口的hasNext和next方法，栈类也需要实现Iterable&lt;&gt;接口\n1234567891011121314151617public Iterator&lt;Item&gt; iterator() {\n    return new ListIterator();\n}\nprivate class ListIterator implements Iterator&lt;Item&gt; {\n    private Node current = first;\n    public boolean hasNext() {\n        return current != null;\n    }\n    public Item next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        Item item = current.item;\n        current = current.next;\n        return item;\n    }\n}\n123456789101112131415public Iterator&lt;Item&gt; iterator() {\n    return new ArrayIterator();\n}\nprivate class ArrayIterator implements Iterator&lt;Item&gt; {\n    private int i = N;\n    public boolean hasNext() {\n        return i &gt; 0;\n    }\n    public Item next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        return s[--N];\n    }\n}\n 队列\n队列是一种基于先进先出（FIFO）策略的集合类型\n API\n\n\n\npublic class Queue\n\n\n\n\n\nQueue()\n构造一个空队列\n\n\nvoid enqueue(Item item)\n入队\n\n\nItem dequeue()\n出队\n\n\nboolean isEmpty()\n判空\n\n\nint size()\n大小\n\n\n\n 链队\n直接贴代码，没什么好说的\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class LinkedQueue&lt;Item&gt; implements Iterable&lt;Item&gt;{\n    private Node first, last;\n    private class Node {\n        Item item;\n        Node next;\n    }\n\n    public boolean isEmpty() { \n        return first == null;\n    } \n\n    public void enqueue(Item item) {\n        Node oldlast = last;\n        last = new Node();\n        last.item = item;\n        last.next = null;\n        if (isEmpty()) first = last;\n        else oldlast.next = last;\n    }\n\n    public Item dequeue() {\n        Item item = first.item;\n        first = first.next;\n        if (isEmpty()) last = null;\n        return item;\n    }\n    \n    public Iterator&lt;Item&gt; iterator() {\n        return new ListIterator();\n    }\n    \n    private class ListIterator implements Iterator&lt;Item&gt; {\n        private Node current = first;\n        \n        public boolean hasNext() {\n            return current != null;\n        }\n        \n        public Item next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            Item item = current.item;\n            current = current.next;\n            return item;\n        }\n    }\n}\n 顺序队列\n顺序队列是基于顺序表的队列，其实一般都是循环队列，就是栈顶、栈底两个指针，front = (front + 1) ％ MaxSize，rear = (rear + 1) ％ MaxSize\n\n队空条件：rear == front\n队满条件：(rear + 1) % MaxSize == front\n元素进队：rear = (rear + 1) % MaxSize\n元素出队：front = (front + 1) % MaxSize\n\n1234567891011public void push(Item item)\t{ \n   if ((rear + 1) % MaxSize == front) return;\n   rear = (rear + 1) % MaxSize;\n   s[rear] = item;\n}\n\npublic Item pop() {  \n   if (front == rear) throw new NoSuchElementException();\n   front = (front + 1) % MaxSize;\n   return s[front];\n}\n","slug":"stack_and_queue","date":"2023-05-30T02:25:48.000Z","categories_index":"Algorithms, Part I","tags_index":"data structure,coding,algorithms,coursera","author_index":"Ivan Snow"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"\n\n\n\n\n\n\n\n\n本文来自Coursera的Algorithms, Part I课程\n 动态连通性\n 我们假设“相连”是一种等价关系，这也就意味 着它具有：\n\n自反性：p 和 p 是相连的\n对称性：如果 p 和 q 是相连的，那么 q 和 p 也是相连的\n传递性：如果 p 和 q 是相连的且 q 和 r 是相连的，那么 p 和 r 也是相连的\n\n 连通分量\n连通分量是相连元素组成的最大集合\n 查找\n检查两个元素是否在一个分量中\n 归并\n将两个分量归并到相同的分量中\n 并查集算法的API\n\n\n\npublic class UF\n\n\n\n\n\nUF(int N)\n以整数标识（ 0 到 N−1N-1N−1 ）初始化 NNN 个触点\n\n\nvoid union(int p, int q)\n在 p 和 q 之间添加一条连接\n\n\nint find(int p)\np（0 到 N−1N-1N−1 ）所在的分量的标识符\n\n\nboolean connected(int p, int q)\n如果 p 和 q 存在于同一个分量中则返回 true\n\n\nint count() \n连通分量的数量\n\n\n\n quick-find 算法\n 数据结构\n\n长度为 N 的整型数组 id[]\n当且仅当 p 和 q 有相同 id 时 p 和 q 连通\n\n123456private int[] id;\npublic QuickFindUF(int N) {\n    id = new int[N];\n    for (int i = 0; i &lt; N; i++)\n        id[i] = i;\n}\n find()\n返回根节点\n123public int root(int p) {\n    return id[p];\n}\n union()\n把要归并的所有连通分量的 id 改为另一个连通分量的 id\n123456public void union(int p, int q) {\n    int pid = id[p];\n    int qid = id[q];\n    for (int i = 0; i &lt; id.length; i++)\n        if (id[i] == pid) id[i] = qid;\n}\n 复杂度分析\n\n\n\n算法\n构造函数\nunion()\nfind()\n\n\n\n\nquick-find\nNNN\nNNN\n111\n\n\n\nunion操作过于复杂，很难运用于大型问题\n quick-union 算法\n 数据结构\n还是 id[] 数组，不过这次不用把所有的分量都改了，一种“偷懒”算法，即尽量避免计算直到不得不进行计算\n12345private int[] id;\npublic QuickUnionUF(int N) {\n    id = new int[N];\n    for (int i = 0; i &lt; N; i++) id[i] = i;\n}\n find()\n返回根节点\n1234private int find(int i) {\n    while (i != id[i]) i = id[i];\n    return i;\n}\n union()\n把要归并的连通分量的根节点的 id 改为另一个连通分量根节点的 id\n12345public void union(int p, int q){\n    int i = find(p);\n    int j = find(q);\n    id[i] = j;\n}\n 复杂度分析\n\n\n\n算法\n构造函数\nunion()\nfind()\n\n\n\n\nquick-union\nNNN\nNNN（包括查找根节点，取决于树的高度）\nNNN（取决于树的高度）\n\n\n\nunion操作过于复杂，很难运用于大型问题\n 改进\n 加权 quick-union 算法\n就是将小树连接到大树来降低高度\n\n我们需要一个额外的数组 sz[] 来记录以 i 为根节点的树的大小，只要在 union 方法中加入三行：\n123456789101112public void union(int p, int q){\n    int i = find(p);\n    int j = find(q);\n    id[i] = j;\n    if (i == j) return;\n    if (sz[i] &lt; sz[j]) {\n        id[i] = j; sz[j] += sz[i];\n    } \n    else {\n        id[j] = i; sz[i] += sz[j];\n    }\n}\n 复杂度分析\n\n\n\n算法\n构造函数\nunion()\nfind()\n\n\n\n\nweighted QU\nNNN\nlg⁡N\\lg NlgN（包括查找根节点）\nlg⁡N\\lg NlgN\n\n\n\n\n\n\n\n\n\n\n\n\n我们能不能再进一步？\n 使用路径压缩的加权 quick-union 算法\n\n\n\n\n\n\n\n\n\n顾名思义，就是路径压缩（\n为了简化路径压缩，直接加上一行代码就行了，将路径上每个节点指向它在路径上的祖父节点。这种实现不如完全展平好，但在实际应用中两者差不多一样好：\n1234567private int find(int i) {\n    while (i != id[i]) {\n        id[i] = id[id[i]];\n        i = id[i];\n    }\n    return i;\n}\n 复杂度分析\n\n\n\n算法\n构造函数\nunion()\nfind()\n\n\n\n\nweighted QU\nNNN\n非常接近线性\n1（均摊 成本）\n\n\n\n","slug":"Union-Find","date":"2023-05-21T10:02:45.000Z","categories_index":"Algorithms, Part I","tags_index":"data structure,coding,algorithms,coursera","author_index":"Ivan Snow"},{"id":"9a4a3c848f25d7dc5b1593149d8fc72a","title":"数据结构之线性表","content":"\n\n\n\n\n\n\n\n\n这是一系列关于数据结构的笔记博客，为了练习自己的代码能力，咱将尽可能不使用C++来实现这些数据结构\n 线性表的简单介绍\n\n线性表是具有相同特性的数据元素的一个有限序列。\n所有数据元素类型相同。\n线性表是有限个数据元素构成的。\n线性表中数据元素与位置相关，即每个数据元素有唯一的序号。\n\n咱们的线性表需要如下的方法：\n123456789createList(a[])：由整数数组a中的全部元素建立线性表的相应存储结构。\nadd(e)：将元素e添加到线性表末尾。\ngetLength()：求线性表的长度。\ngetElem(i)：求线性表中序号为i的元素。\nsetElem(i, e)：设置线性表中序号i的元素值为e。\ngetNo(e)：求线性表中第一个值为e的元素的序号。\ninsert(i, e)：在线性表中插入数据元素e作为第i个元素。\ndelete(i)：在线性表中删除第i个数据元素。\ndispList()：输出线性表的所有元素。\n 顺序表\n顺序表是线性表中的顺序存储结构，通常是一段连续的空间。\n123456const initCap = 5\ntype SqList struct {\n\tdata []int\n\tcapacity int\n\tlength int\n}\n 方法\n 构造函数(伪)\n1234567func NewSqList() SqList {\n    return SqList{\n        data:     make([]interface{}, initCap),//用切片将就着吧\n        capacity: initCap,\n        Length:   0,\n    }\n}\n 重新调整容量\n其实是多此一举\n1234567891011func (list *SqList) reCap(newCap int) {\n    if newCap &lt;= 0 {\n        return\n    }\n    list.capacity = newCap\n    var newData = make([]interface{}, newCap)\n    for i := 0; i &lt; list.Length; i++ {\n        newData[i] = list.data[i]\n    }\n    list.data = newData\n}\n 建表\n123456789func (list *SqList) CreateList(a []interface{}, n int) {\n    for i := 0; i &lt; n; i++ {\n        if list.Length == list.capacity {\n            list.reCap(2 * list.Length)\n        }\n        list.data[list.Length] = a[i]\n        list.Length++\n    }\n}\n 添加元素\n1234567func (list *SqList) Add(e interface{}) {\n    if list.Length == list.capacity {\n        list.reCap(2 * list.Length)\n    }\n    list.data[list.Length] = e\n    list.Length++\n}\n 修改元素\n1234567func (list *SqList) SetElem(i int, e interface{}) bool {\n    if i &lt;= 0 || i &gt;= list.Length {\n        return false\n    }\n    list.data[i] = e\n    return true\n}\n 查找\n12345678func (list *SqList) GetNo(e interface{}) int {\n    for i := 0; i &lt; list.Length; i++ {\n        if list.data[i] == e {\n            return i\n        }\n    }\n    return -1\n}\n 插入\n1234567891011121314func (list *SqList) Insert(i int, e interface{}) bool {\n    if i &lt;= 0 || i &gt;= list.Length {\n        return false\n    }\n    if list.Length == list.capacity {\n        list.reCap(2 * list.Length)\n    }\n    for j := list.Length; j &gt; i; j-- {\n        list.data[j] = list.data[j-1]\n    }\n    list.data[i] = e\n    list.Length++\n    return true\n}\n 删除\n12345678910111213func (list *SqList) Delete(i int) bool {\n    if i &lt;= 0 || i &gt;= list.Length {\n        return false\n    }\n    for j := i; j &lt; list.Length-1; j++ {\n        list.data[j] = list.data[j+1]\n    }\n    list.Length--\n    if list.capacity &gt; initCap &amp;&amp; list.Length &lt;= list.capacity/4 {\n        list.reCap(list.capacity / 2)\n    }\n    return true\n}\n 打印\n1234567func (list *SqList) DispList() {\n    fmt.Print(&quot;顺序表内容是:[&quot;)\n    for i := 0; i &lt; list.Length-1; i++ {\n        fmt.Print(list.data[i], &quot;,&quot;)\n    }\n    fmt.Print(list.data[list.Length-1], &quot;]\\n&quot;)\n}\n 链表\n链表是线性表的链式存储结构，这边就实现一个单链表好了\n\n\n结点\n1234type LinkNode struct {\n\tdata interface{}\n\tnext *LinkNode\n}\n\n\n链表\n12345type LinkList struct {\n\thead   *LinkNode\n\ttail   *LinkNode\n\tlength int\n}\n\n\n 方法\n 构造函数（伪）\n\n\n结点\n1234567891011func NewLinkNode() *LinkNode {\n\treturn &amp;LinkNode{\n\t\tnext: nil,\n\t}\n}\nfunc NewLinkNodeWithData(d interface{}) *LinkNode {\n\treturn &amp;LinkNode{\n\t\tdata: d,\n\t\tnext: nil,\n\t}\n}\n\n\n链表\n1234567func NewLinkList() *LinkList {\n\treturn &amp;LinkList{\n\t\thead:   NewLinkNode(),\n\t\ttail:   NewLinkNode(),\n\t\tlength: 0,\n\t}\n}\n\n\n 建表\n\n\n头插法\n123456// CreateListF 头插法建表\nfunc (l *LinkList) CreateListF(a []interface{}, n int) {\n\tfor i := 0; i &lt; n; i++ {\n\t\tl.Insert(0, a[i])\n\t}\n}\n\n\n尾插法\n123456// CreateListR 尾插法建表\nfunc (l *LinkList) CreateListR(a []interface{}, n int) {\n\tfor i := 0; i &lt; n; i++ {\n\t\tl.Insert(i, a[i])\n\t}\n}\n\n\n 插入\n12345678910111213141516171819// Insert 在第i个位置插入元素\nfunc (l *LinkList) Insert(i int, e interface{}) bool {\n\tif i &lt; 0 {\n\t\treturn false\n\t}\n\ts := NewLinkNodeWithData(e)\n\tp := l.GetI(i - 1)\n\tif p != nil {\n\t\ts.next = p.next\n\t\tp.next = s\n\t\tif s.next == nil {\n\t\t\tl.tail = s\n\t\t}\n\t\tl.length++\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n 返回第i个元素\n12345678// GetI 返回第i个元素\nfunc (l *LinkList) GetI(i int) *LinkNode {\n\tp := l.head\n\tfor j := -1; j &lt; i &amp;&amp; p != nil; j++ {\n\t\tp = p.next\n\t}\n\treturn p\n}\n 打印\n12345678func (l *LinkList) DispList() {\n\tp := l.head.next\n\tfor p != nil {\n\t\tfmt.Print(p.data, &quot; &quot;)\n\t\tp = p.next\n\t}\n\tfmt.Println()\n}\n 删除\n1234567891011121314151617181920// Delete 在单链表中删除序号i位置的结点\nfunc (l *LinkList) Delete(i int) bool {\n\tif i &lt; 0 {\n\t\treturn false\n\t}\n\tp := l.GetI(i - 1)\n\tif p != nil {\n\t\tq := p.next\n\t\tif q != nil {\n\t\t\tp.next = q.next\n\t\t\tq = nil\n\t\t\tl.length--\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\treturn false\n\t}\n}\n 修改元素\n123456789101112// SetElem 设置序号i的结点值\nfunc (l *LinkList) SetElem(i int, e interface{}) bool {\n\tif i &lt; 0 {\n\t\treturn false\n\t}\n\tp := l.GetI(i)\n\tif p != nil {\n\t\tp.data = e\n\t\treturn true\n\t}\n\treturn false\n}\n 查找\n12345678910111213// GetNo 查找第一个为e的元素的序号\nfunc (l *LinkList) GetNo(e interface{}) int {\n\tno := 0\n\tp := l.head.next\n\tfor p != nil &amp;&amp; p.data != e {\n\t\tno++\n\t\tp = p.next\n\t}\n\tif p == nil {\n\t\treturn -1\n\t}\n\treturn no\n}\n 添加元素\n1234// Add 在末尾添加元素\nfunc (l *LinkList) Add(e interface{}) {\n\tl.Insert(l.length, e)\n}\n","slug":"List","date":"2023-05-17T07:35:23.000Z","categories_index":"data structure","tags_index":"data structure,coding","author_index":"Ivan Snow"},{"id":"6ceda27f62dfcd4edcca9c255f5ff0a8","title":"Sports Life Lesson","content":"As Aristotle said, “Life needs sports.” Sport, in its various forms, is an integral part of human culture that transcends geographical, cultural, and linguistic boundaries. It is not only an avenue to maintain a better figure or a source of entertainment, but also a powerful means of character development and learning essential life lessons. Today, we will discuss some of the most important life lessons that sport can offer us beyond the playing field or court.\nFirst and foremost, sport teaches us the value of hard work and perseverance. Higher, Faster, Stronger - the road to the top never comes to an end and being an athlete requires years of training, sweating and discipline. These qualities of dedication and hard work are essential for success in any endeavor, not just sport. When facing challenges, athletes learn to push themselves through adversity and focus on their goals.\nAnother lesson sport can teach us is how to work as a team. Most sports require cooperation as a team to achieve a common goal, such as scoring points or winning a match. Learning to work together, communicate effectively, and trust one another is crucial for success in any team-oriented environment.\nAdditionally, sport helps individuals develop a strong sense of self-confidence and self-awareness. As athletes improve their skills and achieve personal milestones, they gain confidence in their abilities, which can carry over to other areas of life. At the same time, sport requires individuals to recognize their strengths and weaknesses, promoting self-awareness and personal growth.\nSport has the power to change the world. The lessons learned on the field can have a lasting impact on an individual’s life and guide them to success.\n","slug":"Sports-Life-Lesson","date":"2023-05-14T02:16:25.000Z","categories_index":"English","tags_index":"English","author_index":"Ivan Snow"},{"id":"9ae1faec43a5cc6a5b23d428a7b7e9ed","title":"Redis实战——黑马点评","content":"就是黑马程序员的Redis教程里的黑马点评的项目，前面就不讲了，直接开始正题。\n 基于Session实现登录流程\n分为三个步骤：\n\n发送验证码\n短信验证码登录、注册\n校验登录状态\n\n 发送验证码\n 逻辑：\n用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号\n如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户\n\n 代码\n12345678910111213@Override\npublic Result sendCode(String phone, HttpSession session) {\n    //校验手机号，不符合就返回错误，符合就生成验证码\n    if (RegexUtils.isPhoneInvalid(phone)){\n        return Result.fail(&quot;手机号格式错误！&quot;);\n    }\n    String code = RandomUtil.randomNumbers(6);\n    //保存验证码到session\n    session.setAttribute(&quot;code&quot;,code);\n    //发送验证码\n    log.debug(&quot;发送短信验证码成功，验证码：&quot; + code);\n    return Result.ok();\n}\n 短信验证码登录、注册\n 逻辑：\n用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息\n\n 代码\n12345678910111213141516171819202122232425@Override\npublic Result login(LoginFormDTO loginForm, HttpSession session) {\n    //校验手机号和验证码\n    String phone = loginForm.getPhone();\n    if (RegexUtils.isPhoneInvalid(phone)){\n        return Result.fail(&quot;手机号格式错误！&quot;);\n    }\n    Object cacheCode = session.getAttribute(&quot;code&quot;);\n    String code = loginForm.getCode();\n    //不一致，报错\n    if(cacheCode == null || !cacheCode.toString().equals(code)) {\n        return Result.fail(&quot;验证码错误&quot;);\n    }\n\n    //一致，根据手机号查用户\n    User user = query().eq(&quot;phone&quot;, phone).one();\n\n    //判断是否存在\n    if (user == null) {\n        //不存在，创建用户\n        user = createUserWithPhone(phone);\n    }\n    session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));\n    return Result.ok();\n}\n 校验登录状态\n校验登录状态需要配置拦截器来实现登录拦截功能\n 原理\n当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应。\n每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据\n 逻辑\n用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行\n\n 代码\n\n首先实现HandlerInterceptor接口\n\n12345678910111213141516171819202122232425public class LoginInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        //Get session\n        HttpSession session = request.getSession();\n        //Get user from session\n        Object user = session.getAttribute(&quot;user&quot;);\n        //if user exists\n        if (user == null) {\n            //not exists, reject, return 401\n            response.setStatus(401);\n            return false;\n        }\n        //save user in ThreadLocal\n        UserHolder.saveUser((UserDTO) user);\n\n        return true;\n    }\n\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        UserHolder.removeUser();\n    }\n}\n\n然后是MvcConfig\n\n1234567891011121314@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor()).excludePathPatterns(\n                &quot;/user/code&quot;,\n                &quot;/user/login&quot;,\n                &quot;/blog/hot&quot;,\n                &quot;/shop/**&quot;,\n                &quot;/shop-type/**&quot;,\n                &quot;/voucher/**&quot;\n        );\n    }\n}\n session共享问题\n每个Tomcat中都有一份属于自己的session,假设用户第一次访问第一台Tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台Tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个Tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了\n但是这种方案有两个大问题\n\n\n每台服务器中都有完整的一份session数据，服务器压力过大。\n\n\nsession拷贝数据时，可能会出现延迟\n\n\n所以咱们要基于Redis来完成，我们把session换成Redis，Redis数据本身就是共享的，就可以避免session共享的问题了\n\n Redis代替session的业务流程\n 设计key\n我们可以生成一个随机字符串token，来存储。这样既可以满足唯一性也可以满足脱敏性。\n 整体流程\n当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到Redis，并且生成token作为Redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从Redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。\n\n 代码\n直接上代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n    @Override\n    public Result sendCode(String phone, HttpSession session) {\n        //校验手机号，不符合就返回错误，符合就生成验证码\n        if (RegexUtils.isPhoneInvalid(phone)){\n            return Result.fail(&quot;手机号格式错误！&quot;);\n        }\n        String code = RandomUtil.randomNumbers(6);\n        //保存验证码到Redis\n        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);\n        //发送验证码\n        log.debug(&quot;发送短信验证码成功，验证码：&quot; + code);\n\n        return Result.ok();\n    }\n\n    @Override\n    public Result login(LoginFormDTO loginForm, HttpSession session) {\n        //校验手机号和验证码\n        String phone = loginForm.getPhone();\n        if (RegexUtils.isPhoneInvalid(phone)){\n            return Result.fail(&quot;手机号格式错误！&quot;);\n        }\n        // 从redis获取验证码并校验\n        String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);\n        String code = loginForm.getCode();\n        //不一致，报错\n        if(cacheCode == null || !cacheCode.equals(code)) {\n            return Result.fail(&quot;验证码错误&quot;);\n        }\n\n        //一致，根据手机号查用户\n        User user = query().eq(&quot;phone&quot;, phone).one();\n\n        //判断是否存在\n        if (user == null) {\n            //不存在，创建用户\n            user = createUserWithPhone(phone);\n        }\n        // 保存用户信息到 redis中\n        // 随机生成token，作为登录令牌\n        String token = UUID.randomUUID().toString(true);\n        // 将User对象转为HashMap存储\n        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);\n        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap\n                (userDTO, new HashMap&lt;&gt;(),\n                CopyOptions.create()\n                        .setIgnoreNullValue(true)\n                        .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));\n        // 存储\n        String tokenKey = LOGIN_USER_KEY + token;\n        stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);\n        // 设置token有效期\n        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);\n        return Result.ok(token);\n    }\n12345678910111213141516@Configuration\npublic class MvcConfig implements WebMvcConfigurer {\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)).excludePathPatterns(\n                &quot;/user/code&quot;,\n                &quot;/user/login&quot;,\n                &quot;/blog/hot&quot;,\n                &quot;/shop/**&quot;,\n                &quot;/shop-type/**&quot;,\n                &quot;/voucher/**&quot;\n        );\n    }\n}\n1234567891011121314151617181920212223242526272829303132333435363738394041public class LoginInterceptor implements HandlerInterceptor {\n    private StringRedisTemplate stringRedisTemplate;\n\n    public LoginInterceptor(StringRedisTemplate stringRedisTemplate) {\n        this.stringRedisTemplate = stringRedisTemplate;\n    }\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        //Get token in Header\n        String token = request.getHeader(&quot;authorization&quot;);\n        if (StrUtil.isBlank(token)) {\n            //not exists, reject, return 401\n            response.setStatus(401);\n            return false;\n        }\n        String key = RedisConstants.LOGIN_USER_KEY + token;\n        //Get user from Redis\n        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);\n        //if user exists\n        if (userMap.isEmpty()) {\n            //not exists, reject, return 401\n            response.setStatus(401);\n            return false;\n        }\n        //turn Hash to UserDTO\n        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);\n        //save user in ThreadLocal\n        UserHolder.saveUser(userDTO);\n\n        // refresh token TTL\n        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);\n        return true;\n    }\n\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        UserHolder.removeUser();\n    }\n}\n","slug":"heimadianping","date":"2023-05-12T09:47:54.000Z","categories_index":"Redis","tags_index":"coding,Redis,Java,Spring","author_index":"Ivan Snow"},{"id":"e734ef48d2ce2470a46681dcf2eb2449","title":"SpringDataRedis","content":" Redis的Java客户端\nRedis的客户端可以在Redis官网找到，推荐的客户端包括：\n\nJedis：以Redis命令作为方法名称，学习成本低，简单实用。但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用\nLettuce：Lettuce是基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式和管道模式\nRedisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求\n\n Jedis\n\n\n\n\n\n\n\n\n\nJedis官网\n Jedis快速入门\n 导入依赖\n123456789101112&lt;!--jedis--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n    &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;version&gt;4.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;\n    &lt;version&gt;5.9.2&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n 建立连接\n1234567891011private Jedis jedis;\n\n@BeforeEach\nvoid setUp() {\n    // 1.建立连接\n    jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);\n    // 2.设置密码\n    //jedis.auth(&quot;&quot;);\n    // 3.选择库\n    jedis.select(0);\n}\n 测试\n123456789101112131415161718@Test\nvoid testString() {\n    // 存入\n    String result = jedis.set(&quot;name&quot;, &quot;Snow San&quot;);\n    System.out.println(&quot;result = &quot; + result);\n    // 获取\n    String name = jedis.get(&quot;name&quot;);\n    System.out.println(&quot;name = &quot; + name);\n}\n@Test\nvoid testHash() {\n    // 插入\n    jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Snow San&quot;);\n    jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;18&quot;);\n    // 获取\n    Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;);\n    System.out.println(map);\n}\n 释放资源\n123456@AfterEach\nvoid destroy() {\n    if (jedis != null) {\n        jedis.close();\n    }\n}\n Jedis连接池\nJedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池~\n123456789101112131415161718192021222324import redis.clients.jedis.*;\n\npublic class JedisConnectionFactory {\n\n    private static JedisPool jedisPool;\n\n    static {\n        // 配置连接池\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(8);\n        poolConfig.setMaxIdle(8);\n        poolConfig.setMinIdle(0);\n        poolConfig.setMaxWaitMillis(1000);\n        // 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码\n        jedisPool = new JedisPool(poolConfig, \n                                  &quot;127.0.0.1&quot;, \n                                  6379, \n                                  1000, \n                                  &quot;&quot;);//密码在此（\n    }\n    public static Jedis getJedis(){\n        return jedisPool.getResource();\n    }\n}\n SpringDataRedis客户端\n接下来就是本次的主角啦！\nSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，SpringDataRedis官网\nta的特点如下：\n\n提供了对不同Redis客户端的整合（Lettuce和Jedis）\n提供了RedisTemplate统一API来操作Redis\n支持Redis的发布订阅模型\n支持Redis哨兵和Redis集群\n支持基于Lettuce的响应式编程\n支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化\n支持基于Redis的JDKCollection实现\n\nSpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中\n SpringDataRedis快速入门\n 新建一个boot项目\n别说你连boot项目都不会建\n 引入依赖\n要引入spring-boot-starter-data-redis,commons-pool2和jackson-databind，不过貌似MVC已经整合了jackson？\n懒的话整个lombok\n123456789101112131415&lt;!--redis依赖--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--common-pool--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n\t&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--Jackson依赖--&gt;\n&lt;dependency&gt;\n\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n&lt;/dependency&gt;\n 配置Redis\n说到boot果然就是yaml呢~~（笑）~~\n1234567891011spring:\n  data:\n    redis:\n      host: 0.0.0.0\n      port: 6379\n      lettuce:\n        pool:\n          max-active: 8\n          max-idle: 8\n          min-idle: 0\n          max-wait: 1000ms\n 注入RedisTemplate\n12@Autowired\nprivate RedisTemplate redisTemplate;\n 测试！\n12345678@Test\nvoid testString() {\n    // 写入\n    redisTemplate.opsForValue().set(&quot;name&quot;, &quot;Snow San&quot;);\n    // 获取\n    Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;);\n    System.out.println(&quot;name = &quot; + name);\n}\n 自定义序列化~~（白雪）~~\nRedisTemplate可以接收任意Object作为值写入Redis,但在写入前会把Object序列化为字节形式，默认是采用JDK序列化，缺点是：\n\n可读性差\n内存占用较大\n\n因此可以自定义RedisTemplate的序列化方式，采用JSON序列化来代替默认的JDK序列化方式\n12345678910111213141516171819@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory){\n        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();\n        template.setConnectionFactory(connectionFactory);\n        // 创建JSON序列化工具\n        GenericJackson2JsonRedisSerializer jsonRedisSerializer = \n            new GenericJackson2JsonRedisSerializer();\n        // 设置Key的序列化\n        template.setKeySerializer(RedisSerializer.string());\n        template.setHashKeySerializer(RedisSerializer.string());\n        // 设置Value的序列化\n        template.setValueSerializer(jsonRedisSerializer);\n        template.setHashValueSerializer(jsonRedisSerializer);\n        // 返回\n        return template;\n    }\n}\nJSON序列化在查询时还能自动把JSON反序列化为Java对象，注意@class字段，ta会带来额外的内存开销\n StringRedisTemplate\n为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。\n不过当需要存储Java对象时，必须手动完成对象的序列化和反序列化\n12345678910111213141516171819202122232425262728@Autowired\nprivate StringRedisTemplate stringRedisTemplate;\n\n@Test\nvoid testString() {\n    // 写入\n    stringRedisTemplate.opsForValue().set(&quot;verify:phone:11111111&quot;, &quot;123456&quot;);\n    // 获取\n    Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;);\n    System.out.println(&quot;name = &quot; + name);\n}\n\nprivate static final ObjectMapper mapper = new ObjectMapper();\n\n@Test\nvoid testSaveUser() throws JsonProcessingException {\n    // 创建对象\n    User user = new User(&quot;Snow&quot;, 18);\n    // 手动序列化\n    String json = mapper.writeValueAsString(user);\n    // 写入\n    stringRedisTemplate.opsForValue().set(&quot;user:1&quot;, json);\n    // 获取\n    String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:1&quot;);\n    // 手动反序列化\n    User user1 = mapper.readValue(jsonUser, User.class);\n    System.out.println(&quot;user1 = &quot; + user1);\n}\n","slug":"Redis-Learning-03-SpringDataRedis","date":"2023-05-10T13:05:27.000Z","categories_index":"Redis","tags_index":"coding,Redis,Java","author_index":"Ivan Snow"},{"id":"3d9d8863a52feda63ba7c666e672315d","title":"习近平新时代中国特色社会主义思想概论","content":"\n\n 第一讲 马克思主义中国化新飞跃\n 一、习近平新时代中国特色社会主义思想如何创立的\n 时代背景：&quot;两个大局&quot;同步交织\n两个大局：中华民族伟大复兴的战略全局；世界百年未有之大变局。\n\n世界百年未有之大变局加速演进，世界百年未有之大变局概括起来说就是 ：\n\n当前国际格局和国际体系正在发生深刻调整\n全球治理体系正在发生深刻变革\n国际力量对比正在发生近代以来最具革命性的变化\n世界范围呈现出影响人类历史进程和趋向的\n中华民族伟大复兴正处于关键时期\n中华民族迎来了从站起来、富起来到强起来的伟大飞跃，实现中华民族伟大复兴进入了不可逆转的历史进程。\n中华民族伟大复兴，是造成世界百年未有之大变局的重要原因；世界面临百年未有之大变局给中华民族伟大复兴带来重大机遇。\n\n\n\n 历史方位：中国特色社会主义进入新时代\n\n\n社会主要矛盾变化是进入新时代的重要依据\n\n改革开放后，我国社会主要矛盾是人民日益增长的物质文化需要同落后的社会生产之间的矛盾。进入新时代，人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全和环境等方面的要求日益增长。我国社会生产力水平总体上显著提高，更加突出的问题是发展的不平衡不充分。我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。主要矛盾的变化，虽然没有改变我们对我国社会主义所处历史阶段的判断，但却是关系全局的历史性变化。\n\n\n\n新时代是什么样的时代？\n\n\n是承前启后、继往开来、在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代\n\n\n是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代\n\n\n是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代\n\n\n是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代\n\n\n是我国不断为人类作出更大贡献的时代\n\n\n\n\n进入新时代意味着什么？\n\n\n意味着中华民族迎来了从站起来、富起来到强起来的伟大飞跃\n\n\n意味着科学社会主义在二十一世纪的中国焕发出强大生机活力\n\n\n意味着拓展了发展中国家走向现代化的途径，为解决人类问题贡献了中国智慧和中国方案\n\n\n\n\n 实践基础：历史性成就、历时性变革\n\n\n十三个方面的标志性成果\n\n\n\n\n\n 基本方法：“两个结合”\n\n\n两个结合的内涵\n\n坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合。\n\n\n\n 二、习近平新时代中国特色社会主义思想回答了什么课题\n\n\n坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义\n\n\n建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国\n\n\n建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党\n\n\n 三、习近平新时代中国特色社会主义思想主要包含哪些内容\n “十个明确”\n\n\n明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，中国共产党是最高政治领导力量，全党必须增强&quot;四个意识&quot;、坚定&quot;四个自信&quot;、做到&quot;两个维护&quot;。\n\n\n明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国，以中国式现代化推进中华民族伟大复兴。\n\n\n明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，发展全过程人民民主，推动人的全面发展、全体人民共同富裕取得更为明显的实质性进展。\n\n\n明确中国特色社会主义事业总体布局是经济建设、政治建设、文化建设、社会建设、生态文明建设五位一体，战略布局是全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党四个全面。\n\n\n明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。\n\n\n明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家。\n\n\n明确必须坚持和完善社会主义基本经济制度，使市场在资源配置中起决定性作用，更好发挥政府作用，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展，统筹发展和安全。\n\n\n明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队。\n\n\n明确中国特色大国外交要服务民族复兴、促进人类进步，推动建设新型国际关系，推动构建人类命运共同体。\n\n\n明确全面从严治党的战略方针，提出新时代党的建设总要求，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，落实管党治党政治责任，以伟大自我革命引领伟大社会革命。\n\n\n “十四个坚持”\n\n\n\n 四、如何理解习近平新时代中国特色社会主义思想的历史地位\n\n\n当代中国马克思主义、二十一世纪马克思主义\n\n\n中华文化和中国精神的时代精华\n\n\n马克思主义中国化的新飞跃\n\n\n深刻领悟&quot;两个确立&quot;的决定性意义\n\n\n 第二讲 坚持和发展中国特色社会主义总任务\n 一、为什么说实现中华民族伟大复兴进入了不可逆转的历史进程\n 中华民族近代以来最伟大的梦想\n\n\n中华文明源远流长、博大精深，是中华民族独特的精神标识，是当代中国文化的根基，是维系全世界华人的精神纽带，也是中国文化创新的宝藏；\n\n\n我国从十九世纪四十年代起，到二十世纪四十年代中期，全世界几乎一切大中小帝国主义国家都侵略过我国，没有一次战争不是以我国失败、签订丧权辱国条约而告终。其原因：一是社会制度腐败，二是经济技术落后。\n\n\n中国产生了共产党，这是开天辟地的大事变\n\n\n原因：\n\n深刻改变了近代以后中华民族发展的方向和进程；\n深刻改变了中国人民和中华民族的前途和命运；\n深刻改变了世界发展的趋势和格局。\n\n\n\n实现中华民族伟大复兴是党百年奋斗的主题\n\n\n一百年来，中国共产党团结带领中国人民进行的一切奋斗、一切牺牲、一切创造，归结起来就是一个主题：实现中华民族伟大复兴。\n\n\n新民主主义革命时期，党面临的主要任务是，反对帝国主义、封建主义、官僚资本主义，争取民族独立、人民解放，为实现中华民族伟大复兴创造根本社会条件。\n\n\n社会主义革命和建设时期，党面临的主要任务是，实现从新民主主义到社会主义的转变，进行社会主义革命，推进社会主义建设，为实现中华民族伟大复兴奠定根本政治前提和制度基础。\n\n\n改革开放和社会主义现代化建设新时期，党面临的主要任务是，继续探索中国建设社会主义的正确道路，解放和发展社会生产力，使人民摆脱贫困、尽快富裕起来，为实现中华民族伟大复兴提供充满新的活力的体制保证和快速发展的物质条件。\n\n\n中国特色社会主义新时代，党面临的主要任务是，实现第一个百年奋斗目标，开启实现第二个百年奋斗目标新征程，朝着实现中华民族伟大复兴的宏伟目标继续前进。\n\n\n\n\n 中华民族伟大复兴展现出前所未有的光明前景：从站起来到富起来，到迎来强起来\n\n\n&quot;中国梦&quot;是中华民族伟大复兴的形象表达；\n\n\n&quot;中国梦&quot;的本质是国家富强、民族振兴、人民幸福；\n\n\n中国梦归根到底是人民的梦，其最深沉的根基在中国人民心中。\n\n\n中国梦同世界人民的梦想息息相通，是追求和平的梦，贡献世界的梦。\n\n\n今天，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴的目标，作为这一判断的底气在于我国发展具有诸多过去难以想象的战略性有利条件：有中国共产党的坚强领导；有中国特色社会主义制度的显著优势；有持续快速发展积累的坚实基础；有长期稳定的社会环境；有自信自强的精神力量。\n\n\n 实现中华民族伟大复兴的艰巨性、复杂性和长期性\n\n\n中华民族伟大复兴不是轻轻松松、敲锣打鼓就能实现的，必须勇于进行具有许多新的历史特点的伟大斗争。\n\n\n依靠顽强斗争打开事业发展新天地。\n\n应对重大挑战、抵御重大风险、克服重大阻力、解决重大矛盾，必须进行具有许多新的历史特点的伟大斗争。\n最根本的是要把我们自己的事情做好，包括：\n\n实现中国梦必须走中国道路------中国特色社会主义道路；\n实现中国梦必须弘扬中国精神------以爱国主义为核心的民族精神和以改革创新为核心的时代精神；\n实现中国梦必须凝聚中国力量------中国各族人民大团结的力量。\n\n\n\n\n\n 二、如何理解中国特色社会主义是实现中华民族伟大复兴的必由之路\n 党和人民长期奋斗取得的根本成就\n\n\n方向决定道路、道路决定命运\n\n\n我们党在革命、建设、改革各个历史时期，坚持从我国国情出发，探索并形成了符合中国实际的新民主主义革命道路、社会主义改造和社会主义建设道路、中国特色社会主义道路。\n\n\n道路问题是关系党的事业兴衰成败第一位的问题，道路就是党的生命\n\n\n\n\n中国特色社会主义不是从天上掉下来的\n\n\n从历史纵深中走来：是在改革开放40年的伟大实践中得来的，是在中华人民共和国成立近70年的持续探索中得来的，是在我们党领导人民进行伟大社会革命97年的实践中得来的，是在近代以来中华民族由衰到盛170多年的历史进程中得来的，是对中华文明5000多年的传承发展中得来的。\n\n\n走自己的路，是党百年奋斗得出的历史结论\n\n\n\n\n 思考：如何正确认识改革开放前后两个历史时期的关系？\n\n\n如果没有1949年建立新中国并进行社会主义革命和建设，积累了重要的思想、物质、制度条件，积累了正反两方面经验，改革开放也很难顺利推进。\n\n\n两个历史时期虽有很大差别，但决不是彼此割裂的，更不是根本对立的。\n\n\n不能用改革开放后的历史时期否定改革开放前的历史时期，也不能用改革开放前的历史时期否定改革开放后的历史时期。\n\n\n中国特色社会主义道路是创造人民美好生活、实现中华民族伟大复兴的康庄大道。只要我们既不走封闭僵化的老路，也不走改旗易帜的邪路，坚定不移走中国特色社会主义道路，就一定能够实现中华民族伟大复兴。\n\n\n 中国特色社会主义是社会主义而不是其他什么主义\n\n\n廓清对中国特色社会主义的认识迷雾\n\n\n近些年来，国内外有些舆论提出中国现在搞的究竟还是不是社会主义的疑问，有人说是&quot;资本社会主义&quot;，还有人干脆说是&quot;国家资本主义&quot;\n“新官僚资本主义”，这些都是完全错误的。\n\n\n一些人反复炒作&quot;国家资本主义&quot;“资本社会主义”&quot;新官僚资本主义&quot;的目的，就是为遏制中国制造舆论，企图通过抹黑中国社会制度，动摇人们对中国特色社会主义的信心，迫使我们放弃被实践所证明的成功道路和制度。\n\n\n\n\n中国特色社会主义的科学社会主义性质\n\n\n科学社会主义基本原则不能丢，丢了就不是社会主义。这些原则包括：\n\n无产阶级政党是无产阶级的先锋队，社会主义事业必须坚持无产阶级政党的领导；\n无产阶级革命是无产阶级进行斗争的最高形式，必须以建立无产阶级专政的国家为目的；\n在生产资料公有制基础上组织生产，满足全体社会成员的需要是社会主义生产的根本目的；\n对社会生产进行有计划的指导和调节，实行等量劳动领取等量产品的按劳分配原则；\n通过无产阶级专政和社会主义高度发展最终实现向消灭阶级、消灭剥削、实现人的全面而自由发展的共产主义社会的过渡。\n\n\n\n中国特色社会主义坚持了科学社会主义基本原则并赋予其鲜明中国特色，表现在：\n\n领导力量------中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，党是最高政治领导力量；\n国体和政体：实行人民民主专政的国体和人民代表大会制度的政体；\n经济制度------坚持公有制为主体、多种所有制经济共同发展，坚持按劳分配为主体、多种分配方式并存，实行社会主义市场经济体制；\n意识形态：坚守马克思主义信仰、共产主义远大理想、中国特色社会主义共同理想；\n根本立场：坚持以人民为中心，不断促进人的全面发展，实现全体人民共同富裕。\n\n\n\n\n\n 新时代坚持和发展中国特色社会主义要一以贯之\n\n\n中国共产党领导的伟大社会革命接续推进、一以贯之；\n\n\n新民主主义革命、社会主义革命、改革开放新的伟大革命，\n\n都是以解决生产力和生产关系矛盾为根本目的的革命性实践；\n都是建立和建设社会主义、最终实现共产主义的伟大社会革命的不同阶段。\n\n\n\n新时代中国特色社会主义是我们党领导人民进行伟大社会革命的成果，也是我们党领导人民进行伟大社会革命的继续，必须一以贯之进行下去。\n\n\n\n\n科学把握新时代中国面临的战略机遇和风险挑战\n\n\n新时代坚持和发展中国特色社会主义的前进定力\n\n\n认清五个&quot;必由之路&quot;：\n\n坚持党的全面领导是坚持和发展中国特色社会主义的必由之路；\n中国特色社会主义是实现中华民族伟大复兴的必由之路；团结奋斗是中国人民创造历史伟业的必由之路；\n贯彻新发展理念是新时代我国发展壮大的必由之路；\n全面从严治党是党永葆生机活力、走好新的赶考之路的必由之路。\n\n\n\n 坚定中国特色社会主义&quot;四个自信&quot;\n\n\n四个自信的内容：道路自信、理论自信、制度自信、文化自信\n\n\n我国改革开放以来实现了两大奇迹：经济快速发展奇迹；社会长期稳定奇迹。\n\n\n 三、如何建设社会主义现代化强国\n 全面建成小康社会\n\n\n小康是中华民族自古以来不懈追求的梦想\n\n\n实现小康社会是我国现代化建设的重要目标\n\n\n改革开放之初，邓小平同志首先用&quot;小康&quot;来诠释中国式现代化，明确提出到20世纪末&quot;在中国建立一个小康社会&quot;的奋斗目标。\n\n\n人民生活从温饱不足到总体小康、奔向全面小康的历史性跨越\n\n\n1982年党的十二大首次把&quot;小康&quot;作为经济建设总的奋斗目标，提出到20世纪末力争使人民的物质文化生活达到小康水平；\n\n\n1987年党的十三大制定&quot;三步走&quot;现代化发展战略，把20世纪末人民生活达到小康水平作为第二步奋斗目标。\n\n\n1992年在人民温饱问题基本得到解决的基础上，党的十四大提出到20世纪末人民生活由温饱进入小康。\n\n\n\n\n全面建成小康社会，是&quot;两个一百年&quot;奋斗目标的第一个百年奋斗目标。党的十八大以来，以习近平同志为核心的党中央顺应我国经济社会新发展和广大人民群众新期盼，提出了全面建成小康社会新的目标要求，赋予了&quot;小康&quot;更高的标准、更丰富的内涵。\n\n\n全面建成小康社会，强调的不仅是&quot;小康&quot;，更重要、更难做到的是&quot;全面&quot;。&quot;小康&quot;讲的是发展水平，&quot;全面&quot;讲的是发展的平衡性、协调性、可持续性。\n\n\n到2020年底，中国如期完成新时代脱贫攻坚目标任务，现行标准下9899万农村贫困人口全部脱贫，832个贫困县全部摘帽。我们实现了第一个百年奋斗目标，在中华大地上全面建成了小康社会，历史性地解决了绝对贫困问题。\n\n\n全面建成小康社会，意味着中华民族实现千百年来的夙愿；表明我国发展和人民生活水平跃上新的大台阶；是全面建设社会主义现代化国家征程中的关键一步。\n\n\n 全面建设社会主义现代化国家\n\n\n建设社会主义现代化强国是我们党确立的伟大目标；\n\n\n建成社会主义现代化强国的战略安排。\n\n第一步：2035年，基本实现社会主义现代化；\n第二步：本世纪中叶，建成富强民主文明和谐美丽的社会主义现代化强国。\n\n\n\n开启全面建设社会主义现代化国家新征程\n\n\n 推进和拓展中国式现代化\n\n\n鞋子合不合脚，只有穿的人才知道\n\n\n我们建设的现代化必须是具有中国特色、符合中国实际的。\n\n与&quot;串联式&quot;的西方现代化不同，我国发展必然是一个&quot;并联式&quot;的过程，工业化、信息化、城镇化、农业现代化是叠加发展的。\n\n\n\n中国式现代化的重要特征：\n\n人口规模巨大的现代化；\n全体人民共同富裕的现代化；\n物质文明和精神文明相协调的现代化；\n人与自然和谐共生的现代化；\n走和平发展道路的现代化。\n\n\n\n中国式现代化将更好发展自身、造福世界\n\n\n第三讲 坚持党的全面领导\n 一、为什么要坚持党的领导\n 党是最高政治领导力量\n\n\n引领政治方向。方向决定道路，道路决定命运。中国共产党始终坚持共产主义理想和社会主义信念。党的十八大以来，以习近平同志为核心的党中央高举中国特色社会主义伟大旗帜，把准把好新时代改革开放的方向盘。这个方向就是中国特色社会主义道路，而不是其他什么道路。\n\n\n统领政治体系。国家政治体系是一个大系统，其构成包括根本政治制度、基本政治制度和国家治理各方面具体的体制机制，涵盖国家机关、政党组织和各种政治主体。在这个大系统中，中国共产党处于统领地位。\n\n\n决断重大事项。中国共产党作为最高政治领导力量，很重要的是就党和国家的重大事项进行决策。离开决策权，所谓领导就是一句空话。中国共产党一路走来，不断从胜利走向胜利，每一步都离不开科学有效的决策及周密部署和有效实施。善于抓问题、想办法、作决策，是党的领导水平和执政本领的集中体现。\n\n\n领导社会治理。社会治理离不开一定的组织形态。中国共产党的组织形态既推进了社会的有序治理，又保证了社会充满活力。首先，中国共产党的政治功能为社会治理提供方向。其次，中国共产党以党的服务功能推进社会有效运转。最后，中国共产党以强大的组织体系确保社会治理和谐有序。\n\n\n 中国共产党领导是中国特色社会主义最本质的特征\n\n\n中国共产党领导是中国特色社会主义最本质的特征，要置于科学社会主义基本原理中去认识，要置于国际共产主义运动历史经验教训中去分析，要置于中国共产党领导中国社会发展中去把握。中国共产党领导是中国特色社会主义最本质的特征，就在于党的领导直接关系着中国特色社会主义的性质、方向和命运。\n\n\n首先，中国共产党的领导是由科学社会主义的理论逻辑决定的。坚持无产阶级政党的领导是无产阶级革命和社会主义建设取得胜利的根本保证。马克思和恩格斯在《共产党宣言》中明确指出：&quot;在实践方面，共产党人是各国工人政党中最坚决的、始终起推动作用的部分；在理论方面，他们胜过其余无产阶级群众的地方在于他们了解无产阶级运动的条件、进程和一般结果。&quot;中国特色社会主义是科学社会主义基本原则同当代中国实际和时代特征相结合的产物，是植根于当代中国的科学社会主义。只有坚持中国共产党的领导，才能保证中国特色社会主义的性质和正确方向。\n\n\n其次，中国共产党的领导是由中国特色社会主义产生与发展的历史逻辑决定的。中国共产党领导中国人民开创的中国特色社会主义不是从天上掉下来的，而是在改革开放40多年的伟大实践中得来的，是在中华人民共和国成立70多年的持续探索中得来的，是在党领导人民进行伟大社会革命100多年的实践中得来的，是在对近代以来180多年中华民族发展历程的深刻总结中走出来的，是在对中华民族5000多年悠久文明的传承中走出来的，是党和人民历经千辛万苦、付出各种代价取得的宝贵成果。中国共产党是中国特色社会主义事业的开创者、推动者、引领者，团结带领人民开辟了中国特色社会主义道路，创立了中国特色社会主义理论，创建了中国特色社会主义制度，发展了中国特色社会主义文化。历史和现实证明，没有中国共产党的领导，就没有中国特色社会主义的产生和发展。\n\n\n最后，中国共产党的领导是由中国特色社会主义迈向新征程的实践逻辑决定的。百余年来，为了实现中华民族伟大复兴的历史使命，中国共产党初心不改、矢志不渝，团结带领人民历经千难万险、付出巨大牺牲，取得了一个又一个伟大斗争的胜利。今天，我们已经全面建成小康社会、踏上了建设社会主义现代化强国的新征程。在实现中华民族伟大复兴征程中，面临着来自国际国内多种多样前所未有的挑战，不知还要爬多少坡、过多少坎，经历多少风风雨雨、克服多少艰难险阻。坚定走中国道路，把14亿多人民凝聚成中国力量，焕发出中国精神，把新时代中国特色社会主义这篇大文章继续写好、写精彩，从根本上要靠党的全面领导，靠党把好方向盘。\n\n\n 中国共产党领导是中国特色社会主义制度的最大优势\n\n\n中国共产党是中国特色社会主义制度的创建者。没有中国共产党，就没有中国特色社会主义制度的形成、发展和完善，制度优势就无从谈起。中国共产党把科学社会主义原则和中国实际相结合，创建了根本政治制度和基本政治制度，中国特色社会主义法律体系，公有制为主体、多种所有制经济共同发展的基本经济制度。党领导中国人民通过改革不断完善中国特色社会主义制度。\n\n\n中国共产党的领导是充分发挥中国特色社会主义制度优势的根本保障。党的领导作为一项制度安排是中国特色社会主义制度的重要组成部分。作为党的根本组织制度和领导制度的民主集中制，最能体现中国特色社会主义制度的优越性。这项制度把充分发扬党内民主和正确实行集中有机结合起来，既可以最大限度激发全党创造活力，又可以统一全党思想和行动，有效防止和克服议而不决、决而不行的分散主义，是科学合理而又有效率的制度。\n\n\n中国共产党的自身优势是中国特色社会主义制度优势的主要来源。回顾党的历史，我们可以清楚地看到，在长期奋斗中，党形成了自身的理论优势、政治优势、组织优势、制度优势和密切联系群众的优势。正是这些优势使党能够由小到大、由弱到强，团结带领全国各族人民谱写了中国革命、建设、改革的壮丽篇章，根本改变了中国人民和中华民族的前途和命运；也正是这些优势引领和锻造了中国特色社会主义的制度优势，从根本上保证中国特色社会主义不变色、不变质。\n\n\n 二、怎样理解党的领导是全面的、系统的、整体的\n 党的领导是全面的\n\n\n领导对象要全面覆盖.\n党领导一切，包括党领导人大、政府、政协、监察机关、审判机关、检察机关、武装力量、人民团体、企事业单位、基层群众性自治组织、社会组织等。\n\n\n领导内容要全面.\n必须体现到经济建设、政治建设、文化建设、社会建设、生态文明建设和国防军队、祖国统一、外交工作、党的建设等各方面。\n\n\n领导过程要全面.\n既制定路线方针政策，又协调各方、督促落实，贯穿于治国理政的立法、决策、执行、管理、监督等各项工作之中。\n\n\n领导方法要全面.\n通过制定大政方针，提出立法建议，推荐重要干部，进行思想宣传，发挥党组织和党员的作用等，坚持依法执政，实施党对国家和社会的领导。\n\n\n党、政、军、民、学在党中央的集中统一领导下，既各司其职、各负其责又相互配合，这样治国理政才有方向、有章法、有力量。否则就会出现各自为政、一盘散沙的局面，不仅我们确定的目标不能实现，而且必定会产生灾难性后果。\n\n\n 坚持党的全面领导与过去党的一元化领导有什么不同？\n\n\n在坚持和加强党的全面领导问题上，一些人把它与过去党的一元化领导简单等同起来，这种认识是错误的。\n\n\n党的一元化领导。党的一元化领导是抗战时期开始形成的领导制度，当时各根据地长期被分割，为了适应严酷的战争环境，需要党对军、政、民实施统一领导，这对于统一全党的思想意志、有效集中各种资源、推动革命根据地发展，最终取得中国革命的胜利发挥了重要作用。但后来计划经济时期，在&quot;左&quot;的错误思想影响下，加之民主与法制不健全，导致权力过分集中、政企不分、政事不分、政社不分，出现&quot;家长制&quot;“一言堂”，党的一元化领导被极端化和教条化，给党和国家事业带来严重破坏。\n\n\n党的全面领导。改革开放以来，我们不断深化对共产党执政规律的认识，特别是党的十八大以后，针对一段时期党的领导被忽视、淡化、弱化的状况，我们党提出坚持和加强党的全面领导。党的全面领导既坚持党的集中统一领导原则，坚持党是最高政治领导力量，又坚持民主集中制、发扬党内民主，坚持党的领导与人民当家作主、依法治国有机统一。\n\n\n\n\n 党的领导是系统的\n\n\n中国特色社会主义制度是一个严密完整的科学制度体系，起四梁八柱作用的是根本制度、基本制度、重要制度，其中中国共产党的领导是载入宪法的，党的领导制度是我国的根本领导制度，居于统领地位。\n\n\n坚持党的领导，是通过党的制度来保证实施的。制度带有根本性、全局性、稳定性和长期性，健全的领导制度体系对于保证党的领导活动的正常进行，发挥党的领导机关和领导者的作用，发挥党的各级组织和广大党员的积极性主动性创造性，保证党和国家事业的健康发展，具有十分重要的作用。\n\n\n建立不忘初心、牢记使命的制度；完善坚定维护党中央权威和集中统一领导的各项制度；健全党的全面领导制度；健全为人民执政、靠人民执政各项制度；健全提高党的执政能力和领导水平制度；完善全面从严治党制度。\n\n\n党的领导是整体的\n\n从党的中央组织到地方组织再到基层组织，都要按照党章的规定发挥应有作用，党的领导作用要体现到治国理政的全过程，领导功能的发挥要完整。\n\n\n\n习近平强调，&quot;我国社会主义政治制度优越性的一个突出特点是党总揽全局、协调各方的领导核心作用，形象地说是’众星捧月’，这个’月’就是中国共产党。&quot;国家治理体系是由众多子系统构成的复杂系统，这个系统的核心是中国共产党，人大、政府、政协、监委、法院、检察院、军队，各民主党派和无党派人士，各企事业单位，工会、共青团、妇联等群团组织，都要坚持中国共产党领导。\n党的领导不是空洞的、抽象的，要在各方面各环节落实和体现。中国共产党是国家治理体系的核心。哪个领域、哪个方面、哪个环节缺失了弱化了，都会削弱党的力量，损害党和国家事业。党的领导，体现在党的科学理论和正确路线方针政策上，体现在党的执政能力和领导水平上，体现在党的政治判断力、政治领悟力、政治执行力上，同时也体现在党的严密组织体系和强大组织能力上。\n一系列重大制度安排确保党对国家和社会实施领导的制度不断得到加强。从央企集团&quot;党建入章&quot;全面完成，&quot;双向进入、交叉任职&quot;和党委、书记、董事长&quot;一肩挑&quot;实现全覆盖，到全国各高校坚持和完善党委领导下的校长负责制，普遍修订党委常委会、校长办公会等制度，再到公立中小学、医院、科研院所逐步实现党组织领导下的校 (院、所)长负责制…一系列重大制度举措推动党的领导制度纵到底、横到边，实现全覆盖、全贯穿、落实落地。\n坚持党对一切工作的领导，不能只停留在口头表态上，必须落实到行动上，切实贯彻和体现到改革发展稳定、内政外交国防、治党治国治军各个领域各个方面，确保党始终总揽全局、协调各方。\n坚持党的领导是方向性问题，必须旗帜鲜明、立场坚定，决不能羞羞答答、语焉不详，决不能遮遮掩掩、搞自我麻痹。\n\n\n提高党把方向、谋大局、定政策、促改革的能力\n\n坚持党的全面领导，既要政治过硬，也要本领高强。要着力提高党把方向、谋大局、定政策、促改革的能力和定力，善于处理各种复杂矛盾，勇于战胜各种艰难险阻，牢牢把握工作主动权，把党总揽全局、协调各方落到实处。\n\n\n\n方向涉及根本、关系全局、决定长远。着力提高党把方向的能力和定力。党的领导第一位的就是举旗定向。把方向就是要高举中国特色社会主义伟大旗帜，坚持以习近平新时代中国特色社会主义思想为指导，以高度自觉推进社会革命和自我革命，一以贯之坚持和发展中国特色社会主义，一以贯之推进党的建设新的伟大工程，一以贯之增强忧患意识、防范风险挑战。\n\n\n我们既不走封闭僵化的老路，也不走改旗易帜的邪路，要坚定不移走中国特色社会主义道路。全党要从伟大胜利中激发奋进力量，从弯路挫折中吸取历史教训，不为任何风险所惧，不为任何干扰所惑，决不在根本性问题上出现颠覆性错误。\n不谋全局者不足谋一域。着力提高谋大局的能力和定力。不谋全局者不足谋一域，要善于观大势、谋大事，自觉在大局下想问题、做工作。要牢固树立大局意识，自觉把工作放到大局中去思考、定位、摆布，做到正确认识大局、自觉服从大局、坚决维护大局。制定和实施国民经济和社会发展五年规划，引领经济社会发展，是我们党治国理政的一种重要方式，是中国特色社会主义发展模式的重要体现，是中国共产党谋大局的重要表现。从1953年开始，我国已经编制实施了14个五年规划，对我们创造出世所罕见的经济快速发展奇迹和社会长期稳定奇迹，发挥了卓有成效的作用。\n\n政策是体现执政党性质宗旨的试金石，是反映治国理政水平的标志。\n\n着力提高定政策的能力和定力。在推进经济社会发展中，要坚持以人民为中心，着眼解决人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，抓住群众最关心最直接最现实的利益问题，制定切实管用的政策措施。中央一号文件：中共中央在1982年至1986年连续五年发布以农业、农村和农民为主题的中央一号文件，对农村改革和农业发展作出具体部署。2004年至2022年又连续19年发布以&quot;三农&quot; (农业、农村、农民)为主题的中央一号文件，强调了&quot;三农&quot;问题在中国社会主义现代化建设中&quot;重中之重&quot;的地位。\n\n改革开放是决定当代中国命运的关键一招。着力提高促改革的能力和定力。　改革开放是决定当代中国命运的关键一招，也是实现&quot;两个一百年&quot;奋斗目标、实现中华民族伟大复兴的关键一招。当前，全面深化改革已经进入新的阶段，必须一鼓作气、坚定不移，敢于啃硬骨头、敢于涉险滩，进一步解放思想、进一步解放和发展社会生产力、进一步解放和增强社会活力。\n\n党的十八届三中全会审议通过了《中共中央关于全面深化改革若干重大问题的决定》。\n2013年12月30日，中共中央政治局召开会议，决定成立中央全面深化改革领导小组，负责改革总体设计、统筹协调、整体推进、督促落实。各级党委要切实履行对改革的领导责任。\n党的十八届三中全会以来，习近平先后主持召开多次中央全面深化改革领导小组会议、中央全面深化改革委员会会议，历次会议围绕全面深化改革提出了一系列深化改革的理念和方法。特别是立足就业、教育和医疗等重要民生领域，秉持&quot;人民至上&quot;的价值理念，出实招、办实事，进行了卓有成效的改革。\n 三、怎样才能做到自觉在思想上政治上行动上同党中央保持高度一致\n 增强&quot;四个意识&quot;\n\n全党同志要增强政治意识、大局意识、核心意识、看齐意识，切实做到对党忠诚、为党分忧、为党担责、为党尽责。\n\n2016年10月，党的十八届六中全会正式确立习近平总书记党中央的核心、全党的核心地位，要求全党必须牢固树立&quot;四个意识&quot;。\n\n政治意识表现为坚定政治信仰，坚持正确的政治方向，坚持政治原则，站稳政治立场，保持政治清醒和政治定力，不断提高政治判断力、政治领悟力、政治执行力。\n\n我们党要始终做到不忘初心、牢记使命，把党和人民事业长长久久推进下去，必须增强政治意识，善于从政治上看问题，善于把握政治大局。\n\n大局意识就是要正确处理中央与地方、局部与全局、当前与长远的关系，自觉从党和国家大局出发想问题、办事情、抓落实，坚决贯彻落实中央决策部署，确保中央政令畅通。\n\n必须牢固树立高度自觉的大局意识，自觉从大局看问题，把工作放到大局中去思考、定位、摆布，做到正确认识大局、自觉服从大局、坚决维护大局。\n\n核心意识就是要始终坚持、切实加强党的领导，特别是党中央的集中统一领导，更加紧密地团结在以习近平同志为核心的党中央周围，更加坚定地维护党中央权威，更加自觉地在思想上政治上行动上同党中央保持高度一致。\n\n党的历史表明，必须有一个在实践中形成的坚强的中央领导集体，在这个领导集体中必须有一个核心。如果没有这样的领导集体和核心，党的事业就不能胜利。\n\n看齐意识就是要求向党中央看齐，向党的理论和路线方针政策看齐，向党中央决策部署看齐，做到党中央提倡的坚决响应、党中央决定的坚决执行、党中央禁止的坚决不做。\n\n毛泽东说：“要知道，一个队伍经常是不大整齐的，所以就要常常喊看齐，向左看齐，向右看齐，向中看齐。我们要向中央基准看齐，向大会基准看齐。看齐是原则，有偏差是实际生活，有了偏差，就喊看齐。”\n 做到&quot;两个维护&quot;\n事在四方，要在中央。党中央是大脑和中枢。在思想上政治上行动上同党中央保持高度一致，是党性，是大局，关系党、民族、国家前途命运，任何时候任何情况下都不能含糊、不能动摇。\n\n“两个维护”：\n\n坚决维护习近平总书记党中央的核心、全党的核心地位，\n坚决维护党中央权威和集中统一领导。\n\n\n\n首先，确立和维护无产阶级政党的领导核心，始终是马克思主义建党学说的一个基本观点。\n坚决维护习近平总书记党中央的核心、全党的核心地位。\n一个国家、一个政党，领导核心至关重要。坚决维护习近平总书记党中央的核心、全党的核心地位，保证全党令行禁止，形成思想和行动高度统一的整体，这是一个成熟的马克思主义执政党的必然要求。\n坚决维护习近平总书记党中央的核心、全党的核心地位，必须自觉同以习近平同志为核心的党中央保持高度一致，在思想上高度认同，政治上坚决维护，组织上自觉服从，行动上紧紧跟随，把&quot;四个意识&quot;落实到一言一行之中。\n坚决维护习近平总书记党中央的核心、全党的核心地位，形成思想和行动高度统一的整体，是党和国家前途命运所系，是全国各族人民根本利益所在。\n坚决维护党中央权威和集中统一领导。党和国家大政方针的决定权在党中央。历史表明，要治理好中国共产党这个大党、治理好中国这个大国，保证党的团结和集中统一至关重要，维护党中央权威至关重要。党的任何组织和成员必须以实际行动维护党中央的权威，必须服从党中央集中统一领导，这是党的领导的最高原则。\n维护党中央权威和集中统一领导同坚持民主集中制是否矛盾?\n维护党中央权威和集中统一领导同坚持民主集中制是完全一致的。首先，民主集中制包括民主和集中两个方面，两者互为条件、相辅相成、缺一不可。民主是正确集中的前提和基础，离开民主讲集中，集中就成了个人专权专断。集中是民主的必然要求和归宿，离开集中搞民主，就会导致极端民主化和无政府状态。\n其次，中国共产党实行民主集中制。在充分发扬民主的基础上进行集中，坚持党中央权威和集中统一领导，集中全党智慧，体现全党共同意志，是党的一大创举。\n最后，坚持党中央权威和集中统一领导，不是说不要民主集中制了，不要发扬党内民主了，而是体现了充分发扬民主基础上的正确集中，把这两者对立起来是不对的、有害的。\n&quot;两个维护&quot;有明确的内涵和要求，维护习近平总书记党中央的核心、全党的核心地位，对象是习近平总书记而不是其他任何人；维护党中央权威和集中统一领导，对象是党中央而不是其他任何组织。维护党中央权威、向党中央看齐，这个逻辑不能层层推下去。核心只有党中央的核心，看齐只能向党中央看齐。\n&quot;两个维护&quot;作为马克思主义建党学说的最新发展，实现了坚持党的领导与加强党的建设的有机统一，有效解决了过去党的领导虚化弱化的问题，确保党和国家事业始终保持正确政治方向。\n课堂小结\n中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势。党的领导是全面的、系统的、整体的。要增强&quot;四个意识&quot;，做到&quot;两个维护&quot;，自觉在思想上政治上行动上同党中央保持高度一致。\n正如《中共中央关于党的百年奋斗重大成就和历史经验的决议》指出的，“只要我们坚持党的全面领导不动摇，坚决维护党的核心和党中央权威，充分发挥党的领导政治优势，把党的领导落实到党和国家事业各领域各方面各环节，就一定能够确保全党全军全国各族人民团结一致向前进”。\n 第四讲 坚持以人民为中心\n 一、为什么必须坚持以人民为中心\n\n\n人民是创造历史的动力\n\n\n人民是真正的英雄。\n\n\n党的历史伟业是人民创造的\n\n\n党坚持走群众路线，群众路线始终是党的生命线和根本工作路线，是我们党永葆青春活力和战斗力的重要传家宝。\n\n\n江山就是人民、人民就是江山\n\n\n我国的政权是人民的政权，人民是中国共产党执政兴国的最大底气，人民是我们党的生命之根、执政之基、力量之源。\n\n\n历史是最好的教科书，也是最好的清醒剂，赢得人民信任、得到人民支持，党就能够克服任何困难。反之，我们将一事无成，甚至走向衰败。\n\n\n打江山、守江山，守的是人民的心\n\n\n尊重人民群众的首创精神。人民群众实践与智慧，可以增长党的执政智慧，增强党的执政本领。\n\n\n 党依靠人民创造历史伟业\n\n\n党依靠人民夺取新民主主义革命伟大胜利\n\n\n党依靠人民完成社会主义革命和推进社会主义建设\n\n\n党依靠人民进行改革开放和社会主义现代化建设\n\n\n党依靠人民开创中国特色社会主义新时代\n\n\n 二、如何理解不断实现人民对美好生活的向往\n 人民立场是中国共产党的根本政治立场\n\n\n人民立场是马克思主义政党区别于资产阶级政党的显著标志\n\n\n全心全意为人民服务是党的根本宗旨\n\n\n党性和人民性是高度一致的\n\n\n 为中国人民谋幸福是中国共产党的初心\n\n\n中国共产党是人民利益的忠实代表，这是中国共产党立于不败之地的根本所在\n\n\n党始终把人民放在心中最高位置\n\n\n 中国共产党为人民的美好生活而不懈奋斗\n\n\n准确把握人民对美好生活的新期待，人民不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长；\n\n\n把所有精力都用在让老百姓过好日子上\n\n\n党带领人民继续创造美好生活，以人民为中心的发展思想，要全方位贯穿于经济社会发展的各个环节，体现在人民群众获得感、幸福感、安全感的扎实提升上\n\n\n 三、怎样推动人的全面发展、全体人民共同富裕\n 科学认识人的全面发展、全体人民共同富裕\n\n\n实现人的全面发展是共产主义的基本原则\n\n\n人的全面发展是中国特色社会主义的价值目标\n\n人的全面发展的基本内涵：人的社会关系的充分发展；人的能力的全面发展；人的个性的自由发展\n\n\n\n共同富裕是中国共产党人始终不渝的奋斗目标\n\n\n共同富裕是中国特色社会主义的本质要求\n\n\n共同富裕是中国式现代化的重要特征\n\n\n6、促进人的全面发展与促进共同富裕是高度统一的\n 必须推动全体人民共同富裕取得更为明显的实质性进展\n\n\n是践行以人民为中心发展思想的必然要求\n\n\n是更好满足人民日益增长的美好生活需要的重要着力点\n\n\n是关系党的执政基础的重大政治问题\n\n\n是解决我国发展不平衡不充分问题的现实需要\n\n\n新时代推进共同富裕有了更加坚实的发展基础\n\n\n 使全体人民朝着共同富裕目标扎实迈进\n\n\n把握扎实推动共同富裕的基本原则：鼓励勤劳创新致富；掌握就业创业真本领，端上勤劳创新致富&quot;金饭碗&quot;；坚持基本经济制度；尽力而为，量力而行；坚持循序渐进\n\n\n扎实推动共同富裕的总体思路：坚持以人民为中心的发展思想，在高质量发展中促进共同富裕，正确处理效率和公平的关系，构建初次分配、再分配、三次分配协调配套的基础性制度安排，加大税收、社保、转移支付等调节力度并提高精准性，扩大中等收入群体比重，增加低收入群体收入，合理调节高收入，取缔非法收入，形成中间大、两头小的橄榄型分配结构，促进社会公平正义，促进人的全面发展，使全体人民朝着共同富裕目标扎实迈进。\n\n\n扎实推动共同富裕的重大举措：提高发展的平衡性、协调性、包容性；着力扩大中等收入群体规模；促进基本公共服务均等化；加强对高收入的规范和调节；促进人民精神生活共同富裕；促进农民农村共同富裕。\n\n\n全体人民共同富裕是一个总体概念，要从全局上来看，是一个在动态中向前发展的过程，要持续推动，不断取得成效。\n\n\n 第五讲 以新发展理念引领高质量发展\n习近平经济思想是习近平新时代中国特色社会主义思想的重要组成部分，是运用马克思主义政治经济学基本原理对新时代经济发展实践作出的系统理论概括，是以习近平同志为核心的党中央治国理政实践创新和理论创新在经济领域的集中体现，是立足国情、放眼世界、引领未来的科学理论，是党和国家十分宝贵的精神财富，为做好新时代经济工作指明了正确方向、提供了根本遵循。\n 一、如何把握新发展阶段、贯彻新发展理念、构建新发展格局\n 进入新发展阶段是中华民族伟大复兴历史进程的大跨越\n\n进入新发展阶段是我国经济发展的历史方位\n\n正确认识党和人民事业所处的历史方位和发展阶段，是我们党明确阶段性中心任务、制定路线方针政策的根本依据，也是我们党领导革命、建设、改革不断取得胜利的重要经验。\n 如何理解我国进入新发展阶段的基本依据？\n\n\n理论依据：马克思主义是远大理想和现实目标相结合、历史必然性和发展阶段性相统一的统一论者，坚信人类社会必然走向共产主义，但实现这一崇高目标必然经历若干历史阶段。\n\n\n历史依据：新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段。\n\n\n现实依据：我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础。\n\n\n新发展阶段是社会主义初级阶段中的一个阶段。今天我们所处的新发展阶段，就是社会主义初级阶段中的一个阶段，同时是其中经过几十年积累、站到了新的起点上的一个阶段。全面建设社会主义现代化国家、基本实现社会主义现代化，既是社会主义初级阶段我国发展的要求，也是我国社会主义从初级阶段向更高阶段迈进的要求。\n社会主义初级阶段，既不是一个静态、一成不变、停滞不前的阶段，也不是一个自发、被动、不用费多大气力自然而然就可以跨过的阶段，而是一个动态、积极有为、始终洋溢着蓬勃生机活力的过程和一个阶梯式递进、不断发展进步、日益接近质的飞跃的量的积累和发展变化的过程。\n 新发展阶段是全面建设社会主义现代化国家的阶段\n\n我国发展仍然处于重要战略机遇期\n\n经济方面的五个新机遇：加快经济结构优化升级带来新机遇；提升科技创新能力带来新机遇；深化改革开放带来新机遇；加快绿色发展带来新机遇；参与全球经济治理体系变革带来新机遇。\n\n国内外环境深刻变化带来的新挑战：\n\n国际环境日趋复杂，新冠肺炎疫情影响广泛深远，经济全球化遭遇逆流，世界进入新的动荡变革期，大国博弈日趋激烈，单边主义、保护主义、霸权主义对世界和平与发展构成威胁。\n我国发展不平衡不充分问题仍然突出，重点领域关键环节改革任务仍然艰巨，创新能力不适应高质量发展等。\n\n\n\n 贯彻新发展理念是关系我国发展全局的一场深刻变革\n\n\n新发展理念是新时代我国经济发展的指导原则\n\n新发展理念的重大意义：\n\n十八大以来，我们党对经济社会发展提出了许多重大理论和理念，其中新发展理念是最重要、最主要的。\n新发展理念是一个系统的理论体系：回答了关于发展的目的、动力、方式、路径等一系列理论和实践问题。阐明了我们党关于发展的政治立场、价值导向、发展模式、发展道路等重大政治问题。\n\n\n\n\n\n新发展理念的提出背景\n\n\n新发展理念不是凭空得来的，是在深刻总结国内外发展经验教训、分析国内外发展大势的基础上形成的，集中反映了我们党对经济社会发展规律认识的深化，针对我国发展中的突出矛盾和问题。\n\n\n创新注重解决发展动力问题。创新是一个国家、一个民族发展进步的不竭动力。创新发展理念：抓住了创新，就抓住了牵动经济社会发展全局的&quot;牛鼻子&quot;。不断推进理论创新、制度创新、科技创新、文化创新等各方面创新。重大科技创新成果是国之重器、国之利器，必须牢牢掌握在自己手上，必须依靠自力更生、自主创新。\n\n\n协调注重解决发展不平衡问题。协调发展理念：协调既是发展手段又是发展目标，同时还是评价发展的标准和尺度；注重发展的整体效能，否则&quot;木桶&quot;效应就会愈加显现，一系列社会矛盾会不断加深。\n\n\n绿色注重解决人与自然和谐共生问题。绿色发展理念：坚定不移走生态优先、绿色发展之路，2030年前二氧化碳排放达到峰值，2060年前实现碳中和，建立健全绿色低碳循环发展经济体系，促进经济社会发展全面绿色转型。\n\n\n开放注重解决发展内外联动问题。开放发展理念：对外开放是我国的基本国策，任何时候都不能动摇；经济全球化遇到一些回头浪，但开放合作仍然是历史潮流，互利共赢依然是人心所向；当今时代，任何关起门来搞建设的想法，任何拒人于千里之外的做法，都是逆历史潮流而动的。\n\n\n共享注重解决社会公平正义问题。共享发展理念：改革发展搞得成功不成功，最终的判断标准是人民是不是共同享受到了改革发展成果；坚持全民共享、全面共享、共建共享、渐进共享，使全体人民有更多获得感、幸福感、安全感，朝着共同富裕方向稳步前进。\n\n\n 如何完整、准确、全面贯彻新发展理念？\n\n\n从根本宗旨把握新发展理念。为人民谋幸福、为民族谋复兴，这既是我们党领导现代化建设的出发点和落脚点，也是新发展理念的&quot;根&quot;和&quot;魂&quot;。\n\n\n从问题导向把握新发展理念。突出问题和挑战：发展不平衡不充分的一些突出问题尚未解决，发展质量和效益还不高，创新能力不够强，实体经济水平有待提高，生态环境保护任重道远，民生领域还有不少短板，城乡区域发展和收入分配差距依然较大，群众在就业、教育、医疗、居住、养老等方面面临不少难题。\n\n\n从忧患意识把握新发展理念。增强忧患意识，坚持底线思维；积极主动，未雨绸缪；见微知著，防微杜渐；下好先手棋，打好主动仗。\n\n\n 构建新发展格局是把握发展主动权的战略性布局\n\n\n构建新发展格局是我国经济发展的路径选择\n-构建新发展格局的重大意义。构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，是根据我国发展阶段、环境、条件变化，特别是基于我国比较优势变化，审时度势作出的重大决策，是新发展阶段要着力推动完成的重大历史任务，也是贯彻新发展理念的重大举措。\n\n\n构建新发展格局的提出背景。改革开放前，我国经济以国内循环为主，进出口占国民经济的比重很小。改革开放以来，特别是加入世界贸易组织后，我国加入国际大循环，市场和资源&quot;两头在外&quot;，形成&quot;世界工厂&quot;发展模式，对我国快速提升经济实力、改善人民生活发挥了重要作用。\n\n\n构建新发展格局是对我国客观经济规律的自觉把握。自2008年国际金融危机以来，我国经济已经向以国内大循环为主体转变，国内需求对经济增长的贡献率有多个年份超过100%。构建新发展格局是把握发展主动权的先手棋，不是被迫之举和权宜之计。\n\n\n构建新发展格局的本质特征。改革开放以来，我们遭遇过很多外部风险冲击，最终都能化险为夷，靠的就是办好自己的事、把发展立足点放在国内。我们只有立足自身，把国内大循环畅通起来，努力炼就百毒不侵、金刚不坏之身，才能任由国际风云变幻，始终充满朝气生存和发展下去，没有任何人能打倒我们、卡死我们！\n\n\n\n\n把握扩大内需战略基点\n\n\n加快培育完整内需体系。市场资源是我国的巨大优势：我国具有全球最完整、规模最大的工业体系；有强大的生产能力、完善的配套能力；拥有1亿多市场主体和- 7亿多受过高等教育或拥有各类专业技能的人才；还有包括4亿多中等收入群体在内的14亿多人口所形成的超大规模内需市场。\n\n\n加快建设全国统一大市场。主要目标：持续推动国内市场高效畅通和规模拓展；加快营造稳定公平透明可预期的营商环境；进一步降低市场交易成本；促进科技创新和产业升级；培育参与国际竞争合作新优势。\n\n\n\n\n以国内大循环为主体、国内国际双循环相互促进\n\n\n畅通国内大循环。依托强大国内市场；形成需求牵引供给、供给创造需求的更高水平动态平衡；贯通生产、分配、流通、消费各环节；促进国民经济良性循环。\n\n\n国内国际双循环相互促进。构建新发展格局，绝不是关起门来搞国内循环。顺应经济全球化的历史潮流，坚定不移全面扩大开放，推动建设开放型世界经济。以国际循环提升国内大循环效率和水平，改善国内生产要素质量和配置水平。通过参与国际市场竞争，增强出口产品和服务竞争力.推动国内产业转型升级，增强我国在全球产业链供应链创新链中的影响力。\n\n\n\n\n新发展阶段、新发展理念、新发展格局紧密关联\n\n\n进入新发展阶段：历史方位和现实依据；贯彻新发展理念：指导原则和行动指南；构建新发展格局：路径选择和战略选择。\n 二、如何理解我国经济转向高质量发展\n 我国经济发展进入新常态\n\n\n进入新常态的判断依据\n\n\n从时间上看，新常态是我国不同发展阶段更替变化的结果。我国经济发展正处于增长速度换挡期、结构调整阵痛期和前期刺激政策消化期。经济发展面临着速度换挡节点、结构调整节点和动力转换节点。\n\n\n从空间上看，新常态是我国出口优势和参与国际产业分工模式变化的体现。维持出口高增长、出口占国内生产总值的高比例已不大可能，必须把经济增长动力更多放在创新驱动和扩大内需特别是消费需求上。\n\n\n\n\n新常态下我国经济发展的特点和趋势。\n\n\n新常态下我国经济发展的主要特点\n\n\n中国经济发展进入新常态主要特征：\n\n一是增长速度从高速增长转为中高速增长；\n二是发展方式由规模速度型向质量效率型转变；\n三是经济结构由增量扩能为主转向调整存量做优增量并举转变；\n四发展动力由是从主要依靠资源和低成本劳动力等要素投入转向创新驱动。\n\n\n\n\n\n新常态下我国经济发展大势。经济发展长期向好的基本面；经济结构调整优化的前进态势；经济韧性好、潜力足、回旋余地大的基本特质；经济持续增长的良好支撑基础和条件。\n\n转向高质量发展\n\n高质量发展是从&quot;有没有&quot;转向&quot;好不好&quot;，是能够很好满足人民日益增长的美好生活需要的发展，是体现新发展理念的发展。\n推动高质量发展的必要性：推动高质量发展是保持经济持续健康发展的必然要求，只有推动高质量发展，才能适应科技新变化、人民新需要，形成优质高效多样化的供给体系，提供更多优质产品和服务，在新的水平上实现供求均衡和经济持续健康发展。\n推动高质量发展是适应我国社会主要矛盾变化的必然要求。我国经济发展阶段也在发生历史性变化，不平衡不充分的发展就是发展质量不高的表现，发展中的矛盾和问题主要就集中在发展质量上。解决我国社会的主要矛盾，必须把发展质量摆在更为突出的位置，着力提升发展质量和效益，推动高质量发展。我们既要重视量的发展，更要重视解决质的问题，在质的大幅度提升中实现量的有效增长。\n推动高质量发展是遵循经济发展规律的必然要求。经济发展是一个螺旋式上升的过程，上升不是线性的，量积累到一定阶段，必须转向质的提升，我国经济发展要遵循这一规律。20世纪60年代以来，全球100多个中等收入经济体中只有十几个成为高收入经济体。那些取得成功的国家和地区，都是在经历高速增长阶段后实现了经济发展从量的扩张转向质的提高。那些徘徊不前甚至倒退的国家和地区，都是没有实现这种根本性转变。只有通过高质量发展，实现投资有回报、企业有利润、员工有收入、政府有税收，实现生产、流通、分配、消费循环通畅，国民经济重大比例关系和空间布局比较合理，经济发展比较平衡，不出现大的起落，才能逐步进入高收入经济体行列。\n 以供给侧结构性改革为主线\n\n\n供给侧结构性改革的提出依据\n\n\n供给侧管理和需求侧管理。供给侧管理重在解决结构性问题；需求侧重在解决总量性问题。\n\n\n供给侧结构性改革的提出。当前和今后一个时期，我国经济发展面临的问题，供给和需求两侧都有，但矛盾的主要方面在供给侧。解决结构性问题，必须把改善供给侧结构作为主攻方向，实现由低水平供需平衡向高水平供需平衡跃升。\n\n\n\n\n完整准确理解供给侧结构性改革\n\n\n供给侧结构性改革的内涵和目的\n\n内涵：增强供给侧结构对需求变化的适应性、灵活性，不断让新的需求催生新的供给，让新的供给创造新的需求，在相互推动中实现经济发展。\n目的：使我国供给能力更好满足广大人民日益增长的美好生活需要，从而实现社会主义生产目的。\n\n\n\n\n\n供给侧结构性改革不是西方&quot;供给学派&quot;的翻版。西方供给学派兴起于上世纪70年代，以&quot;拉弗曲线&quot;为代表思想，主张重点是减税，过分突出税率作用，思想方法比较绝对，只注重供给而忽视需求，只注重市场功能而忽视政府作用。供给侧结构性改革既强调供给又关注需求，既突出发展社会生产力又注重完善生产关系，既发挥市场在资源配置中的决定性作用又更好发挥政府作用，既着眼当前又立足长远。\n\n\n深化供给侧结构性改革的意义与方向\n\n\n供给侧结构性改革的必要性。适应把握引领经济发展新常态的重大创新；适应国际金融危机发生后综合国力竞争新形势的主动选择；推动我国经济实现高质量发展的必然要求。\n\n\n推进供给侧结构性改革是一场硬仗。大力破除无效供给；大力培育新动能；大力降低实体经济成本。例如2021年全国粗钢产量同比减少近3000万吨，引导钢铁企业摒弃以量取胜的粗放发展方式，促进钢铁行业高质量发展。\n\n\n深化供给侧结构性改革的八字方针：巩固、增强、提升、畅通。巩固&quot;三去一降一补&quot;成果，推动更多产能过剩行业加快出清，降低全社会各类营商成本，加大基础设施等领域补短板力度；增强微观主体活力，发挥企业和企业家主观能动性，建立公平开放透明的市场规则和法治化营商环境，促进正向激励和优胜劣汰，发展更多优质企业；提升产业链水平，注重利用技术创新和规模效应形成新的竞争优势，培育和发展新的产业集群。畅通国民经济循环，加快建设统一开放、竞争有序的现代市场体系，提高金融体系服务实体经济能力，形成国内市场和生产主体、经济增长和就业扩大、金融和实体经济良性循环。\n\n\n\n\n建设现代化经济体系\n\n\n现代化经济体系的内容。现代化经济体系是由社会经济活动各个环节、各个层面、各个领域的相互关系和内在联系构成的一个有机整体。创新引领、协同发展的产业体系；统一开放、竞争有序的市场体系；体现效率、促进公平的收入分配体系；彰显优势、协调联动的城乡区域发展体系；资源节约、环境友好的绿色发展体系；多元平衡、安全高效的全面开放体系；充分发挥市场作用、更好发挥政府作用的经济体制。\n\n\n建设现代化经济体系的重点举措。筑牢坚实基础，大力发展实体经济；强化战略支撑，实施创新驱动发展战略；夯实重要基础，实施乡村振兴战略；优化空间布局，实施区域协调发展战略；提高国际竞争力，着力发展开放型经济；完善制度保障，深化经济体制改革。\n\n\n\n\n 三、如何坚持和完善社会主义基本经济制度\n 社会主义基本经济制度是我国经济发展的制度基础\n\n社会主义基本经济制度的发展。社会主义革命和建设时期，通过社会主义改造，建立了以公有制和按劳分配为基础的社会主义经济制度。改革开放和社会主义现代化建设新时期，逐步确立了公有制为主体、多种所有制经济共同发展的基本经济制度，按劳分配为主体、多种分配方式并存的基本分配制度，实现了从计划经济体制到社会主义市场经济体制的历史性转变。进入新时代，党的十九届四中全会将公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等作为社会主义基本经济制度。\n\n党的十九届四中全会第一次从所有制结构、分配制度、资源配置方式等方面阐述了我国基本经济制度的内涵，把我们党对社会主义基本经济制度的认识提高到一个新境界。\n\n社会主义基本经济制度的科学内涵：所有制结构是以公有制为主体、多种所有制经济共同发展；分配制度是以按劳分配为主体、多种分配方式并存；经济体制是社会主义市场经济体制。\n\n我国基本经济制度是中国特色社会主义制度的重要支柱，既体现了社会主义制度的优越性，又同我国社会主义初级阶段社会生产力发展水平相适应，既有利于激发各类市场主体活力、解放和发展社会生产力，又有利于促进效率和公平有机统一、推动全体人民共同富裕。\n 坚持公有制为主体、多种所有制经济共同发展\n\n毫不动摇巩固和发展公有制经济。\n\n生产资料所有制是生产关系的核心，决定着社会的基本性质和发展方向。国有企业是中国特色社会主义的重要物质基础和政治基础，关系公有制主体地位的巩固，关系我们党的执政地位和执政能力，关系我国社会主义制度。\n公有制经济为国家建设、国防安全、人民生活改善作出了突出贡献。公有制主体地位、国有经济主导作用是我国各族人民共享发展成果的制度性保证，也是巩固党的执政地位、坚持我国社会主义制度的重要保证。\n支持国有资本和国有企业做强做优做大；建立中国特色现代企业制度；增强国有经济竞争力、创新力、控制力、影响力、抗风险能力。\n\n毫不动摇鼓励、支持、引导非公有制经济发展。\n\n生产资料所有制是生产关系的核心，决定着社会的基本性质和发展方向。非公有制经济是稳定经济的重要基础，是国家税收的重要来源，是技术创新的重要主体，是金融发展的重要依托，是经济持续健康发展的重要力量。构建亲清政商关系，促进非公有制经济健康发展和非公有制经济人士健康成长。民营经济是社会主义市场经济发展的重要成果，也是我们党长期执政、团结带领全国人民实现&quot;两个一百年&quot;奋斗目标和中华民族伟大复兴中国梦的重要力量。贡献了50%以上的税收，60%以上的国内生产总值，70%以上的技术创新成果，80%以上的城镇劳动就业，90%以上的企业数量。\n 坚持按劳分配为主体、多种分配方式并存\n要发挥分配的功能和作用。要处理好效率和公平关系，构建初次分配、再分配、三次分配协调配套的基础性制度安排。\n\n中国特色社会主义初次分配------完善制度、规范秩序。\n\n社会总产品在生产资料所有者、劳动者和国家间的分配，表现为利润、劳动报酬和流转税等；坚持按劳分配主体地位，增加劳动者特别是一线劳动者劳动报酬，提高劳动报酬在初次分配中的比重；完善按要素分配体制机制，允许一部分人靠诚实劳动和合法经营先富起来。\n\n中国特色社会主义再分配------统筹兼顾、公平合理。\n\n履行好政府再分配调节职能；强化税收调节，合理调节城乡、区域、不同群体间的分配关系；合理调节过高收入，清理规范不合理收入；强化互助共济功能，把更多人纳入社会保障体系；加大对革命老区、民族地区、边疆地区、欠发达地区的转移支付。\n\n中国特色社会主义三次分配------鼓励引导、自觉自愿。\n\n发挥第三次分配作用，发展慈善等社会公益事业；加强公益慈善事业规范管理，鼓励高收入人群和企业更多回报社会；提升社会公益事业透明度，推动社会公益资源配置更加公平公正。\n 加快完善社会主义市场经济体制\n\n\n完善社会主义市场经济体制的核心问题是处理好政府和市场关系。\n\n\n有效的市场，有为的政府。市场配置资源的决定性作用：\n市场配置资源是最有效率的形式，市场决定资源配置是市场经济的一般规律，市场经济本质上就是市场决定资源配置的经济。更好发挥政府作用：保持宏观经济稳定，优化公共服务，保障公平竞争，加强市场监管，维护市场秩序，推动可持续发展，促进共同富裕，弥补市场失灵。\n\n\n用好&quot;看不见的手&quot;和&quot;看得见的手&quot;。\n市场即&quot;看不见的手&quot;：要坚持使市场在资源配置中起决定性作用，完善市场机制，打破行业垄断、进入壁垒、地方保护，增强企业对市场需求变化的反应和调整能力，提高企业资源要素配置效率和竞争力。政府即&quot;看得见的手&quot;：要更好发挥政府作用，在尊重市场规律的基础上，用改革激发市场活力，用政策引导市场预期，用规划明确投资方向，用法治规范市场行为。\n\n\n发挥社会主义市场经济体制优势的内在要求。\n我国实行的是社会主义市场经济体制，仍然要坚持发挥社会主义制度的优越性、发挥党和政府的积极作用。科学的宏观调控、有效的政府治理，是发挥社会主义市场经济体制优势的内在要求。\n\n\n正确认识和把握资本的特性和行为规律，为资本设置&quot;红绿灯&quot;。\n\n\n\n\n资本是社会主义市场经济的重要生产要素，在社会主义市场经济条件下规范和引导资本发展，既是一个重大经济问题、也是一个重大政治问题，既是一个重大实践问题、也是一个重大理论问题。\n资本是带动各类生产要素集聚配置的重要纽带，要促进各类资本良性发展、共同发展，发挥资本发展生产力、创造社会财富、增进人民福祉的作用，各类资本都不能横冲直撞，要防止有些资本野蛮生长，不让&quot;资本大鳄&quot;恣意妄为，要反垄断、反暴利、反天价、反恶意炒作、反不正当竞争。\n 第六讲 全面深化改革\n 一、为什么要全面深化改革\n 改革开放是决定当代中国前途命运的关键一招\n\n\n建立中国共产党、成立中华人民共和国、推进改革开放和中国特色社会主义事业是五四运动以来我国发生的三大历史性事件，是近现代以来实现中华民族伟大复兴的三大里程碑。\n\n\n改革开放推动了中国特色社会主义事业的伟大飞跃；走出了中华民族伟大复兴的正确道路。\n\n\n如何理解改革开放是决定当代中国命运和实现中华民族伟大复兴的关键一招？\n\n改革开放可以解决好生产力和生产关系的矛盾，解放和发展生产力；解决好经济基础和上层建筑的矛盾，完善和发展社会主义制度；进行广泛而深刻的社会变革，推动走出一条中国式现代化道路；吸收人类一切优秀文明成果，创造人类文明新形态\n改革开放44年取得辉煌成就\n改革开放是当代中国最壮丽的气象\n\n\n\n改革进入攻坚期和深水区\n\n原因：\n\n好吃的肉都吃掉了，剩下的都是硬骨头\n矛盾交织叠加，单项改革难奏效\n新形势新挑战，提出新的改革任务\n产业结构不合理\n科技创新能力不强\n\n\n\n\n\n对策：\n\n只有全面深化改革，才能赢得主动\n新时代坚持和发展中国特色社会主义，根本动力仍然是全面深化改革\n在更高起点、更高层次、更高目标上推进全面深化改革，将改革开放进行到底。\n\n\n\n什么是&quot;全面&quot;深化改革\n\n改革目标的总体性：完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化\n改革领域的全面性改革机制的系统性\n\n\n\n为何要&quot;全面&quot;深化改革\n\n我们的主要历史任务是完善和发展中国特色社会主义制度，为党和国家事业发展、为人民幸福安康、为社会和谐稳定、为国家长治久安提供一整套更完备、更稳定、更管用的制度体系。这项工程极为宏大，零敲碎打调整不行,碎片化修补也不行，必须是全面的系统的改革和改进，是各领域改革和改进的联动和集成，在国家治理体系和治理能力现代化上形成总体效应、取得总体效果。\n\n\n\n要敢于啃硬骨头、敢于涉险滩\n\n\n全面领导、统筹各方：中央全面深化改革委员会负责对改革总体设计、统筹协调、整体推进、督促落实。\n 二、怎样推进全面深化改革\n 坚持全面深化改革总目标\n\n\n党的十八届三中全会对全面深化改革作出顶层设计和全面部署，提出了全面深化改革的总目标：完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化\n\n\n深刻理解和准确把握全面深化改革的总目标\n\n\n完善和发展中国特色社会主义制度，赋予社会主义新的生机活力，提供一套更完备、更稳定、更管用的制度体系；最核心是坚持和改善党的领导、坚持和完善中国特色社会主义制度\n\n\n推进国家治理体系和治理能力现代化\n\n\n\n\n原因：国家治理体系和治理能力还有许多亟待改进的地方；制度还没有达到更加成熟更加定型的要求；有些地方甚至成为制约发展和稳定的重要因素\n\n\n强调：推进国家治理体系和治理能力现代化，\n\n\n一是不等于西方化------&quot;治理&quot;概念并非西方现代政治文明的专利，我国的治理体系和治理能力现代化是建立在中国特色社会主义制度基础之上的。\n\n\n二是不等于资本主义化；西方的治理体系和治理能力现代化以资本为中心，我国的治理体系和治理能力现代化以人民为中心。\n\n\n必须是全面的系统的改革和改进，形成总体效应、取得总体效果\n\n\n要不断提升国家治理本领。国家治理体系和国家治理能力是一个国家制度和制度执行力的集中体现，两者相辅相成，不能单靠其中一个治理国家。\n\n\n全面深化改革是有方向、有立场、有原则的\n\n\n改革是在中国特色社会主义道路上不断前进\n\n\n完善和发展中国特色社会主义制度，规定了全面深化改革的根本方向，就是走中国特色社会主义道路，而不是其他什么道路；\n\n\n推进国家治理体系和治理能力现代化，规定了在根本方向指引下完善和发展中国特色社会主义制度的鲜明指向。\n\n\n加强党对全面深化改革的集中统一领导，这是全面深化改革取得成功的关键，党要总揽全局、协调各方\n\n\n坚持市场经济改革的社会主义方向：发挥经济体制改革的牵引作用；完善社会主义市场经济体制\n\n\n必须以促进社会公平正义、增进人民福祉为出发点和落脚点\n\n\n许多领域实现历史性变革、系统性重塑、整体性重构\n党的十八届三中全会开启了全面深化改革、系统整体设计推进改革的新时代，实现了改革开放由局部探索、破冰突围到系统集成、全面深化的转变；\n\n\n全面深化改革不是某个领域某个方面的单项改革\n\n\n\n\n做到&quot;六个紧紧围绕&quot;：\n\n\n紧紧围绕使市场在资源配置中起决定性作用深化经济体制改革；\n\n\n紧紧围绕坚持党的领导、人民当家作主、依法治国有机统一深化政治体制改革；\n\n\n紧紧围绕建设社会主义核心价值体系、社会主义文化强国深化文化体制改革；\n\n\n紧紧围绕更好保障和改善民生、促进社会公平正义深化社会体制改革；\n\n\n紧紧围绕建设美丽中国深化生态文明体制改革；\n\n\n紧紧围绕提高科学执政、民主执政、依法执政水平深化党的建设制度改革。\n\n\n党的十九届四中全会，对坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化作出总体擘画。\n\n\n改革的系统集成主要体现：\n\n加强顶层设计和总体规划；\n注重系统性、整体性、协同性；\n从&quot;五位一体&quot;总体布局和党的制度建设上整体推进。\n\n\n\n党的十八大以来，党和国家组织结构实现系统性、整体性重构\n\n\n 三、如何构建对外开放新格局\n 实行更加积极主动的开放战略\n\n\n开放是当代中国的鲜明标识\n\n\n党的十八大以来，我国采取了更加积极主动的开放战略\n\n\n主动开放、双向开放、全面开放、公平开放、共赢开放、包容开放\n\n\n党的十八大以来，我国对外开放水平持续提升\n\n\n我国对外开放正面临着逆全球化的挑战，但中国对外开放的大门只会越开越大\n\n\n构建互利共赢、多元平衡、安全高效的开放型经济体系\n\n\n全新的开放型经济体系：扩内需和增外需相互动；引进来&quot;和&quot;走出去&quot;并举；促开放和护安全统筹；规则、规制、管理、标准等制度型开放\n 推动共建&quot;一带一路&quot;高质量发展\n\n\n坚持共商共建共享原则：不打地缘博弈小算盘；不搞封闭排他小圈子；不做凌驾于人的强买强卖\n\n\n基础设施更加通畅\n\n\n合作层次进一步提升\n\n\n政策对接更加顺畅\n\n\n人文交流更加深入\n\n\n围绕经济发展、民生改善和文明进步，建设和平之路、繁荣之路、开放之路、绿色之路、创新之路、文明之路。\n\n\n 第七讲 发展全过程人民民主\n 一、什么是全过程人民民主\n 民主是一种国家形式\n\n\n民主是一种阶级统治的国家制度，是统治阶级用来实现其阶级利益的政治形式和手段。\n\n\n古希腊雅典民主：实质是奴隶主的民主制，是奴隶主对奴隶的统治。\n\n\n\n\n\n\n\n\n\n\n\n近现代的西方资本主义民主：资产阶级的阶级本质决定其民主是虚假的民主，是资产阶级维护其统治的工具。\n社会主义民主：在人类历史上第一次实现多数人对少数人的统治，它不同于以往的一切少数剥削阶级占统治地位的国家的民主。\n\n\n为什么说社会主义民主是一种新的民主类型？\n\n\n资本主义民主：建立在生产资料私有制的经济基础之上；关注政治权利和政治平等，却无视人民群众经济权利平等，反对实行经济平等和社会平等；私人资本和权势集团控制公共权力；民主形式与实质相背离；实质是资产阶级的专政。\n\n\n社会主义民主：建立在以生产资料公有制为主体的经济基础之上；不仅要实现全体人民的政治民主，还要实现人民群众的经济权利和社会权利；国家一切权力属于人民；民主内容和形式是一致的；实质是人民当家作主。\n\n\n社会主义民主的实质是人民当家作主，人民当家作主是社会主义民主政治的本质和核心。\n\n\n\n\n怎样评价民主？\n\n\n从主体看，民主应该由这个国家的人民来评判；\n\n\n从功效看，民主要用来解决人民需要解决的问题；\n\n\n从标准看，民主作为一种国家制度，有其基本的评价依据。\n\n\n\n\n人民民主是社会主义的生命,没有民主就没有社会主义,就没有社会主义的现代化,就没有中华民族伟大复兴。\n\n\n 全过程人民民主是全链条、全方位、全覆盖的民主\n\n\n具有完整的制度程序和完整的参与实践\n\n\n在领域上，全过程人民民主涵盖经济、政治、文化、社会、生态文明等各个方面；以多样、畅通、有序的民主渠道，充分调动各地区、各民族、各方面、各阶层的积极性主动性创造性；充分发挥各级国家机关和武装力量、各政党和各社会团体、各企业事业组织的作用。\n\n\n在环节上，人民民主具体地、生动地体现在人民当家作主的全过程各环节，民主选举、民主协商、民主决策、民主管理、民主监督，五个环节，环环相扣，内在统一，形成全过程人民民主的完整链条。\n\n\n在形式和特点上，人民通过选举、投票行使权利和人民内部各方面在重大决策之前进行充分协商，尽可能就共同性问题取得一致意见。\n\n\n\n在实际效果上，实现了过程民主和成果民主、程序民主和实质民主、直接民主和间接民主、人民民主和国家意志相统一。\n\n\n党的领导是根本保证。中国共产党的领导，是中国发展全过程人民民主的根本保证。\n\n\n 二、全过程人民民主好在哪里\n 人民民主参与不断扩大\n\n\n民主参与的形式不断创新、渠道不断拓展\n\n\n人民参与的广度和深度不断拓展\n\n\n人民利益要求畅通表达\n\n\n人民利益要求得到回应\n\n\n 国家治理高效\n\n\n充分彰显人民的主体地位\n\n\n有效调节国家政治关系\n\n\n把党的主张、国家意志、人民意愿紧密融合在一起\n\n\n始终把中国人民利益放在第一位\n\n\n 社会和谐稳定\n\n人民民主是中国社会进步的推进器和润滑剂\n\n 权力运用得到有效制约和监督\n\n\n权力是一把&quot;双刃剑&quot;。权力在有效制约和监督下运行才能实现民主、造福人民；权力失去约束、恣意妄为必然破坏民主、危害人民。\n\n\n人民民主监督的形式和成效不断拓展深化。\n\n\n民主好不好，实践最有说服力，人民最有发言权。\n\n\n 三、如何进一步发展全过程人民民主\n 坚持走中国特色社会主义政治发展道路\n\n坚持党的领导、人民当家作主、依法治国有机统一。\n\n核心是坚持党的领导，党的领导是人民当家作主和依法治国的根本保证。人民当家做主是社会主义民主政治的本质特征。依法治国是党领导人民治理国家的基本方式。三者有机统一。\n\n绝不照搬西方政治制度模式。\n\n西方民主概念陷阱：概念泛化、价值矮化、原理神化、模式幻化。&quot;照搬&quot;无用、“照搬&quot;危险、不用&quot;照搬”。\n\n中国特色社会主义政治制度。\n\n是源于历史、根植民意的制度选择；是彰显民主、凝聚共识的制度设计；是中国发展、中国梦想的制度保障。\n 健全人民当家作主制度体系\n\n充分发挥人民代表大会制度的重要制度载体作用。\n\n坚持党的领导、保证人民权利、完善平台载体、讲好民主故事。\n\n增加和扩大制度的优势和特点。\n\n坚持党的领导核心作用、坚持国家一切权力属于人民、坚持和完善多党合作和政治协商制度、坚持和完善民族区域自治制度、坚持和完善基层群众自治制度、坚持和完善民主集中制的制度和原则。\n 推进社会主义协商民主广泛多层制度化发展\n\n\n发挥社会主义协商民主的独特优势。\n\n\n巩固和发展最广泛的爱国统一战线。\n\n\n 把人民当家作主具体地、现实地体现出来\n\n\n我们要继续推进全过程人民民主建设，把人民当家作主具体地、现实地体现到党治国理政的政策措施上来。\n\n\n我们要继续推进全过程人民民主建设，具体地、现实地体现到党和国家机关各个方面各个层级工作上来。\n\n\n我们要继续推进全过程人民民主建设，具体地、现实地体现到实现人民对美好生活向往的工作上来。\n\n\n 第八讲 全面依法治国\n 一、为什么要全面推进依法治国\n习近平法治思想的内容&quot;十一个坚持&quot;\n\n\n坚持党对全面依法治国的领导\n\n\n坚持以人民为中心\n\n\n坚持中国特色社会主义法治道路\n\n\n坚持依宪治国、依宪执政\n\n\n坚持在法治轨道上推进国家治理体系和治理能力现代化\n\n\n坚持建设中国特色社会主义法治体系\n\n\n坚持依法治国、依法执政、依法行政共同推进，法治国家、法治政府、法治社会一体建设\n\n\n坚持全面推进科学立法、严格执法、公正司法、全民守法\n\n\n坚持统筹推进国内法治和涉外法治\n\n\n坚持建设德才兼备的高素质法治工作队伍\n\n\n坚持抓住领导干部这个&quot;关键少数&quot;\n\n\n法治固根本、稳预期、利长远\n\n\n法治固根本。\n\n\n法治对于国家制度和治理体系具有&quot;固根本&quot;的保障作用。\n\n法治稳预期。\n\n在法治框架内活动，在法治轨道上运行，有利于全社会稳定预期、增强信心。\n\n法治利长远。\n\n法治是经验的总结、规律的反映、社会的共识，是制度之治最基本最稳定最可靠的保障。\n\n\n中国特色社会主义的本质要求和重要保障\n\n\n法治保障人民当家作主。\n\n\n法治保障党和国家长治久安。\n\n\n国家治理的一场深刻革命\n\n\n党对法治理论和实践的探索逐步深化。\n\n\n解决党和国家事业发展中重大问题的根本要求\n\n\n 二、如何理解全面依法治国的总目标\n 从&quot;依法治国&quot;到&quot;全面依法治国&quot;\n\n\n从&quot;依法治国&quot;到&quot;全面依法治国&quot;的历史发展脉络。\n\n\n从&quot;依法治国&quot;到&quot;全面依法治国&quot;的全面升级。\n\n\n全面依法治国。\n-全方位：法律规范体系、法治实施体系、法治监督体系、法治保障体系、党内法规体系。\n\n\n全层次：依法治国、依法执政、依法行政共同推进；法治国家、法治政府、法治社会一体建设。\n\n\n全过程：科学立法、严格执法、公正司法、全民守法。\n\n\n\n\n 全面依法治国的总目标\n\n\n全面依法治国的总目标是建设中国特色社会主义法治体系、建设社会主义法治国家。\n\n\n全面推进依法治国总抓手，就是建设中国特色社会主义法治体系。\n\n\n什么是中国特色社会主义法治体系。完备的法律规范体系、高效的法治实施体系、严密的法治监督体系、有力的法治保障体系、完善的党内法规体系。\n\n\n 坚持依宪治国、依宪执政\n\n\n宪法是治国理政的总章程。\n\n\n我国宪法的社会主义性质。\n\n\n为什么我们不能跟着西方所谓的&quot;宪政&quot;跑？\n\n\n坚持依宪治国、依宪执政，就包括坚持宪法确定的中国共产党领导地位不动摇，坚持宪法确定的人民民主专政的国体和人民代表大会制度的政体不动摇。\n\n\n拿西方&quot;宪政&quot;的标准来框住我们，用所谓&quot;宪政&quot;架空中国共产党领导、攻击我们不是&quot;宪政国家&quot;“法治国家”。以任何借口否定中国共产党领导和社会主义根本制度，都是错误的、有害的，都是绝对不能接受的，也是从根本上违反宪法的。\n\n\n\n\n全面贯彻实施宪法。宪法的生命在于实施，宪法的权威也在于实施。\n\n\n推动合宪性审查工作。维护宪法权威。\n\n\n深入开展宪法宣传教育。加强宪法学习宣传教育是实施宪法的重要基础。\n\n\n 三、如何建设法治中国\n 坚持党对全面依法治国的领导\n\n\n坚持党的领导是中国特色社会主义法治之魂。\n\n\n把党的领导贯彻到依法治国全过程和各方面。\n\n\n正确认识把握党和法的关系。\n\n\n在中国&quot;党大还是法大&quot;是一个伪命题。党和法、党的领导和依法治国是高度统一的，党和法的关系是政治和法治关系的集中反映。\n\n\n&quot;权大还是法大&quot;是个真命题。必须牢牢树立&quot;权不能大于法&quot;基本行为准则。\n\n\n坚持抓住领导干部这个&quot;关键少数。\n\n\n\n\n 完善以宪法为核心的中国特色社会主义法律体系\n\n\n完善立法体制。\n\n\n深入推进科学立法、民主立法。\n\n\n加强重点领域立法。\n\n\n 深入推进依法行政，加快建设法治政府\n\n\n依法全面履行政府职能，健全依法决策机制。\n\n\n深化行政执法体制改革。\n\n\n加强执法管理，坚持严格规范公正文明执法。\n\n\n强化对行政权力的制约和监督，全面推进政务公开。\n\n\n 保证公正司法，提高司法公信力\n\n\n完善司法权行使制度，优化司法职权配置。\n\n\n推进严格司法，加强人权司法保障\n\n\n保障人民群众参与司法，加强对司法活动的监督\n\n\n 增强全民法治观念，推进法治社会建设\n\n\n推动全社会树立法治意识。\n\n\n推进多层次多领域依法治理。\n\n\n建设完备的法律服务体系，健全依法维权和化解纠纷机制。\n\n\n 加强法治工作队伍建设\n\n\n建设高素质法治专门队伍，加强法律服务队伍建设。\n\n\n创新法治人才培养机制。\n\n\n 第九讲 建设社会主义文化强国\n 一、为什么建设中国特色社会主义文化\n 文化是一个国家、一个民族的灵魂\n\n\n为什么文化如此重要。\n\n文化是一种重要的力量，融入经济力量、政治力量、社会力量之中，成为经济发展的&quot;助推器&quot;、政治文明的&quot;导航灯&quot;、社会和谐的&quot;黏合剂&quot;。化解矛盾，要依靠文化的熏陶、教化、激励作用，发挥先进文化的凝聚、润滑、整合作用。\n\n\n\n为什么中国文化具有独特性。\n\n中华文明5000多年绵延不断、经久不衰，在长期演进过程中，形成了中国人看待世界、看待社会、看待人生的独特价值体系、文化内涵和精神品质，这是我们区别于其他国家和民族的根本特征，铸就了中华民族博采众长的文化自信。\n\n\n\n为什么强调文化自信。\n\n文化自信是更基础、更广泛、更深厚的自信，是一个国家、一个民族发展中最基本、最深沉、最持久的力量。\n\n\n\n如何发挥文化的重要作用。\n\n先进思想文化，一旦被群众掌握，就会转化为强大的物质力量。\n\n\n\n 没有文化繁荣兴盛就没有中华民族伟大复兴\n\n\n中华民族伟大复兴以文化繁荣兴盛为支撑条件。\n\n\n文化的繁荣兴盛需要强大的领导力量。\n\n\n 更好满足人民日益增长的精神文化需要\n\n\n促进满足人民文化需求和增强人民精神力量相统一。\n\n\n为人民提供更多优秀精神文化产品。\n\n\n促进人民精神生活共同富裕。\n\n\n 二、为什么要坚持马克思主义在意识形态领域指导地位的根本制度\n 意识形态工作是党的一项极端重要的工作\n\n\n做好意识形态工作。\n\n\n意识形态关乎旗帜、关乎道路、关乎国家政治安全。\n\n\n 巩固马克思主义在意识形态领域的指导地位\n\n\n为什么坚持马克思主义在意识形态领域指导地位的根本制度是历史的结论、现实的必然。\n\n\n为什么要坚持马克思主义在意识形态领域指导地位的根本制度。\n\n\n是由马克思主义的理论性质决定的。马克思主义是共产党人的&quot;真经&quot;。马克思主义是社会主义事业的&quot;北斗&quot;。马克思主义是当代中国文化发展的灵魂。\n 不断增强意识形态领域主导权和话语权\n\n意识形态领域现状：形势依然复杂、挑战依然严峻。\n\n社会思想意识复杂多样、相互交织；社会主流价值遭遇市场逐利性的挑战；媒体格局和舆论生态发生深刻变化；各种敌对势力对我国渗透遏制。\n\n如何应对：牢牢掌握意识形态工作领导权。\n\n用习近平新时代中国特色社会主义思想武装全党；巩固和发展主流意识形态；提升党、国家和民族的凝聚力向心力；加强意识形态人才队伍建设；推动传播手段建设和创新。\n\n\n互联网是意识形态斗争的主阵地、主战场、最前沿\n\n\n为什么网络意识形态如此重要。\n\n\n互联网是社会舆论的放大器；互联网是意识形态交锋最前沿。\n\n\n加强互联网内容建设，壮大主流舆论阵地。\n\n\n做强网上正面宣传，旗帜鲜明坚持正确政治方向、舆论导向、价值取向。\n\n\n加强网络空间治理，构建良好网络秩序。\n\n\n\n\n 三、为什么要用社会主义核心价值观凝心聚力\n 文化的影响力首先是价值观念的影响力\n\n\n不同民族、国家有不同的核心价值观。\n\n\n培育社会主义核心价值观的意义是什么。\n\n\n一个国家的文化软实力，从根本上说，取决于其核心价值观的生命力、凝聚力、感召力。确立反映全国各族人民共同认同的价值观&quot;最大公约数&quot;，使全体人民同心同德、团结奋进，关乎国家前途命运，关乎人民幸福安康。\n 社会主义核心价值观的内涵要义\n\n\n社会主义核心价值观的提出。\n\n\n应该坚守什么样的社会主义核心价值观。\n\n\n国家、社会、公民三个层面，24字概括。\n\n\n国家层面：富强 民主 文明 和谐；\n\n\n社会层面：自由 平等 公正 法治；\n\n\n公民层面：爱国 敬业 诚信 友善.\n\n\n培育和践行社会主义核心价值观\n\n\n使核心价值观的影响像空气一样无所不在、无时不有。\n\n\n推动理想信念教育常态化、制度化。\n\n\n融入法治建设和社会治理。\n\n\n在落细、落小、落实上下功夫\n\n\n 四、如何提升国家文化软实力和中华文化影响力\n\n\n推动中华优秀传统文化创造性转化、创新性发展\n\n\n从中华优秀传统文化中寻找源头活水。\n\n\n传承弘扬中华优秀传统文化。\n\n\n传统文化与现代文化相融合。\n\n\n警惕对待传统文化的两种错误倾向。\n\n\n反对文化复古主义、反对文化虚无主义，坚持守正创新。\n\n\n用中国特色社会主义文化培根铸魂\n\n\n发展社会主义先进文化。\n\n\n传承弘扬革命文化。\n\n\n推进文化事业和文化产业全面发展\n\n\n繁荣发展文化事业和文化产业，提高国家文化软实力。\n\n\n发展文化事业和文化产业。\n\n\n讲好中国故事，传播好中国声音\n\n\n展现中国形象。\n\n\n加强对外话语体系建设。\n\n\n提高讲好中国故事的能力。\n\n\n讲好中国故事的底气。\n\n\n 第十讲 加强以民生为重点的社会建设\n 一、为什么说&quot;悠悠万事，民生为大&quot;\n 民生是最大的政治\n\n\n民生事关人民幸福生活。\n\n\n民生事关社会和谐稳定。\n\n\n抓民生也是抓发展。\n\n\n 人民美好生活需要日益增长\n人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。\n 增进民生福祉是发展的根本目的\n中国共产党自成立之日起，就始终把为中国人民谋幸福、为中华民族谋复兴作为自己的初心使命。从中国共产党的百年奋斗历史来看，让老百姓过上好日子是党一切工作的出发点和落脚点。\n 二、怎样增强人民获得感、幸福感、安全感\n 抓住人民最关心最直接最现实的利益问题\n\n\n在幼有所育、学有所教、劳有所得、病有所医、老有所养、住有所居、弱有所扶上不断取得新进展。\n\n\n保障和改善民生的重要原则。\n\n\n既要尽力而为，又要量力而行。\n\n谨防三个&quot;陷阱&quot;。\n\n避免&quot;中等收入陷阱&quot;、警惕&quot;福利国家陷阱&quot;、摆脱&quot;贫困陷阱&quot;。\n\n\n坚决打赢脱贫攻坚战\n\n\n党中央把脱贫攻坚摆在治国理政的突出位置、把脱贫攻坚作为全面建成小康社会的底线任务、把精准脱贫作为三大攻坚战的重要内容。\n\n\n脱贫攻坚取得了伟大成就。\n\n\n脱贫攻坚精神。\n\n\n上下同心、尽锐出战、精准务实、开拓创新、攻坚克难、不负人民。\n\n\n脱贫攻坚的伟大经验。\n\n\n脱贫攻坚的伟大意义。\n\n\n 抗疫斗争最大限度保护人民生命安全和身体健康\n\n\n抗击新冠肺炎疫情成果显著。\n\n\n伟大抗疫精神。\n\n\n生命至上、举国同心、舍生忘死、尊重科学、命运与共。\n\n抗击新冠肺炎疫情的伟大经验。\n\n中国共产党的坚强领导力、中国人民不屈不挠的意志力、中国特色社会主义制度的显著优势、新中国成立以来积累的坚实国力、社会主义核心价值观中华优秀传统文化所具有的强大精神动力、构建人类命运共同体所具有的广泛感召力。\n\n统筹推进疫情防控和经济社会发展工作。\n\n 三、怎样推进社会治理现代化\n 坚持系统治理、综合治理、依法治理、源头治理\n\n推动社会管理向社会治理转变。\n\n行动理念、行动主体、行动取向。\n\n不断改进社会治理方式。\n\n系统治理、综合治理、依法治理、源头治理\n\n加强和创新社会治理工作的重点内容。\n\n创新社会治理体制、完善正确处理新形势下人民内部矛盾有效机制、\n健全公共安全体系、完善社会治安防控体系、加强社会心理服务体系建设、构建基层社会治理新格局。\n 健全党组织领导的自治、法治、德治相结合的城乡基层治理体系\n\n\n坚持党组织领导基层群众性自治组织的制度。\n\n\n推进基层法治与德治建设。\n\n\n发展公益慈善事业。\n\n\n加强社会治安综合治理\n\n\n建设立体化、信息化的全方位社会治安防控体系。\n\n\n防范化解影响社会安定的问题，打击违法犯罪活动。\n\n\n扎实开展平安中国建设，维护社会稳定、保障人民安全。\n\n\n常态化开展扫黑除恶斗争。\n\n\n 第十一讲 建设社会主义生态文明\n习近平生态文明思想是习近平新时代中国特色社会主义思想的重要组成部分，是我们党不懈探索生态文明建设的理论升华和实践结晶，是马克思主义基本原理同中国生态文明建设实践相结合、同中华优秀传统生态文化相结合的重大成果，是以习近平同志为核心的党中央治国理政实践创新和理论创新在生态文明建设领域的集中体现，是人类社会实现可持续发展的共同思想财富，是新时代我国生态文明建设的根本遵循和行动指南。\n十个坚持：\n\n\n坚持党对生态文明建设的全面领导\n\n\n坚持生态兴则文明兴\n\n\n坚持人与自然和谐共生\n\n\n坚持绿水青山就是金山银山\n\n\n坚持良好生态环境是最普惠的民生福祉\n\n\n坚持绿色发展是发展观的深刻革命\n\n\n坚持统筹山水林田湖草沙系统治理\n\n\n坚持用最严格制度最严密法治保护生态环境\n\n\n坚持把建设美丽中国转化为全体人民自觉行动\n\n\n坚持共谋全球生态文明建设之路\n\n\n 一、为什么建设生态文明------关乎中华民族永续发展的根本大计\n 顺应人类文明进程\n生态文明是人类社会进步的重大成果。人类经历了原始文明、农业文明、工业文明，生态文明是工业文明发展到一定阶段的产物，是实现人与自然和谐发展的新要求。历史地看，生态兴则文明兴，生态衰则文明衰。古今中外，这方面的事例众多。\n\n生态兴则文明兴，生态衰则文明衰\n\n在人类发展史上特别是工业化进程中，曾发生过大量破坏自然资源和生态环境的事件，酿成惨痛教训。马克思在研究这一问题时，曾列举了波斯、美索不达米亚、希腊等由于砍伐树木而导致土地荒芜的事例。据史料记载，丝绸之路、河西走廊一带曾经水草丰茂。由于毁林开荒、乱砍滥伐，致使这些地方生态环境遭到严重破坏。据反映，三江源地区有的县，三十多年前水草丰美，但由于人口超载、过度放牧、开山挖矿等原因，虽然获得过经济超速增长，但随之而来的是湖泊锐减、草场退化、沙化加剧、鼠害泛滥，最终牛羊无草可吃。古今中外的这些深刻教训，一定要认真吸取，不能再在我们手上重犯！\n\n人类文明进程的生态趋向\n\n建设生态文明是顺应人类文明进程、实现人与自然和谐共生的必然要求，具有历史必然性。原始文明、农业文明、工业文明、生态文明。\n 破解我国经济社会发展短板问题\n改革开放以后，党日益重视生态环境保护。同时，生态文明建设仍然是一个明显短板，资源环境约束趋紧、生态系统退化等问题越来越突出，特别是各类环境污染、生态破坏呈高发态势，成为国土之伤、民生之痛。如果不抓紧扭转生态环境恶化趋势，必将付出极其沉重的代价。\n\n破解我国资源保障能力较弱对经济社会可持续发展的制约\n\n随着经济社会不断发展，我国已成为世界上最大的能源消费国，大量能源需要进口；从长远看，对资源的需求仍然在不断增长。要破解这一短板问题，实现我国经济社会的可持续发展，必须着力开发利用清洁能源，提高资源利用效率。\n\n破解环境污染依然严重对人民生活质量和幸福感的制约\n\n大气污染、水体污染、土壤污染严重制约人民群众的生活质量和幸福感。要破解这一短板问题，必须坚决打好环境污染防治攻坚战，从根本上改善我国生态环境。\n\n破解我国生态系统依然脆弱对其服务经济社会发展能力的制约\n\n过去一段时期，我国生态退化比较严重，致使我国经济社会发展的环境承载力下降。要破解这一短板问题，必须加快构建生态功能保障基线，提升生态系统质量和稳定性。像青海和西藏等地的重点生态功能区，生态产品和服务的价值极大。如果盲目开发造成破坏，今后花多少钱也补不回来。\n 满足人民日益增长的优美生态环境需要\n现在，随着我国社会主要矛盾转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，人民群众对优美生态环境需要已经成为这一矛盾的重要方面，广大人民群众热切期盼加快提高生态环境质量。人民对美好生活的向往是我们党的奋斗目标，解决人民最关心最直接最现实的利益问题是执政党使命所在。\n\n生态环境破坏与人民优美生态环境需要不相适应\n\n改革开放以来，多年快速发展积累的生态环境问题十分突出，老百姓意见大、怨言多，生态环境破坏和污染不仅影响经济社会可持续发展，而且严重影响人民优美生态环境需要的满足。随着人民群众的生活水平不断提高，保护生态环境、建设美丽中国应该而且必须成为发展的题中之义。\n\n人民日益增长的优美生态环境需要\n\n生态环境是关系党的使命宗旨的重大政治问题，也是关系民生的重大社会问题。进入新时代，生态环境在群众生活幸福指数中的地位不断凸显，人民对优美生态环境的需要愈益普遍、愈发强烈，渴望远离浓烟重霾、臭水脏土、垃圾围城，期盼蓝天白云、繁星闪烁、清水绿岸、鱼翔浅底、鸟语花香。\n\n凸显生态文明建设的利民、惠民、为民价值\n\n&quot;民之所好好之，民之所恶恶之。&quot;积极回应人民群众所想、所盼、所急，不断满足人民群众日益增长的优美生态环境需要是新时代中国共产党不忘初心、牢记使命的自觉担当。迫切需要大力推进生态文明建设，提供更多优质生态产品，让人民群众吃穿住行更放心、更称心、更安心，望得见山、看得见水、记得住乡愁。\n 应对全球生态环境领域挑战\n近年来，气候变化、生物多样性丧失、荒漠化加剧、极端气候事件频发，给人类生存和发展带来严峻挑战。新冠肺炎疫情持续蔓延，使各国经济社会发展雪上加霜。面对全球环境治理前所未有的困难，国际社会要以前所未有的雄心和行动，勇于担当，勠力同心，共同构建人与自然生命共同体。\n\n生态环境恶化是当代人类面临的严重全球性问题\n\n当代生态环境恶化的影响日益扩大，人为造成的生态环境问题日益严重，并迅速由发达国家向发展中国家蔓延，对生态安全等造成威胁。气候变化、海洋污染、臭氧空洞、生化污染、土地沙漠化、生物多样性锐减等严峻状况，威胁着整个人类社会的生存和发展。\n\n积极参与全球环境治理是我国生态文明建设的有机组成部分\n\n气候变化等全球性生态环境问题导致当代世界生态环境风险凸显，需要国际社会共同担当和应对。积极参与气候变化等全球环境治理，不仅能推动国际社会共同构建人与自然命运共同体，展现我国作为负责任发展中大国的担当和影响力，而且可化解全球生态环境问题给中华民族永续发展带来的风险。\n 二、建设什么样的生态文明------树立社会主义生态文明观\n 人与自然和谐共生的现代化\n把握进入新发展阶段、贯彻新发展理念、构建新发展格局对生态文明建设提出的新任务新要求，分析我国生态文明建设面临的新形势，推动建设人与自然和谐共生的现代化。\n\n人与自然是生命共同体\n\n人因自然而生，人与自然是一种共生关系。生态环境没有替代品，用之不觉，失之难存。如果竭泽而渔，最后必然是什么鱼也没有了。河北塞罕坝几代人驰而不息所创造的&quot;绿色奇迹&quot;堪称恢复和优化人与自然生命共同体的典范。人类对大自然的伤害最终会伤及人类自身，这是无法抗拒的规律。这从20世纪发生的世界十大环境公害事件可见一斑。\n\n实现人与自然和谐共生的现代化\n\n我国生态文明是以生态规律为依循、以实现人与自然和谐共生的现代化为目标的文明新形态。在整个建设过程中，我们不是只讲索取不讲投入，不是只讲发展不讲保护，不是只讲利用不讲修复，而是像保护眼睛一样保护生态环境，还自然以宁静、和谐、美丽，追求人与自然和谐共生。\n 绿水青山就是金山银山\n既要绿水青山，也要金山银山；绿水青山就是金山银山。绿水青山和金山银山决不是对立的，关键在人，关键在思路。为什么说绿水青山就是金山银山？&quot;鱼逐水草而居，鸟择良木而栖。&quot;如果其他各方面条件都具备，谁不愿意到绿水青山的地方来投资、来发展、来工作、来生活、来旅游？从这一意义上说，绿水青山既是自然财富，又是社会财富、经济财富。\n\n绿水青山与金山银山的内在联系\n\n绿水青山的诱人景象及其宜居宜业宜游特征，不仅会成为当地人民的生态福祉，而且会使游客、人才和投资者偏爱有加，成为引来&quot;金凤凰&quot;的&quot;梧桐树&quot;和激活土地、劳动力、资产等要素的&quot;催化剂&quot;。\n\n绿水青山与金山银山的良性循环\n\n绿水青山在社会生产中持续&quot;为劳动提供材料&quot;，促进金山银山量和质的双重提升，推动社会生产力的绿色发展，而这又将回馈、绵延绿水青山的生机，保护和改善自然生产力。\n 良好生态环境是最普惠的民生福祉\n动员全社会力量推进生态文明建设，共建美丽中国，让人民群众在绿水青山中共享自然之美、生命之美、生活之美，走出一条生产发展、生活富裕、生态良好的文明发展道路。\n\n保护生态环境是为了民生\n\n环境就是民生，青山就是美丽，蓝天也是幸福。发展经济是为了民生，保护生态环境同样也是为了民生。如新疆哈密市着力推动生态恢复的目的就是惠民生。\n\n人民共同建设共同享有的生态文明\n\n生态惠民、生态利民、生态为民，生态靠民。重点解决损害群众健康的突出环境问题，建设健康宜居美丽家园，有效防范生态环境风险，为人民群众提供更多优质生态产品，让人民群众日益普遍地享有优美生态环境。生态文明成为人民群众共同参与共同建设共同享有的事业和全体人民的自觉行动。\n 山水林田湖草沙是生命共同体\n山水林田湖草是生命共同体。生态是统一的自然系统，是相互依存、紧密联系的有机链条。人的命脉在田，田的命脉在水，水的命脉在山，山的命脉在土，土的命脉在林和草，这个生命共同体是人类生存发展的物质基础。一定要算大账、算长远账、算整体账、算综合账，如果因小失大、顾此失彼，最终必然对生态环境造成系统性、长期性破坏。\n\n生态系统是有机关联的系统整体\n\n生态系统是一个系统整体，山水林田湖草沙构成相依共存、有机关联的生命共同体。这个生命共同体的生生循环、绵延不息葆有着人类生存发展的物质根基。\n\n\n山水林田湖草沙系统治理之道\n\n\n坚持系统观念，保护生态环境\n\n\n国土绿化规模增大，生态安全屏障牢固\n\n\n各种生态环境要素之间的比例和空间关系得到维持、恢复、优化\n\n\n自然生态系统稳定性和生态服务功能全面提升\n\n\n 用最严格制度最严密法治保护生态环境\n保护生态环境必须依靠制度、依靠法治。只有实行最严格的制度、最严密的法治，才能为生态文明建设提供可靠保障。\n\n保护生态环境必须依靠最严格制度最严密法治\n\n保证党中央关于生态文明建设决策部署落地生根见效，牢固树立生态环境法治理念，生态文明制度体系健全、配套完善，管权治吏、护蓝增绿制度严格，有权必有责、有责必担当、失责必追究。\n\n生态环境治理的体系化、法治化和效能化\n\n制度涵盖生态文明建设的源头处置、过程控制、损害赔偿和责任追究，覆盖生态环境保护的主体和对象，建有最严格的执行机制。以制度力量提升生态环境治理效能，促进人与自然和谐共生。\n 共谋全球生态文明建设\n生态文明建设关乎人类未来，建设绿色家园是人类的共同梦想，保护生态环境、应对气候变化需要世界各国同舟共济、共同努力，任何一国都无法置身事外、独善其身。我国已成为全球生态文明建设的重要参与者、贡献者、引领者，主张加快构筑尊崇自然、绿色发展的生态体系，共建清洁美丽的世界。\n\n地球是全人类的共有家园\n\n当代经济和生态环境问题的全球化，将人类的利益和命运紧紧联系在一起，构成了现实的命运共同体。生态环境问题的跨国界蔓延，危及全人类的共有家园，需要世界各国同舟共济、携手合作、共同应对。\n\n全球生态文明建设的重要参与者、贡献者、引领者\n\n我国是全球气候变化谈判进程和《巴黎协定》签署、生效、实施的积极推动者，是将绿色发展纳入&quot;一带一路&quot;合作规划和中非合作计划的引领者。\n我国秉持历史与现实相统一、可持续发展、共同但有区别的责任原则，根据自身条件，努力解决生态环境问题，美丽中国建设不断迈上新台阶，同时携手国际社会共同应对环境问题，成为全球生态环境治理智慧和方案的重要贡献者。\n 三、怎样建设美丽中国------推进绿色发展、循环发展、低碳发展\n 形成绿色发展方式和生活方式\n推动形成绿色发展方式和生活方式是贯彻新发展理念的必然要求，必须把生态文明建设摆在全局工作的突出地位，坚持节约资源和保护环境的基本国策，坚持节约优先、保护优先、自然恢复为主的方针，形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式，努力实现经济社会发展和生态环境保护协同共进，为人民群众创造良好生产生活环境。\n\n加快推动发展方式和生活方式绿色转型\n\n构建市场导向的绿色科技创新体系，推进资源全面节约和循环利用体系，倡导简约适度绿色低碳的生活方式，建立健全绿色低碳循环的经济体系。\n\n\n产业结构，空间结构，能源结构，消费方式绿色转型\n\n\n打造国家重大战略绿色发展高地\n\n\n 着力解决突出环境问题\n\n\n环境保护和治理要以解决损害群众健康突出环境问题为重点，坚持预防为主、综合治理，强化水、大气、土壤等污染防治，着力推进重点流域和区域水污染防治，着力推进重点行业和重点区域大气污染治理。\n\n\n着力打赢污染防治攻坚战，深入实施大气、水、土壤污染防治三大行动计划，深入打好蓝天、碧水、净土保卫战，开展农村人居环境整治。全面禁止洋垃圾入境：严打走私\n严查倒卖。\n\n\n 加快推进生态环境保护修复\n\n\n要深入实施山水林田湖草一体化生态保护和修复，开展大规模国土绿化行动，加快水土流失和荒漠化石漠化综合治理。\n\n\n多措并举，全方位推进生态环境保护修复\n\n\n优化国土空间开发保护格局，建立以国家公园为主体的自然保护地体系，持续开展大规模国土绿化行动，加强大江大河和重要湖泊湿地及海岸带生态保护和系统治理。建立市场化、多元化生态补偿机制\n 扎实推进碳达峰碳中和工作\n实现碳达峰、碳中和是我国向世界作出的庄严承诺，也是一场广泛而深刻的经济社会变革，绝不是轻轻松松就能实现的。\n\n增加碳吸收 减少碳使用 加强碳转换 控制碳排放\n\n必须坚持全国统筹、节约优先、双轮驱动、内外畅通、防范风险的原则，更好发挥我国制度优势、资源条件、技术潜力、市场活力。\n\n最大限度地克制&quot;生存和发展排放&quot;\n\n发达国家应减少的是&quot;奢侈排放&quot;，中国则是最大限度地克制&quot;生存和发展排放&quot;。我们要坚持共同但有区别的责任原则、公平原则和各自能力原则，坚定维护多边主义，有效应对一些西方国家对我国进行&quot;规锁&quot;的企图，坚决维护我国发展利益。\n\n注重处理好四对关系，落实六项举措\n\n四对关系包含发展和减排、整体和局部、长远和短期、政府和市场。\n\n\n\n\n\n\n\n\n\n六项举措包含\n\n\n加强统筹协调\n\n\n推动能源革命\n\n\n推进产业优化升级\n\n\n加快绿色低碳科技革命\n\n\n完善绿色低碳政策体系\n\n\n积极参与和引领全球气候治理\n\n\n 改革完善生态环境监管考核体制\n推进生态文明建设，解决资源约束趋紧、环境污染严重、生态系统退化的问题，必须采取一些硬措施，真抓实干才能见效。\n健全落地见效的生态环境监管考核体制\n\n\n设立国有自然资源资产管理和自然生态监管机构\n\n\n构建国土空间全方位开发保护制度体系\n\n\n建立政府、企业、社会、公众参与的治理体系\n\n\n党的十八大以来，我国全面加强生态文明建设，决心之大、力度之大、成效之大前所未有。习近平在主持中共十九届中央政治局第二十九次集体学习时的讲话时指出，“九年来，蓝天白云重新展现，绿色版图不断扩展，绿色经济加快发展，能耗物耗不断降低，浓烟重霾有效抑制，黑臭水体明显减少，城乡环境更加宜居，美丽中国建设迈出坚实步伐，绿水青山就是金山银山的理念成为全党全社会的共识和行动。”\n生态文明建设是关乎中华民族永续发展的根本大计。建设社会主义生态文明主要涵括人与自然和谐共生的现代化，绿水青山就是金山银山，良好生态环境是最普惠的民生福祉，山水林田湖草沙是生命共同体，用最严格制度最严密法治保护生态环境，共谋全球生态文明建设。要加快推进绿色发展、循环发展、低碳发展，开创美丽中国建设新局面。\n\\\n 第十二讲 建设巩固国防和强大人民军队\n习近平强军思想作为习近平新时代中国特色社会主义思想的重要组成部分，是我们党不懈探索中国特色强军之路形成的宝贵思想结晶，是加快国防和军队现代化、全面建设世界一流军队的行动纲领，谱写了当代中国马克思主义军事理论和军事实践发展的新篇章，为新时代国防和军队建设提供了科学指南和行动纲领。\n十一个方面\n\n\n关于强国必须强军\n\n\n关于实现党在新时代的强军目标\n\n\n关于坚持党对人民军队的绝对领导\n\n\n关于全面提高新时代备战打仗能力\n\n\n关于弘扬我党我军光荣传统和优良作风\n\n\n关于推动我军高质量发展\n\n\n关于深化国防和军队改革\n\n\n关于加快国防科技创新\n\n\n关于锻造高素质专业化新型军事人才\n\n\n关于提高国防和军队建设法治化水平\n\n\n关于构建一体化国家战略体系和能力\n\n\n 一、为什么要建设一支强大人民军队------强国必须强军、军强才能国安\n 国际战略形势发生深刻变化\n\n经济全球化进程出现波折\n\n保护主义、霸凌行径上升，新冠肺炎疫情和乌克兰危机影响交织叠加，全球面临粮食、能源、金融安全危机，国际安全风险加大。\n\n国际战略格局深度调整\n\n一超多强趋势明显，一些西方国家长期主导国际事务的优势逐渐丧失，国际格局演变进程不会风平浪静。\n\n全球治理体系变革加速推进\n\n发展中国家话语权的增加涉及各国特别是大国利益，必然会有斗争，不可能一帆风顺。\n\n发展道路和发展模式的竞争更加激烈\n\n新冠肺炎疫情全球大流行，各国的领导力和制度优越性激烈较量，围绕发展道路的竞争是长期复杂的。\n 我国处于由大向强发展的关键阶段\n一个国家往往在两个时期面临的外部压力最大，一个是积贫积弱之时，另一个是发展振兴之时。今天，我们比历史上任何时期都更接近中华民族伟大复兴的目标，比历史上任何时期都更需要建设一支强大的人民军队。\n\n由大向强、将强未强之际是国家安全的高风险期\n\n我国国家安全形势不稳定性不确定性增大；\n必须建立强大的人民军队；\n人民军队必须时刻绷紧备战打仗这根弦。\n\n\n某些西方大国不甘心让中国&quot;赢得21世纪&quot;\n\n经济压制 、高科技封锁 、疫情溯源 (“甩锅&quot;中国)、印太战略 (印太版的&quot;北约”)、所谓&quot;五四三二&quot;的遏制阵势 (强化&quot;五眼联盟&quot;、兜售&quot;四边机制&quot;、拼凑三边安全伙伴关系、收紧双边军事同盟)。\n\n\n我国周边热点地区局势充满变数\n\n&quot;三股势力&quot;威胁西北边境地区安全稳定、海上安全环境更趋复杂、陆上部分边境地区可能爆发冲突。\n\n\n\n 国际军事竞争日趋激烈\n世界新军事革命加速发展，军事技术和战争形态发生革命性变化，军事竞争战略主动权的争夺更加激烈。这场世界新军事革命给我军提供了难得的历史机遇，同时也提出了严峻挑战。机遇稍纵即逝，抓住了就能乘势而上，抓不住就可能错过整整一个时代。\n\n世界新军事革命正加速推进\n\n这场军事领域的变革以信息化为核心，以军事战略、军事技术、作战思想、作战力量、组织体制和军事管理创新为基本内容，以重塑军事体系为主要目标，其速度之快、范围之广、程度之深、影响之大，为第二次世界大战结束以来所罕见。武器装备远程精确化、智能化、隐身化、无人化趋势更加明显，战争形态加速向信息化战争演变，智能化战争初现端倪。\n我军必须加快推进中国特色军事变革，缩小同世界强国在军事实力上的差距，掌握军事竞争战略主动权。\n未来智能化战争的场景：智能化作战体系成为主要力量形态。人的智能移植到了武器上。人与武器实现高度一体化，智能化作战体系的核心要义在于&quot;人类指挥、机器自主、网络支撑&quot;。自主作战成为主要作战方式。智能化作战系统广泛应用于装备部队，并逐渐成为战场的主要作战力量，自主作战上升为主要作战方式，从自主、规模、弹性、认知等方面深刻改变着作战样式。&quot;制智权&quot;成为战争核心制权。&quot;制智权&quot;成为战争制权争夺的核心，智能主导、自主驭能、以智谋胜将成为智能化战争的基本法则。\n\n各主要国家纷纷加快军事变革\n\n美国、俄罗斯、英国、法国、德国、日本、印度等国家纷纷采取新的重大军事举措，加紧推进军事转型。我军不仅要赶上潮流、赶上时代，还要力争走在时代前列。\n 我军需要一场革命性变革------全面推进国防和军队现代化\n我军许多年没有打过仗了，打现代化战争能力不够，各级干部指挥现代化战争能力不够，这两个问题依然很现实地摆在我们面前。\n\n回答好&quot;胜战之问&quot;，需要一支强大人民军队\n\n现代战争特点\n\n\n制信息权是战场争夺的核心\n\n\n一体化联合作战是基本作战形式\n\n\n运用精锐力量实施精确作战\n\n\n我军差距\n中国特色军事变革取得重大进展，但机械化建设任务尚未完成，信息化水平亟待提高，军事安全面临技术突袭和技术代差被拉大的风险，军队现代化水平与国家安全需求相比差距还很大，与世界先进军事水平相比差距还很大。\n\n\n解决军队长期积累的制度性障碍、结构性矛盾、政策性问题，需要革命性重塑\n\n\n军事理论现代化\n\n\n军队组织形态现代化\n\n\n军事人员现代化\n\n\n武器装备现代化\n\n\n加快军事智能化发展，提高基于网络信息体系的联合作战能力、全域作战能力\n\n\n加快机械化信息化智能化融合发展\n\n\n 二、怎样建设巩固国防和强大人民军队------全面推进国防和军队现代化\n 确立党在新时代的强军目标\n明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队。\n\n\n听党指挥是灵魂\n\n决定军队建设的政治方向\n\n\n\n毛泽东在1929年指出，“一个子弹不问过党不能支配，他们是绝对的党领导”。人民军队由党缔造，自人民军队诞生起，其命运就与党的命运紧密相连。\n坚持党对人民军队的绝对领导，这一建军根本原则不是凭空产生的，而是我们党和军队以鲜血为代价换来的、历经艰辛探索得来的。\n无论时代如何发展、形势如何变化，坚持党对人民军队的绝对领导始终是我军的军魂和命根子，永远不能变，永远不能丢。\n\n引领我军从胜利走向胜利\n\n\n\n\n\n\n\n\n\n\n1935年12月，红军到达陕北后，毛泽东在瓦窑堡党的活动分子会议上指出：“谁使长征胜利的呢？是共产党。没有共产党，这样的长征是不可能设想的。”\n我军之所以能够无往而不胜，最终战胜一切敌人而不为敌人所压倒，是因为坚决听党指挥，这是我们的建军之魂、强军之魂。\n\n确保我军不变质不变色\n\n党旗所指，军旗所向。这是一切敌人最惧怕我们的一点，也是保证我们党长期执政、国家长治久安的根本法宝。党对军队的绝对领导是中国特色社会主义的本质特征，是党和国家的重要政治优势，是人民军队的建军之本、强军之魂。\n\n能打胜仗是核心\n\n当兵就是要打仗，这就像工人要做工、农民要种田一样，打仗和准备打仗是军人的天职，也是军队使命职责之所在。\n\n战场打不赢，一切等于零\n\n军事上的落后一旦形成，对国家安全的影响将是致命的。\n\n英雄的人民军队打出了国威军威\n\n90年来，人民军队历经硝烟战火，一路披荆斩棘，付出巨大牺牲，取得一个又一个辉煌胜利，为党和人民建立了伟大的历史功勋。\n\n切实把战斗队思想立起来\n\n必须扭住能打仗、打胜仗这个强军之要，强化当兵打仗、带兵打仗、练兵打仗思想。按照打仗的要求搞建设、抓准备，坚持不懈拓展和深化军事斗争准备。锻造召之即来、来之能战、战之必胜的精兵劲旅。\n\n\n作风优良是保证\n\n\n人民军队在党的旗帜下前进，培育了特有的光荣传统和优良作风\n\n\n人民军队为党的伟大精神的形成作出突出贡献\n\n\n\n\n井冈山精神、长征精神、抗美援朝精神、雷锋精神\n\n\n风清弊绝，才能实现强军目标\n\n\n新时代全军必须夯实依法治军、从严治军这个强军之基，持之以恒推进作风建设和反腐败斗争，自觉践行人民军队根本宗旨，保持人民军队长期形成的良好形象。\n\n\n贯彻依法治军战略，提高国防和军队建设法治化水平。“依法治军战略&quot;的内涵要求------“八个坚持”：坚持党对军队绝对领导，坚持战斗力标准，坚持建设中国特色军事法治体系，坚持按照法治要求转变治军方式，坚持从严治军铁律，坚持抓住领导干部这个&quot;关键少数”，坚持官兵主体地位，坚持贯彻全面依法治国要求。\n\n\n大力弘扬优良作风，把红色基因一代代传下去。\n\n\n建成世界一流军队\n\n\n到2027年实现建军一百年奋斗目标，到2035年基本实现国防和军队现代化，到本世纪中叶把人民军队全面建成世界一流军队。\n\n\n在强军目标下确立新时代军事战略方针\n\n\n新时代军事战略方针，坚持防御、自卫、后发制人原则，实行积极防御，坚持&quot;人不犯我、我不犯人，人若犯我、我必犯人&quot;，强调遏制战争与打赢战争相统一。强调战略上防御与战役战斗上进攻相统一。\n\n\n增强军事战略指导的进取性和主动性。整体运筹备战与止战、维权与维稳、威慑与实战、战争行动与和平时期军事力量运用，注重深远经略，塑造有利态势，综合管控危机，坚决遏制和打赢战争。\n\n\n\n\n在强军目标下调整优化军事战略布局\n\n\n根据中国地缘战略环境、面临安全威胁和军队战略任务，构建全局统筹、分区负责，相互策应、互为一体的战略部署和军事布势；应对太空、网络空间等新型安全领域威胁，维护共同安全；加强海外利益攸关区国际安全合作，维护海外利益安全。\n\n\n根据国家面临的安全威胁，扎实做好军事斗争准备，全面提高新时代备战打仗能力，构建立足防御、多域统筹、均衡稳定的新时代军事战略布局。\n\n\n\n\n 贯彻政治建军方略\n\n在古田召开全军政治工作会议\n\n习近平提议并主持召开全军政治工作会议 ( 2014年10月30日至11月2日)\n\n\n强调革命的政治工作是革命军队的生命线，明确提出军队政治工作的时代主题。\n\n\n要求把理想信念、党性原则、战斗力标准、政治工作威信4个带根本性的东西立起来。\n\n\n着力抓好铸牢军魂工作、高中级干部管理、作风建设和反腐败斗争、战斗精神培育、政治工作创新发展等五个方面的重点工作。\n\n\n全面深入贯彻军委主席负责制\n\n\n中央军委实行主席负责制，是坚持党对人民军队绝对领导的根本制度和根本实现形式，在党领导军队的一整套制度体系中处于最高层次、居于统领地位。\n\n\n加强新时代军队党的建设\n\n\n着力抓好军队党的政治建设，严肃政治纪律和政治规矩，确保部队绝对忠诚、绝对纯洁、绝对可靠，确保枪杆子永远听党指挥。\n\n\n严肃军队党内政治生活，认真执行党的民主集中制，认真开展批评和自我批评。\n\n\n锻造坚强有力的党组织，加强我军党的组织体系建设，增强各级党组织的领导力、组织力、执行力，把党的政治优势和组织优势转化为制胜优势。\n\n\n用习近平强军思想武装官兵\n\n\n全面系统学习习近平新时代中国特色社会主义思想，学习习近平强军思想。\n\n\n把习近平强军思想作为学习教育的主题主课，打牢部队听党指挥、履行使命的思想政治基础。\n\n\n加强研究阐释，深入回答强军兴军的重大理论和实践问题，推动习近平强军思想入脑入心。\n\n\n培养&quot;四有&quot;新时代革命军人，锻造&quot;四铁&quot;过硬部队。 (有灵魂、有本事、有血性、有品德；铁一般的信仰、铁一般的信念、铁一般的纪律、铁一般的担当)\n\n\n 深化国防和军队改革\n\n搞好深化国防和军队改革的顶层设计\n\n深化国防和军队改革是一场回避不了的大考。不改革军队是打不了仗、打不了胜仗的，要树立向改革要战斗力的思想。\n\n\n2013年11月，党的十八届三中全会把深化国防和军队改革单列为一个部分写入全会决定中，纳入全面深化改革总体布局、上升为党的意志和国家行为，这在党的历史上是首次。\n\n\n2015年11月，中央军委改革工作会议召开，对深化国防和军队改革进行总体部署。\n\n\n2016年1月，印发《中央军委关于深化国防和军队改革的意见》。\n\n\n深化国防和军队改革的&quot;三大战役&quot;\n\n\n第一大战役：领导指挥体制改革，重在解决体制性障碍 (2015年底开始)\n第二大战役：压茬推进规模结构和力量编成改革，重在解决结构性矛盾 (2016年底开始)\n第三大战役：深化政策制度改革，重在解决政策性问题 (2018年底开始)\n\n深化国防和军队改革取得重大成效\n\n体制一新------打破了长期实行的总部体制、大军区体制、大陆军体制。\n结构一新------形成了军委管总、战区主战、军种主建的新格局。\n格局一新------改变了长期以来陆战型、国土防御型的力量结构和兵力布势。\n面貌一新------实现了我军组织架构和力量体系的整体性、革命性重塑。\n党的十八大以来，深化国防和军队改革大开大合、大破大立、蹄疾步稳，实现了我军组织架构和力量体系的整体性、革命性重塑，有效解决了制约我军建设的体制性障碍、结构性矛盾。\n 聚焦能打胜仗练兵备战\n\n\n牢固确立战斗力这个唯一的根本的标准\n\n\n军队是要打仗的，要牢固树立战斗力这个唯一的根本的标准，坚持把战斗力标准贯彻到全军各项建设和工作之中。\n\n\n把新时代军事战略思想、新时代军事战略方针、备战打仗指挥棒、抓备战打仗的责任担当立起来。\n\n\n大力纠治和平积弊，推进军事训练转型升级，狠抓军事斗争准备，大抓战斗精神培育。\n\n\n加快构建新型军事训练体系\n\n\n坚持以战领训、以训促战、战训一致，大抓实战化军事训练。\n\n\n加快军事训练条件建设，创新训练保障模式，创设逼真战场环境，开发先进训练手段。\n\n\n深入推进联战联训，加速提升一体化联合作战能力，广泛开展各战略方向使命课题针对性训练和各军兵种演训。\n\n\n更好更快进行武器装备现代化建设\n\n\n设计武器装备就是设计未来战争。把发展高技术武器装备摆在战略位置，抓紧攻坚具有前瞻性、战略性意义的&quot;杀手锏&quot;装备，加强前瞻性、先导性、探索性、颠覆性技术研究，加快军事智能化发展。\n 三、人民军队怎样捍卫国家主权、安全、发展利益------坚决履行新时代人民军队使命任务\n 人民军队实现整体性革命性重塑\n\n重振政治纲纪\n\n有一个时期，人民军队党的领导弱化问题突出，如果不彻底解决，不仅影响战斗力，而且事关党指挥枪这一重大政治原则。党中央和中央军委狠抓全面从严治军，果断决策整肃人民军队政治纲纪，在古田召开全军政治工作会议，对新时代政治建军作出部署，恢复和发扬我党我军光荣传统和优良作风，以整风精神推进政治整训，全面加强军队党的领导和党的建设，深入推进军队党风廉政建设和反腐败斗争，坚决查处郭伯雄、徐才厚、房峰辉、张阳等严重违纪违法案件并彻底肃清其流毒影响，推动人民军队政治生态根本好转。\n\n重塑组织形态\n\n形成军委管总、战区主战、军种主建新格局，打造以精锐作战力量为主体的军事力量体系，初步形成中国特色社会主义军事政策制度体系基本框架。\n\n重整斗争格局\n\n军事斗争准备基点放在打赢具有智能化特征的信息化局部战争上\n\n\n重构建设布局\n\n\n作出新&quot;三步走&quot;战略安排\n\n\n形成&quot;五个坚持&quot;战略布局坚持政治建军、改革强军、科技强军、\n\n\n人才强军、依法治军\n\n确立&quot;五个更加注重&quot;战略指导更加注重聚焦实战，更加注重创新驱动，\n\n更加注重体系建设，更加注重集约高效，更加注重军民融合\n\n\n加快机械化信息化智能化融合发展\n\n\n重树作风形象\n\n\n坚决纠&quot;四风&quot;转作风全面停止有偿服务；坚持有腐必反有贪必肃；弘扬人民军队的光荣传统和优良作风。\n十年砥砺奋进，强军事业取得历史性成就、发生历史性变革，最根本在于以习近平同志为核心的党中央坚强领导，在于习近平强军思想的科学指引。\n 新时代人民军队使命任务\n\n\n为巩固中国共产党领导和我国社会主义制度提供战略支撑\n\n\n为捍卫国家主权、统一、领土完整提供战略支撑\n\n\n为维护我国海外利益提供战略支撑\n\n\n为促进世界和平与发展提供战略支撑\n\n\n 坚定灵活开展军事斗争\n人民军队有效应对外部军事挑衅，震慑&quot;台独&quot;分裂行径，遂行边防斗争、海上维权、反恐维稳、抢险救灾、抗击疫情、维和护航、人道主义救援和国际军事合作等重大任务，以顽强斗争精神和实际行动捍卫了国家主权、安全、发展利益。\n\n维护边防安全稳定\n\n加强边境管控和反蚕食斗争\n\n应对海上安全威胁和侵权挑衅行为\n\n组织东海、南海、黄海等重要海区和岛礁警戒防卫，划设东海防空识别区，组织南海常态化战斗巡航，掌握周边海上态势，组织海上联合维权执法，妥善处置海空情况，坚决应对海上安全威胁和侵权挑衅行为。\n\n震慑&quot;台独&quot;分裂行径\n\n着眼捍卫国家统一，加强以海上方向为重点的军事斗争准备，组织舰机&quot;绕岛巡航&quot;，对&quot;台独&quot;分裂势力发出严正警告。\n 积极遂行重大任务\n\n抢险救灾\n\n哪里有危难，哪里就有人民子弟兵。\n\n抗击疫情\n\n新冠肺炎疫情发生后，全军闻令而动，勇挑重担，发挥出突击队作用。\n\n维和护航\n\n党的十八大以来，伴随使命任务的拓展，中国军人的身影越来越多地出现在国境之外，为世界提供公共安全产品和服务。在国际维和、亚丁湾护航等行动中，我军参与规模愈益扩大、发挥作用愈益突出，赢得了国际社会的高度赞誉。\n\n人道主义救援和国际军事合作\n\n在西非埃博拉疫情防控、马航失联航班搜寻、尼泊尔地震救援等行动中，都有中国军队紧急驰援的身影。从太平洋到印度洋，从东南亚到亚丁湾，中国军人在灾难中及时伸出援手，在困苦中播种美好希望，体现的是&quot;真实力&quot;，更是&quot;暖实力&quot;。\n青春不只有诗和远方，还有家国与边关。要把对祖国血浓于水、与人民同呼吸共命运的情感贯穿于学业全过程、融汇在事业追求中。我们的军队是人民军队，我们的国防是全民国防。强军号角已经吹响，加快构建一体化的国家战略体系和能力，需要全社会共同努力。\n大学生要把小我融入大我，立志作出我们这一代人的历史贡献。把爱国之心化为报国之行，把热血挥洒在实现中国梦、强军梦的伟大实践之中，书写绚烂无悔的青春篇章。\n小结：\n强国必须强军，军强才能国安。党的十八大以来，党中央和中央军委就加快国防和军队现代化作出一系列战略谋划和部署，引领全军开创了强军事业新局面。在全面建设社会主义现代化国家、实现第二个百年奋斗目标的历史进程中，必须把国防和军队建设摆在更加重要的位置，加快建设巩固国防和强大军队。\n 第十三讲 全面贯彻落实总体国家安全观\n总体国家安全观是我们党历史上第一个被确立为国家安全工作指导思想的重大战略思想，是中国共产党和中国人民捍卫国家主权、安全、发展利益百年奋斗实践经验和集体智慧的结晶，是马克思主义国家安全理论中国化的最新成果，是习近平新时代中国特色社会主义思想的重要组成部分，是新时代国家安全工作的根本遵循和行动指南。\n十个坚持：\n\n\n党对国家安全工作的绝对领导\n\n\n中国特色国家安全道路\n\n\n以人民安全为宗旨\n\n\n统筹发展和安全\n\n\n把政治安全放在首位\n\n\n统筹推进各领域安全\n\n\n把防范化解国家安全风险摆在突出位置\n\n\n推进国际共同安全\n\n\n推进国家安全体系和能力现代化\n\n\n加强国家安全干部队伍建设\n\n\n 一、为什么说保证国家安全是头等大事------国家安全是安邦定国的重要基石\n 安而不忘危，存而不忘亡，治而不忘乱\n国家安全是指国家政权、主权、统一和领土完整、人民福祉、经济社会可持续发展和国家其他重大利益相对处于没有危险和不受内外威胁的状态，以及保障持续安全状态的能力。\n\n\n中华优秀传统文化中蕴含着丰富的国家安全战略思想\n\n\n强调忧患意识------“生于忧患，死于安乐”\n\n\n注重民本思想------“民惟邦本，本固邦宁”\n\n\n倡导和平共处------“和衷共济”“和合共生”\n\n\n主张讲信修睦------“亲人善邻，国之宝也”\n\n\n力求内外兼修------“内事文而和，外事武而义”\n\n\n重视刚柔并济------“方而又刚，柔而又圆，求安难以”\n\n\n推崇张弛有度------“文武之道，一张一弛”\n\n\n党中央始终把维护国家安全工作紧紧抓在手上\n\n\n我们党诞生于国家内忧外患、民族危难之时，对国家安全的重要性有着刻骨铭心的认识。新中国成立以来，党中央对发展和安全高度重视，始终把维护国家安全工作紧紧抓在手上。\n\n为实现中华民族伟大复兴提供坚强安全保障\n\n近代史上的惨痛教训证明，失去国家安全保障，中华民族就无法掌握自己的命运。实现伟大梦想，就必须进行具有许多新的历史特点的伟大斗争，其中就包括为实现中国梦筑牢安全保障的伟大斗争。\n 安全基础不牢，发展大厦地动山摇\n推动创新发展、协调发展、绿色发展、开放发展、共享发展，前提都是国家安全、社会稳定。没有安全和稳定，一切都无从谈起。\n国家安全：内涵外延比历史上任何时候都要丰富，时空领域比历史上任何时候都要宽广，内外因素比历史上任何时候都要复杂。\n进入新时代，我国面临复杂多变的安全和发展环境，面临更为严峻的国家安全形势，外部压力前所未有，传统安全威胁和非传统安全威胁相互交织，各种可以预见和难以预见的风险因素明显增多，各方面风险可能不断积累甚至集中显露。\n过去\n\n\n我们顺势而上，机遇比较好把握\n\n\n大环境相对平稳，风险挑战容易看清楚\n\n\n我们发展水平低，同别人的互补性多一些\n\n\n现在\n\n\n我们顶风而上，把握机遇难度加大\n\n\n世界形势动荡复杂，对应变能力提出更高要求\n\n\n我们发展水平提高，同别人的竞争性多起来\n\n\n 国泰民安是人民群众最基本、最普遍的愿望\n人民希望：国家更加强大，更有力地维护国家统一和民族团结；党和政府更加主动作为，更有效地保护生命财产安全；着力解决空气、水、土壤污染以及农产品、食品药品安全等突出问题。\n国家安全工作，归根结底是保障人民利益，为群众安居乐业提供坚强保障。有了安全感，获得感才有保障，幸福感才会持久。\n 新时代国家安全经受住了来自多方面的风险挑战考验\n党的十八大以来，国家安全得到全面加强，经受住了来自政治、经济、意识形态、自然界等方面的风险挑战考验，为党和国家兴旺发达、长治久安提供了有力保证。\n党的十八大以来，以习近平同志为核心的党中央加强对国家安全工作的集中统一领导，把坚持总体国家安全观纳入坚持和发展中国特色社会主义基本方略，从全局和战略高度对国家安全作出一系列重大决策部署，强化国家安全工作顶层设计，完善各重要领域国家安全政策，健全国家安全法律法规，有效应对了一系列重大风险挑战，保持了我国国家安全大局稳定。\n\n国家安全的重要地位更加凸显\n\n中央国家安全委员会第一次会议  - ：我们党要巩固执政地位，要团结带领人民坚持和发展中国特色社会主义，保证国家安全是头等大事。\n十八届中央政治局第十四次集体学习  - 维护国家安全和社会安定，对全面深化改革、实现&quot;两个一百年&quot;奋斗目标、实现中华民族伟大复兴的中国梦都十分紧要。\n党的十九大  - 国家安全是安邦定国的重要基石，维护国家安全是全国各族人民根本利益所在。\n十九届中央政治局第二十六次集体学习  - 国家安全工作是党治国理政一项十分重要的工作，也是保障国泰民安一项十分重要的工作。\n\n\n国家安全体系基本形成\n\n\n建立国家安全领导体制\n\n\n设立中央国家安全委员会 (2013年)\n\n\n出台《中国共产党领导国家安全工作条例》 (2021年)\n\n\n\n\n制定完善国家安全战略体系\n\n《国家安全战略纲要》 (2015年)\n\n-《国家安全战略 (2021—2025年)》 (2021年)\n\n\n着力构建国家安全法治体系\n\n\n国家安全法\n\n\n国家情报法\n\n\n反恐怖主义法\n\n\n境外非政府组织境内活动管理法\n\n\n国防交通法\n\n\n网络安全法\n\n\n核安全法\n\n\n数据安全法\n\n\n\n\n建立健全国家安全工作机制\n\n\n情报信息工作协调机制\n\n\n风险评估机制\n\n\n审查和监管制度\n\n\n危机管控制度\n\n\n保障体系\n\n\n国家安全能力显著增强\n\n\n\n\n\n\n反渗透反恐怖反分裂斗争卓有成效\n\n\n坚定维护政权安全、制度安全、意识形态安全\n\n\n顶住和反击外部极端打压遏制\n\n\n推动香港局势实现由乱到治的重大转折\n\n\n深入开展涉台、涉疆、涉藏、涉海等斗争\n\n\n稳步推进兴边富民、稳边固边\n\n\n妥善处置周边安全风险\n\n\n\n\n把安全发展贯穿国家发展各领域全过程\n\n\n防控经济金融风险取得重大进展\n\n\n关键核心技术攻关取得重要进展\n\n\n扫黑除恶专项斗争取得胜利\n\n\n妥善应对重大自然灾害\n\n\n统筹疫情防控和经济社会发展\n\n\n网络、数据、人工智能、生物、太空、深海、极地等新型领域安全能力持续增强\n\n\n有力应对海外利益风险挑战\n\n\n维护国家安全的民心基础更加巩固\n\n\n\n\n加强国家安全宣传教育和全民国防教育，巩固国家安全人民防线。人民群众国家安全意识显著增强，汇聚起维护国家安全的强大力量，有力夯实了国家安全的社会基础。\n经过不懈努力，我国的国家主权、安全、发展利益得到全面维护，社会大局保持长期稳定。中国成为世界上最有安全感的国家之一。\n 二、什么是总体国家安全观------新时代国家安全工作的根本遵循和行动指南\n 总体国家安全观的形成过程\n2014年4月中央国家安全委员会第一次会议，习近平首次提出&quot;坚持总体国家安全观&quot;，强调走中国特色国家安全道路。\n2017年10月党的十九大将&quot;坚持总体国家安全观&quot;纳入新时代坚持和发展中国特色社会主义的基本方略，并写入党章。\n2018年4月十九届中央国家安全委员会第一次会议，习近平进一步阐述了总体国家安全观，提出坚持人民安全、政治安全、国家利益至上的有机统一，坚持维护和塑造国家安全等重大判断。\n2020年10月党的十九届五中全会强调牢牢守住安全发展底线，首次把统筹发展和安全纳入&quot;十四五&quot;时期我国经济社会发展的指导思想，历史性地用专章对筑牢国家安全屏障作出战略部署。\n2020年12月十九届中央政治局第二十六次集体学习：习近平对总体国家安全观作出全面、系统、完整的论述，阐明了新时代国家安全工作的总体目标，提出&quot;十个坚持&quot;的工作要求。\n2021年11月党的十九届六中全会：系统总结新时代维护国家安全取得的重大成就和宝贵经验。\n 总体国家安全观的丰富内涵\n总体国家安全观以一系列紧密联系、相互贯通的基本观点，科学回答了中国这样一个发展中的社会主义大国如何维护和塑造国家安全的一系列基本问题，把我们党对国家安全的认识提升到了新的高度和境界，为破解我国国家安全面临的难题，推进新时代国家安全工作提供了基本遵循。\n\n总体国家安全观的关键是&quot;总体&quot;，强调大安全理念；\n强调科学统筹；\n\n\n总体国家安全观强调做好国家安全工作的系统思维和方法，做到&quot;五个统筹&quot;，着力解决国家安全工作不平衡不充分的问题。\n\n统筹发展和安全\n\n发展和安全是一体之两翼、驱动之双轮。发展是安全的基础和目的，安全是发展的条件和保障，发展和安全要同步推进。\n\n统筹开放和安全\n\n健全开放安全保障体系，是&quot;中国开放的大门越开越大&quot;的重要保证。要坚持开放和安全的有机统筹，在保障安全中持续扩大开放，着力增强自身竞争能力、开放监管能力、风险防控能力，创造有利于我国经济社会发展的安全环境，牢固树立开放型经济安全防线。\n\n统筹传统安全和非传统安全\n\n面对传统安全威胁和非传统安全威胁相互交织、复杂演变的国际国内安全环境，必须统筹好传统安全和非传统安全，统筹推进各领域安全，构筑兼顾传统安全与非传统安全威胁的大安全格局。\n\n统筹自身安全和共同安全\n\n各国安全相互关联、彼此影响，安全利益你中有我、我中有你，没有绝对安全的世外桃源，必须摈弃唯我独尊、损人利己、以邻为壑等狭隘思维，把合作作为唯一选择。\n中国始终坚持对内求发展、求变革、求稳定，建设平安中国；对外求和平、求合作、求共赢，维护世界和平与发展。\n\n统筹维护国家安全和塑造国家安全\n\n维护国家安全，要立足国际秩序大变局来把握，立足防范风险的大前提来统筹，立足我国发展重要战略机遇期大背景来谋划，保持战略定力、战略自信、战略耐心，把战略主动权牢牢掌握在自己手中。\n塑造是更高层次更具前瞻性的维护，要发挥负责任大国作用，引导国际社会共同塑造更加公正合理的国际新秩序，推动各方朝着互利互惠、共同安全的目标相向而行。\n\n强调打总体战\n\n总体国家安全观强调国家安全要贯穿到党和国家工作全局各方面、各环节，绝非某一领域、单一部门的职责，必须汇聚党政军民学各战线各方面各层级的强大合力，全社会全政府全体系全手段应对重大国家安全风险挑战。\n\n总体国家安全观具有重大而深远的意义\n\n理论意义：总体国家安全观深化了我们党对中国特色社会主义建设规律的认识，为发展马克思主义国家安全理论作出了重大原创性贡献。\n实践意义：总体国家安全观经过实践检验、富有实践伟力，为维护和塑造新时代国家安全提供了行动纲领\n文化意义：总体国家安全观提炼中华优秀传统战略文化，总结我们党维护国家安全的理论和实践成果，为坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合树立了光辉典范。\n世界意义：总体国家安全观开辟了国家安全治理新路径，为推动和完善全球安全治理贡献了中国方案。\n 坚持中国特色国家安全道路\n中国特色国家安全道路本质上是中国特色社会主义道路在国家安全上的具体体现。必须坚持总体国家安全观，以人民安全为宗旨，以政治安全为根本，以经济安全为基础，以军事、科技、文化、社会安全为保障，以促进国际安全为依托，走出一条中国特色国家安全道路。\n中国特色国家安全道路的重要特征\n\n\n坚持党的绝对领导，完善集中统一、高效权威的国家安全工作体制，实现人民安全、政治安全、国家利益至上相统一。\n\n\n坚持捍卫国家主权和领土完整，维护边疆、边境、周边安定有序。\n\n\n坚持安全发展，推动高质量发展和高水平安全动态平衡。\n\n\n坚持总体战，统筹传统安全和非传统安全。\n\n\n坚持走和平发展道路，促进自身安全和共同安全相协调。\n\n\n走中国特色国家安全道路，努力开创国家安全工作新局面，是对总体国家安全观的贯彻落实，归根到底是为了确保中华民族伟大复兴进程不被迟滞甚至中断。\n 贯彻总体国家安全观要统筹推进重点领域安全\n政治安全、国土安全、经济安全、社会安全、网络安全、外部安全\n\n维护政治安全\n\n政治安全攸关党和国家生死存亡，是国家安全的根本。政治安全的核心是政权安全和制度安全，最根本的就是维护中国共产党的领导和执政地位、维护中国特色社会主义制度。\n\n\n要毫不动摇地坚持和巩固党的领导地位和执政地位\n\n\n要毫不动摇地坚持和完善中国特色社会主义制度\n\n\n要坚决打赢意识形态斗争\n\n\n要严密防范和坚决打击各种渗透颠覆破坏活动\n\n\n要全面贯彻党的民族政策和宗教政策\n\n\n要防范化解党的建设面临的风险\n\n\n要高度重视对青年一代的思想政治工作\n\n\n维护国土安全\n\n\n国土安全是立国之基。国土的安全状态与国家能否繁荣息息相关。\n\n\n要加强边防、海防、空防建设，坚决捍卫领土主权和海洋权益\n\n\n要有效遏制侵害我国国土安全的各种图谋和行为，筑牢国土安全的铜墙铁壁\n\n\n要坚决反对一切分裂祖国的活动，严厉打击恐怖主义、分裂主义、极端主义这&quot;三股势力&quot;，坚决防范&quot;藏独&quot;“东突”，防范恐怖极端势力回流\n\n\n要坚决挫败任何形式的&quot;台独&quot;分裂图谋，全力维护香港、澳门长期繁荣稳定\n\n\n维护经济安全\n\n\n经济安全是国家安全的基础。只有推动经济持续健康发展，才能筑牢国家繁荣富强、人民幸福安康、社会和谐稳定的物质基础。\n\n\n要保证基本经济制度安全\n\n\n要坚决守住不发生系统性金融风险底线\n\n\n要深化供给侧结构性改革\n\n\n要优化和稳定产业链、供应链\n\n\n要确保能源和重要资源安全\n\n\n要牢牢把住粮食安全主动权\n\n\n要织密织牢开放安全网\n\n\n要加强自主创新能力建设\n\n\n维护社会安全\n\n\n社会安全与人民群众切身利益关系最密切，是人民群众安全感的晴雨表，是社会安定的风向标。\n\n\n要大力推进平安中国建设\n\n\n要完善立体化信息化社会治安防控体系\n\n\n要深入推进扫黑除恶专项斗争\n\n\n要坚决打击恐怖主义\n\n\n要推进应急管理体系和能力现代化\n\n\n维护网络安全\n\n\n网络安全已经成为我国面临的最复杂、最现实、最严峻的非传统安全问题之一。\n\n\n要加速推动信息领域核心技术突破\n\n\n要加强关键信息基础设施网络安全防护\n\n\n要加强网络安全预警监测\n\n\n要依法加强网络空间治理\n\n\n要切实维护国家网络空间主权安全，共同构建网络空间命运共同体\n\n\n维护外部安全\n\n\n和平稳定的国际环境和国际秩序是国家安全的重要保障。\n\n\n要坚持共同、综合、合作、可持续的新安全观，积极塑造外部安全环境\n\n\n要切实维护我国海外利益安全，努力形成强有力的海外利益安全保障体系\n\n\n要加强安全领域国际合作，引导国际社会共同维护国际安全\n\n\n 三、怎样着力防范化解重大风险------新时代维护国家安全的实践要求\n 增强忧患意识、坚持底线思维\n忧患意识是中华民族能够生生不息、绵延不绝的文化基因，也是融入中国共产党精神血脉的政治品质。中国共产党在内忧外患中诞生，在磨难挫折中成长，在战胜风险挑战中壮大，始终有着强烈的忧患意识、风险意识。\n新形势下我国国家安全和社会安定面临的威胁和挑战增多，特别是各种威胁和挑战联动效应明显。如果防范不及、应对不力，就会传导、叠加、演变、升级，使小的矛盾风险挑战发展成大的矛盾风险挑战，局部的矛盾风险挑战发展成系统的矛盾风险挑战，国际上的矛盾风险挑战演变为国内的矛盾风险挑战，经济、社会、文化、生态领域的矛盾风险挑战转化为政治矛盾风险挑战，最终危及党的执政地位、危及国家安全。\n面对波谲云诡的国际形势、复杂敏感的周边环境、艰巨繁重的改革发展稳定任务，我们必须树立底线思维。\n\n\n各种风险我们都要防控，但重点要防控那些可能迟滞或中断中华民族伟大复兴进程的全局性风险。\n\n\n把困难估计得更充分，把风险思考得更深入，注重堵漏洞、强弱项，提高防控能力，用大概率思维应对小概率事件，牢牢守住不发生系统性风险的底线。\n\n\n 坚持立足于防、又有效处置风险\n\n\n既要高度警惕&quot;黑天鹅&quot;事件，也要防范&quot;灰犀牛&quot;事件\n\n\n既要有防范风险的先手，也要有应对和化解风险挑战的高招\n\n\n既要打好防范和抵御风险的有准备之战，也要打好化险为夷、转危为机的战略主动战\n\n\n既要高度警惕&quot;黑天鹅&quot;事件，也要防范&quot;灰犀牛&quot;事件\n\n\n&quot;黑天鹅&quot;事件：难以预测，但突然发生时会引起连锁反应、带来巨大负面影响的小概率事件\n&quot;灰犀牛&quot;事件：明显的、高概率的却又屡屡被人忽视、最终有可能酿成大危机的事件。\n\n既要有防范风险的先手，也要有应对和化解风险挑战的高招\n\n既要有防范风险的先手：要加强战略预判和风险预警，见微知著、未雨绸缪，力争把风险化解在源头，防止各种风险传导、叠加、演变、升级。\n不让小风险演化为大风险；不让个别风险演化为综合风险；不让局部风险演化为系统性风险；不让经济风险演化为社会政治风险；不让国际风险演化为国内风险\n应对和化解风险挑战的高招：要提高风险化解能力，抓住要害、找准原因，果断决策，引导群众、组织群众，整合各方力量、科学排兵布阵，有效予以处理。\n 运用制度威力应对风险挑战\n我们要打赢防范化解重大风险攻坚战，必须坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化，运用制度威力应对风险挑战的冲击。发展环境越是严峻复杂，越要坚定不移深化改革，健全各方面制度，完善治理体系，促进制度建设和治理效能更好转化融合。\n小结：\n党的十八大以来，习近平创造性提出总体国家安全观的系统思想，成为维护国家安全的行动纲领和科学指南。总体国家安全观以一系列紧密联系、相互贯通的基本观点，科学回答了中国这样一个发展中的社会主义大国如何维护和塑造国家安全的一系列基本问题，标志着我们党对国家安全基本规律的认识达到了新高度。国家安全是安邦定国的重要基石，必须坚持总体国家安全观，实现人民安居乐业、党的长期执政、国家长治久安。\n 第十四讲 坚持&quot;一国两制&quot;和推进祖国统一\n 一、如何坚持&quot;一国两制&quot;\n &quot;一国两制&quot;是中国特色社会主义的一个伟大创举\n&quot;一国两制&quot;是国家的一项基本国策，&quot;一国两制&quot;就是在统一的国家之内，国家主体实行社会主义制度，个别地区依法实行资本主义制度。\n\n\n“一国两制&quot;构想最早是针对台湾问题提出来的。1956年，毛泽东委托章士钊转去一封中共中央致蒋介石的信，并在信中提出了一系列和平统一台湾的具体办法。1963年1月，这些主张被周恩来概括归纳为&quot;一纲四目”。1982年1月11日，邓小平会见美国华人协会主席李耀滋时说：&quot;九条方针是以叶剑英副主席的名义提出来的，实际上就是一个国家，两种制度。&quot;这是邓小平首次提出&quot;一国两制&quot;的概念。&quot;一国两制&quot;构想在实践中首先被运用于解决香港、澳门问题。按照这一伟大构想，1997年和1999年香港、澳门相继回归祖国，改变了历史上但凡收复失地都要大动干戈的所谓定势，创造了推进祖国和平统一的伟大创举。&quot;一国两制&quot;在香港、澳门的成功实践为解决台湾问题提供了实践样本。\n\n\n&quot;一国两制&quot;伟大构想为世界和平与发展作出积极贡献。&quot;一国两制&quot;的伟大构想，以海纳百川、有容乃大的政治智慧，获得了有关各方的一致认可，不费一兵一卒实现了港澳和平回归。这个新构想新方案，为国际社会解决类似问题提供了新的选择，为世界和平与发展作出了重要贡献。\n\n\n&quot;一国两制&quot;是人类政治文明史上前无古人的伟大创举。&quot;一国两制&quot;重要制度，立足中国国情，顺应时代潮流，观照人民福祉，把原则性和灵活性、现实性和长远性、一致性和差异性统一起来，凝结了中国共产党人为解决国家统一问题展现出的超凡勇气和卓越智慧，是人类政治文明史上前无古人的伟大创举。\n\n\n 全面准确贯彻&quot;一国两制&quot;方针\n&quot;一国两制&quot;是一个完整的概念。&quot;一国&quot;是实行&quot;两制&quot;的前提和基础，&quot;两制&quot;从属和派生于&quot;一国&quot;并统一于&quot;一国&quot;之内。&quot;一国&quot;是根，根深才能叶茂；&quot;一国&quot;是本，本固才能枝荣。\n\n如何理解中央对香港、澳门的全面管治权？\n\n近年来，香港社会有些人鼓吹香港有所谓&quot;固有权力&quot;&quot;自主权力&quot;等，否认或抗拒中央对香港的管治权。事实上，我国是单一制国家，中央对包括香港、澳门特别行政区在内的所有区域拥有全面管治权，香港、澳门两个特别行政区的高度自治权不是固有的，主权和治权都在中央，其高度自治权是中央授予的。\n\n中央依据宪法和基本法对特别行政区拥有全面管治权。通过宪法和基本法，使中央政府拥有全面管治权，香港特别行政区拥有高度自治权。\n\n 坚定不移贯彻&quot;一国两制&quot;方针\n\n\n支持特别行政区政府和行政长官依法施政、积极作为\n\n\n坚守&quot;一国&quot;之本，实现&quot;两制&quot;和谐相处、彼此促进\n\n\n在&quot;一国两制&quot;的实践中，必须把坚持&quot;一国&quot;原则和尊重&quot;两制&quot;差异有机结合起来，做到坚守&quot;一国&quot;之本，实现&quot;两制&quot;和谐相处、彼此促进，既要把实行社会主义制度的内地建设好，也要把实行资本主义制度的香港、澳门建设好。例如不断支持内地与港澳地区在CEPA框架下不断扩大和升级经贸合作。\n\n在&quot;一国&quot;前提下，&quot;两制&quot;成为保持社会长期繁荣的最佳制度形式\n\n香港、澳门长期遭受殖民统治，受西方资本主义制度影响深重，与国家主体社会主义制度存在较大差异。在&quot;一国&quot;的前提下，&quot;两制&quot;并存具有最大程度的包容性和适应性，为港澳顺利回归、保持长期繁荣稳定提供了最佳制度形式。\n二、为什么说&quot;一国两制&quot;行得通、办得到、得人心\n 推动香港局势由乱到治的重大转折\n\n\n香港&quot;修例风波&quot;的缘起。香港回归祖国以来，&quot;一国两制&quot;实践取得举世公认的成就。但香港内外的破坏性力量一直没有停止对&quot;一国两制&quot;方针的干扰和破坏，&quot;港独&quot;组织和本土激进分离势力的活动日益猖獗。自2019年6月以来，香港反对派和一些激进势力借和平游行集会之名，进行各种激进抗争活动。虽然特区政府已多次表示修订《逃犯条例》工作已彻底停止，但他们继续以&quot;反修例&quot;为幌子，得寸进尺、变本加厉，暴力行为不断升级，社会波及面越来越广。2019年&quot;修例风波&quot;期间，“港独&quot;组织和激进分离势力在外国和&quot;台独&quot;势力支持下，公然叫嚣&quot;香港独立&quot;等口号，煽动无底线的&quot;揽炒”，实施触目惊心甚至具有恐怖主义性质的暴力犯罪，乞求并勾连外国和&quot;台独&quot;势力赤裸裸地干预香港事务…这些违法行径，严重挑战&quot;一国两制&quot;原则底线，严重冲击香港的法治和社会秩序，严重威胁香港居民的权利、自由和香港的繁荣稳定。\n\n\n&quot;修例风波&quot;的实质。“修例风波&quot;实质上是一场港版&quot;颜色革命”，反中乱港势力及其背后支持的外部势力不仅是要夺取香港管治权，搞乱香港，而且企图搞乱内地，颠覆中国共产党的领导和中国特色社会主义制度，阻挠中华民族伟大复兴的进程。\n\n\n在此次香港&quot;修例风波&quot;中，黎智英、李柱铭、陈方安生、何俊仁组成的&quot;叛国乱港四人帮&quot;勾结美国等西方势力，\n上蹿下跳、肆意妄为，演出了一幕幕&quot;反中乱港&quot;的丑剧。香港&quot;修例风波&quot;期间，美国众议院议长南希·佩洛西曾把乱港暴力游行形容为&quot;美丽风景线&quot;，并暗中扶持、教唆、挑动乱港暴行。\n\n香港地区政治经济社会生活秩序面临严峻挑战。\n\n根据香港政府经济顾问办公室推算，2019年香港&quot;修例风波&quot;期间，共计造成经济损失至少约150亿元。仅2019年第三季度，访港游客数环比下跌逾26%，超过40个地区向香港发出旅游警示。零售业销售总量环比下跌- 5%。香港地区罪案数字在2019年期间上升9%。\n面对&quot;修例风波&quot;造成的香港回归以来最严峻的局势，以习近平同志为核心的党中央审时度势，果断决策，决定成立中央港澳工作领导小组，并接连推出一系列标本兼治的举措，止暴制乱，促使香港局势由乱到治、香港发展重回正轨。\n\n制定实施《中华人民共和国香港特别行政区维护国家安全法》。\n\n2020年6月30日，为堵塞香港国家安全法律漏洞，保持香港繁荣稳定，保障香港居民合法权益，第十三届全国人大常委会第二十次会议表决通过《中华人民共和国香港特别行政区维护国家安全法》。2020年7月3日，香港特别行政区维护国家安全委员会正式成立，并于7月6日召开首次会议。\n\n香港法治得到彰显，政治社会生活逐步回归正轨。\n\n2021年以来，在新选举制度下，香港先后举行了选举委员会选举、第七届立法会选举、第六任行政长官选举，都取得成功。在新选制的保障下，越来越多贤能爱国者进入特别行政区管治架构，一支爱国爱港、担当作为、精诚团结、为民服务的爱国者治港队伍初步形成。\n6、香港已实现由乱到治的重大转折，正处在由治及兴的关键时期\n在中央政府、香港特别行政区政府和社会各界的共同努力下，香港已实现由乱到治的重大转折，正处在由治及兴的关键时期。香港新起点与国家新征程相交汇，必将产生强大合力，迸发巨大能量。行而不辍，未来可期。只要毫不动摇坚持&quot;一国两制&quot;，香港的未来一定会更加美好，香港一定能为中华民族伟大复兴作出新的更大贡献！\n 推进具有澳门特色的&quot;一国两制&quot;成功实践\n\n\n全面落实&quot;一国两制&quot;与&quot;爱国者治澳&quot;相结合.\n澳门特别行政区政府和社会各界人士坚持把&quot;一国两制&quot;原则要求同澳门实际相结合，勇于探索和创新，使澳门&quot;一国两制&quot;实践呈现出许多亮点：爱国爱澳成为全社会的核心价值，宪法和基本法权威牢固树立，行政主导体制顺畅运行，融入国家发展大局积极主动，包容和谐增强社会凝聚力。\n\n\n实现澳门地区经济发展、社会有效治理。\n\n\n回归以来，澳门地区在中央大力支持下实现了经济迅速发展，旅游、会展、餐饮、酒店及零售业欣欣向荣，实现跨越式发展，人均收入水平稳居世界前列。\n在中央政府和祖国内地的大力支持下，在&quot;爱国爱澳&quot;主流价值的引领下，在澳门各界的努力下，澳门发生了翻天覆地的变化，丰富了&quot;一国两制&quot;内涵，走出一条具有澳门特色的&quot;一国两制&quot;成功实践道路。\n 支持香港、澳门融入国家发展大局\n当前，香港、澳门经济社会发展中遇到一些新情况新问题，传统优势相对减弱，新的经济增长点尚未形成，住房等民生问题比较突出。囿于港澳地域、经济结构和体量、市场空间等条件，仅靠自身力量难以解决这些问题。\n\n\n积极推动港澳地区与内地经济发展互动。\n\n\n2014年以来，以&quot;沪港通&quot;“深港通”&quot;债券通&quot;为主要载体的港澳地区与内地金融市场互联互通机制正式建立，并实现了有序发展。\n\n\n粤港澳大湾区建设，是习近平总书记亲自谋划、亲自部署、亲自推动的重大国家战略。&quot;一个国家、两种制度、三个关税区、三种货币&quot;之下的湾区建设，开世界未有之先例。目前，横琴粤澳深度合作区建设稳步推进，创新粤澳双方共商共建共管新体制，管委会、执委会和省派出机构已揭牌运作。截至2022年6月末，合作区实有企业54350户，其中内资企业46690户，外商及港澳台商投资企业7660户 (含澳资企业4934户)，就业登记人数67569人。\n\n\n开发建设前海深港现代服务业合作区，是习近平总书记亲自谋划、亲自部署、亲自推动的国家改革开放重大举措，对于支持香港经济社会发展、提升粤港澳合作水平、增强香港同胞对祖国的向心力具有重要意义。2021年，前海合作区在地港资企业数量同比增长156%，实际使用港资占前海实际使用外资- 8%。前海深港现代服务业合作区统筹推进&quot;物理扩区&quot;和&quot;政策扩区&quot;，坚持1/3以上土地面向港企出让，累计注册港资企业- 19万家，2021年前海合作区### 完成地区生产总值- 7亿元，同比增长- 5%。推动粤港澳青年交往交流交融，2022年7月，前海深港青年梦工场北区正式开园，拓展创业空间至- 9万平方米，新孵化创业团队87家。\n\n\n\n\n三、为什么说祖国完全统一的时和势始终在我们这一边\n党的十八大以来，习近平总书记全面把握两岸关系时代变化，就对台工作提出一系列重要理念、重大政策主张，形成新时代党解决台湾问题的总体方略。新时代党解决台湾问题的总体方略，是习近平新时代中国特色社会主义思想的重要组成部分，是中国共产党人在解决台湾问题、推进祖国统一实践中形成的最新理论结晶，为新时代对台工作提供了根本遵循和行动指南。\n 祖国必须统一，也必然统一\n\n民族复兴、国家统一是大势所趋、大义所在、民心所向。虽然两岸迄今尚未统一，但中国的主权和领土完整从未分裂。两岸同属一个国家、两岸同胞同属一个民族，这一历史事实和法理基础从未改变，也不可能改变。\n\n2005年颁布实施的《反分裂国家法》明确指出：世界上只有一个中国，大陆和台湾同属一个中国，中国的主权和领土完整不容分割。完成统一祖国的大业是包括台湾同胞在内的全中国人民的神圣职责。\n2完成统一祖国的大业是全体中华儿女的神圣职责。解决台湾问题、实现祖国完全统一，是党矢志不渝的历史任务，是全体中华儿女的共同愿望，是实现中华民族伟大复兴的必然要求。确保国家完整不被分裂，维护中华民族根本利益，是全体中华儿女共同意志，是不可阻挡的历史潮流。\n 推进祖国和平统一进程\n1恪守&quot;一个中国&quot;原则，努力实现两岸和平统一。&quot;一个中国&quot;原则是两岸关系的政治基础，推动两岸关系和平发展的最根本原则。\n2推进两岸经济社会融合发展。\n近年来，两岸交流合作日益广泛，互动往来日益密切，给两岸同胞特别是台湾同胞带来实实在在的好处，充分说明两岸合则两利、合则双赢。\n3秉持&quot;两岸一家亲&quot;，出台一系列惠及广大台胞的政策\n从《关于促进两岸经济文化交流合作的若干措施》到《关于进一步促进两岸经济文化交流合作的若干措施》，从《关于应对疫情统筹做好支持台资企业发展和推进台资项目有关工作的通知》到《关于支持台湾同胞台资企业在大陆农业林业领域发展的若干措施》…大陆种种举措给予台胞生活、学习、就业及创业同等待遇，使广大台胞积极融入祖国发展新格局，在两岸融合发展中画出最大同心圆。\n 绝不允许把任何一块中国领土从中国分裂出去\n1坚决反对任何形式的&quot;台独&quot;分裂行径\n2016年以来，台湾当局加紧进行&quot;台独&quot;分裂活动，致使两岸关系和平发展势头受到严重冲击。当前，对两岸关系和平发展的最大现实威胁是&quot;台独&quot;势力及其分裂活动。&quot;台独&quot;煽动两岸同胞敌意和对立，损害国家主权和领土完整，破坏台海和平稳定，阻挠两岸关系发展，只会给两岸同胞带来深重祸害，是走不通的绝路。\n民进党当局坚持&quot;台独&quot;分裂立场，勾连外部势力不断进行谋&quot;独&quot;挑衅。他们拒不接受一个中国原则，歪曲否定&quot;九二共识&quot;，妄称&quot;中华民国与中华人民共和国互不隶属&quot;，公然抛出&quot;新两国论&quot;；在岛内推行&quot;去中国化&quot;“渐进台独”，纵容&quot;急独&quot;势力鼓噪推动&quot;修宪修法&quot;，欺骗台湾民众，煽动仇视大陆，阻挠破坏两岸交流合作和融合发展，加紧&quot;以武谋独&quot;“以武拒统”；勾结外部势力，在国际上竭力制造&quot;两个中国&quot;“一中一台”。民进党当局的谋&quot;独&quot;行径导致两岸关系紧张，危害台海和平稳定，破坏和平统一前景、挤压和平统一空间，是争取和平统一进程中必须清除的障碍。\n2&quot;台独&quot;分裂势力抗拒统一不会得逞\n台湾是包括2300万台湾同胞在内的全体中国人民的台湾，中国人民捍卫国家主权和领土完整、维护中华民族根本利益的决心不可动摇、意志坚如磐石，这是挫败一切&quot;台独&quot;分裂图谋的根本力量。搞&quot;台独&quot;分裂抗拒统一，根本过不了中华民族的历史和文化这一关，也根本过不了14亿多中国人民的决心和意志这一关，是绝对不可能得逞的。\n当前，美国一些势力图谋&quot;以台制华&quot;，处心积虑打&quot;台湾牌&quot;，刺激&quot;台独&quot;分裂势力冒险挑衅，不仅严重危害台海和平稳定，妨碍中国政府争取和平统一的努力，也严重影响中美关系健康稳定发展。\n3外部势力阻碍中国完全统一必遭失败\n中国坚定不移走和平发展道路，同时决不会在任何外来干涉的压力面前退缩，决不会容忍国家主权、安全、发展利益受到任何损害。&quot;挟洋谋独&quot;没有出路，&quot;以台制华&quot;注定失败。祖国统一的历史车轮滚滚向前，任何人任何势力都无法阻挡。\n我们愿继续以最大诚意、尽最大努力争取和平统一。我们不承诺放弃使用武力，保留采取一切必要措施的选项，针对的是外部势力干涉和极少数&quot;台独&quot;分裂分子及其分裂活动，绝非针对台湾同胞，非和平方式将是不得已情况下做出的最后选择。如果&quot;台独&quot;分裂势力或外部干涉势力挑衅逼迫，甚至突破红线，我们将不得不采取断然措施。\n课堂小结\n&quot;一国两制&quot;是国家的一项基本国策，是中国特色社会主义的一个伟大创举，必须完整准确理解&quot;一国两制&quot;方针，坚定不移贯彻&quot;一国两制&quot;方针。&quot;一国两制&quot;是维护港澳长期繁荣稳定的最佳制度，推动香港实现了由乱到治的重大转折，推进了具有澳门特色的成功实践，有力支持了港、澳融入国家发展大局。祖国必须统一，也必然统一。新时代党解决台湾问题的总体方略，有力推进了祖国和平统一进程，也为彻底解决&quot;台独&quot;问题，实现祖国完全统一提供了根本遵循。\n 第十五讲 推动构建人类命运共同体\n 一、世界怎么了\n 世界进入动荡变革期\n把握世界历史大势的方法论：正确历史观、正确大局观、正确角色观\n\n\n百年变局与世纪疫情交织叠加\n\n\n表征之一：世界经济增长放缓\n\n\n表征之二：&quot;西方之乱&quot;凸显资本主义制度缺陷\n\n\n\n\n 国际力量对比发生深刻变化：新兴市场国家和发展中国家快速发展\n 经济全球化遭遇逆流\n\n\n单边主义、保护主义抬头\n\n\n经济全球化不是世界问题的&quot;祸根&quot;\n\n\n 国际体系和国际秩序深度调整\n\n\n美国全球霸权地位遭遇挑战\n\n\n发展中国家在全球治理体系中的话语权提升\n\n\n 二、人类向何处去\n 人类是一个整体，地球是一个家园\n\n\n人类生活在同一个&quot;地球村&quot;\n\n\n人类是不可分割的有机整体，解决全球性问题包括治理赤字、和平赤字、信任赤字、发展赤字等需要全人类共同努力\n\n\n 人类命运共同体的内涵\n\n\n人类命运共同体理念是回答和解决当今世界面临的&quot;时代之问&quot;的中国方案\n\n\n人类命运共同体的提出与深化\n\n\n2013年3月，习近平在莫斯科国际关系学院发表题为《顺应时代前进潮流\n促进世界和平发展》的演讲，指出这个世界越来越成为你中有我、我中有你的命运共同体，和平、发展、合作、共赢成为时代潮流。\n\n\n2015年9月，习近平在纽约联合国总部出席第70届联合国大会一般性辩论时发表题为《携手构建合作共赢新伙伴\n同心打造人类命运共同体》的重要讲话，指出我们要继承和弘扬联合国宪章的宗旨和原则，构建以合作共赢为核心的新型国际关系，打造人类命运共同体。\n\n\n2017年1月，习近平在联合国日内瓦总部发表《共同构建人类命运共同体》的主旨演讲，提出世界怎么了、我们怎么办？这是整个世界都在思考的问题。中国方案是：构建人类命运共同体，实现共赢共享。\n\n\n2019年5月，习近平在亚洲文明对话大会开幕式上发表题为《深化文明交流互鉴\n共建亚洲命运共同体》的主旨演讲，希望各国秉持开放精神，推进政策沟通、设施联通、贸易畅通、资金融通、民心相通，共同构建亚洲命运共同体、人类命运共同体。\n\n\n2020年9月，习近平在第75届联合国大会一般性辩论上发表重要讲话，强调坚守和平、发展、公平、正义、民主、自由的全人类共同价值，推动构建新型国际关系，推动构建人类命运共同体，共同创造世界更加美好的未来。\n\n\n2021年1月，习近平在世界经济论坛&quot;达沃斯议程&quot;对话会上发表题为《让多边主义的火炬照亮人类前行之路》的特别致辞，强调人类只有一个地球，人类也只有一个共同的未来。无论是应对眼下的危机，还是共创美好的未来，人类都需要同舟共济、团结合作。实践一再证明，任何以邻为壑的做法，任何单打独斗的思路，任何孤芳自赏的傲慢，最终都必然归于失败！让我们携起手来，让多边主义火炬照亮人类前行之路，向着构建人类命运共同体不断迈进。\n\n\n2022年4月，习近平在博鳌亚洲论坛2022年年会开幕式上发表题为《携手迎接挑战，合作开创未来》的主旨演讲，强调人类是休戚与共的命运共同体，各国要顺应和平、发展、合作、共赢的时代潮流，向着构建人类命运共同体的正确方向，携手迎接挑战、合作开创未来。\n\n\n\n\n如何理解人类命运共同体的内涵？\n\n\n------人类生活在同一个地球村，生活在历史和现实交汇的同一个时空，越来越成为你中有我，我中有你的命运共同体。构建人类命运共同体是为解决世界之问、人类之问、时代之问而提出的中国方案，需要国际社会从伙伴关系、安全格局、经济发展、文明交流、生态建设等方面作出努力。\n\n\n坚持对话协商，建设持久和平的世界\n\n\n坚持共建共享，建设普遍安全的世界\n\n\n坚持合作共赢，建设共同繁荣的世界\n\n\n坚持交流互鉴，建设开放包容的世界\n\n\n坚持绿色低碳，建设清洁美丽的世界\n\n\n中国是全球应对气候变化事业的积极参与者\n 弘扬全人类共同价值\n\n全人类共同价值：和平、发展、公平、正义、民主、自由\n\n全人类共同价值是构建人类命运共同体的重要思想基础，凝聚了人类不同文明的价值共识，反映了世界各国人民普遍认同的价值理念的最大公约数，超越了意识形态、社会制度和发展水平的差异，顺应历史潮流，契合时代需要。\n\n\n西方&quot;普世价值&quot;并不&quot;普世&quot;\n\n\n含义：西方&quot;普世价值&quot;是指，试图将自由、民主、人权等西方资本主义社会的核心价值观作为人类普遍遵循的价值观念。\n\n\n目的：西方国家打着&quot;普世价值&quot;的旗号为其推行霸权主义寻找借口，攻击甚至颠覆不符合其意愿和利益的他国政权，以获取战略利益和战略资源。\n\n\n本质：&quot;普世价值&quot;是西方推行霸权主义的工具、抢占道德高地的道具和对外形象宣传的面具。\n\n\n全人类共同价值与普世价值的本质区别\n\n\n\n\n形成条件不同。全人类共同价值是全人类共同追求和坚守的价值观念，是人类历史从民族的历史走向世界的历史的必然产物。西方&quot;普世价值&quot;的本质是西方资本主义的价值观，是基于西方独特历史实践而形成的价值理念。\n\n\n目标追求不同。全人类共同价值倡导不同社会制度、不同意识形态、不同历史文化、不同发展水平的国家在国际事务中利益共生、权利共享、责任共担。西方&quot;普世价值&quot;旨在推销资本主义政治体制和意识形态，所追求的是维护西方主导的国际秩序，并将之拓展到世界每一个角落。\n\n\n实现方式不同。全人类共同价值主张推动构建人类命运共同体，携手应对全球性风险和挑战，共同创造人类更加美好的未来。西方&quot;普世价值&quot;将世界划分为三六九等，强迫非西方国家接受西方理念，不惜发动战争，先制造危机，而后通过&quot;解决危机&quot;实现价值渗透。\n\n\n总结：弘扬和平、发展、公平、正义、民主、自由的全人类共同价值是人间正道。\n 三、中国怎么办\n 全面推进中国特色大国外交\n中国特色大国外交新路：以周边和大国为重点、以发展中国家为基础、以多边为舞台\n\n\n推进大国协调合作，构建总体稳定、均衡发展的大国关系框架\n\n\n秉承亲诚惠容的周边外交理念，打造周边命运共同体\n\n\n中国视周边为安身立命之所、发展繁荣之基，始终将周边置于外交全局的首要位置\n\n秉承正确义利观和真实亲诚理念，加强同发展中国家团结合作\n\n 推动建设新型国际关系\n\n创造性提出建设新型国际关系\n\n新型国际关系&quot;新&quot;在何处？\n\n\n&quot;新&quot;在合作共赢，强调把本国利益同各国共同利益结合起来，努力扩大各方共同利益的汇合点，积极树立双赢、多赢、共赢的新理念，摒弃赢者通吃的旧思维。\n\n\n核心是维护联合国宪章的宗旨和原则，维护不干涉别国内政和尊重国家主权、独立、领土完整等国际关系基本准则，维护联合国及其安理会对世界和平承担的首要责任，开展对话和合作，而不是对抗；实现双赢和共赢，而不是单赢。\n\n\n总结：构建人类命运共同体是目标和方向，建设新型国际关系是前提和路径，实质是要走出一条国与国交往的新路，并为构建人类命运共同体开辟道路、创造条件。\n\n中国的&quot;朋友圈&quot;越来越大\n\n 积极参与全球治理体系改革\n\n全球治理理念创新\n\n全球治理观：国际社会发展到今天已经成为一部复杂精巧、有机一体的机器，拆掉一个零部件就会使整个机器运转面临严重困难，被拆的人会受损，拆的人也会受损。当今世界，任何单边主义、极端利己主义都是根本行不通的，任何脱钩、断供、极限施压的行径都是根本行不通的，任何搞&quot;小圈子&quot;、以意识形态划线挑动对立对抗也都是根本行不通的。我们要践行共商共建共享的全球治理观，弘扬全人类共同价值，倡导不同文明交流互鉴。\n\n践行真正的多边主义\n\n 开展抗疫国际合作\n携手抗疫国际合作，展现大国担当形象\n第十六讲 全面从严治党\n一、为什么全面从严治党\n\n从严治党是马克思主义政党的政治优势。\n\n我们党是用革命理想和铁的纪律组织起来的马克思主义政党，组织严密、纪律严明是党的优良传统和政治优势，也是我们的力量所在。\n首先，从严治党是马克思主义政党建设的一贯要求\n。马克思在《国际工人协会共同章程》中提出，“每一支部应对接受的会员的品质纯洁负责”\n。\n其次，从严治党是中国共产党建设的优良传统。百年来，中国共产党始终把从严治党视为重中之重。新民主主义革命时期，红都瑞金打响了中国共产党惩治腐败分子的第一枪；社会主义革命和建设时期，针对刘青山、张子善等人的腐败行为，中国共产党坚持从严治党，坚决进行了处理；改革开放和社会主义现代化建设新时期，中共中央在1983年到1987年开展了全面整党工作。党始终坚持从严治党，保持了党的先进性和纯洁性。\n\n全面从严治党是实现民族复兴的根本保证\n\n坚持党的领导，坚持党要管党、全面从严治党，是进行具有许多新的历史特点的伟大斗争、推进中国特色社会主义伟大事业、实现民族复兴伟大梦想的根本保证，也是我们党紧跟时代前进步伐、始终保持先进性和纯洁性的必然要求。我们党团结带领人民进行革命、建设、改革的实践都证明，什么时候我们党自身坚强有力，什么时候党和人民事业就能无往而不胜。------习近平在党的十九届一中全会上的讲话\n把全面从严治党纳入&quot;四个全面&quot;战略布局。党的十八大以来，以习近平同志为核心的党中央将全面从严治党纳入&quot;四个全面&quot;战略布局，把严的标准、严的措施贯穿管党治党全过程和各方面，为实现中华民族伟大复兴提供坚强政治引领和政治保障。\n 全面从严治党是决定党兴衰成败的关键因素\n新形势下，我们党的自身建设面临一系列新情况新问题新挑战，落实党要管党、从严治党的任务比以往任何时候都更为繁重、更为紧迫。我们必须以更大的决心和勇气抓好党的自身建设。------习近平在党的十八届一中全会上的讲话\n新形势下党面临&quot;四大考验&quot;“四种危险”\n&quot;四大考验&quot;长期执政考验、改革开放考验、市场经济考验、外部环境考验。\n“四种危险”：精神懈怠、能力不足、脱离群众、消极腐败。\n党内出现的管党不力治党不严的问题：七个有之。\n搞任人唯亲、排斥异己的有之\n搞团团伙伙、拉帮结派的有之\n搞匿名诬告、制造谣言的有之\n搞收买人心、拉动选票的有之\n搞封官许愿、弹冠相庆的有之\n搞自行其是、阳奉阴违的有之\n搞尾大不掉、妄议中央的也有之\n二、为什么十八大以来管党治党宽松软状况得到根本扭转\n 把党的政治建设摆在首位\n 补足共产党人精神上的钙\n 贯彻落实新时代党的组织路线\n 始终绷紧作风建设这根弦\n 把纪律的螺丝拧得紧而又紧\n 把权力关进制度的笼子里\n 巩固发展反腐败斗争压倒性胜利\n坚持和加强党的全面领导，坚持党要管党、全面从严治党，以加强党的长期执政能力建设、先进性和纯洁性建设为主线，以党的政治建设为统领，以坚定理想信念宗旨为根基，以调动全党积极性、主动性、创造性为着力点，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，不断提高党的建设质量，把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党。\n------习近平在中国共产党第十九次全国代表大会上的报告\n 把党的政治建设摆在首位\n党的十九大明确提出党的政治建设这个重大命题，强调党的政治建设是党的根本性建设，要把党的政治建设摆在首位，以党的政治建设为统领。\n为什么要把党的政治建设摆在首位？\n首先，政治建设决定党的建设的方向和效果。如果在方向问题上出现偏离，就会犯颠覆性错误。只有党的政治建设抓好了，党的政治方向、政治立场、政治大局把握住了，党的政治能力提高了，党的建设才能铸魂扎根。党的其他建设最终的着眼点和落脚点必须在政治建设上。不抓党的政治建设或背离党的政治建设指引的方向，党的其他建设就难以取得预期成效。\n其次，把政治建设摆在首位，抓住了全面从严治党的根本性问题。党的十八大以来，在全面从严治党实践中，党深刻认识到，党内存在的很多问题都同政治问题相关联，都是因为党的政治建设没有抓紧、没有抓实。不从政治上认识问题、解决问题，就会陷入头痛医头、脚痛医脚的被动局面，就无法从根本上解决问题。“全面从严治党首先要从政治上看”。\n再次，突出政治建设是十八大以来全面从严治党的成功经验。党的十八大以来，以习近平同志为核心的党中央突出强调党的政治建设，不断强化管党治党政治责任，严肃党内政治生活，严明政治纪律和政治规矩，党内政治生态明显好转，为党和国家各项事业发展提供了良好政治氛围和有力政治保证。这些成功实践使全党同志深刻认识到，党内存在的许多问题，原因都是过去一个时期管党治党宽松软，特别是对党的政治建设没有抓紧、抓实、抓好。党的十九大明确提出党的政治建设这个重大命题，强调党的政治建设是党的根本性建设，把党的政治建设纳入党的建设总体布局并摆在首位，这是马克思主义党建理论的重大创新。\n党的政治建设的基本内容：1保证全党服从中央，坚持党中央权威和集中统一领导2坚定执行党的政治路线，严格遵守政治纪律和政治规矩3尊崇党章，严格执行新形势下党内政治生活若干准则4完善和落实民主集中制的各项制度5弘扬忠诚老实、公道正派、实事求是、清正廉洁等价值观6加强党性锻炼，不断提高政治觉悟和政治能力\n最后，保证全党服从中央，坚持党中央权威和集中统一领导。中国共产党是中国特色社会主义事业的领导核心，是最高政治领导力量。坚持和完善党的领导，是党和国家的根本所在、命脉所在，是全国各族人民的利益所在、幸福所在。应对和战胜前进道路上的各种风险和挑战，关键在党。在坚持党中央权威和集中统一领导这个重大原则问题上，全党全国必须保持高度的思想自觉、政治自觉、行动自觉，丝毫不能动摇。\n 补足共产党人精神上的钙\n共产党人如果没有信仰、没有理想，或信仰、理想不坚定，精神上就会&quot;缺钙&quot;，就会得&quot;软骨病&quot;，就必然导致政治上变质、经济上贪婪、道德上堕落、生活上腐化。\n------习近平在全国党校工作会议上的讲话 (2015年12月11日)\n为什么苏共拥有20万党员时夺取了政权，拥有200万党员时打败了希特勒，而拥有近2000万党员时却失去了政权？\n基础不牢，地动山摇。信念不牢也是要地动山摇的。苏联解体、苏共垮台、东欧剧变不就是这个逻辑吗？历史和现实都告诫我们：全党理想信念坚定，党就拥有无比强大力量；全党理想信念淡薄，党就会成为乌合之众，风一吹就散。\n百年来，中国共产党坚持性质宗旨，坚持理想信念，坚守初心使命，勇于自我革命，从最初50多名党员发展到今天拥有9600多万名党员的世界第一大执政党，历经千锤百炼而朝气蓬勃，正带领中国人民以不可阻挡的步伐迈向伟大复兴。\n如何做？\n用科学理论武装头脑。党的十八大以来，我们党坚持思想建党和制度治党同向发力，用党的创新理论武装全党，推进学习型政党建设，教育引导广大党员、干部特别是领导干部从思想上正本清源、固本培元，筑牢信仰之基、补足精神之钙、把稳思想之舵，保持共产党人政治本色，挺起共产党人的精神脊梁。\n党的十八大以来的5次集中学习教育一脉相承、次第展开，环环紧扣、层层深入，每一次都是理论武装的重要课堂，每一次都是自我革命的生动实践，每一次都是凝心聚力的奋进号角。\n用习近平新时代中国特色社会主义思想武装全党。要坚持不懈用习近平新时代中国特色社会主义思想武装全党、教育人民，引导人们把握丰富内涵、精神实质、实践要求，打牢信仰信念的思想理论根基。\n如何深入学习贯彻习近平新时代中国特色社会主义思想？\n深入学习贯彻习近平新时代中国特色社会主义思想，必须在学懂弄通做实上下功夫。坚持读原著、学原文、悟原理，全面系统学、及时跟进学、深入思考学、联系实际学。强化理论武装，聚焦解决思想根子问题，深刻把握贯穿其中的马克思主义立场观点方法，知其然又知其所以然，不断提高马克思主义理论水平。\n 贯彻落实新时代党的组织路线\n全面贯彻新时代中国特色社会主义思想，以组织体系建设为重点，着力培养忠诚干净担当的高素质干部，着力集聚爱国奉献的各方面优秀人才，坚持德才兼备、以德为先、任人唯贤，为坚持和加强党的全面领导、坚持和发展中国特色社会主义提供坚强组织保证。\n------习近平在全国组织工作会议上的讲话 (2018年7月3日)\n首先，以组织体系建设为重点。\n党的力量来自组织。党的全面领导、党的全部工作要靠党的坚强组织体系去实现。进入新时代，开启新征程，我们必须更加注重党的组织体系建设，不断增强党的政治领导力、思想引领力、群众组织力、社会号召力，把党员组织起来，把人才凝聚起来，把群众动员起来，为实现党的十九大提出的宏伟目标团结奋斗。\n------习近平在全国组织工作会议上的讲话 (2018年7月3日)\n其次，各级各类党组织应建尽建。  - 党的地方委员会.  - 城市街道、乡镇、社区### 、行政村党组织.  - 机关、事业单位、企业和社会组织党组织\n最后，扩大基层党的组织覆盖和工作覆盖。截至2021年12月31日，中国共产党现有基层组织- 6万个，比2020年净增- 7万个，增幅为- 4%。其中基层党委- 8万个，总支部- 6万个，支部- 2万个。\n明确新时代好干部标准：信念坚定、为民服务、勤政务实、敢于担当、清正廉洁。\n坚持正确选人用人导向。\n 始终绷紧作风建设这根弦\n“党的作风就是党的形象，关系人心向背，关系党的生死存亡。我们党作为一个在中国长期执政的马克思主义政党，对作风问题任何时候都不能掉以轻心。”\n------习近平在十八届中央政治局第十六次集体学习时的讲话 (2014年6月30日)\n首先，持之以恒纠治四风。党的十八大以来，我们坚持党要管党、全面从严治党，坚持问题导向，以整治&quot;四风&quot; (形式主义、官僚主义、享乐主义和奢靡之风)为突破口，大力弘扬真抓实干作风，交出了新答卷，取得了新成效。应清醒看到，作风问题具有顽固性和反复性，形成优良作风不可能一劳永逸，克服不良作风也不可能一蹴而就，作风建设永远在路上。\n中央八项规定：\n一改进调查研究。到基层调研要深入了解真实情况，总结经验、研究问题、解决困难、指导工作，向群众学习、向实践学习，多同群众座谈，多同干部谈心，多商量讨论，多解剖典型，多到困难和矛盾集中、群众意见多的地方去，切忌走过场、搞形式主义；要轻车简从、减少陪同、简化接待，不张贴悬挂标语横幅，不安排群众迎送，不铺设迎宾地毯，不摆放花草，不安排宴请。\n二要精简会议活动。切实改进会风，严格控制以中央名义召开的各类全国性会议和举行的重大活动，不开泛泛部署工作和提要求的会，未经中央批准一律不出席各类剪彩、奠基活动和庆祝会、纪念会、表彰会、博览会、研讨会及各类论坛；提高会议实效，开短会、讲短话，力戒空话、套话。\n三要精简文件简报。切实改进文风，没有实质内容、可发可不发的文件、简报一律不发。\n四要规范出访活动。从外交工作大局需要出发合理安排出访活动，严格控制出访随行人员，严格按照规定乘坐交通工具，一般不安排中资机构、华侨华人、留学生代表等到机场迎送。\n五要改进警卫工作。坚持有利于联系群众的原则，减少交通管制，一般情况下不得封路、不清场闭馆。\n六要改进新闻报道。中央政治局同志出席会议和活动应根据工作需要、新闻价值、社会效果决定是否报道，进一步压缩报道的数量、字数、时长。\n七要严格文稿发表。除中央统一安排外，个人不公开出版著作、讲话单行本，不发贺信、贺电，不题词、题字。\n八要厉行勤俭节约。严格遵守廉洁从政有关规定，严格执行住房、车辆配备等有关工作和生活待遇的规定。\n\n严肃整治享乐主义和奢靡之风。\n\n党的十八大以来，在以习近平同志为核心的党中央坚强领导下，各地各部门持之以恒落实中央八项规定精神，驰而不息将作风建设引向深入，反对特权思想和特权现象，狠刹公款送礼、公款吃喝、公款旅游、奢侈浪费等不正之风；“舌尖上的浪费”“会所中的歪风”“车轮上的铺张”“节日中的腐败”，高档小区&quot;一桌餐&quot;、调研考察搭车旅游等隐形变异&quot;四风&quot;问题得到严肃整治。\n\n力戒形式主义和官僚主义作风。\n\n党的十九大以来，作风建设更加注重集中整治形式主义、官僚主义问题。2019年，党中央、国务院发文数量都比上年减少30%以上；省区市文件和会议平均压缩39%、37%，中央和国家机关分别压缩39%、33%；中央和国家机关督查检查考核事项从近900项大幅压缩至96项，实际开展88项。力戒形式主义、官僚主义取得成效。\n其次，党风政风与社会风气为之一新。党的十八大以来，党中央从制定和落实中央八项规定破题，坚持从中央政治局做起、从领导干部抓起，以上率下改进工作作风，刹住了一些过去被认为不可能刹住的歪风，纠治了一些多年未除的顽瘴痼疾，党风政风为之一新，社风民风向上向善。\n 把纪律的螺丝拧得紧而又紧\n加强纪律建设是全面从严治党的治本之策。党要管党、从严治党，靠什么管，凭什么治？就要靠严明纪律和规矩。党员&quot;破法&quot;，无不始于&quot;破纪&quot;。党的十八大以来，我们党坚持纪严于法、纪在法前，严在日常，把纪律和规矩挺在前面，不断完善纪律规定，持续加强执纪问责，做到惩前毖后、治病救人。\n必须使纪律成为带电的&quot;高压线&quot;。遵守党的纪律是无条件的，要说到做到，有纪必执，有违必查，不能把纪律作为一个软约束或是束之高阁的一纸空文。对违规违纪、破坏法规制度踩&quot;红线&quot;、越&quot;底线&quot;、闯&quot;雷区&quot;的，要坚决严肃查处，不以权势大而破规，不以问题小而姑息，不以违者众而放任，不留&quot;暗门&quot;、不开&quot;天窗&quot;。深化运用监督执纪&quot;四种形态&quot;，特别是要在用好第一种形态上下功夫，多做红脸出汗、咬耳扯袖的工作。\n\n把权力关进制度的笼子里\n\n制约和监督权力是制度建设的关键问题。\n公权力姓公，也必须为公。各级党组织、各级领导干部手中的权力是党和人民赋予的，姓公不姓私。只要公权力存在，就必须受到制约，否则就会被滥用。必须把权力关进制度的笼子里，依法设定权力、规范权力、制约权力、监督权力，让权力在阳光下运行。\n把权力关进制度的笼子里，首先要建好笼子。\n要坚持权责法定，科学配置权力，明晰权力边界，强化权力制约，扎细扎密扎牢制度笼子。以党章为根本遵循，本着于法周延、于事有效的原则，制定新的法规制度，完善已有的法规制度，废止不适应的法规制度，进一步健全覆盖党的领导和党的建设各方面的党内法规制度体系，最大限度减少权力出轨、个人寻租的机会。\n强化政治监督，深化政治巡视。把权力关进制度的笼子里，健全党和国家监督制度、坚持和完善党和国家监督体系是重点。强化政治监督，深化政治巡视，切实发挥监督&quot;利剑&quot;和巡视&quot;千里眼&quot;作用。把党委### 全面监督、纪委监委专责监督、党的工作部门职能监督、党的基层组织日常监督、党员民主监督等结合起来、融为一体。\n 巩固发展反腐败斗争压倒性胜利\n一体推进不敢腐、不能腐、不想腐；反腐败斗争取得空前成效；打好反腐败攻坚战持久战。\n三、如何理解全面从严治党这场伟大自我革命\n 勇于自我革命是跳出历史周期率的第二个答案\n勇于自我革命是我们党最鲜明的品格和最大的优势。\n马克思主义政党以实现人的自由全面发展和解放全人类为己任，要实现这样的崇高使命，永葆先进性和纯洁性，就必须一刻不放松地解决自身存在的问题，以彻底的自我革命来推动深刻的社会革命。中国共产党的伟大不在于不犯错误,\n而在于从不讳疾忌医, 敢于直面问题, 勇于自我革命, 具有极强的自我修复能力。\n勇于自我革命是我们党区别于其他政党的显著标志纵观各国政党。真正像中国共产党这样能够始终如一正视自身问题，能够形成一整套自我约束的制度规范体系，能够严肃惩处党内一大批腐化变质分子的，可以说少之又少。中国共产党作为马克思主义政党，党的性质决定了我们党除了国家、民族、人民的利益，没有任何自己的特殊利益。不谋私利才能谋根本、谋大利，才有资格、有底气敢于直面问题、勇于自我革命。\n 全面从严治党以其丰富内涵诠释了自我革命的内在要求\n从明确提出&quot;从严治党&quot;，到提升为&quot;全面从严治党&quot;，谈谈你对此的理解。\n“全面&quot;就是管全党、治全党，面向全体党员、党组织，覆盖党的建设各个领域、各个方面、各个部门，重点是抓住&quot;关键少数”。把从严治党的要求落实到每个党组织中、落实到每名党员身上。对象全覆盖，体现到党的思想建设、组织建设、作风建设、反腐倡廉建设和制度建设各个领域、各个方面；领域全范围，一把尺子量到底、一根竿子插到底，层层传导责任压力，让全面从严治党真正落地生根；责任全担负，一把尺子量到底、一根竿子插到底，层层传导责任压力，让全面从严治党真正落地生根。\n“严”：真管真严，要动真格，不降标准，不图形式，不走过场，确保全面从严治党真正落实；敢管敢严，要敢于碰硬，不惧压力，不畏艰难，不避矛盾，让一切违纪违规的言行无处遁形；常管常严，要善始善终，不松劲头，不减力度，不打折扣，坚持不懈严管严治。\n&quot;治&quot;就是从党中央到地方各级党委，从中央部委、国家机关部门党组### 到基层党支部，都要肩负起主体责任。\n 全面从严治党推进自我革命不断走向深入\n实施中央八项规定改进作风，构建行之有效的权力监督制度和执纪执法体系；反腐败无禁区、全覆盖、零容忍，一体推进不敢腐、不能腐、不想腐；开展党的群众路线教育实践活动，建立不忘初心、牢记使命的制度；严格规范党内政治生活，着力营造风清气正的政治生态。\n","slug":"XJP","date":"2023-05-10T10:31:09.000Z","categories_index":"trash","tags_index":"learning,trash","author_index":"Ivan Snow"},{"id":"0437c0ef9a3f376d408b0ef08ee77a3d","title":"Redis的快速入门","content":" Redis命令行客户端\nRedis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：\n1redis-cli [options] [commonds]\n其中常见的options有：\n\n-h 127.0.0.1：指定要连接的Redis节点的IP地址，默认是127.0.0.1\n-p 6379：指定要连接的Redis节点的端口，默认是6379\n-a 123456：指定Redis的访问密码\n\n其中的commonds就是Redis的操作命令，例如：\n\nping：与Redis服务端做心跳测试，服务端正常会返回pong\n\n不指定commond时，会进入redis-cli的交互控制台\n Redis的通用命令\n\n\n\n\n\n\n\n\n\n通过help [command] 可以查看一个命令的具体用法\nRedis为了方便我们学习，将操作不同数据类型的命令也做了分组，在Redis官网可以查看到不同的命令：\n通用指令是部分数据类型的，都可以使用的指令，常见的有：\n\nKEYS：查看符合模板的所有key，可以使用通配符（模糊查询效率不高，单线程阻塞请求）\n\nKEYS * 查询所有\nKEYS a* 查询以a开头的所有\n\n\nDEL：删除一个指定的key，可删除多个，返回值是删除个数\nEXISTS：判断key是否存在，可判断多个\nEXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除（Redis基于内存存储，节省内存，防止内存占满）\nTTL( Time To Live)：查看一个KEY的剩余有效期，返回-1表示永久有效\n\n String类型\nString类型是Redis中最简单的存储类型。\n其value是字符串，不过根据字符串的格式不同，又可以分为3类：\n\nstring：普通字符串\nint：整数类型，可以做自增、自减操作\nfloat：浮点类型，可以做自增、自减操作\n\n底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.\n String的常用命令\n\nSET：添加或者修改已经存在的一个String类型的键值对\nGET：根据key获取String类型的value\nMSET：批量添加多个String类型的键值对\nMGET：根据多个key获取多个String类型的value\nINCR：让一个整型的key自增1\nINCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\nINCRBYFLOAT：让一个浮点类型的数字自增并指定步长\nSETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行\nSETEX：添加一个String类型的键值对，并且指定有效期\n\n Key结构\nRedis的key允许有多个单词形成层级结构，多个单词之间用:隔开，格式如下：\n1Key1:Key2:Key3\n这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。\n如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储\n\n\n\nKey\nValue\n\n\n\n\nKey1:Key2:Key3\n&#123;&quot;Key3&quot;: value3, …&#125;\n\n\n\n Hash类型\nHash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。\nString结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便，Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD\n Hash的常见命令\n\nHSET key field value：添加或者修改hash类型key的field的值\nHGET key field：获取一个hash类型key的field的值\nHMSET：批量添加多个hash类型key的field的值\nHMGET：批量获取多个hash类型key的field的值\nHGETALL：获取一个hash类型的key中的所有的field和value\nHKEYS：获取一个hash类型的key中的所有的field\nHINCRBY：让一个hash类型key的字段值自增并指定步长\nHSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\n\n List类型\nRedis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索,特征为：\n\n有序\n元素可以重复\n插入和删除快\n查询速度一般\n\n\n List常见命令\n\nLPUSH key element ...：向列表左侧插入一个或多个元素（倒序）\nLPOP key：移除并返回列表左侧的第一个元素，没有则返回nil\nRPUSH key element ... ：向列表右侧插入一个或多个元素（顺序）\nRPOP key：移除并返回列表右侧的第一个元素\nLRANGE key star end：返回一段角标范围内的所有元素\nBLPOP和BRPOP (Block)：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil\n\n Set类型\nRedis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：\n\n\n无序\n\n\n元素不可重复\n\n\n查找快\n\n\n支持交集、并集、差集等功能\n\n\n Set的常见命令\n\nSADD key member ...：向set中添加一个或多个元素\nSREM key member ... : 移除set中的指定元素\nSCARD key： 返回set中元素的个数\nSISMEMBER key member：判断一个元素是否存在于set中\nSMEMBERS：获取set中的所有元素\nSINTER key1 key2 ... ：求key1与key2的交集\nSDIFF key1 key2 ...：求key1与key2的差集\nSUNION key1 key2 ..：求key1和key2的并集\n\n SortedSet类型\nRedis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表，具备下列特性：\n\n可排序\n元素不重复\n查询速度快\n\nSortedSet经常被用来实现排行榜这样的功能\n SortedSet的常见命令\n\n\nZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值\n\n\nZREM key member：删除sorted set中的一个指定元素\n\n\nZSCORE key member : 获取sorted set中的指定元素的score值\n\n\nZRANK key member：获取sorted set 中的指定元素的排名\n\n\nZCARD key：获取sorted set中的元素个数\n\n\nZCOUNT key min max：统计score值在给定范围内的所有元素的个数\n\n\nZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值\n\n\nZRANGE key min max：按照score排序后，获取指定排名范围内的元素\n\n\nZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素\n\n\nZDIFF、ZINTER、ZUNION：求差集、交集、并集\n\n\n\n\n\n\n\n\n\n所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：ZREVRANK key memeber\n\n\n","slug":"Redis-Learning-02-快速入门","date":"2023-05-08T12:16:45.000Z","categories_index":"Redis","tags_index":"coding,Redis","author_index":"Ivan Snow"},{"id":"aaff5ef21db577e0ee734c817bd9cecf","title":"The Best Way For A Student To Make Friends","content":"Friendship is an essential aspect of a student’s life that fosters personal growth and emotional well-being by providing support, encouragement, and companionship. However, making friends can be daunting for some students, especially when seeking meaningful connections. Fortunately, there are some effective strategies that you can use to make friends.\nThe first step is to be open and approachable. For example, a simple smile can break the ice between strangers. A friendly attitude creates a comfortable atmosphere and makes others feel welcomed. By being approachable, you signal to others that you are open to conversations and building connections.\nParticipating actively in extracurricular activities and clubs is another proven way of making friends that enriches your academic and social life. By engaging in shared interests, you will bond with like-minded people and nurture new friendships.\nIt’s important to remember that a friend without faults will never be found. Try to be patient and tolerant of diversity among people. Do not judge people based on appearance, background, or opinions. Try to learn from others and respect differences.\nBe slow in choosing a friend. Building meaningful connections requires patience and persistence. Do not be discouraged if friendships do not form immediately. Continue putting yourself in social situations and engaging with others.\nThe only way to have a friend is to be one. I believe the best way for students to make friends is to become their best selves. Therefore, by following these strategies, you will not only form lasting bonds and relationships, but also form a whole new self.\n","slug":"making-friends","date":"2023-05-04T03:31:21.000Z","categories_index":"English","tags_index":"English","author_index":"Ivan Snow"},{"id":"6690aa0e5bbdd795f0a15fde119a77e1","title":"离散数学复习","content":"\n\n\n 集合论\n 集合的基本概念\n 集合的定义\n\n具有某种特定性质事物的全体，通常，用大写的英文字母A,B,C,……A, B, C,……A,B,C,……表示集合\n\n 集合的元素\n\n组成一个集合的那些对象或单元称为这个集合的元素，通常，用小写的英文字母aaa,bbb,ccc,…，或者a1a_1a1​,a2a_2a2​,b1b_1b1​,b2b_2b2​…表示集合中的元素\n\n 属于\n\n设A是一个集合，a是集合A中的元素，记以a∈Aa \\in Aa∈A，读作aaa属于AAA；若aaa不是集合AAA中的元素，则记以a∉Aa \\notin Aa∈/A，读作aaa不属于AAA\n\n 有限集\n\n包含有限个元素的集合，称为有限集或有穷集(finite set)\n\n 无限集\n\n包含无限个元素的集合，称为无限集或无穷集(infinite set )\n\n 空集\n\n约定，存在一个没有任何元素的集合，称为空集(empty set) ，记为∅\\varnothing∅，有时也用{}\\{\\}{}来表示\n\n 全集\n\n\n约定，所讨论的对象的全体称为全集(universal set)，记作EEE或UUU，我们所讨论的集合都是全集的子集\n\n\n全集是相对的\n\n\n 集合的元素数\n\n设AAA是有穷集合，AAA中元素的个数称为集合AAA的元素数，记为∣A∣|A|∣A∣，特别，∣∅∣=0|\\varnothing|=0∣∅∣=0\n\n 集合的表示法\n 列举法\n\n将集合中的元素一一列举，或列出足够多的元素以反映集合中元素的特征\n\n 描述法\n\n通过描述集合中元素的共同特征来表示集合\n\n 文氏图\n\n用一个大的矩形表示全集，在矩形内画一些圆或其它的几何图形，来表示集合，有时也用一些点来表示集合中的特定元素\n\n 集合的特征\n 确定性\n\n任何一个对象，或者是这个集合的元素，或者不是，二者必居其一\n\n 互异性\n\n集合中任何两个元素都是不同的，即集合中不允许出现重复的元素\n\n 无序性\n\n集合与其中的元素的顺序无关\n\n 多样性\n\n集合中的元素可以是任意的对象，相互独立，不要求一定要具备明显的共同特征\n\n 集合间的关系\n 集合相等\n\n当两个集合AAA和BBB的元素完全一样，即AAA，BBB实际上是同一个集合时，则称集合AAA，BBB相等，记以A=BA=BA=B\n\n 集合包含\n 子集\n\n设AAA，BBB是两个集合，若AAA的元素都是BBB的元素，则称AAA是BBB的子集(subset) ，也称BBB包含AAA，或AAA包含于BBB，记以A⊆BA \\subseteq BA⊆B，或B⊇AB \\supseteq AB⊇A\n\n 真子集\n\n若A⊆BA \\subseteq BA⊆B，且A≠BA \\neq BA=B，则称AAA是BBB的真子集(proper subset)，也称BBB真包含AAA，或AAA真包含于BBB，记以A⊂BA \\subset BA⊂B，或B⊃AB \\supset AB⊃A\n\n 重要结论\n\n对任意集合AAA, 有A⊆AA ⊆ AA⊆A\n∅\\varnothing∅是任意集合的子集，且空集是唯一的\n对于任意两个集合AAA、BBB，A=BA=BA=B当且仅当A⊆BA⊆BA⊆B且B⊆AB⊆ AB⊆A。\n\n 幂集\n 定义\n\n设AAA是集合，AAA的所有子集为元素组成的集合称为AAA的幂集，记以ρ(A)ρ(A)ρ(A)或2A2^A2A，ρ(A)={S∣S⊆A}ρ(A)=\\{S|S ⊆ A\\}ρ(A)={S∣S⊆A}\n\n 性质\n\n若A为有穷集，∣A∣=n|A|=n∣A∣=n，则∣2A∣=∣ρ(A)∣=Cn0+Cn1+…+Cnn=2n|2^A | = |ρ(A)|= C_n^0 + C_n^1 + … + C_n^n =2^n∣2A∣=∣ρ(A)∣=Cn0​+Cn1​+…+Cnn​=2n\nx∈ρ(A)x∈ρ(A)x∈ρ(A)当且仅当x⊆Ax⊆Ax⊆A\n设AAA、BBB是两个集合，A⊆BA⊆BA⊆B当且仅当ρ(A)⊆ρ(B)ρ(A)⊆ρ(B)ρ(A)⊆ρ(B)\n\n 集合运算\n 集合的并集\n\n设AAA，BBB是两个集合。所有属于AAA或者属于BBB的元素组成的集合，称为AAA和BBB的并集，记以A∪BA∪BA∪B。即A∪B={x∣x∈A或x∈B}A∪B=\\{x|x∈A或x∈B\\}A∪B={x∣x∈A或x∈B}\n\n 集合的交集\n\n设AAA，BBB是两个集合。由属于AAA又属于BBB的元素组成的集合，称为AAA和BBB的交集，记以A∩BA∩BA∩B。即A∩B={x∣x∈A且x∈B}A∩B=\\{x|x∈A且x∈B\\}A∩B={x∣x∈A且x∈B}\n\n 并集和交集的推广\n\n\n设A1A_1A1​，A2A_2A2​，…，AnA_nAn​是nnn个集合，则：A1∪A2∪…∪AnA_1∪A_2∪…∪A_nA1​∪A2​∪…∪An​，简记为⋃i=1nAi\\bigcup\\limits_{i=1}^nA_ii=1⋃n​Ai​\n\n\nA1∩A2∩…∩AnA_1∩A_2∩…∩A_nA1​∩A2​∩…∩An​，简记为⋂i=1nAi\\bigcap\\limits_{i=1}^n A_ii=1⋂n​Ai​\n\n\n 集合的补集\n\n\n设AAA是一个集合，全集EEE与AAA的差集称为AAA的补集，记以∼A\\sim A∼A，即∼A=E−A\\sim A=E-A∼A=E−A\n\n\n特别， ∼∅=E\\sim \\varnothing=E∼∅=E，∼E=∅\\sim E= \\varnothing∼E=∅\n\n\n 集合的差集\n\n设AAA，BBB是两个集合。由属于集合AAA而不属于集合BBB的所有元素组成的集合，称为AAA与BBB的差集，记以A−BA-BA−B。即A−B={x∣x∈A且x∉B}A-B=\\{x|x∈A且x ∉B\\}A−B={x∣x∈A且x∈/B}\n\n 集合的对称差\n\n设AAA，BBB是两个集合。则AAA与BBB的和(对称差),记以A⊕BA⊕BA⊕B, 定义为A⊕B=(A−B)∪(B−A)A⊕B=(A-B)∪(B-A)A⊕B=(A−B)∪(B−A)，即A⊕B={x∣(x∈A)且(x∉B)或(x∈B)且(x∉A)}A \\oplus B=\\{x|(x \\in A)且(x \\notin B)或(x \\in B)且(x \\notin A)\\}A⊕B={x∣(x∈A)且(x∈/B)或(x∈B)且(x∈/A)}\nAAA与BBB的对称差还有一个等价的定义，即A⊕B=(A∪B)−(A∩B)A⊕B=(A∪B)-(A∩B)A⊕B=(A∪B)−(A∩B)\n\n 集合的运算律\n 等幂律\n\nA∩A=AA∩A=AA∩A=A\nA∪A=AA∪A=AA∪A=A\n\n 交换律\n\nA∩B=B∩AA∩B=B∩AA∩B=B∩A\nA∪B=B∪AA∪B=B∪AA∪B=B∪A\n\n 结合律\n\n(A∩B)∩C=A∩(B∩C)(A∩B)∩C=A∩(B∩C)(A∩B)∩C=A∩(B∩C)\n(A∪B)∪C=A∪(B∪C)(A∪B)∪C=A∪(B∪C)(A∪B)∪C=A∪(B∪C)\n\n 分配律\n\nA∩(B∪C)=(A∩B)∪(A∩C)A∩(B∪C)=(A∩B)∪(A∩C)A∩(B∪C)=(A∩B)∪(A∩C)\nA∪(B∩C)=(A∪B)∩(A∪C)A∪(B∩C)=(A∪B)∩(A∪C)A∪(B∩C)=(A∪B)∩(A∪C)\n\n 吸收律\n\nA∩(A∪B)=AA∩(A∪B)=AA∩(A∪B)=A\nA∪(A∩B)=AA∪(A∩B)=AA∪(A∩B)=A\n\n 互补律\n\n∼A∩A=∅\\sim A∩A= \\varnothing∼A∩A=∅\n∼A∪A=E\\sim A∪A=E∼A∪A=E\n\n 德摩根律\n\n∼(A∩B)=∼A∪∼B\\sim (A∩B)=\\sim A ∪ \\sim B∼(A∩B)=∼A∪∼B\n∼(A∪B)=∼A∩∼B\\sim(A∪B)=\\sim A ∩ \\sim B∼(A∪B)=∼A∩∼B\n\n 同一律\n\nE∩A=AE∩A=AE∩A=A\n∅∪A=A\\varnothing ∪A=A∅∪A=A\n\n 零一律\n\n\n∅∩A=∅\\varnothing∩A=\\varnothing∅∩A=∅\n\n\nE∪A=EE∪A=EE∪A=E\n\n\n 双重否定律\n\n∼(∼A)=A\\sim (\\sim A)=A∼(∼A)=A\n\n 其他算律\n\nA−B=A∩∼BA-B=A∩ \\sim BA−B=A∩∼B\nA⊕B=(A−B)∪(B−A)=(A∪B)−(A∩B)A⊕B=(A-B)∪(B-A)=(A∪B)-(A∩B)A⊕B=(A−B)∪(B−A)=(A∪B)−(A∩B)\nA⊕A=∅A⊕A=\\varnothingA⊕A=∅\n∼∅=E\\sim\\varnothing=E∼∅=E\n∼E=∅\\sim E=\\varnothing∼E=∅\n\n 有限集合的计数\n 容斥原理\n\n∣A∪B∣=∣A∣+∣B∣−∣A∩B∣|A∪B|=|A|+|B|-|A∩B|∣A∪B∣=∣A∣+∣B∣−∣A∩B∣\n∣A∪B∪C∣=∣A∣+∣B∣+∣C∣−∣A∩B∣−∣A∩C∣−∣B∩C∣+∣A∩B∩C∣|A∪B∪C|=|A|+|B|+|C|-|A∩B|-|A∩C|-|B∩C|+|A∩B∩C|∣A∪B∪C∣=∣A∣+∣B∣+∣C∣−∣A∩B∣−∣A∩C∣−∣B∩C∣+∣A∩B∩C∣\n设A1，A2，…，AnA_1，A_2，…，A_nA1​，A2​，…，An​是nnn个集合，则：∣⋃i=1nAi∣=∑i=1n∣Ai∣−∑i&lt;jn∣Ai∩Aj∣+∑i&lt;j&lt;kn∣Ai∩Aj∩Ak∣+...+(−1)n−1∣A1∩A2∩A3∩...∩An∣|\\bigcup\\limits_{i=1}^n A_i|=\\sum\\limits_{i=1}^n|A_i|-\\sum\\limits_{i&lt;j}^n|A_i\\cap A_j|+\\sum\\limits_{i&lt;j&lt;k}^n|A_i\\cap A_j \\cap A_k|+...+(-1)^{n-1}|A_1 \\cap A_2 \\cap A_3 \\cap ...\\cap A_n|∣i=1⋃n​Ai​∣=i=1∑n​∣Ai​∣−i&lt;j∑n​∣Ai​∩Aj​∣+i&lt;j&lt;k∑n​∣Ai​∩Aj​∩Ak​∣+...+(−1)n−1∣A1​∩A2​∩A3​∩...∩An​∣称为包含排斥原理，简称容斥原理\n\n 集合恒等式的证明\n 基本定义法\n 公式等价法\n 基本原则\n\n将集合运算表达式中其他运算符号转换为∩和∪；\n将补运算作用到单一集合上；\n左  ⟹  \\implies⟹右，右  ⟹  \\implies⟹左，左  ⟹  \\implies⟹中间式，右  ⟹  \\implies⟹中间式；\n根据基本运算符号的定义和运算定律转换。\n\n 集合成员表法\n 关系\n 序偶和笛卡尔积\n 序偶\n 定义\n\n对于有序nnn元组，当n=2n=2n=2时，我们将其称作有序二元组，也称作有序对,或序偶。\n\n 特点\n\n若a≠ba≠ba=b,则(a,b)≠(b,a)(a,b)≠(b,a)(a,b)=(b,a)\n两个有序对(a,b)(a,b)(a,b)和(c,d)(c,d)(c,d)相等当且仅当a=ca=ca=c，b=db=db=d\n\n 特征\n\n成对出现、具有一定的顺序\n\n 笛卡尔积\n 定义\n\n设AAA，BBB是两个集合，所有有序对(x,y)(x, y)(x,y)做成的集合(其中x∈A，y∈B)(其中x∈A，y∈B)(其中x∈A，y∈B)，称为AAA，BBB的笛卡儿积，记为A×BA×BA×B，A×B={(x，y)∣x∈A且y∈B}A×B=\\{(x，y)|x∈A且y∈B\\}A×B={(x，y)∣x∈A且y∈B}\n设A1,A2,...,AnA_1,A_2 , ...,A_nA1​,A2​,...,An​是nnn个集合，由所有有序nnn元组(a1,a2,…,ana_1,a_2,…,a_na1​,a2​,…,an​)组成的集合(其中ai∈Ai，i=1,2,…,n)(其中ai∈A_i，i=1,2, … ,n)(其中ai∈Ai​，i=1,2,…,n)，称为A1,A2,...,AnA_1,A_2,...,A_nA1​,A2​,...,An​的笛卡儿积，记以A1×A2×...×AnA_1×A_2 ×...×A_nA1​×A2​×...×An​，A1×A2×...×An={(a1,a2,…,an)∣ai∈Ai，i=1,2,…,n}A_1×A_2 ×...×A_n=\\{(a_1,a_2 ,… ,a_n) | a_i∈A_i，i=1,2, … ,n \\}A1​×A2​×...×An​={(a1​,a2​,…,an​)∣ai​∈Ai​，i=1,2,…,n}\n\n 性质\n\n\n∣A×B∣=∣A∣×∣B∣|A×B|=|A|× |B|∣A×B∣=∣A∣×∣B∣\n\n\n对任意集合AAA，有A×∅=∅A×\\varnothing=\\varnothingA×∅=∅，∅×A=∅\\varnothing \\times A=\\varnothing∅×A=∅\n\n\n笛卡儿积运算不满足交换律，即A×B≠B×AA×B≠B×AA×B=B×A\n\n\n笛卡儿积运算不满足结合律，即(A×B)×C≠A×(B×C)(A×B)×C≠A×(B×C)(A×B)×C=A×(B×C)\n\n\n笛卡儿积运算对并和交运算满足分配律， 即\n\nA×(B∪C)=(A×B)∪(A×C)A×(B∪C)=(A×B)∪(A×C)A×(B∪C)=(A×B)∪(A×C)\n(B∪C)×A=(B×A)∪(C×A)(B∪C)×A=(B×A)∪(C×A)(B∪C)×A=(B×A)∪(C×A)\nA×(B∩C)=(A×B)∩(A×C)A×(B∩C)=(A×B)∩(A×C)A×(B∩C)=(A×B)∩(A×C)\n(B∩C)×A=(B×A)∩(C×A)(B∩C)×A=(B×A)∩(C×A)(B∩C)×A=(B×A)∩(C×A)\n\n\n\n设AAA，BBB，CCC，DDD是集合，若A⊆CA⊆CA⊆C且B⊆DB⊆DB⊆D，则A×B⊆C×DA×B ⊆ C×DA×B⊆C×D\n\n\n 二元关系\n 定义\n\n给定任意集合AAA和BBB，若R⊆A×BR⊆A×BR⊆A×B，则称RRR为从AAA到BBB的二元关系，特别在A=BA=BA=B时，称RRR为AAA上的二元关系\n\n 补充\n\n关系是一个集合，是序偶的集合\nRRR是有序对的集合。若(x,y)∈R(x,y)∈R(x,y)∈R，则也表示为xRyx R yxRy，即(x,y)∈R  ⟺  xRy(x,y)∈ R \\iff x R y(x,y)∈R⟺xRy\n\n若R=∅R =\\varnothingR=∅，则称RRR为AAA到BBB上空关系\n若R=A×BR =A×BR=A×B，称RRR为AAA到BBB上全域关系\n称R={(x,x)∣x∈A}R=\\{(x,x)|x∈A\\}R={(x,x)∣x∈A}为AAA上的恒等关系，记为IAI_AIA​\n\n\n当集合A,BA,BA,B都是有限集时，A×BA×BA×B共有2∣A∣⋅∣B∣2^{|A|\\cdot|B|}2∣A∣⋅∣B∣个不同的子集，\n即从AAA到BBB的不同关系共有2∣A∣⋅∣B∣2^{|A|\\cdot|B|}2∣A∣⋅∣B∣个\n\n 定义域、值域和域\n 定义\n\n令R⊆A×BR \\subseteq A \\times BR⊆A×B，且\n{D(R)={x∣(∃y)(xRy)}R(R)={y∣(∃x)(xRy)}F(R)=D(R)∪R(R)\\begin{cases} D (R) = \\{ x | (∃y) (x R y ) \\}\\\\R (R) = \\{ y | (∃x) (x R y ) \\}\\\\F(R) = D(R)∪R(R)\\end{cases}⎩⎪⎪⎨⎪⎪⎧​D(R)={x∣(∃y)(xRy)}R(R)={y∣(∃x)(xRy)}F(R)=D(R)∪R(R)​则称D(R)D(R)D(R)、R(R)R(R)R(R)和F(R)F(R)F(R)分别是二元关系RRR的定义域、值域和域，显然D(R)⊆AD(R) ⊆ AD(R)⊆A，R(R)⊆BR(R) ⊆ BR(R)⊆B\n\n 关系矩阵与关系图\n 关系矩阵\n\n给定集合A={a1,a2,⋅⋅⋅,am}A=\\{a_1,a_2,···,a_m \\}A={a1​,a2​,⋅⋅⋅,am​}和B={b1,b2,⋅⋅⋅,bn}B=\\{b_1,b_2,···,b_n \\}B={b1​,b2​,⋅⋅⋅,bn​}，且R⊆A×BR⊆A×BR⊆A×B，若rij={1,aiRbj0,否则r_{ij}=\\begin{cases} 1 ,&amp; {a_i R b_j}\\\\0 ,&amp; 否则 \\end{cases}rij​={1,0,​ai​Rbj​否则​\n则称矩阵MR=(rij)M_R=(r _{i j})MR​=(rij​)为RRR的关系矩阵\n\n 关系图\n\n给定集合A={a1,a2,⋅⋅⋅,am}A=\\{a_1,a_2,···,a_m \\}A={a1​,a2​,⋅⋅⋅,am​}和AAA上的关系RRR，且R⊆A×AR⊆A×AR⊆A×A，若：以AAA中的元素为结点；对RRR中的元素(ai,aj)(a_i ,a_j )(ai​,aj​), 以aia_iai​为起点,以aja_jaj​为终点,作有向边所构成的图，则称该图为RRR的关系图\n\n 关系运算\n 关系的并、交、补、差\n\n关系是序偶(有序对)的集合，因此可以对关系进行运算。\n若R,S⊆A×BR, S⊆A×BR,S⊆A×B，则R∪SR∪SR∪S，R∩SR ∩SR∩S，∼R\\sim R∼R，R−S⊆A×BR-S⊆A×BR−S⊆A×B\n\n 关系的复合\n 定义\n\n设RRR是从集合XXX到YYY的关系，SSS是从YYY到ZZZ的关系，把XXX到ZZZ的关系定义为R∘SR\\circ SR∘S。称R∘SR\\circ SR∘S是关系RRR和SSS的合成关系或复合关系，R∘S={(x,z)∣∃x∈X,∃z∈Z,至少存在一个y∈Y有(x,y)∈R且(y,z)∈S}R\\circ S=\\{(x,z)|∃x∈X, ∃z∈Z, 至少存在一个y∈Y有(x , y)∈R且(y , z)∈S\\}R∘S={(x,z)∣∃x∈X,∃z∈Z,至少存在一个y∈Y有(x,y)∈R且(y,z)∈S}\n\n 定理\n\n\n已知集合X,Y,Z,WX,Y,Z,WX,Y,Z,W，关系R1,R2,R3,R4R_1,R_2,R_3,R_4R1​,R2​,R3​,R4​如下X⟶R1Y⟶R2R3Z⟶R4WX\\stackrel {R_1}\\longrightarrow Y \\stackrel {R_2R_3}\\longrightarrow Z \\stackrel {R_4}\\longrightarrow WX⟶R1​​Y⟶R2​R3​​Z⟶R4​​W，则有：\n\n𝑅1∘(𝑅2∪𝑅3)=(𝑅1∘𝑅2)∪(𝑅 1∘𝑅3)𝑅_1∘(𝑅_2∪𝑅_3)=(𝑅_1∘𝑅_2)∪(𝑅_ 1∘𝑅_3)R1​∘(R2​∪R3​)=(R1​∘R2​)∪(R ​1∘R3​)\nR1∘(R2∩R3)⊆(R1∘R2)∩(R1∘R3)R_1∘(R_2∩R_3)⊆(R_1∘R_2)∩(R_1∘R_3)R1​∘(R2​∩R3​)⊆(R1​∘R2​)∩(R1​∘R3​)\n(𝑅2∪𝑅3)∘𝑅4=(𝑅2∘𝑅4)∪(𝑅3∘𝑅4)(𝑅_2∪𝑅_3)∘𝑅_4=(𝑅_2∘𝑅_4)∪(𝑅_3∘𝑅_4)(R2​∪R3​)∘R4​=(R2​∘R4​)∪(R3​∘R4​)\n(𝑅2∩𝑅3)∘𝑅4⊆(𝑅2∘𝑅4)∩(𝑅3∘𝑅4)(𝑅_2∩𝑅_3)∘𝑅_4⊆(𝑅_2∘𝑅_4)∩(𝑅_3∘𝑅_4)(R2​∩R3​)∘R4​⊆(R2​∘R4​)∩(R3​∘R4​)\n\n\n\n已知集合X,Y,Z,WX, Y, Z, WX,Y,Z,W，关系R1,R2,R3R_1, R_2, R_3R1​,R2​,R3​如下X⟶R1Y⟶R2Z⟶R3WX\\stackrel {R_1}\\longrightarrow Y \\stackrel {R_2}\\longrightarrow Z \\stackrel {R_3}\\longrightarrow WX⟶R1​​Y⟶R2​​Z⟶R3​​W，则有：(R1∘R2)∘R3=R1∘(R2∘R3)(R_1 \\circ R_2)\\circ R_3=R_1\\circ (R_2 \\circ R_3)(R1​∘R2​)∘R3​=R1​∘(R2​∘R3​) 结合律\n\n\nR∘R∘R∘⋯∘R=R(n)R\\circ R\\circ R \\circ\\dots\\circ R=R^{(n)}R∘R∘R∘⋯∘R=R(n)\n\n\nR(0)=IX={(x,x)∣x∈X}R^{(0)}=I_X=\\{(x,x)|x\\in X\\}R(0)=IX​={(x,x)∣x∈X}\n\n\n 逆关系\n 定义\n\n若R⊆A×BR⊆A×BR⊆A×B，则关系R‾={(y,x)∣(x,y)∈R}\\overline R =\\{(y,x)|(x,y)∈ R\\}R={(y,x)∣(x,y)∈R}\n是集合BBB到AAA的关系，R‾\\overline RR称为关系RRR的逆关系\n\n 定理\n\n\nR1,R2,RR_1, R_2, RR1​,R2​,R为XXX到YYY的二元关系，则\n\n\nR1∪R2‾=R1‾∪R2‾\\overline{R_1∪ R_2} =\\overline{R_1} ∪\\overline{R_2}R1​∪R2​​=R1​​∪R2​​\n\n\nR1∩R2‾=R1‾∩R2‾\\overline{R_1 \\cap R_2}=\\overline {R_1} \\cap \\overline {R_2}R1​∩R2​​=R1​​∩R2​​\n\n\nX×Y‾=Y×X\\overline{X \\times Y} = Y \\times XX×Y​=Y×X\n\n\n∼R‾=∼R‾\\overline{\\sim R}=\\sim \\overline{R}∼R=∼R\n\n\nR1−R2‾=R1‾−R2‾\\overline{R_1-R_2}=\\overline{R_1}-\\overline{R_2}R1​−R2​​=R1​​−R2​​\n\n\nS⊆R  ⟺  S‾⊆R‾S \\subseteq R \\iff \\overline{S}\\subseteq\\overline{R}S⊆R⟺S⊆R\n\n\n\n\n已知集合X,Y,ZX, Y, ZX,Y,Z，关系R,SR, SR,S如下，X⟶RY⟶SZX \\stackrel {R}\\longrightarrow Y \\stackrel {S}\\longrightarrow ZX⟶R​Y⟶S​Z，则有：R∘S‾=S‾∘R‾\\overline{R\\circ S}=\\overline{S}\\circ\\overline{R}R∘S=S∘R\n\n\n 注意\n\n将RRR的关系矩阵转置即得R‾\\overline RR的关系矩阵，即RRR和R‾\\overline RR的关系矩阵互为转置矩阵\nR‾\\overline RR的前域与后域正好是RRR的后域和前域，即domR=ranR‾domR=ran\\overline RdomR=ranR，domR‾=ranRdom\\overline R=ranRdomR=ranR\n∣R∣=∣R‾∣|R|=|\\overline R|∣R∣=∣R∣\n\n 关系性质\n 自反性\n\n令R⊆A×AR⊆A×AR⊆A×A，若对AAA中每个xxx，都有xRxxRxxRx，则称RRR是自反的，即A上关系R是自反的  ⟺  ∀x(x∈A→xRx)A上关系R是自反的\\iff∀x(x∈A→xRx)A上关系R是自反的⟺∀x(x∈A→xRx)\n该定义表明了，在自反的关系RRR中，除其他有序对外，必须包括由每个x∈Ax∈Ax∈A所组成的元素相同的有序对\n\n 反自反性\n\n令R⊆A×AR⊆A×AR⊆A×A，若对于AAA中每个xxx，有(x,x)∉R(x,x) ∉R(x,x)∈/R，则称RRR是反自反的，即A上关系R是反自反的  ⟺  ∀x(x∈A→(x,x)∉R)A上关系R是反自反的\\iff∀x (x∈A→(x,x) ∉R)A上关系R是反自反的⟺∀x(x∈A→(x,x)∈/R)\n该定义表明了，一个反自反的关系RRR中，不应包括有任何相同元素的有序对\n应该指出，任何一个不是自反的关系，未必是反自反的；反之，任何一个不是反自反的关系，未必是自反的。这就是说，存在既不是自反的也不是反自反的二元关系\n\n 对称性\n\n令R⊆A×AR⊆A×AR⊆A×A，对于AAA中每个xxx和yyy，若xRyxRyxRy，则yRxyRxyRx，称RRR是对称的，即在A上关系R是对称的  ⟺  (∀x)(∀y)(x,y∈A且xRy→yRx)在A上关系R是对称的\\iff(∀x)(∀y)(x,y∈A且xRy→yRx)在A上关系R是对称的⟺(∀x)(∀y)(x,y∈A且xRy→yRx)\n该定义表明了，在表示对称的关系RRR的有序对集合中，若有有序对(x,y)(x, y)(x,y)，则必定还会有有序对(y,x)(y, x)(y,x)\n\n 反对称性\n\n令R⊆A×AR⊆A×AR⊆A×A，对于AAA中每个xxx和yyy，若xRyxRyxRy且yRxyRxyRx，则x=yx=yx=y，称RRR是反对称的，即A上关系R是反对称的  ⟺  (∀x)(∀y)(x,y∈A且xRy且yRx→x=y)A上关系R是反对称的 \\iff (∀x)(∀y)(x,y∈A且xRy且yRx→x=y)A上关系R是反对称的⟺(∀x)(∀y)(x,y∈A且xRy且yRx→x=y)\n该定义表明了，在表示反对称关系RRR的有序对集合中，若存在有序对(x,y)(x, y)(x,y)和(y,x)(y, x)(y,x)，则必定是x=yx=yx=y。或者说，在RRR中若有有序对(x,y)(x, y)(x,y)，则除非x=yx=yx=y，否则必定不会出现(y,x)(y, x)(y,x)\n\n 传递性\n\n令R⊆A×AR⊆A×AR⊆A×A，对于AAA中每个x,y,zx, y, zx,y,z，若xRy且yRzxRy且yRzxRy且yRz，则xRzxRzxRz，称RRR是传递的，即A上关系R是传递的  ⟺  (∀x)(∀y)(∀z)(x,y,z∈A且xRy且yRz→xRz)A上关系R是传递的 \\iff (∀x)(∀y)(∀z)(x,y,z∈A且xRy且yRz→xRz)A上关系R是传递的⟺(∀x)(∀y)(∀z)(x,y,z∈A且xRy且yRz→xRz)\n该定义表明了，在表示可传递关系RRR的有序对集合中，若有有序对(x,y)(x, y)(x,y)和(y,z)(y, z)(y,z)，则必有有序对(x,z)(x, z)(x,z)\n\n 结论\n\n关系RRR是自反的  ⟹  \\implies⟹ RRR不是反自反的\n关系RRR是自反的  ⟺  \\iff⟺关系图中每个结点都有环\n关系RRR是反自反的  ⟺  \\iff⟺关系图中每个结点都无环\n关系RRR是自反的  ⟺  \\iff⟺关系矩阵的主对角线上全为1\n关系RRR是反自反的  ⟺  \\iff⟺关系矩阵的主对角线上全为0\n关系RRR是对称的  ⟺  \\iff⟺关系图中任何一对结点之间，要么有方向相反的两条边，要么无任何边\n关系RRR是反对称的  ⟺  \\iff⟺关系图中任何一对结点之间，至多有一条边\n关系RRR是对称的  ⟺  \\iff⟺ RRR的关系矩阵为对称矩阵\n关系RRR是反对称的  ⟺  \\iff⟺ RRR的关系系矩阵满足rij⋅rji＝0，i,j=1,2,…,n，i≠jr_{ij}\\cdot r_{ji}＝0，i,j=1,2,…,n，i≠jrij​⋅rji​＝0，i,j=1,2,…,n，i=j\n非空集合上的空关系是反自反的，对称的，反对称的和传递的，但不是自反的。空集合上的空关系则是自反的，反自反的，对称的，反对称的和传递的\n非空集合上的全域关系是自反的，对称的和传递的，但不是反自反的和反对称的\n设R⊆A×AR⊆A×AR⊆A×A，若RRR是反自反的和传递的，则RRR是反对称的\n\n 闭包运算\n 自反闭包\n\n设RRR是AAA上的二元关系，若R′R&#x27;R′是RRR的自反闭包,记作r(R)r(R)r(R)，则：\n\nR′R&#x27;R′是自反的\nR⊆R′R⊆R&#x27;R⊆R′\n对任意的自反关系R′′R&#x27;&#x27;R′′，R⊆R′′R⊆R&#x27;&#x27;R⊆R′′，则必有R′⊆R′′R&#x27;⊆R&#x27;&#x27;R′⊆R′′\n\n\n\n 对称闭包\n\n设RRR是AAA上的二元关系，若R′R&#x27;R′是RRR的对称闭包,记作s(R)s(R)s(R)，则：\n\nR′R&#x27;R′是对称的\nR⊆R′R⊆R&#x27;R⊆R′\n对任意的对称关系R′′R&#x27;&#x27;R′′，R⊆R′′R⊆R&#x27;&#x27;R⊆R′′，则必有R′⊆R′′R&#x27;⊆R&#x27;&#x27;R′⊆R′′\n\n\n\n 传递闭包\n\n\n设RRR是AAA上的二元关系，若R′R&#x27;R′是RRR的传递闭包,记作t(R)t(R)t(R)，则：\n\nR′R&#x27;R′是传递的\nR⊆R′R⊆R&#x27;R⊆R′\n对任意的传递关系R′′R&#x27;&#x27;R′′，R⊆R′′R⊆R&#x27;&#x27;R⊆R′′，则必有R′⊆R′′R&#x27;⊆R&#x27;&#x27;R′⊆R′′\n\n\n\n 定理\n\nR是 X 上的二元关系,则：\n\nr(R)=R∪{(x,x)∣x∈X}=R∪Ixr(R)=R∪\\{(x,x)|x∈X\\}=R∪I_xr(R)=R∪{(x,x)∣x∈X}=R∪Ix​\ns(R)=R∪R‾s(R) = R∪ \\overline{R}s(R)=R∪R\nt(R)=R∪R(2)∪R(3)...∪R(n)t(R)=R∪ R^{(2)}∪ R^{(3)}...∪ R^{(n)}t(R)=R∪R(2)∪R(3)...∪R(n)，nnn为集合XXX的元素的个数\nRRR是自反的  ⟺  \\iff⟺ r(R)r(R)r(R)\nRRR是对称的  ⟺  \\iff⟺ s(R)=Rs(R)=Rs(R)=R\nRRR是传递的  ⟺  \\iff⟺ t(R)t(R)t(R)\n\n\n\n 等价关系\n 定义\n\n设RRR是集合XXX上的二元关系，如果RRR是自反的、对称的、传递的，那么称RRR是等价关系\n\n 划分\n\n设集合A={S1,S2,…,Sm}A=\\{S_1, S_2 , …, S_m\\}A={S1​,S2​,…,Sm​},SiS_iSi​是SSS的非空子集, 如果称AAA是SSS的一个划分，称SiS_iSi​为划分的块，则：\n\nSiS_iSi​之间是不相交的\nS1∪S2∪…∪Sm=SS_1∪S_2∪…∪S_m = SS1​∪S2​∪…∪Sm​=S\n\n\n\n 等价类\n 定义\n\nRRR是集合SSS上的等价关系, 对任一x∈Sx\\in Sx∈S，均可构造一个SSS的非空子集[x]R={y∣y∈S且xRy}[x]_R= \\{ y | y\\in S 且 xRy \\}[x]R​={y∣y∈S且xRy}，也可记为[x][x][x]，叫做xxx关于RRR的等价类:\n\n 性质\n\nx∈[x]x\\in[x]x∈[x]\n若y∈[x]y\\in[x]y∈[x],  则[y]=[x][y]=[x][y]=[x]\n若y∈[x]y\\in[x]y∈[x],  则[y]∩[x]=∅[y]∩[x]=\\varnothing[y]∩[x]=∅\n\n 定理\n\n集合SSS上的一个等价关系RRR生成的等价类集合对应SSS的一个划分\n集合SSS上的一个等价关系RRR生成的等价类集合对应SSS的一个划分。此划分称为集合SSS关于RRR的商集，记为S/RS/RS/R\n集合SSS上的一个划分可产生SSS上的一个等价关系\n\n 偏序关系\n 定义\n\n设RRR是集合AAA中的二元关系，如果RRR是自反的、反对称的和可传递的，则称RRR是AAA中的偏序关系。\n通常用符号“≼≼≼”来标记偏序关系RRR\n\n 偏序集\n\n在偏序集合(A,≼)(A ,≼ )(A,≼)中，如果有元素x,y∈Ax,y∈Ax,y∈A,且x≼yx≼ yx≼y(或者写为(x,y)∈≼(x,y)∈≼(x,y)∈≼)和x≠yx≠yx=y,同时不存在其它任何元素z∈Az∈Az∈A，能使x≼zx≼ zx≼z和z≼yz≼ yz≼y,则称元素yyy盖住xxx，若元素yyy盖住xxx，则可以将x,yx,yx,y间的关系用图形表示，即：哈斯图\n\n 哈斯图\n\n用小圆圈表示AAA中的元素\n若x≼yx≼yx≼y且x≠yx≠yx=y, 则xxx在yyy的下方\n若x≼yx≼yx≼y且x≠yx≠yx=y, 并且AAA中不存在另外的元素zzz, 满足x≼zx≼zx≼z,z≼yz≼yz≼y, 则在xxx与yyy之间画一直线\n\n 拟序关系\n\n设RRR是集合AAA中的反自反和传递的二元关系，则称RRR是AAA中的拟序关系  (“≺≺≺”)\n\n 全序和全序集\n\n设≼≼≼是AAA中的偏序关系，若对任意的x,y∈Ax,y∈Ax,y∈A，必有x≼yx ≼ yx≼y或y≼xy ≼ xy≼x，即xxx和yyy可比较，则称≼≼≼是AAA中的线性次序关系或全序关系，又称全序或线性序。相应的偏序集(A,≼)(A,≼)(A,≼)称为线性序集或全序集\n显然，任一全序集也是偏序集，其哈斯图为一条链，\n但是任一偏序集不一定是全序集合\n\n 最大（小）元素\n\n设(X,≼)( X, ≼ )(X,≼)是偏序集，YYY是XXX的子集。若存在元素y∈Yy∈ Yy∈Y,对于每一个y’∈Yy’ ∈ Yy’∈Y，\n\n若有y’≼yy’ ≼ yy’≼y，则称yyy是集合YYY的最大元素\n若有y≼y’y ≼y’y≼y’，则称yyy是集合YYY的最小元素\n\n\n\n 性质\n\n设(X,≼)( X, ≼ )(X,≼)是偏序集，YYY是XXX的子集，如果YYY有最大（最小）元素，则必定是唯一的\n\n 极大（小）元素\n\n设(X,≼)( X, ≼)(X,≼)是偏序集，YYY是XXX的子集，若y∈Yy ∈ Yy∈Y，且不存在y’∈Yy’ ∈ Yy’∈Y，y≠y’y≠ y’y=y’，\n\n若有y≼y’y ≼ y’y≼y’，则称yyy是YYY的极大元素\n若有y’≼yy’ ≼ yy’≼y，则称yyy是YYY的极小元素\n\n\n\n 上（下）界\n\n设(X,≼)( X, ≼ )(X,≼)是偏序集，Y⊆XY\\subseteq XY⊆X，若x∈Xx ∈ Xx∈X，使得对任意y’∈Yy’ ∈ Yy’∈Y,\n\n若有y’≼xy’≼xy’≼x，则称xxx是YYY的上界\n若有x≼y’x ≼ y’x≼y’，则称xxx是YYY的下界\n\n\n\n 上（下）确界\n\n设(X,≼)( X, ≼ )(X,≼)是偏序集，YYY是XXX的子集。\n\nxxx是YYY的上界，若对YYY的任一上界x’x’x’，都有x≼x’x ≼x’x≼x’，则称xxx是YYY的上确界，记作LUBLUBLUB YYY\nxxx是YYY的下界，若对于YYY的任一下界x’x’x’，均有x’≼xx’ ≼xx’≼x，则称xxx是YYY的下确界,记作GLBGLBGLB YYY\n\n\n\n 函数\n 函数及其分类\n 函数的定义\n\n设fff是集合AAA到BBB的关系\n若称fff是集合AAA到BBB的函数或映射，记作f:A→Bf: A→Bf:A→B 或 A→BA → BA→B。\n当(a,b)∈f(a,b)∈f(a,b)∈f时，通常记为b=f(a)b=f(a)b=f(a)，bbb称为aaa在fff下的像，称aaa为bbb的原像。则fff满足下列两个条件：\n\n对每个a∈Aa∈Aa∈A，必存在b∈Bb∈Bb∈B，使得(a,b)∈f(a,b)∈f(a,b)∈f——存在性条件\n对每个a∈Aa∈Aa∈A，只存在一个b∈Bb∈Bb∈B，使得(a,b)∈f(a,b)∈f(a,b)∈f——唯一性条件\n\n\n即：值域为函数的像集合\n\n 函数相等\n\n设f:X→Yf:X→Yf:X→Y，g:Z→Wg:Z→Wg:Z→W，如果fff和ggg具有相同的定义域和值域，即X=ZX=ZX=Z和Y=WY=WY=W，并且对于所有的x∈Xx∈Xx∈X和x∈Zx∈Zx∈Z，都有f(x)=g(x)f(x)=g(x)f(x)=g(x)，则称函数fff和ggg相等，并记作f=gf=gf=g\n\n 函数个数\n\n设AAA，BBB是非空有限集合，则从AAA到BBB共有∣B∣∣A∣|B|^{|A|}∣B∣∣A∣ 个不同的函数\n因为函数是一种特殊的关系，所以一个函数确定一个关系；但一个关系不一定确定一个函数\n\n 函数的分类\n\n设f:A→Bf: A→Bf:A→B是一个函数：\n\n对任意的a1a_1a1​和a2∈Aa_2∈Aa2​∈A，若a1≠a2a_1≠a_2a1​=a2​，均有f(a1)≠f(a2)f(a_1)≠f(a_2)f(a1​)=f(a2​)，则称fff为AAA到BBB的单射函数或一对一函数；否则，称fff为AAA到BBB的多对一函数。\n如果对任意的b∈Bb∈Bb∈B，均有a∈Aa∈Aa∈A，使b=f(a)b=f(a)b=f(a)，即Cf=BC_f=BCf​=B，则fff为AAA到BBB的满射函数；否则，称fff为AAA到BBB的内射函数。\n如果fff既是AAA到BBB的单射，又是AAA到BBB的满射，则称fff为AAA到BBB的双射函数或一一对应函数。特殊地，在一一对应函数f:A→Bf: A→Bf:A→B中，若A=BA=BA=B，则此函数叫做AAA的变换。\n\n\n\n 函数分类结论\n\n设A，B为有限集合，f是从A到B的函数，则：\n\nfff是单射的必要条件为∣A∣≤∣B∣|A|≤|B|∣A∣≤∣B∣\nfff是满射的必要条件为∣B∣≤∣A∣|B|≤|A|∣B∣≤∣A∣\nfff是双射的必要条件为∣A∣＝∣B∣|A|＝|B|∣A∣＝∣B∣\n\n\n\n 特殊函数\n\n设fff是一个函数，若对任意的a∈Aa∈Aa∈A，均有f(a)=bf(a)=bf(a)=b，b∈Bb∈Bb∈B，则称fff是从AAA到BBB的常值函数或常函数\n设fff是一个函数，若对任意的a∈Aa∈Aa∈A，均有f(a)=af(a)=af(a)=a，则称fff是AAA上的恒等函数\n设f:R→Rf:R→Rf:R→R是一个函数，其中RRR为实数集，\n\n对任意a,b∈Ra,b∈Ra,b∈R，若a&lt;ba&lt;ba&lt;b，必有f(a)≤f(b)f(a)≤f(b)f(a)≤f(b)，则称fff为单调递增函数\n对任意a,b∈Ra,b∈Ra,b∈R，若a&lt;ba&lt;ba&lt;b，必有f(a)&lt;f(b)f(a)&lt;f(b)f(a)&lt;f(b)，则称fff为严格单调递增函数\n\n\n设UUU是全集，且A⊆UA⊆UA⊆U，函数ΨA:U→{0,1}\\Psi _A:U\\to \\{0,1\\}ΨA​:U→{0,1}定义为: ΨA={1,a∈A0,a∉A\\Psi_A=\\begin{cases}\n1,&amp; a \\in A\\\\\n0,&amp; a \\notin A\n\\end{cases}ΨA​={1,0,​a∈Aa∈/A​ 则称ΨA\\Psi_AΨA​是集合AAA的特征函数\n\n 复合函数与逆函数\n 复合函数\n 复合函数定义\n\n函数的合成运算可定义如下：设f:X→Yf : X→Yf:X→Y, g:Y→Zg : Y→Zg:Y→Z是两个函数，于是合成函数记为g∘f:X→Zg\\circ f : X→Zg∘f:X→Z\ng∘f={(x,z)∣x∈X且z∈Z且存在y∈Y且y=f(x)且z=g(y)}\\\\g\\circ f=\\{(x,z)|x∈X且z∈Z且存在y∈Y且y=f(x)且z=g(y)\\}g∘f={(x,z)∣x∈X且z∈Z且存在y∈Y且y=f(x)且z=g(y)} 通常称为函数fff和ggg的合成，确切的说，g∘fg\\circ fg∘f称为fff和ggg左合成，从fff和ggg求得g∘fg\\circ fg∘f的运算“∘\\circ∘”称为左合成运算\n关系的合成运算为f∘gf\\circ gf∘g，函数的合成运算为g∘fg\\circ fg∘f\n\n 复合函数定理\n\n函数的合成运算是可结合的\n设fff和ggg是函数，并且有合成函数g∘fg\\circ fg∘f,则\n\n如果fff和ggg都是满射函数，则g∘fg \\circ fg∘f也是满射函数\n如果fff和ggg都是单射函数，则g∘fg\\circ fg∘f也是单射函数\n如果fff和ggg都是双射函数，则g∘fg\\circ fg∘f也是双射函数\n\n\n\n 逆函数\n 逆函数定义\n\n设f:A→Bf : A→Bf:A→B是一个双射函数 , 称f−1:B→Af^{-1} : B→Af−1:B→A是fff的逆函数\n在关系部分，曾定义了从集合XXX到YYY的关系RRR的逆关系，但是对于函数来说，交换序偶中的成员次序并不一定能保证得到的仍然是个函数\n设f:A→Bf:A→Bf:A→B是一一对应的函数，则fff的逆关系 称为它的逆函数，记成f−1:B→Af^{-1}: B→Af−1:B→A。这时称函数fff是可逆的\n\n 逆函数的定理\n\n函数f:A→Bf : A→Bf:A→B，若存在逆函数f−1:B→Af^{-1} : B→Af−1:B→A，则必须满足：\n\n对任意的a∈Aa∈Aa∈A，必有唯一的b∈Bb∈Bb∈B与之对应；\n对任意的b∈Bb∈Bb∈B，必有唯一的a∈Aa∈Aa∈A与之对应；\n\n\n\n 代数系统\n 代数系统的基本概念\n 二元运算\n 定义\n\n设A,B,CA, B, CA,B,C是非空集合，从A×BA×BA×B到CCC的一个函数f：A×B→Cf ：A×B→Cf：A×B→C称为一个A×BA×BA×B到CCC的二元代数运算，简称二元运算\n一个二元运算就是一个特殊的函数 ，该函数能够对a∈Aa\\in Aa∈A和b∈Bb\\in Bb∈B进行运算，得到CCC中的一个元素ccc ， 即 ∘(a,b)＝c\\circ (a, b)＝c∘(a,b)＝c。\n中缀方法表示为：a∘b＝ca \\circ b＝ca∘b＝c\n\n 特点\n 封闭性\n\n如果“ ∗\\ast∗”是A×AA×AA×A到AAA的二元运算，则称运算“ ∗\\ast∗”对集合AAA是封闭的，或者称“ ∗\\ast∗”是AAA上的二元运算\n设“ ∗\\ast∗”是一个A1×A2×…×AnA_1×A_2×…×A_nA1​×A2​×…×An​到AAA的nnn元代数运算，如果A1＝A2＝…＝An＝AA_1＝A_2＝…＝A_n＝AA1​＝A2​＝…＝An​＝A，则称代数运算“ ∗\\ast∗”对集合AAA是封闭的，或者称“ ∗\\ast∗”是AAA上的nnn元代数运算\n\n 代数系统的定义\n\n设AAA是非空集合， ∗\\ast∗是定义在AAA上kkk元封闭运算，称集合AAA和 ∗\\ast∗所组成的系统称为代数系统，简称代数，记为(A,∗)(A,  \\ast )(A,∗)\n当AAA是有限集合时，该代数系统称为有限代数系统，否则称为无限代数系统\n注意：判断集合AAA和其上的代数运算是否是代数系统，关键是判断两点：\n\n集合AAA非空\n这些运算关于AAA是否满足封闭性\n\n\n\n 同类型代数系统\n\n设(A,∗)(A,  \\ast )(A,∗)和(B,∘)(B, \\circ )(B,∘)是两个代数系统，若“∘\\circ∘”和“ ∗\\ast∗”都是kkk元运算，i=1,2,…,mi = 1, 2, …, mi=1,2,…,m，则称这两个代数同类型\n\n 运算规律\n 结合律\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，若对任意a,b,c∈Aa, b, c∈Aa,b,c∈A，都有\n(a∗b)∗c＝a∗(b∗c)(a \\ast b) \\ast c＝a \\ast (b \\ast c)(a∗b)∗c＝a∗(b∗c)\n则称“ ∗\\ast∗”在AAA上是可结合的，或称满足结合律\n\n 交换律\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，若对任意a,b∈Aa, b∈Aa,b∈A，都有\na∗b＝b∗aa \\ast b＝b \\ast aa∗b＝b∗a\n则称“ ∗\\ast∗”在AAA上是可交换的，或称“ ∗\\ast∗”满足交换律\n\n 消去律\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，元素a∈Aa∈Aa∈A，\n\n对任意x,y∈Ax, y∈Ax,y∈A，都有如果a∗x=a∗ya \\ast x = a \\ast ya∗x=a∗y，那x=yx = yx=y，则称aaa在AAA中关于“ ∗\\ast∗”是左可消去元\n对任意x,y∈Ax,  y∈Ax,y∈A，都有如果x∗a=y∗ax \\ast a = y \\ast ax∗a=y∗a，那么x=yx = yx=y，则称aaa在AAA中关于“ ∗\\ast∗”是右可消去元\n如果aaa既是AAA左可消去元又是右可消去元，则称aaa是AAA的可消去元\n若AAA中所有元素都是可消去元，则称“ ∗\\ast∗”在AAA上可消去，或称“ ∗\\ast∗”满足消去律\n\n\n\n 幂等律\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，若元素a∈Aa∈Aa∈A，满足a∗a=aa \\ast a=aa∗a=a则称aaa是AAA中关于“ ∗\\ast∗”的一个幂等元，简称aaa为幂等元。若AAA中的每一个元素都是幂等元，则称“ ∗\\ast∗”在AAA中是幂等的，或称“ ∗\\ast∗”满足幂等律\n\n 幂\n\n设“ ∗\\ast∗”是集合AAA上可结合的二元运算，a∈Aa∈Aa∈A，则a∗a∈A，a∗a∗a∈A，…，a \\ast a∈A，a \\ast a \\ast a∈A，…，a∗a∈A，a∗a∗a∈A，…，由此，可以归纳定义aaa的正整数幂方：\na1=a，a2=a∗a，a3=a2∗a，…，an=an−1∗a，…a^1 = a，a^2 = a \\ast a，a^3 = a^2 \\ast a，… ，\na^n = a^{n-1} \\ast a，…a1=a，a2=a∗a，a3=a2∗a，…，an=an−1∗a，…\n对任意正整数nnn，mmm，有以下等式：an∗am=an+m，(an)m=anma^n  \\ast  a^m = a^{n+m}，    (a^n)^m = a^{nm}an∗am=an+m，(an)m=anm\n\n 分配律\n\n设“ ∗\\ast∗”、“∘\\circ∘”是集合A上的二元运算，(A,∗,∘)(A, \\ast , \\circ)(A,∗,∘)是一个代数系统， 对任意a,b,c∈Aa,b,c\\in Aa,b,c∈A，\n\na∘(b∗c)=(a∘b)∗(a∘c)a\\circ (b \\ast c)=(a\\circ b) \\ast (a\\circ c)a∘(b∗c)=(a∘b)∗(a∘c)，\n则称运算“∘\\circ∘”对“ ∗\\ast∗”在AAA上满足左分配律(或第一分配律)\n(b∗c)∘a=(b∘a)∗(c∘a)(b \\ast c) \\circ a=(b\\circ a) \\ast (c\\circ a)(b∗c)∘a=(b∘a)∗(c∘a)，\n则称运算“∘\\circ∘”对“ ∗\\ast∗”在AAA上满足右分配律(或第二分配律)\n如果“∘\\circ∘”对“ ∗\\ast∗”既满足左分配律又满足右分配律，则称“∘\\circ∘”对“ ∗\\ast∗”在AAA上满足分配律\n\n\n\n 吸收律\n\n设“ ∗\\ast∗”、“∘\\circ∘”是集合AAA上的二元运算，(A,∗,∘)(A, \\ast , \\circ )(A,∗,∘)是一个代数系统，如果对任意x,y∈Ax,  y∈Ax,y∈A，都有x∗(x∘y)=x，x∘(x∗y)=xx  \\ast (x \\circ y) = x，x \\circ(x \\ast y) = xx∗(x∘y)=x，x∘(x∗y)=x\n则称“ ∗\\ast∗”和“∘\\circ∘”满足吸收律\n\n 特殊元\n 特殊元的定义\n\n在代数系统中，有些元素有特殊性质，叫特殊元\n\n 单位元\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，\n\n若存在e∈Ae∈Ae∈A，对任意a∈Aa∈Aa∈A，都有  a∗e=e∗a=aa  \\ast e = e \\ast  a = aa∗e=e∗a=a，则称eee是AAA中关于运算“ ∗\\ast∗”的一个单位元\n若存在el∈Ae_l∈Ael​∈A，使得对任意a∈Aa∈Aa∈A，都有 el∗a=ae_l  \\ast a = ael​∗a=a，则称ele_lel​是AAA中关于运算“ ∗\\ast∗”的一个左单位元\n若存在er∈Ae_r∈Aer​∈A，使得对任意a∈Aa∈Aa∈A，都有 a∗er=aa  \\ast e_r = aa∗er​=a，则称ere_rer​是AAA中关于运算“ ∗\\ast∗”的一个右单位元\n\n\n\n 零元\n\n设(A,∗)(A,  \\ast )(A,∗)是一个二元代数系统，\n\n若存在θ∈Aθ∈Aθ∈A，使得对任意a∈Aa∈Aa∈A，都有a∗θ=θ∗a=θa  \\ast θ = θ \\ast  a =θa∗θ=θ∗a=θ，则称θθθ是AAA中关于运算“ ∗\\ast∗”的一个零元\n若存在θl∈Aθ_l∈Aθl​∈A，使得对任意a∈Aa∈Aa∈A，都有θl∗a=θlθ_l  \\ast a = θ_lθl​∗a=θl​，则称θlθ_lθl​是AAA中关于运算“ ∗\\ast∗”的一个左零元\n若存在θr∈Aθ_r∈Aθr​∈A，使得对任意a∈Aa∈Aa∈A，都有a∗θr=θra  \\ast θ_r = θ_ra∗θr​=θr​，则称θrθ_rθr​是AAA中关于运算“ ∗\\ast∗”的一个右零元。\n\n\n\n 逆元\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，eee是幺元，a∈Aa∈Aa∈A，若存在一个元素b∈Ab∈Ab∈A，\n\n使得：a∗b=b∗a=ea  \\ast b = b \\ast  a = ea∗b=b∗a=e，则称aaa可逆，并称bbb是aaa的一个逆元，记为a−1a^{-1}a−1\n使得：b∗a=eb \\ast a = eb∗a=e，则称aaa左可逆，并称bbb是aaa的一个左逆元，记为al−1a_l^{-1}al−1​\n使得：a∗b=ea \\ast b = ea∗b=e，则称aaa右可逆，并称bbb是aaa的一个右逆元，记为ar−1a_r^{-1}ar−1​\n\n\n\n 定理\n\n设(A,∗)(A,  \\ast )(A,∗)是一个代数系统，“ ∗\\ast∗” 满足结合律，a∈Aa∈Aa∈A，aaa可逆，则aaa是可消去元\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，\n\n如果(A,∗)(A,  \\ast )(A,∗)存在单位元，则单位元唯一\n如果(A,∗)(A,  \\ast )(A,∗)存在单位元，则该单位元一定是左、右单位元\n如果(A,∗)(A,  \\ast )(A,∗)存在左、右单位元，则该左、右单位元相等，且是单位元。\n\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，\n\n如果(A,∗)(A,  \\ast )(A,∗)存在零元，则零元唯一\n如果(A,∗)(A,  \\ast )(A,∗)存在零元，则该零元一定是左、右零元\n如果(A,∗)(A,  \\ast )(A,∗)存在左、右零元，则该左、右零元相等，且是零元。\n\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，“ ∗\\ast∗”满足结合律且设eee是单位元，则对任意a∈Aa∈Aa∈A，\n\n如果aaa存在逆元，则逆元唯一\n如果aaa存在逆元，则该逆元一定是左、右逆元\n如果aaa存在左、右逆元，则该左、右逆元相等，且是逆元。\n\n\n设(A,∗)(A,  \\ast )(A,∗)是二元代数系统，“ ∗\\ast∗”满足结合律，a,b∈Aa, b∈Aa,b∈A，\n\n如果a,ba, ba,b分别有逆元a−1,b−1a^{-1}, b^{-1}a−1,b−1，则(a∗b)−1=b−1∗a−1(a \\ast b)^{-1} = b^{-1} \\ast a^{-1}(a∗b)−1=b−1∗a−1\n如果aaa是左（或右）可逆的元素，则aaa是左（或右）可消去的元素\n如果aaa是可逆的元素，则aaa是可消去的元素\n\n\n\n 同构\n 同构的定义\n\n在现实社会中，存在着很多代数系统，但仔细分析这些众多的代数系统发现，有些代数系统，他们之间表面上似乎不相同，但他们本质上是“相同”的\n\n 同构的条件\n\n必须是同型代数系统\n两个集合的元素个数应相等\n运算定义法则相同，即对应元素运算后的结果也对应\n\n 同态\n 同态的定义\n\n设(A,∗)(A,  \\ast )(A,∗)和(B,∘)(B, \\circ)(B,∘)为两个二元代数系统，ggg是AAA到BBB的函数。对任意x,y∈Ax, y∈Ax,y∈A，都有g(x∗y)=g(x)∘g(y)g(x \\ast y) = g(x) \\circ g(y)g(x∗y)=g(x)∘g(y)，则称ggg是从(A,∗)(A,  \\ast )(A,∗)到(B,∘)(B, \\circ)(B,∘)的同态映射，称g(A)g(A)g(A)为同态像，其中g(A)={g(x)∣x∈A}g(A) = \\{g(x) | x∈A\\}g(A)={g(x)∣x∈A}。如果存在一个从(A,∗)(A, \\ast )(A,∗)到(B,∘)(B, \\circ )(B,∘)的同态映射，则称(A,∗)(A,  \\ast )(A,∗)与(B,∘)(B, \\circ )(B,∘)同态，记为(A,∗)∽(B,∘)(A, \\ast )∽(B, \\circ )(A,∗)∽(B,∘)。当(A,∗)=(B,∘)(A,  \\ast )= (B, \\circ )(A,∗)=(B,∘)时，称其同态为自同态\n当同态映射ggg分别是单射、满射、双射时，分别称ggg是单一同态映射、满同态映射、同构映射\n如果存在一个从(A,∗)(A,  \\ast )(A,∗)到(B,∘)(B, \\circ )(B,∘)的同构映射（单一同态映射、满同态映射），则称代数系统(A,∗)(A, \\ast )(A,∗)与(B,∘)(B, \\circ )(B,∘)同构（单一同态、满同态）。\n用(A,∗)≌(B,∘)(A,  \\ast )≌(B, \\circ )(A,∗)≌(B,∘)表示(A,∗)(A, \\ast )(A,∗)与(B,∘)(B, \\circ )(B,∘)同构\n\n 命题逻辑\n 命题与命题联结词\n 命题\n\n具有真假意义的陈述句称为命题\n命题可以取一个“值”，称为真值\n真值只有“真”和“假”两种，分别用“ＴＴＴ”(或“１１１”)和“ＦＦＦ”(或“０００)表示\n\n 命题的分类\n\n原子命题(简单命题)：不能再分解为更为简单命题的命题\n复合命题：可以分解为原子命题的命题，这些原子命题之间通过如“或者”、“并且”、“不”、“如果…则…”、“当且仅当”等这样的关联词和标点符号复合而构成一个复合命题。（优先级：否定→合取→析取→蕴涵→等价）\n\n 命题联结词\n 否定¬\\neg¬\n\n设PPP是任一命题，复合命题“非PPP”(或“PPP的否定”)称为PPP的否定式(Negation)，记作¬P\\neg P¬P，“¬\\neg¬”为否定联结词\n\n 合取∧\\wedge∧\n\n设PPP、QQQ是任两个命题，复合命题“P并且QP并且QP并且Q”(或“P和QP和QP和Q”)称为PPP与QQQ的合取式(Conjunction)，记作P∧QP∧QP∧Q，“∧∧∧”为合取联结词\n\n 析取∨\\vee∨\n\n设PPP、QQQ是任两个命题，复合命题“P或者QP或者QP或者Q”称为PPP与QQQ的析取式(Disjunction)，记作P∨QP∨QP∨Q，“∨∨∨”为析取联结词\n\n 蕴涵→→→\n\n设PPP、QQQ是任两个命题，复合命题“如果P，则Q如果P，则Q如果P，则Q”称为PPP与QQQ的蕴涵式(Implication)，记作P→QP→QP→Q，“→→→”称为蕴涵联结词，PPP称为蕴涵式的前件，QQQ称为后件\n\n 等价↔\\leftrightarrow↔\n\n设P、QP、QP、Q是任两个命题，复合命题“P当且仅当QP当且仅当QP当且仅当Q”称为PPP与QQQ的等价式(Equivalence)，记作P↔QP\\leftrightarrow QP↔Q，“↔\\leftrightarrow↔”称为等价联结词\n\n 说明\n\n联结词与自然语言之间的对应并非一一对应：\n\n合取联结词“∧∧∧”对应自然语言的“既…又…”、“不仅…而且…”、“虽然…但是…”、“并且”、“和”、“与”等\n蕴涵联结词“→→→”,“P→QP→QP→Q”对应自然语言中的“如P则Q” , “只要P就Q”,“P仅当Q”,“只有Q才P”,“除非Q否则¬\\neg¬ P”等\n等价联结词“↔↔↔”对应了自然语言中的“等价”、“当且仅当”、“充分必要”等\n析取联结词“∨\\vee∨”对应的是相容（可兼）的或\n否定联结词“¬\\neg¬”是自然语言中的“非”、“不”和“没有”等\n\n\n当前件PPP为假时，不管QQQ的真假如何，则P→QP→QP→Q都为真。此时称为“善意推定”\n复合命题的真值只取决于构成他们的各原子命题的真值，而与它们的内容、含义无关，与联结次所连接的两原子命题之间是否有关系无关\n\n 命题公式与符号化\n 命题公式的定义\n\n一个特定的命题是一个常值命题，它不是具有值“T”(“1”)，就是具有值“F”(“0”)\n一个任意的没有赋予具体内容的原子命题称为命题变量(或命题变元)，该命题变量无具体的真值，它的变域是集合{T，F}\\{T，F\\}{T，F}(或{0，1}\\{0，1\\}{0，1})\n当原子命题是命题变元时，此复合命题也即为命题变元的“函数”，且该“函数”的值仍为“真”或“假”值，这样的函数可形象地称为“真值函数”,或称为命题公式，此命题公式没有确切真值\n\n 公式的解释\n 定义\n\n设P1、P2、…、PnP_1、P_2、…、P_nP1​、P2​、…、Pn​是出现在公式GGG中的所有命题变元，指定P1、P2、…、PnP_1、P_2、…、P_nP1​、P2​、…、Pn​一组真值，则这组真值称为GGG的一个解释,常记为III\n\n 性质\n\n一般来说，若有ｎｎｎ个命题变元，则应有2n2^n2n个不同的解释\n如果公式GGG在解释III下是真的，则称III满足GGG；如果GGG在解释III下是假的，则称III弄假GGG\n\n 真值表\n 定义\n\n将公式GGG在其所有可能解释下的真值情况列成的表，称为GGG的真值表\n\n 公式的等价性\n 基本等价式\n 交换律\n\nP∧Q  ⟺  Q∧PP∧Q\\iff Q∧PP∧Q⟺Q∧P\nP∨Q  ⟺  Q∨PP∨Q\\iff Q∨PP∨Q⟺Q∨P\nP↔Q  ⟺  Q↔PP\\leftrightarrow Q\\iff Q\\leftrightarrow PP↔Q⟺Q↔P\n\n 结合律\n\n(P∧Q)∧R  ⟺  P∧(Q∧R)(P∧Q)∧R\\iff P∧(Q∧R)(P∧Q)∧R⟺P∧(Q∧R)\n(P∨Q)∨R  ⟺  P∨(Q∨R)(P∨Q)∨R\\iff P∨(Q∨R)(P∨Q)∨R⟺P∨(Q∨R)\n(P↔Q)↔R  ⟺  P↔(Q↔R)(P\\leftrightarrow Q)\\leftrightarrow R\\iff P\\leftrightarrow (Q\\leftrightarrow R)(P↔Q)↔R⟺P↔(Q↔R)\n\n 分配律\n\nP∧(Q∨R)  ⟺  (P∧Q)∨(P∧R)P∧(Q∨R)\\iff (P∧Q)∨(P∧R)P∧(Q∨R)⟺(P∧Q)∨(P∧R)\nP∨(Q∧R)  ⟺  (P∨R)∧(P∨R)P∨(Q∧R)\\iff(P∨R)∧(P∨R)P∨(Q∧R)⟺(P∨R)∧(P∨R)\n\n 否定深入\n\n¬¬P  ⟺  P\\neg \\neg P \\iff P¬¬P⟺P\n¬(P∧Q)  ⟺  ¬P∨¬Q\\neg (P∧Q) \\iff \\neg P∨ \\neg Q¬(P∧Q)⟺¬P∨¬Q\n¬(P∨Q)  ⟺  ¬P∧¬Q\\neg (P\\vee Q) \\iff \\neg P\\wedge \\neg Q¬(P∨Q)⟺¬P∧¬Q\n¬(P→Q)  ⟺  P∧¬Q\\neg (P → Q)\\iff P ∧ \\neg Q¬(P→Q)⟺P∧¬Q\n¬(P↔Q)  ⟺  ¬P↔Q  ⟺  P↔¬Q\\neg(P \\leftrightarrow Q) \\iff \\neg P \\leftrightarrow Q \\iff P \\leftrightarrow \\neg Q¬(P↔Q)⟺¬P↔Q⟺P↔¬Q\n\n 联结词化归\n\nP∧Q  ⟺  ¬（¬P∨¬Q）P∧Q\\iff \\neg（\\neg P∨\\neg Q）P∧Q⟺¬（¬P∨¬Q）\nP∨Q  ⟺  ¬（¬P∧¬Q）P∨Q\\iff \\neg （\\neg P∧\\neg Q）P∨Q⟺¬（¬P∧¬Q）\nP→Q  ⟺  ¬P∨QP→Q\\iff  \\neg P∨QP→Q⟺¬P∨Q\nP↔Q  ⟺  (P→Q)∧(Q→P)  ⟺  (¬P∨Q)∧(¬Q∨P)  ⟺  (P∧Q)∨(¬P∧¬Q)P \\leftrightarrow Q \\iff  (P→Q)∧(Q→P) \\iff  (\\neg P∨Q) ∧(\\neg Q∨P) \\iff  (P ∧ Q) ∨(\\neg P ∧ \\neg Q)P↔Q⟺(P→Q)∧(Q→P)⟺(¬P∨Q)∧(¬Q∨P)⟺(P∧Q)∨(¬P∧¬Q)\n\n 命题与集合的关系\n\n将G，HG，HG，H理解为某总体论域上的子集合，而规定G∧HG∧HG∧H为两集合的公共部分（交集），G∨HG∨HG∨H为两集合的全部（并集），¬G\\neg G¬G为总体论域（如矩形域）中GGG的补集，将命题中的真值“1”理解为集合中的总体论域（全集），将命题中的真值“0”理解为集合中的空集\n\n 永真式、永假式与蕴含式\n 定义\n\n公式G称为永真式，如果在它的所有解释之下都为“真”\n公式G称为永假式，如果在它的所有解释之下都为“假”\n公式G称为可满足的，如果它不是永假的\n\n 公式等价\n 定义\n\n设G、H是公式，如果在任意解释I下，G与H的真值相同，则称公式G、H是等价的，记作G  ⟺  HG\\iff HG⟺H\n\n 定理\n\nG  ⟺  HG\\iff HG⟺H等价的充分必要条件为G  ⟹  HG\\implies HG⟹H且H  ⟹  GH\\implies GH⟹G\n公式G、H等价的充分必要条件是公式G  ⟺  HG\\iff HG⟺H是永真公式\n\n 性质\n\n由于“  ⟺  \\iff⟺”不是一个联结词，而是一种关系，为此，这种关系具有如下三个性质：\n\n自反性   G=G\n对称性   若G=H，则H=G\n传递性   若G=H，H=S，则G=S\n\n\n\n 命题逻辑推理\n 基本蕴含式\n\n(P→Q)∧(Q→R)  ⟹  P→R(P \\to Q) \\land (Q \\to R) \\implies P \\to R(P→Q)∧(Q→R)⟹P→R  (假言三段论)\n\n 定理\n\n若前提集合为{H1，H2，…，Hm}\\{ H_1，H_2，…，H_m \\}{H1​，H2​，…，Hm​}, 结论为P→QP→ QP→Q ，则{H1，H2，…，Hm}  ⟹  P→Q\\{ H_1，H_2，…，H_m \\}\\implies P\\to Q{H1​，H2​，…，Hm​}⟹P→Q等价于{H1，H2，…，Hm，P}  ⟹  Q\\{H_1，H_2，…，H_m，P\\}\\implies Q{H1​，H2​，…，Hm​，P}⟹Q (CP规则)\n\n 推理规则\n\nP→Q,Q→R⊢P→RP \\to Q, Q \\to R \\vdash P \\to RP→Q,Q→R⊢P→R\n\n 公式蕴涵的证明方法\n\n真值表法\n证G→HG \\to HG→H是恒真公式\n利用一些基本等价式及蕴涵式进行推导\n任取真值I，若I满足G，往证I满足H\n反证法，设结论假，往证前提假\n\n 三个基本推理规则\n\nP规则(前提引入规则)：前提总是可用\nT规则(推理引入规则)：推理中允许使用推理规则，所得结果在后面的推理中可用\nCP规则(附加前提引入规则) ：证明P→QP\\to QP→Q时可将P作为附加前提引入\n\n 范式\n 定义\n 合取式\n\n在一公式中，仅由命题变元及其否定构成的合取，称该公式为合取式\n其中每个命题变元或其否定，称为合取项\n\n 析取式\n\n在一公式中，仅由命题变元及其否定构成的析取，称该公式为析取式\n其中每个命题变元或其否定，称为析取项\n\n 析取范式\n\n一个命题公式A称为析取范式可表示为：多个合取式的析取\n\n 合取范式\n\n一个命题公式A称为合取范式可表示为：多个析取式的合取\n\n 定理\n\n合取式为永假式的充要条件是：它同时含有某个命题变元及其否定\n析取式为永真式的充要条件是：它同时含有某个命题变元及其否定\n对于任何一命题公式，都存在与其等价的析取范式和合取范式\n\n 范式的应用\n\n公式A为永假式的充要条件是其析取范式中每个简单合取式至少包含一个命题变元及其否定\n公式A为永真式的充要条件是其合取范式中每个简单析取式至少包含一个命题变元及其否定\n\n 公式的主范式\n 最小项\n\n在含有n个命题变元的合取式中， 若每个命题变元与其否定不同时存在，而二者之一出现一次且仅出现一次，则称该合取式为最小项\nn个命题变元共形成2n2^n2n个最小项\n任意两个不同的最小项的合取式是永假的：mi∧mj  ⟺  F,i≠jm_i∧m_j\\iff F,i≠jmi​∧mj​⟺F,i=j\n所有最小项之析取为永真：⋁i=1nmi  ⟺  T\\bigvee\\limits_{i=1}^n m_i \\iff Ti=1⋁n​mi​⟺T\n每个最小项只有一个真值组合为真\n\n 最大项\n\n在n个命题变元的析取式中，若每个命题变元与其否定不同时存在，而二者之一必出现一次且仅出现一次，则称该析取式为最大项\n任何两个不同最大项之析取是永真的，即：Mi∨Mj  ⟺  T,i≠jM_i∨M_j\\iff T,i≠jMi​∨Mj​⟺T,i=j\n所有最大项之合取为永假，即：⋀i=1nMi  ⟺  F\\bigwedge\\limits_{i=1}^n M_i \\iff Fi=1⋀n​Mi​⟺F\n每个最大项只有一个真值组合为假，且其真值0位于主对角线上\n\n 主析取范式\n\n在给定公式的析取范式中，若其合取式都是最小项，则称该范式为主析取范式\n任意含n个命题变元的非永假命题公式A，都存在与其等价的主析取范式\n任意含n个命题变元的非永假命题公式，其主析取范式是惟一的\n\n 主合取范式\n\n在给定公式的合取范式中，若其所有简单析取式都是最大项，称该范式为主合取范式\n任意含有n个命题变元的非永真命题公式A，都存在与其等价的主合取范式\n任意含n个命题变元的非永真命题公式A，其主合取范式是唯一的\n\n 求法\n\n公式化归法\n真值表法\n\n 主析取范式与主合取范式之间的关系\n\n由于主范式是由最小项或最大项构成，由其定义，可知两者有下列关系：¬mi  ⟺  Mi,¬Mi  ⟺  mi\\neg m_i\\iff M_i, \\neg M_i\\iff m_i¬mi​⟺Mi​,¬Mi​⟺mi​\n因此，主析取范式和主合取范式有着“互补”关系，即由公式的主析取范式可以求出其主合取范式\n\n 主范式的应用\n\n根据主范式的定义和定理，可以判定含n个命题变元的公式，其关键是先求出给定公式的主范式Ａ；其次按下列条件判定之：\n\n若A  ⟺  ＴA\\iff ＴA⟺Ｔ，或A可化为与其等价的、含2n2^n2n个最小项的主析取范式，则A为永真式\n若A  ⟺  ＦA\\iff ＦA⟺Ｆ，或A可化为与其等价的、含2n2^n2n个最大项的主合取范式，则A为永假式\n若A不与Ｔ或者Ｆ等价，且又不含2n2^n2n个最小项或最大项，则A为可满足的\n\n\n由于任一公式的主范式是唯一的，所以将给定的公式求出其主范式，若主范式相同，则给定两公式是等价的\n\n 推理规则\n “  ⟹  \\implies⟹”与“→\\to→”的不同\n\n“→→→”仅是一般的蕴涵联结词，G→HG→HG→H的结果仍是一个公式，而“  ⟹  \\implies⟹”却描述了两个公式G，H之间的一种逻辑蕴涵关系，G  ⟹  HG\\implies HG⟹H的“结果”，是非命题公式\n用计算机来判断G  ⟹  HG\\implies HG⟹H是办不到的。然而计算机却可“计算”公式G→HG→HG→H是否为永真公式\n\n 谓词逻辑\n 谓词逻辑基本概念\n 谓词\n 定义\n\n用以刻划客体的性质或客体之间的关系即是谓词\n\n 简单命题函数\n\n由一个谓词和一些客体变元组成的表达式.\nA(x1，x2,…,xn)A(x_1，x_2,…,x_n)A(x1​，x2​,…,xn​)称n元命题函数或n元原子谓词公式，n元谓词就是有 n 个客体变元的命题函数\n\n 复合命题函数\n\n由一个或 n个简单命题函数以及联结词组成的表达式\n\n 结论\n\n谓词中个体词的顺序是十分重要的，不能随意变更。如命题F(b,c)F(b, c)F(b,c)为“真”，但命题F(c,b)F(c, b)F(c,b)为“假”\n一元谓词用以描述某一个个体的某种特性，而n元谓词则用以描述n个个体之间的关系\n0元谓词(不含个体词的)实际上就是一般的命题\n具体命题的谓词表示形式和n元命题函数(n元谓词)是不同的，前者是有真值的，而后者不是命题，它的真值是不确定的。如上例中S(a)是有真值的，但S(x)却没有真值\n一个n元谓词不是一个命题，但将n元谓词中的个体变元都用个体域中具体的个体取代后，就成为一个命题。而且，个体变元在不同的个体域中取不同的值对是否成为命题及命题的真值有很大的影响\n\n 客体\n\n客体变元在哪些范围内取值（称客体），对是否成为命题及命题的真值都有影响\n在命题函数中，命题变元的论述范围称作个体域，个体域可以是有限的，也可以是无限的，把各种个体域综合在一起作为论述范围的域称为全总客体域\n\n 量词\n 全称量词∀\\forall∀\n\n∀\\forall∀称为全称量词，“对所有的” ,“每一个”, “对任一个”\n\n 存在量词∃\\exists∃\n\n∃\\exists∃称为存在量词，“存在一个”，“有一个”，“对于一些”\n\n 特性谓词\n\n限定客体变元变化范围的谓词\n\n 注意\n\n由量词确定的表达式，都与个体域有关\n用全总个体域，对每个的客体变元变化范围，用特性谓词加以限制，一般地：\n\n对全称量词，特性谓词常作条件的前提条件\n对存在量词，特性谓词常作合取项\n\n\n\n 谓词逻辑符号化的两条规则\n\n统一个体域为全总个体域，而对每一个句子中个体变量的变化范围用一元特性谓词刻划之。这种特性谓词在加入到命题函数中时必定遵循如下原则：\n\n对于全称量词(∀x\\forall x∀x)，刻划其对应个体域的特性谓词作为蕴涵式之前件加入\n对于存在量词(∃x\\exists x∃x)，刻划其对应个体域的特性谓词作为合取式之合取项加入\n\n\n\n 谓词公式翻译\n 谓词演算的逻辑公式\n\n原子谓词公式是逻辑公式，如Q，A(x)，A(x,y)，…\n若AAA是逻辑公式,则¬A\\neg A¬A也是逻辑公式\n若A,B是逻辑公式，则A∧BA∧BA∧B，A∨BA∨BA∨B，A→BA→BA→B，A↔BA\\leftrightarrow BA↔B 也是逻辑公式\n若A是逻辑公式，x是A中出现的任何变元，则∀xA\\forall xA∀xA和∃xA\\exists xA∃xA也是逻辑公式\n\n 约束变元与自由变元\n 约束部分\n\n在谓词公式中,形如∀xP(x)\\forall x P(x)∀xP(x) ，∃xP(x)\\exists x P(x)∃xP(x)的部分,称为谓词公式的x约束部分\n\n∀∃\\forall \\exists∀∃后的x叫量词的指导变元或作用变元\nP(x)叫做相应量词的作用域或辖域\n\n\n\n 约束出现\n\n在作用域中x的一切出现，称为 x在公式中的约束出现\n\n所有约束出现的变元叫做约束变元\n不受约束的变元为自由变元\n\n\n\n n-k元谓词和有关命题\n\nP(x1,x2,...,xn)P(x_1,x_2,...,x_n)P(x1​,x2​,...,xn​)是n元谓词，有n个独立的自由变元。若对其中k个变元进行约束，则称为 n-k 元谓词。若没有自由变量出现，则该式就成为有关命题\n\n###　变元换名规则\n\n换名范围:量词中的指导变元和作用域中出现的该变元.公式中其余部分不变\n要换成作用域中没有出现的变元名称\n\n 变元代入规则\n\n对该自由变元每一处进行代入\n代入的变元与原公式中所有变元名称不能相同\n\n 谓词演算的等价式和蕴含式\n 基本概念\n 等价\n\n任意给定两个谓词公式A和B , E 为它们共同的个体域, 若对A和 B的任一组变元进行赋值, 所得命题真值相同,则称 A 和 B 在 E 上是等价的,\n记为A  ⟺  BA\\iff BA⟺B\n\n 永真的(有效的)\n\n给定任意谓词公式 A，其个体域为E对于A的所有赋值A都真，则称A在E上是永真的(有效的)\n\n 可满足的\n\n一谓词公式A ，若至少在一种赋值下为真，则称A在E 上是可满足的\n\n 命题公式的推广\n\n当用谓词演算中的公式代替命题演算中永真式的变元时，所得公式为有效公式\n\n∀𝑥(𝑃(𝑥)→𝑄(𝑥))  ⟺  ∀𝑥(¬𝑃(𝑥)∨𝑄(𝑥))∀𝑥(𝑃(𝑥)→𝑄(𝑥))\\iff ∀𝑥(¬𝑃(𝑥)∨𝑄(𝑥))∀x(P(x)→Q(x))⟺∀x(¬P(x)∨Q(x))\n\n\n量词与否定联结词¬\\neg¬间的关系：量词前的否定,是否定被量化了的整个命题\n\n¬∀𝑥𝑃(𝑥)  ⟺  ∃𝑥¬𝑃(𝑥)¬∀𝑥𝑃(𝑥)\\iff ∃𝑥¬𝑃(𝑥)¬∀xP(x)⟺∃x¬P(x)\n¬∃𝑥𝑃(𝑥)  ⟺  ∀𝑥¬𝑃(𝑥)¬∃𝑥𝑃(𝑥)\\iff ∀𝑥¬𝑃(𝑥)¬∃xP(x)⟺∀x¬P(x)\n\n\n量词作用域的扩张与收缩\n\n∀𝑥(𝐴(𝑥)∨𝐵)  ⟺  ∀𝑥𝐴(𝑥)∨𝐵∀𝑥(𝐴(𝑥)∨𝐵)\\iff ∀𝑥𝐴(𝑥)∨𝐵∀x(A(x)∨B)⟺∀xA(x)∨B\n∀𝑥(𝐴(𝑥)∧𝐵)  ⟺  ∀𝑥𝐴(𝑥)∧𝐵∀𝑥(𝐴(𝑥)∧𝐵)\\iff ∀𝑥𝐴(𝑥)∧𝐵∀x(A(x)∧B)⟺∀xA(x)∧B\n∀𝑥(𝐴(𝑥)→𝐵)  ⟺  ∃𝑥𝐴(𝑥)→𝐵∀𝑥(𝐴(𝑥)→𝐵)\\iff ∃𝑥𝐴(𝑥)→𝐵∀x(A(x)→B)⟺∃xA(x)→B\n∀𝑥(𝐵→𝐴(𝑥))  ⟺  𝐵→∀𝑥𝐴(𝑥)∀𝑥(𝐵→𝐴(𝑥))\\iff 𝐵→∀𝑥𝐴(𝑥)∀x(B→A(x))⟺B→∀xA(x)\n∃𝑥(𝐴(𝑥)∨𝐵)  ⟺  ∃𝑥𝐴(𝑥)∨𝐵∃𝑥(𝐴(𝑥)∨𝐵)\\iff ∃𝑥𝐴(𝑥)∨𝐵∃x(A(x)∨B)⟺∃xA(x)∨B\n∃𝑥(𝐴(𝑥)∧𝐵)  ⟺  ∃𝑥𝐴(𝑥)∧𝐵∃𝑥(𝐴(𝑥)∧𝐵)\\iff ∃𝑥𝐴(𝑥)∧𝐵∃x(A(x)∧B)⟺∃xA(x)∧B\n∃𝑥𝐴(𝑥)→𝐵  ⟺  ∀𝑥(𝐴(𝑥)→𝐵)∃𝑥𝐴(𝑥)→𝐵\\iff ∀𝑥(𝐴(𝑥)→𝐵)∃xA(x)→B⟺∀x(A(x)→B)\n∃𝑥(𝐵→𝐴(𝑥))  ⟺  𝐵→∃𝑥𝐴(𝑥)∃𝑥(𝐵→𝐴(𝑥))\\iff 𝐵→∃𝑥𝐴(𝑥)∃x(B→A(x))⟺B→∃xA(x)\n\n\n量词分配律\n\n∀𝑥(𝐴(𝑥)∧𝐵(𝑥))  ⟺  ∀𝑥𝐴(𝑥)∧∀𝑥𝐵(𝑥)∀𝑥(𝐴(𝑥)∧𝐵(𝑥))\\iff ∀𝑥𝐴(𝑥)∧∀𝑥𝐵(𝑥)∀x(A(x)∧B(x))⟺∀xA(x)∧∀xB(x)\n∃𝑥(𝐴(𝑥)∨𝐵(𝑥))  ⟺  ∃𝑥𝐴(𝑥)∨∃𝑥𝐵(𝑥)∃𝑥(𝐴(𝑥)∨𝐵(𝑥))\\iff ∃𝑥𝐴(𝑥)∨∃𝑥𝐵(𝑥)∃x(A(x)∨B(x))⟺∃xA(x)∨∃xB(x)\n∀𝑥𝐴(𝑥)∨∀𝑥𝐵(𝑥)  ⟹  ∀𝑥(𝐴(𝑥)∨𝐵(𝑥))∀𝑥𝐴(𝑥)∨∀𝑥𝐵(𝑥)\\implies ∀𝑥(𝐴(𝑥)∨𝐵(𝑥))∀xA(x)∨∀xB(x)⟹∀x(A(x)∨B(x))\n∃𝑥(𝐴(𝑥)∧𝐵(𝑥))  ⟹  ∃𝑥𝐴(𝑥)∧∃𝑥𝐵(𝑥)∃𝑥(𝐴(𝑥)∧𝐵(𝑥))\\implies ∃𝑥𝐴(𝑥)∧∃𝑥𝐵(𝑥)∃x(A(x)∧B(x))⟹∃xA(x)∧∃xB(x)\n\n\n含多个变元的等价式和蕴含式\n\n∀𝑥∀𝑦𝑃(𝑥,𝑦)  ⟺  ∀𝑦∀𝑥𝑃(𝑥,𝑦)∀𝑥∀𝑦𝑃(𝑥,𝑦)\\iff ∀𝑦∀𝑥𝑃(𝑥,𝑦)∀x∀yP(x,y)⟺∀y∀xP(x,y)\n∀𝑥∀𝑦𝑃(𝑥,𝑦)  ⟹  ∃𝑦∀𝑥𝑃(𝑥,𝑦)∀𝑥∀𝑦𝑃(𝑥,𝑦)\\implies ∃𝑦∀𝑥𝑃(𝑥,𝑦)∀x∀yP(x,y)⟹∃y∀xP(x,y)\n∀𝑦∀𝑥𝑃(𝑥,𝑦)  ⟹  ∃𝑥∀𝑦𝑃(𝑥,𝑦)∀𝑦∀𝑥𝑃(𝑥,𝑦)\\implies ∃𝑥∀𝑦𝑃(𝑥,𝑦)∀y∀xP(x,y)⟹∃x∀yP(x,y)\n∃𝑦∀𝑥𝑃(𝑥,𝑦)  ⟹  ∀𝑥∃𝑦𝑃(𝑥,𝑦)∃𝑦∀𝑥𝑃(𝑥,𝑦)\\implies ∀𝑥∃𝑦𝑃(𝑥,𝑦)∃y∀xP(x,y)⟹∀x∃yP(x,y)\n∃𝑥∀𝑦𝑃(𝑥,𝑦)  ⟹  ∀𝑦∃𝑥𝑃(𝑥,𝑦)∃𝑥∀𝑦𝑃(𝑥,𝑦)\\implies ∀𝑦∃𝑥𝑃(𝑥,𝑦)∃x∀yP(x,y)⟹∀y∃xP(x,y)\n∀𝑥∃𝑦𝑃(𝑥,𝑦)  ⟹  ∃𝑦∃𝑥𝑃(𝑥,𝑦)∀𝑥∃𝑦𝑃(𝑥,𝑦)\\implies ∃𝑦∃𝑥𝑃(𝑥,𝑦)∀x∃yP(x,y)⟹∃y∃xP(x,y)\n∀𝑦∃𝑥𝑃(𝑥,𝑦)  ⟹  ∃𝑥∃𝑦𝑃(𝑥,𝑦)∀𝑦∃𝑥𝑃(𝑥,𝑦)\\implies ∃𝑥∃𝑦𝑃(𝑥,𝑦)∀y∃xP(x,y)⟹∃x∃yP(x,y)\n∃𝑥∃𝑦𝑃(𝑥,𝑦)  ⟺  ∃𝑦∃𝑥𝑃(𝑥,𝑦)∃𝑥∃𝑦𝑃(𝑥,𝑦)\\iff ∃𝑦∃𝑥𝑃(𝑥,𝑦)∃x∃yP(x,y)⟺∃y∃xP(x,y)\n\n\n\n 谓词逻辑的推理理论\n 规则\n\n设 A(x)是谓词公式\n\n全称移去规则 US (全称指定)：∀𝑥𝐴(𝑥)⇒𝐴(𝑐)∀𝑥𝐴(𝑥)⇒𝐴(𝑐)∀xA(x)⇒A(c)，c 是论域中某个任意客体\n全称附加规则 UG (全称推广)：𝐴(𝑐)⇒∀𝑥𝐴(𝑥)𝐴(𝑐)⇒∀𝑥𝐴(𝑥)A(c)⇒∀xA(x)，每个 c, A©为真\n存在移去规则 ES (存在指定)：∃𝑥𝐴(𝑥)⇒𝐴(𝑐)∃𝑥𝐴(𝑥)⇒𝐴(𝑐)∃xA(x)⇒A(c)，c 是论域中使A©为真的客体\n存在附加规则 EG (存在推广)：𝐴(𝑐)⇒∃𝑥𝐴(𝑥)𝐴(𝑐)⇒∃𝑥𝐴(𝑥)A(c)⇒∃xA(x)，c 是论域中使A©为真的客体\n\n\n\n 谓词演算的综合推理方法\n\n推导过程中可以引用命题演算中的P规则 和T规则\n如果结论是以蕴涵形式(或析取形式)给出，我们还可以使用CP规则\n若需消去量词，可以引用US规则和ES规则\n当所要求的结论可能被定量时，此时可引用UG规则和EG规则将其量词加入\n证明时可采用如命题演算中的直接证明方法和间接证明方法\n在推导过程中，对消去量词的公式或公式中不含量词的子公式，完全可以引用命题演算中的基本等价公式和基本蕴涵公式\n在推导过程中，对含有量词的公式可以引用谓词中的基本等价公式和基本蕴涵公式\n\n 图的基本概念\n 图与子图\n 图的定义\n\n图G是由非空集合V={v1,v2,…,vn}V=\\{v_1,v_2,…,v_n\\}V={v1​,v2​,…,vn​}，以及边的集合E={l1,l2,…,lm}E=\\{l_1,l_2,…,l_m\\}E={l1​,l2​,…,lm​}所组合，其中每条边可用一个结点对表示，即：li=(vi1,vi2),i=1,2,…,ml_i=(v_{i1},v_{i2}),i=1,2,…,mli​=(vi1​,vi2​),i=1,2,…,m，这样的图G可用G=(V，E)G=(V，E)G=(V，E)表示\n\n 图的基本概念\n 有向图\n\n图中的所有边均为有向边，有向边lk=&lt;vi,vj&gt;l_k=&lt;v_i,v_j&gt;lk​=&lt;vi​,vj​&gt;, viv_ivi​为起点，vjv_jvj​为终点，箭头指向终点\n\n 无向图\n\n图中的所有边均为无向边\n\n 邻接与环\n\n多条边关联于同一个结点，则这些边称为邻接的\n构成边的一对结点之间称为邻接的\n若一条边由相同的结点构成，则称为环(vi,vi)(v_i,v_i)(vi​,vi​)\n\n 零图与平凡图\n\n仅含一些孤立点的图称为零图\n特别，仅含一个孤立点的零图称为平凡图\n\n 多重图与线图\n\n有相同端点（起终点）的两条无（有）向边叫做重边\n含重边的图称为多重图\n非多重图称为线图\n不含自环和重边的图称为简单图（无自环的线图）\n\n 完全图\n\n每对结点间都有一条无向边（一对方向相反的有向边）的简单图，称为无（有）向完全图\n设G是含有n个顶点和m条边的无（有）向完全图m=n(n−1)/2,m=n(n−1)m=n(n-1)/2,m=n(n-1)m=n(n−1)/2,m=n(n−1)\n\n 赋权图\n\n赋权图G是一个三重组(V,E,g)(V, E, g)(V,E,g)，其中V是结点集合，E是边的集合\n\n 子图与补图\n\n若V’⊆V,E’⊆EV’\\subseteq V, E’\\subseteq EV’⊆V,E’⊆E, 则称G’=(V’,E’)G’=(V’,E’)G’=(V’,E’)是G=(V,E)G=(V,E)G=(V,E)的子图\nE’⊆EE’\\subseteq EE’⊆E之子图叫做真子图\nV’=VV’=VV’=V之子图叫做生成子图\n设V’⊆VV’\\subseteq VV’⊆V且$V’≠\\varnothing ，以，以，以V’为结点集，以两个端点均在为结点集，以两个端点均在为结点集，以两个端点均在V’中的边的全体为边集的G的子图，称为’中的边的全体为边集的G的子图，称为’中的边的全体为边集的G的子图，称为V’导出的G的子图，简称导出的G的子图，简称导出的G的子图，简称V’$的导出子图\n图G’=(V’,E’)G’=(V’, E’)G’=(V’,E’)是图G=(V,E)G=(V, E)G=(V,E)的子图。若G有子图G’’=(V’’,E’’)G’’=(V’’, E’’)G’’=(V’’,E’’),其中E’’=E−E’E’’=E-E’E’’=E−E’，V’’V’’V’’是仅含E’’E’’E’’中的边关联的结点和不在G’G’G’中的GGG的孤立点的集合，则称G’’G’’G’’是G’G’G’关于GGG的**补图 \\ast 8\n若称图GGG和G’G’G’互为补图，则两图G=(V,E)、G’=(V,E’)G=(V, E)、G’=(V, E’)G=(V,E)、G’=(V,E’)满足：\n\nE∩E’=∅E∩E’=\\varnothingE∩E’=∅\n(V,E∪E’)(V, E∪E’)(V,E∪E’)是完全图\n\n\n\n 节点的次数\n\n结点的(全)度数d(v)：与结点v相关联的边数\n在有向图中，度数又分为：\n\n引入度数d−(v)d^-(v)d−(v)：以v为终点的边数\n引出度数d+(v)d^+(v)d+(v)：以v为起点的边数\n\n\nd(v)=d−(v)+d+(v)d(v) = d^-(v)+ d^+(v)d(v)=d−(v)+d+(v)\n次数为奇（偶）数的结点称为奇（偶）结点\n图中若有奇结点，则必有偶数个奇结点\n图中所有结点次数之和必为偶数，为图中边数的两倍\n\n 握手定理\n\n(n, m)图中，结点的总次数为：∑i=1nd(vi)=2m\\sum\\limits_{i=1}^nd(v_i)=2mi=1∑n​d(vi​)=2m\n\n 图的同构\n 定义\n\n图G=(V,E)G=(V, E)G=(V,E)与G’=(V’,E’)G’=(V’, E’)G’=(V’,E’)，如果存在双射函数ƒ:V→V’ƒ:V→V’ƒ:V→V’, 使得边也一一对应，则称GGG与G’G’G’同构\n\n 同构的必要条件\n\n结点数目相同\n边数相同\n度数相同的结点数相同\n\n 通路、回路与连通性\n 通路\n 定义\n\n(有向)图中k条(首尾)相连的边(vi0,vi1),(vi1,vi2),…,(vik−1,vik)(v_{i0},v_{i1}),(v_{i1},v_{i2}),…,(v_{ik-1},v_{ik})(vi0​,vi1​),(vi1​,vi2​),…,(vik−1​,vik​),记成(vi0,vi1,vi2,…,vik)(v_{i0},v_{i1},v_{i2}, …, v_{ik})(vi0​,vi1​,vi2​,…,vik​)，其中：vi0v_{i0}vi0​：起点，vikv_{ik}vik​：终点，kkk：通路长度\n\n 简单通路\n\n边不同之通路\n\n 基本通路\n\n结点不同之通路\n\n 可达\n\n从结点u到结点v有通路，称u到v可达\n\n 短程线\n\n两点间最短的通路\n\n 距离d(u,v)\n\n从u到v的短程线的长度(不可达则为无限)\n\n 回路\n 定义\n\nvi0=vikv_{i0}=v_{ik}vi0​=vik​之通路，即“起点=终点” 之通路\n\n 简单回路\n\n边不同之回路\n\n 基本回路\n\n结点不同之回路\n\n 结论\n\n任一通路删去所有回路必得基本通路\n任一回路删去其中间回路必得基本回路\n\n 定理\n\n一个(n,m)有向图中任何基本通路长度都小于n，而任何基本回路长度都不大于n\n\n 连通性\n 无向连通图\n\n任两点间均是可达的无向图\n\n 有向连通图\n\n去掉边的方向后是无向连通图之有向图\n\n 强连通图\n\n任两点间均互相可达之有向图\n\n 单向连通图\n\n任两点间至少有一向可达之有向图\n\n 弱连通图\n\n有向连通图\n\n 图的矩阵表示法\n 有向图的邻接矩阵\n 定义\n\n对图 G=({v1,v2,…,vn},E)G=(\\{v_1,v_2, …, v_n\\},E)G=({v1​,v2​,…,vn​},E), 其邻接矩阵AAA如下构成： A=(aij)n×n,aij={1vi与vj邻接0vi不与vj邻接A=(a_{ij})_{n\\times n},a_{ij}=\\begin{cases}1 &amp; v_i与v_j邻接\\\\0 &amp; v_i不与v_j邻接\\end{cases}A=(aij​)n×n​,aij​={10​vi​与vj​邻接vi​不与vj​邻接​\n\n 矩阵中的信息\n\n结点viv_ivi​的次数\n\n引出次数：d+(vi)=∑k=1naikd^+(v_i)=\\sum\\limits_{k=1}^n a_{ik}d+(vi​)=k=1∑n​aik​\n引出次数：d−(vi)=∑k=1nakid^-(v_i)=\\sum\\limits_{k=1}^n a_{ki}d−(vi​)=k=1∑n​aki​\n\n\nAlA^lAl\n\n令 C=Al,cijC=A^l, c_{ij}C=Al,cij​ 是viv_ivi​到vjv_jvj​的长度为lll的通路数目\n\n\n\n 可达性矩阵\n\nRn=A+A2+…+AnR_n=A+A^2+…+A^nRn​=A+A2+…+An —— 反映任两点间的通路数目\n可达性矩阵P —— 将RnR_nRn​中的非零值改为1—— 反映任两点间是否可达\nP也可如下计算：$P=A (+) A^{(2)} (+) … (+) A^{(n)} $\n\n 无向图的矩阵表示\n 无向图的邻接矩阵\n\n无向图的邻接矩阵与有向图的类似，并且是对称的\n结点的次数只要计算行(或列)之和即可，但对角线上的1要计算2次\n矩阵RnR_nRn​及P的计算方法也相同\n\n 多重图的邻接矩阵\n\n1改为重边的数目\n\n 有权图的邻接矩阵\n\n1改为权值\n\n 矩阵与图的连通性\n\n无向图G是连通的  ⟺  \\iff⟺G的可达性矩阵P除对角元外均为1\n有向图G是强连通的  ⟺  \\iff⟺G的可达性矩阵P除对角元外均为1\n有向图G是单向连通的  ⟺  P(+)PT\\iff P(+)P^T⟺P(+)PT (P的转置)除对角元外均为1\n有向图G是弱连通的  ⟺  A(+)AT\\iff A(+)A^T⟺A(+)AT图的可达性矩阵P除对角元外均为1 （A是G的邻接矩阵）\n\n 特殊图\n 欧拉图及其应用\n 欧拉回路\n\n通过图中每条边一次之回路\n欧拉回路是经过图中所有边的回路中长度最短的回路，即为通过图中所有边的简单回路\n\n 欧拉图\n\n有欧拉回路之图\n\n 欧拉通路\n\n通过图中每条边一次之通路(非回路)\n欧拉通路是经过图中所有边的通路中长度最短的通路，即为通过图中所有边的简单通路\n\n 定理\n\n无向连通图G是欧拉图  ⟺  \\iff⟺G的所有结点的次数都是偶数\n无向连通图中结点u、v之间有欧拉通路  ⟺  \\iff⟺图中u、v的次数是奇数，其余结点的次数均为偶数\n无向连通图G是欧拉图的充分必要条件是G的每个结点均具有偶次数\n\n 应用\n\n一笔画问题\n蚂蚁比赛问题\n邮递员问题\n洒水车\n\n 哈密顿图及其应用\n 哈密顿回路\n\n通过图中每个结点一次之回路\n是经过图中所有结点的回路中长度最短的回路，即为通过图中所有结点的基本回路\n\n 哈密顿图\n\n有哈密顿回路之图\n\n 哈密顿通路\n\n通过图中每个结点一次之通路(非回路)\n是经过图中所有结点的通路中长度最短的通路，即为通过图中所有结点的基本通路\n\n 定理\n\n设无向图G=(V,E)G=(V,E)G=(V,E)是哈密顿图，∅⊆V1⊆V\\varnothing \\subseteq V_1 \\subseteq V∅⊆V1​⊆V ，则ω(G−V1)≤∣V1∣\\omega(G-V_1)\\leq|V_1|ω(G−V1​)≤∣V1​∣ （必要）\n设无向图G=(V,E)G = (V, E)G=(V,E)中存在哈密顿通路，则对VVV的任意非空子集V1V_1V1​，都有ω(G−V1)≤∣V1∣+1ω(G-V_1)  ≤  |V_1| + 1ω(G−V1​)≤∣V1​∣+1\n设G=(V,E)G = (V, E)G=(V,E)是具有n个结点的简单无向图。如果对任意两个不相邻的结点u,v∈Vu, v∈Vu,v∈V，均有d(u)+d(v)≥n−1d(u)+d(v)≥n-1d(u)+d(v)≥n−1则G中存在哈密顿通路\n设G=(V,E)G = (V, E)G=(V,E)是具有n个结点的简单无向图：\n\n如果对任意两个不相邻的结点u,v∈Vu, v∈Vu,v∈V，均有d(u)+d(v)≥nd(u)+d(v)≥nd(u)+d(v)≥n则G中存在哈密顿回路\nn≥3n≥3n≥3，如果对任意v∈Vv∈Vv∈V，均有d(v)≥n/2d(v)≥ n/2d(v)≥n/2，则G是哈密顿图\n\n\n设G=(V,E)G=(V, E)G=(V,E)是有n(n≥2)n(n≥2)n(n≥2)个结点的一些简单有向图。如果忽略G中边的方向所得的无向图中含生成子图KnK_nKn​，则有向图G中存在哈密顿通路\n设G=(V,E)G=(V,E)G=(V,E)是有向图，∣V∣≥2|V|\\geq 2∣V∣≥2，如果任意两个不同结点次数之和≥∣V∣−1\\geq |V|-1≥∣V∣−1，则G存在哈密顿通路(判断有向图是否是哈密顿图不要求)\n\n 哈密顿图的应用\n\n考试安排问题\n推销员问题\n\n 树\n 树\n\n不含回路的简单连通无向图\n\n 叶\n\n树中次数为1的结点\n\n 森林\n\n每个连通分支是树的无向图\n\n 树枝\n\n无向树（林）中的边\n\n 树的性质\n\n设无向图G=(V,E)，∣V∣=n，∣E∣=mG = (V,E)，|V| = n，|E| = mG=(V,E)，∣V∣=n，∣E∣=m，下列各命题是等价的\n\nG连通而不含回路(即G是树)\nG中无回路，且m=n−1m = n-1m=n−1\nG是连通的，且m=n−1m = n-1m=n−1\nG中无回路，但在G中任二结点之间增加一条新边，就得到惟一的一条基本回路\nG是连通的，但删除G中任一条边后，便不连通(n≥2n≥2n≥2)\nG中每一对结点之间有惟一一条基本通路(n≥2n≥2n≥2)\n\n\n\n 定理\n\n任意非平凡树T=(n,m)T = (n, m)T=(n,m) 都至少有两片叶\n\n 生成树\n 定义\n\n给定图G=(V,E)G = (V, E)G=(V,E)，若G的某个生成子图是树，则称之为G的生成树(Spanning Tree)，记为TG。生成树TG中的边称为树枝(Branch)\n\n 定理\n\n一个图G=(V,E)G = (V, E)G=(V,E)存在生成树TG=(V,ET)T _G = (V, E_T)TG​=(V,ET​)的充分必要条件是G是连通的\n\n 破圈法与避圈法\n\n破圈法算法  求连通图G=(V,E)G = (V, E)G=(V,E)的生成树的破圈法：每次删除回路中的一条边，其删除的边的总数为m−n+1m-n+1m−n+1\n避圈法算法  求连通图G=(V,E)G = (V, E)G=(V,E)的生成树的避圈法：每次选取G中一条与已选取的边不构成回路的边，选取的边的总数为n−1n-1n−1\n\n 最小生成树\n\n设G=(V,E)G = (V, E)G=(V,E)是连通的赋权图，T是G的一棵生成树，T的每个树枝所赋权值之和称为T的权(Weight)，记为W(T)W(T)W(T)。G中具有最小权的生成树称为G的最小生成树(Minimal Spanning Tree)\n\n Kruskal算法\n\n(1)在G中选取最小权边e1e_1e1​，置i=1i = 1i=1\n(2)当i=n−1i = n-1i=n−1时，结束，否则转(3)\n(3)设已选取的边为e1,e2,…,eie_1, e_2, …, e_ie1​,e2​,…,ei​，在G中选取不同于e1,e2,…,eie_1, e_2, …, e_ie1​,e2​,…,ei​的边ei+1e_{i+1}ei+1​，使{e1,e2,…,ei,ei+1}\\{e_1, e_2, …, e_i, e_{i+1}\\}{e1​,e2​,…,ei​,ei+1​}中无回路且ei+1e_{i+1}ei+1​是满足此条件的最小权边\n(4)置i=i+1i = i+1i=i+1，转(2)\n\n Prim算法\n\n(1)在G中任选取一个结点v1v_1v1​，置VT=v1,ET=∅，k=1V_T = {v_1}, E_T = \\varnothing，k = 1VT​=v1​,ET​=∅，k=1\n(2)在V−VTV-V_TV−VT​中选取与某个vi∈VTv_i∈V_Tvi​∈VT​邻接的结点vjv_jvj​，使得边(vi,vj)(v_i, v_j)(vi​,vj​)的权最小，置VT=VT∪vj,ET=ET∪(vi,vj)，k=k+1V_T = V_T∪{v_j}, E_T = E_T∪{(v_i, v_j)}，k = k+1VT​=VT​∪vj​,ET​=ET​∪(vi​,vj​)，k=k+1\n(3)重复(2)，直到k=∣V∣k = |V|k=∣V∣\n\n 有向树\n 定义\n\n一个有向图，若略去所有有向边的方向所得到的无向图是一棵树，则这个有向图称为有向树(Directed Tree)\n\n 外向树\n\nT仅有一个结点的引入次数为0，该结点为T的根\nT的其他结点的入度均为1\nT有一些结点的出度为0，该结点为T的叶\n由外向树的根到结点viv_ivi​的通路长度称为结点viv_ivi​的级\n若从结点viv_ivi​到vjv_jvj​可达，则称viv_ivi​是vjv_jvj​的祖先(Ancestor)，vjv_jvj​是viv_ivi​的后代(Descendant)\n若&lt;vi,vj&gt;&lt;v_i, v_j&gt;&lt;vi​,vj​&gt;是根树中的有向边，则称viv_ivi​是vjv_jvj​的父亲(Father)，vjv_jvj​是viv_ivi​的儿子(Son)\n如果两个结点是同一个结点的儿子，则称这两个结点是兄弟(Brother)\n若每个分支点至多有k个儿子，则称T为k元树(k-ary Tree)\n若每个分支点都恰有k个儿子，则称T为k元完全树(k-ary Complete Tree)\n若k元树T是有序的，则称T为k元有序树(k-ary Ordered Tree)\n若k元完全树T是有序的，则称T为k元有序完全树(k-ary Ordered Complete Tree)\n\n 内向树\n\nT仅有一个结点的引出次数为0，该结点为T的根\nT的其他结点的引出次数均为1\nT有一些结点的引入次数为0，该结点为T的叶\n\n 有序树\n\n如果在外向树中规定了每一层上结点的次序，这样的根树称为有序树\n一般地，在有序树中同一层中结点的次序为从左至右。有时也可以用边的次序来代替结点的次序\n\n 二元树的遍历\n\n二元树的先根次序遍历算法：\n\n访问根\n按先根次序遍历根的左子树\n按先根次序遍历根的右子树\n\n\n二元树的中根次序遍历算法:\n\n按中根次序遍历根的左子树\n访问根\n按中根次序遍历根的右子树\n\n\n二元树的后根次序遍历算法：\n\n按后根次序遍历根的左子树\n按后根次序遍历根的右子树\n访问根\n\n\n\n 根树转化为二元树算法\n\n从根开始，保留每个父亲同其最左边儿子的连线，撤销与别的儿子的连线\n兄弟间用从左向右的有向边连接\n按如下方法确定二元树中结点的左儿子和右儿子：直接位于给定结点下面的结点，作为左儿子，对于同一水平线上与给定结点右邻的结点，作为右儿子，依此类推\n转化的要点：弟弟结点变右儿子结点\n\n 二分图\n 定义\n\n若无向图G=(V,E)G = (V, E)G=(V,E)的结点集V能够划分为两个子集V1,V2V_1, V_2V1​,V2​，满足V1∩V2=∅V_1∩V_2 = \\varnothingV1​∩V2​=∅，且V1∪V2=VV_1∪V_2 = VV1​∪V2​=V，使得G中任意一条边的两个结点，一个属于V1V_1V1​，另一个属于V2V_2V2​，则称G为二分图(Bigraph)。V1V_1V1​和V2V_2V2​称为互补结点子集，二分图可记为G=(V1,V2)G = (V_1, V_2)G=(V1​,V2​)\n二分图没有自回路\n平凡图和零图可看成特殊的二分图\n\n 完全二分图\n\n在二分图G=(V1,V2)G = (V_1, V_2)G=(V1​,V2​)中，若V1V_1V1​中的每个结点与V2V_2V2​中的每个结点都有且仅有一条边相关联，则称二分图G为完全二分图(Complete Bigraph)，记为Km,nK_{m,n}Km,n​，其中，m=∣V1∣，n=∣V2∣m = |V_1|，n = |V_2|m=∣V1​∣，n=∣V2​∣\n\n 二分图的判定\n\n无向图G=(V,E)G = (V, E)G=(V,E)为二分图的充分必要条件是G的所有回路的长度均为偶数\n无向图G 不是二分图的充分必要条件是G中存在长度为奇数的回路\n\n 匹配\n\n在二分图G=(V1,V2)G = (V_1, V_2)G=(V1​,V2​)中，V1={v1,v2,…,vq}V_1 = \\{v_1, v_2, …, v_q\\}V1​={v1​,v2​,…,vq​}，若存在E的子集E’={(v1,v1’)，(v2,v2’)，…，(vq,vq’)，其中v1’,v2’,…,vq’是V2中的q个不同的结点}E’= \\{(v_1, v_1’)，(v_2, v_2’)，…，(v_q, v_q’)，其中v_1’, v_2’, …, v_q’ 是V_2中的q个不同的结点\\}E’={(v1​,v1​’)，(v2​,v2​’)，…，(vq​,vq​’)，其中v1​’,v2​’,…,vq​’是V2​中的q个不同的结点}，则称G的子图G’=(V1,E’,V2)G’ = (V_1, E’, V_2)G’=(V1​,E’,V2​)为从V1V_1V1​到V2V_2V2​的一个完全匹配(Complete Matching)，简称匹配\n\n 平面图\n 定义\n\n如果能把一个无向图G的所有结点和边画在平面上，使得任何两边除公共结点外没有其他交叉点，则称G为平面图(Plane Graph)，否则称G为非平面图(Nonplanar Graph)。当且仅当一个图的每个连通分支都是平面图时，这个图是平面图\n\n 判断图是否是可平面图的方法\n 观察法\n 欧拉公式\n\n\n在平面图G的一个平面表示中，\n\n由边所包围的其内部不包含图的结点和边的区域，称为G的一个面(Surface)\n包围该面的诸边所构成的回路称为这个面的边界(Bound)\n面r的边界的长度称为该面的次数(Degree)，记为D(r)D(r)D(r)\n区域面积有限的面称为有限面(Finite Surface)，区域面积无限的面称为无限面(Infinite Surface)\n平面图有且仅有一个无限面\n\n\n\n平面图中所有面的次数之和等于边数的二倍\n\n\n设G=(V,E)G = (V, E)G=(V,E)是连通平面图，若它有nnn个结点、mmm条边和rrr个面，则有n−m+r=2n-m+r = 2n−m+r=2\n\n\n设设G是一个(n,m)(n,m)(n,m)简单连通平面图，若m＞1m＞1m＞1，则有m≤3n−6m≤3n-6m≤3n−6\n\n\n一个简单连通图，若不满足m≤3n−6m≤3n-6m≤3n−6，则一定是非平面图\n\n\n 库拉托夫斯基定理\n\n一个图是平面图的充分必要条件是它的任何子图都不可能收缩为K5K_5K5​或K3,3K_{3,3}K3,3​\n一个图是非平面图的充分必要条件是它存在一个能收缩为K5K_5K5​或K3,3K_{3,3}K3,3​的子图\n我们将K5K_5K5​和K3,3K_{3,3}K3,3​称为库拉托夫斯基图(Kuratowski Graph)\n\n 平面图的应用\n\n公共事业问题\n\n","slug":"离散数学","date":"2023-04-24T12:11:05.000Z","categories_index":"Math","tags_index":"learning,Math,Discrete Mathematics","author_index":"Ivan Snow"},{"id":"4b4f7cdf0dd2548c372a61ce48da36cd","title":"Redis的数据类型","content":"Redis 支持五种数据类型：\n\nstring\nhash\nlist\nset\nzset\n\n String\nstring 是最基本的类型。string 二进制安全，即可以包含任何数据。\nstring 一个键最大能存储512MB。\nstring 类型的数据结构存储方式有三种int、raw、embstr：\n int\nRedis 中规定假如存储的是整数型值，比如set num 123这样的类型，就会使用int的存储方式进行存储，在redisObject的ptr属性中就会保存该值。\n\n SDS\n假如存储的字符串是一个字符串值并且长度大于32个字节就会使用 SDS（simple dynamic string）方式进行存储，并且encoding设置为raw；若是字符串长度小于等于32个字节就会将encoding改为embstr来保存字符串。\nSDS称为简单动态字符串，对于SDS中的定义在Redis的源码中有的三个属性int len、int free、char buf[]。\nlen保存了字符串的长度，free表示buf数组中未使用的字节数量，buf数组则是保存字符串的每一个字符元素。\n因此当你在Redis中存储一个字符串&quot;Hello_World&quot;时，SDS 的形式的redisObject结构图如下图所示：\n\n Hash\nRedis hash 是一个键值(key=&gt;value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n每个 hash 可以存储 232−12^{32} -1232−1 键值对。\nHash对象的实现方式有两种分别是ziplist、hashtable，其中hashtable的存储方式key是 String 类型的，value也是以key value的形式进行存储。\n ziplist\n压缩列表（ziplist）是一组连续内存块组成的顺序的数据结构，压缩列表能够节省空间，压缩列表中使用多个节点来存储数据。\n压缩列表是列表键和哈希键底层实现的原理之一，压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间，压缩列表的内存结构图如下：\n\n其中：\n\nzlbytes：4个字节的大小，记录压缩列表占用内存的字节数。\nzltail：4个字节大小，记录表尾节点距离起始地址的偏移量，用于快速定位到尾节点的地址。\nzllen：2个字节的大小，记录压缩列表中的节点数。\nentry：表示列表中的每一个节点。\nzlend：表示压缩列表的特殊结束符号'0xFF'\n\n每一个entry节点又有三部分组成，分别是previous_entry_length、encoding、content。\n\nprevious_entry_length表示前一个节点entry的长度，可用于计算前一个节点的其实地址，因为他们的地址是连续的。\nencoding：这里保存的是content的内容类型和长度。\ncontent：content保存的是每一个节点的内容。\n\n\n hashtable\nhashtable 是一种字典类型的数据结构，用于存储键值对，其中键是字符串类型，值可以是字符串、列表、集合或有序集合。hashtable 的底层实现是一个数组，每个数组元素是一个链表，用于解决哈希冲突。当 hashtable 中的键值对数量变化时，会进行扩展或收缩操作，重新分配数组的大小和哈希值。hashtable 是哈希键和集合键的底层实现之一，当这些键的元素数量和长度较大时，Redis 会使用 hashtable 作为其存储方式。\n List\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部或者尾部。\n列表最多可存储 232−12^{32} - 1232−1 元素。\nRedis中的列表在3.2之前的版本是使用ziplist和linkedlist进行实现的。在3.2之后的版本就是引入了quicklist。\n linkedlist\nlinkedlist 是一个双向链表，他和普通的链表一样都是由指向前后节点的指针。插入、修改、更新的时间复杂度是 O(1)，查询的时间复杂度是 O(n)。其特性为\n\n每一个节点都有指向前一个节点和后一个节点的指针。\n头节点和尾节点的prev和next指针指向为null，所以链表是无环的。\n链表有自己长度的信息，获取长度的时间复杂度为 O(1)。\n\n\n quicklist\nquicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。\n\nprev、next指向该节点的前后节点。\nzl指向该节点对应的 ziplist 结构。\nsz代表整个 ziplist 结构的大小。\nencoding代表采用的编码方式：1代表是原生的，2代表使用LZF进行压缩。\ncontainer为 quickListNode 节点zl指向的容器类型：1代表none，2代表使用ziplist存储数据。\nrecompress代表这个节点之前是否是压缩节点，若是，则在使用压缩节点前先进行解压缩，使用后需要重新压缩，此外为1，代表是压缩节点。\nattempted_compress测试时使用。\nextra为预留。\n\n\n Set\nRedis 的 Set 是 string 类型的无序集合。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n集合中最大的成员数为 232−12^{32} - 1232−1。\nRedis 中列表和集合都可以用来存储字符串，但是 Set 是不可重复的集合，而 List 列表可以存储相同的字符串。\nSet 的底层实现是hashtable和intset。\n intset\ninset 也叫做整数集合，用于保存整数值的数据结构类型，它可以保存int16_t、int32_t 或者int64_t 的整数值。\n在整数集合中，有三个属性值encoding、length、contents[]，分别表示编码方式、整数集合的长度、以及元素内容，length就是记录contents里面的大小。\n在整数集合新增元素的时候，若是超出了原集合的长度大小，就会对集合进行升级，具体的升级过程如下：\n\n首先扩展底层数组的大小，并且数组的类型为新元素的类型。\n然后将原来的数组中的元素转为新元素的类型，并放到扩展后数组对应的位置。\n整数集合升级后就不会再降级，编码会一直保持升级后的状态。\n\n\n Zset\nRedis zset 和 set 一样也是 string 类型元素的集合,且不允许重复的成员。\n不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。\nzset 的成员是唯一的,但分数（score）却可以重复。\nzset 的底层实现是ziplist和skiplist。\n skipset\nskiplist 也叫做跳跃表，跳跃表是一种有序的数据结构，它通过每一个节点维持多个指向其它节点的指针，从而达到快速访问的目的。\nskiplist 由如下几个特点：\n\n有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大。\n每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点。\n每一层的每一个每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针。\n如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点。\n\n\n","slug":"Redis-Learning-01-数据类型","date":"2023-04-24T02:31:49.000Z","categories_index":"Redis","tags_index":"coding,Redis","author_index":"Ivan Snow"},{"id":"3b7fce38e480c65a2ce7cfa0852550a0","title":"VIM的学习","content":"\n Vim的哲学\n在编程时，您大部分时间都花在阅读/编辑上，而不是写作上。因此，Vim 是一个模态编辑器：它有不同的插入文本和操作文本的模式。Vim 是可编程的（使用 Vimscript 以及 Python 等其他语言），并且 Vim 的界面本身就是一种编程语言：击键（具有助记名称）是命令，并且这些命令是可组合的。Vim 避免使用鼠标，因为它太慢了；Vim 甚至避免使用箭头键，因为它需要太多的移动。\n最终结果是一个可以匹配您思考速度的编辑器。\n 模态编辑\nVim有多种运行模式\n\n\nNormal 用于在文件中移动并进行编辑\nInsert 用于插入文本，按 i 键\nReplace 用于替换文本，按 R 键\nVisual 用于选择文本块，可视模式为 v 键，可视行模式为V 键，可视块模式为&lt;C-v&gt; 键\nCommand-line 用于运行命令，按 : 键\n\n击键在不同的操作模式下具有不同的含义。例如，字母 x 在插入模式下只会插入一个文字字符 ‘x’ ，但在普通模式下，它会删除光标下的字符，而在可视模式下，它会删除选择的字符。\n 缓冲区，选项卡和窗口\nVim 维护一组打开的文件，称为&quot;缓冲区&quot;。一个 Vim 会话有许多选项卡，每个选项卡都有许多窗口( 拆分窗格) 。每个窗口显示一个缓冲区。与您熟悉的其他程序( 如网络浏览器) 不同，缓冲区和窗口之间不存在一对一的对应关系，窗户只是视图。一个给定的缓冲区可以在多个窗口中打开，甚至在同一个选项卡中。这非常方便，例如，同时查看文件的两个不同部分。\n默认情况下，Vim 打开一个选项卡，其中包含一个窗口。\n 底线命令模式\n命令模式可以通过在普通模式下输入:来进入。按下:后，光标会跳到屏幕底部的命令行，你可以在那里输入不同的命令。这种模式有很多功能，包括：\n\n:q 退出（关闭窗口）\n:w 保存（“写入”）\n:wq 保存并退出\n:e {文件名} 打开文件进行编辑\n:ls 显示打开的缓冲区\n:help {主题} 打开帮助\n:help :w 打开:w命令的帮助\n:help w 打开w移动的帮助\n\n例如，如果你想打开一个名为test.txt的文件，你可以在命令模式下输入:e test.txt，然后按回车键。如果你想保存当前文件，你可以输入:w，然后按回车键。如果你想查看Vim的基本用法，你可以输入:help，然后按回车键。\n 移动\n\nh 或 向左箭头键 ← 光标向左移动一个字符\nj 或 向下箭头键 ↓ 光标向下移动一个字符\nk 或 向上箭头键 ↑ 光标向上移动一个字符\nl 或 向右箭头键 → 光标向右移动一个字符\nCtrl + f 屏幕向下移动一页，相当于 Page Down 按键 (常用)\nCtrl + b 屏幕向上移动一页，相当于 Page Up 按键 (常用)\nCtrl + d 屏幕向下移动半页\nCtrl + u 屏幕向上移动半页\n+ 光标移动到非空格符的下一行\n- 光标移动到非空格符的上一行\nn&lt;space&gt; 那个 n 表示数字，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20&lt;space&gt; 则光标会向后面移动 20 个字符距离。\n0 或功能键Home 移动到这一行的最前面字符处 (常用)\n$ 或功能键End 移动到这一行的最后面字符处(常用)\nH 光标移动到这个屏幕的最上方那一行的第一个字符\nM 光标移动到这个屏幕的中央那一行的第一个字符\nL 光标移动到这个屏幕的最下方那一行的第一个字符\nG 移动到这个档案的最后一行(常用)\nnG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\ngg 移动到这个档案的第一行，相当于 1G  (常用)\nn&lt;Enter&gt; n 为数字。光标向下移动 n 行(常用)\n\n 搜索替换\n\n/word  向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)\n?word 向光标之上寻找一个字符串名称为 word 的字符串。\nn 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\nN 这个 N 是英文按键。与 n 刚好相反，为反向进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示向上搜寻 vbird 。\n\n 删除、复制与粘贴\n\nx, X 在一行字当中，x 为向后删除一个字符 (相当于 del 按键)， X 为向前删除一个字符(相当于 backspace 亦即是退格键) (常用)\nnx n 为数字，连续向后删除 n 个字符。\ndd 剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。\nndd n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。\nd1G 删除光标所在到第一行的所有数据\ndG 删除光标所在到最后一行的所有数据\nd$ 删除游标所在处，到该行的最后一个字符\nd0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\nyy 复制游标所在的那一行(常用)\nnyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\ny1G 复制游标所在行到第一行的所有数据\nyG 复制游标所在行到最后一行的所有数据\ny0 复制光标所在的那个字符到该行行首的所有数据\ny$ 复制光标所在的那个字符到该行行尾的所有数据\np, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！  (常用)\nJ 将光标所在行与下一行的数据结合成同一行\nc 重复删除多个数据，例如 10cj 表示向下删除 10 行\nu 复原前一个动作。(常用)\nCtrl + r 重做上一个动作。(常用)\n\n 补充\n\n\n\n进入输入或取代的编辑模式\n\n\n\n\n\ni, I\n进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)\n\n\na, A\n进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)\n\n\no, O\n进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)\n\n\nr, R\n进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n\n上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！\n\n\n\n[Esc]\n退出编辑模式，回到一般模式中(常用)\n\n\n\n\n\n\n指令行的储存、离开等指令\n\n\n\n\n\n:w\n将编辑的数据写入硬盘档案中(常用)\n\n\n:w!\n若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n\n\n:q\n离开 vi (常用)\n\n\n:q!\n若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n\n\n注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\nZZ\n这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)\n\n\nZQ\n不保存，强制退出。效果等同于 :q!。\n\n\n:w [filename]\n将编辑的数据储存成另一个档案（类似另存新档）\n\n\n:r [filename]\n在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n\n:n1,n2 w [filename]\n将 n1 到 n2 的内容储存成 filename 这个档案。\n\n\n:! command\n暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！\n\n\n\n\n\n\nvim 环境的变更\n\n\n\n\n\n:set nu\n显示行号，设定之后，会在每一行的前缀显示该行的行号\n\n\n:set nonu\n与 set nu 相反，为取消行号！\n\n\n\n 参考资料\nEditors (Vim) · Missing Semester (mit.edu)\nLinux vi/vim | 菜鸟教程 (runoob.com)\n","slug":"VIM的学习","date":"2023-04-17T13:44:17.000Z","categories_index":"coding","tags_index":"coding,vim","author_index":"Ivan Snow"},{"id":"ad07a23e70b0e9f11bd9b11c976479b5","title":"TEST","content":"这是一篇测试文章\n\n\n","slug":"TEST","date":"2023-04-16T12:30:05.000Z","categories_index":"test","tags_index":"test","author_index":"Ivan Snow"}]