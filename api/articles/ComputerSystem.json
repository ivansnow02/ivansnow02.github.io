{"title":"操作系统复习","uid":"2ed5c397762475d4e4b4f7ab2d780b9f","slug":"ComputerSystem","date":"2024-03-07T04:51:59.000Z","updated":"2024-03-26T13:09:14.961Z","comments":true,"path":"api/articles/ComputerSystem.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/computer_system.jpg","content":"<h2 id=\"概论\"><a class=\"markdownIt-Anchor\" href=\"#概论\"></a> 概论</h2>\n<h3 id=\"操作系统的定义和功能\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的定义和功能\"></a> 操作系统的定义和功能</h3>\n<h4 id=\"操作系统的定义\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的定义\"></a> 操作系统的定义</h4>\n<ul>\n<li>一组计算机程序的集合，主要用以控制和管理 计算机的硬件和软件资源，合理地组织计算机的工作流程，向应用程序和用户提供方便、快捷、友好的使用接口</li>\n</ul>\n<h4 id=\"操作系统的功能\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的功能\"></a> 操作系统的功能</h4>\n<ul>\n<li>进程管理</li>\n<li>存储管理</li>\n<li>文件管理</li>\n<li>设备管理</li>\n</ul>\n<h4 id=\"操作系统的特征\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的特征\"></a> 操作系统的特征</h4>\n<ul>\n<li>并发</li>\n<li>共享</li>\n<li>虚拟</li>\n<li>异步</li>\n</ul>\n<h3 id=\"操作系统的发展\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的发展\"></a> 操作系统的发展</h3>\n<ol>\n<li>手工操作时代</li>\n<li>早期单道批处理系统时代</li>\n<li>多道批处理系统时代</li>\n</ol>\n<h3 id=\"操作系统的分类\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的分类\"></a> 操作系统的分类</h3>\n<h4 id=\"批处理操作系统\"><a class=\"markdownIt-Anchor\" href=\"#批处理操作系统\"></a> 批处理操作系统</h4>\n<ul>\n<li>主要特征\n<ul>\n<li>用户脱机工作</li>\n<li>成批处理作业</li>\n<li>单/多道程序运行</li>\n<li>作业周转时间长</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分时操作系统\"><a class=\"markdownIt-Anchor\" href=\"#分时操作系统\"></a> 分时操作系统</h4>\n<ul>\n<li>主要特征：\n<ul>\n<li><strong>同时性</strong>。允许各终端用户同时工作，系统分时响应用户请求（使用CPU并不同时）</li>\n<li><strong>交互性</strong>。支持联机的操作方式，用户可以在终端上通过操作系统进行人-机对话，随时控制和调试程序，以交互的方式工作</li>\n<li><strong>独立性</strong>。用户之间彼此独立的工作，好象独占一台计算机系统一样，互不干扰</li>\n<li><strong>及时性</strong>。用户请求能在较短的时间内得到响应</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"实时操作系统\"><a class=\"markdownIt-Anchor\" href=\"#实时操作系统\"></a> 实时操作系统</h4>\n<ul>\n<li>系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行</li>\n</ul>\n<h4 id=\"个人计算机操作系统\"><a class=\"markdownIt-Anchor\" href=\"#个人计算机操作系统\"></a> 个人计算机操作系统</h4>\n<ul>\n<li>主要特点：\n<ul>\n<li>图形用户接口</li>\n<li>开放性</li>\n<li>多媒体支持</li>\n<li>应用软件丰富</li>\n<li>操作系统管理性能高</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"网络操作系统\"><a class=\"markdownIt-Anchor\" href=\"#网络操作系统\"></a> 网络操作系统</h4>\n<ul>\n<li>除具备通常操作系统功能外，还具备联网功能，支持网络体系结构和各种网络通信协议，提供网络互连能力，支持可靠、有效、安全的数据传输</li>\n<li>主要采用客户机/服务器(C/S)工作方式\n<ul>\n<li>客户机一般由微型计算机承担，主动从本地向服务器提出服务请求</li>\n<li>服务器接收客户机请求、处理请求的服务、返回服务结果。一般由高档微机、小、中、大型机承担</li>\n</ul>\n</li>\n<li>对等模式：网络中的每台计算机同时具有客户端和服务器两种功能</li>\n</ul>\n<h4 id=\"分布式操作系统\"><a class=\"markdownIt-Anchor\" href=\"#分布式操作系统\"></a> 分布式操作系统</h4>\n<ul>\n<li>特点：\n<ul>\n<li>计算机网络系统的高级形式，由多台计算机组成，计算机之间没有主次之分</li>\n<li>数据和控制及任务的分布性、整体性、资源共享的透明性、各节点的自制性和协同性</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"嵌入式操作系统\"><a class=\"markdownIt-Anchor\" href=\"#嵌入式操作系统\"></a> 嵌入式操作系统</h4>\n<ul>\n<li>\n<p>指运行在嵌入式(计算机)环境中，对整个系统各种部件和资源进行统一协调、处理、指挥和控制的系统软件。它具有通常操作系统的基本功能</p>\n</li>\n<li>\n<p>与一般操作系统有很大不同，主要体现在微型化、可定制、实时性、可靠性、易移植、开发工具与使用环境密切相关等特点</p>\n</li>\n</ul>\n<h3 id=\"操作系统的接口\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的接口\"></a> 操作系统的接口</h3>\n<h4 id=\"程序接口\"><a class=\"markdownIt-Anchor\" href=\"#程序接口\"></a> 程序接口</h4>\n<ul>\n<li>系统调用：“系统调用”可以获得操作系统的底层服务，从而进一步使用或访问系统管理的各种软硬件资源。不同的操作系统提供的系统调用的种类、数量和名字不尽相同</li>\n<li>API（application programming interface）\n<ul>\n<li>常用的Windows系统，微软公司只公布了相关的API，它是一种应用程序编程接口，是在操作系统系统调用的基础经过规范整理出来，面向社会公布的唯一的接口方式</li>\n<li>由于不是直接的系统调用，其效率有所损失。微软公司没有发布全部的API，也为开发程序带来了一定的难度</li>\n</ul>\n</li>\n<li>系统调用 &amp; POSIX标准\n<ul>\n<li>系统调用内部的具体实现与硬件相关，直接使用会产生问题：\n<ul>\n<li>接口复杂，使用困难</li>\n<li>应用程序的跨平台可移植性受到很大限制</li>\n</ul>\n</li>\n<li>POSIX标准：专门规定内核的系统调用接口标准，操作系统若遵循此标准，则应用程序在不同操作系统之间就具有可移植性\n<ul>\n<li>Unix/Linux遵循此标准</li>\n<li>Windows NT-based 系统不能直接支持新版POSIX接口</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>系统调用的处理过程\n<ol>\n<li>应用程序使用系统调用时会产生一条指令（陷入指令或访管指令），该指令中存放了对应系统调用的功能号，有时还附带传递给内核的参数：<code>系统调用—功能号—入口地址表—入口地址</code></li>\n<li>处理机在执行到该访管指令时发出相应的中断信号给“陷阱处理机制”</li>\n<li>陷阱处理机制启动相关的内核函数完成该系统调用所要求的功能：保护CPU现场、获取功能号、根据功能号查找对应内核函数入口地址表、转到入口地址执行内核函数、内核函数执行完，中断处理结束</li>\n<li>恢复CPU现场，继续执行中断点的下一条指令</li>\n</ol>\n</li>\n<li>注意：执行系统调用时，应用程序从用户态（目态）转到了核心态（管态），即执行内核函数时必须在核心态下运行，但访管指令本身是在用户态下执行的</li>\n</ul>\n<h4 id=\"操作接口\"><a class=\"markdownIt-Anchor\" href=\"#操作接口\"></a> 操作接口</h4>\n<ul>\n<li>命令界面（CLI，Command Line Interface ）\n<ul>\n<li>简单命令的一般形式：命令 参数1 参数2 … 参数n</li>\n<li>Windows操作系统的基本命令：type、erase、attrib、copy、xcopy、dir、cd、md、rd、tree、ver等</li>\n</ul>\n</li>\n<li>图形界面（ GUI，Graphics User Interface ）</li>\n<li>作业控制命令\n<ul>\n<li>专为批处理作业的用户提供的，所以也称批处理用户接口。操作系统提供一个作业控制语言JCL（Job Control Language），它由一组作业控制语句、作业控制操作命令及相应语法规范组成</li>\n<li>用户利用作业控制语言书写批处理作业控制说明书，操作系统解释作业控制说明书，按其要求一步步地运行用户作业。\n<ul>\n<li>DOS下的批处理命令是一种简单的作业控制语言（.bat）</li>\n<li>UNIX的Shell语言是现代计算机一种功能强大的作业控制语言</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"操作系统的设计实现方法\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的设计实现方法\"></a> 操作系统的设计实现方法</h3>\n<h4 id=\"操作系统设计与开发\"><a class=\"markdownIt-Anchor\" href=\"#操作系统设计与开发\"></a> 操作系统设计与开发</h4>\n<ul>\n<li>操作系统设计与开发特点\n<ul>\n<li>与硬件关联</li>\n<li>复杂程度高</li>\n<li>生产周期长</li>\n</ul>\n</li>\n<li>操作系统的设计原则\n<ul>\n<li>可靠性</li>\n<li>方便性</li>\n<li>高效率</li>\n<li>易维护性</li>\n<li>可扩充性</li>\n<li>开放性</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"操作系统的体系结构\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的体系结构\"></a> 操作系统的体系结构</h4>\n<ul>\n<li>无结构操作系统</li>\n<li>模块化结构</li>\n<li>分层结构</li>\n<li>客户/服务器结构（微内核）</li>\n<li>虚拟机结构</li>\n<li>面向对象结构</li>\n</ul>\n<h2 id=\"进程管理\"><a class=\"markdownIt-Anchor\" href=\"#进程管理\"></a> 进程管理</h2>\n<h3 id=\"程序的执行方式\"><a class=\"markdownIt-Anchor\" href=\"#程序的执行方式\"></a> 程序的执行方式</h3>\n<h4 id=\"程序的顺序执行\"><a class=\"markdownIt-Anchor\" href=\"#程序的顺序执行\"></a> 程序的顺序执行</h4>\n<ul>\n<li>一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行\n<ul>\n<li>程序设计中的顺序控制结构仅能控制程序内部指令的执行序列</li>\n<li>程序的顺序执行意味着运行时程序间的执行序列也是顺序的——一个程序执行完了，才能执行另一个程序</li>\n</ul>\n</li>\n<li>顺序执行的特性：\n<ul>\n<li>顺序性</li>\n<li>封闭性</li>\n<li>可再现性</li>\n<li>程序的顺序执行方式便于程序的编制与调试，但不利于充分利用计算机系统资源，运行效率低下</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"程序的并发执行与并行执行\"><a class=\"markdownIt-Anchor\" href=\"#程序的并发执行与并行执行\"></a> 程序的并发执行与并行执行</h4>\n<ul>\n<li>为了提高系统的运行效率，允许“同时”执行多个程序</li>\n<li>并行（parallel）：多个事件在同一时刻发生</li>\n<li>并发（concurrent）：多个事件在同一时期内发生</li>\n<li>显然，<strong>并行是并发的特例</strong>，程序并行执行的硬件前提是系统中有多个CPU</li>\n<li>并发的<strong>本质</strong>是一个CPU在多个程序运行过程中的<strong>时分复用</strong></li>\n<li>并发执行的特性：\n<ul>\n<li>间断性</li>\n<li>开放/交互性</li>\n<li>不可再现性</li>\n<li>进行并发程序设计时应当避免由于程序间开放交互引起的不可再现性而产生运行时错误</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程概念的引入\"><a class=\"markdownIt-Anchor\" href=\"#进程概念的引入\"></a> 进程概念的引入</h4>\n<ul>\n<li>程序（program）：静态的代码文件（*.exe）</li>\n<li>进程（process）：程序在某个数据集合上的一次执行，系统资源分配的基本单位</li>\n<li>作业（job）：批处理系统要装入系统运行处理的一系列程序步骤和数据</li>\n</ul>\n<h3 id=\"进程的特征与控制\"><a class=\"markdownIt-Anchor\" href=\"#进程的特征与控制\"></a> 进程的特征与控制</h3>\n<h4 id=\"进程的相关概念\"><a class=\"markdownIt-Anchor\" href=\"#进程的相关概念\"></a> 进程的相关概念</h4>\n<ul>\n<li>\n<p>进程有以下特征</p>\n<ul>\n<li>结构性</li>\n<li>动态性</li>\n<li>独立性</li>\n<li>并发性</li>\n</ul>\n</li>\n<li>\n<p>进程分类：系统进程、用户进程</p>\n</li>\n<li>\n<p>进程上下文（process context）</p>\n<ul>\n<li>用户级上下文（user-level context）：进程的代码区、数据区、用户栈区和共享存储区</li>\n<li>系统级上下文（system-level context）：PCB、内存管理信息、进程环境块、系统栈</li>\n<li>寄存器上下文（register context）</li>\n<li>一个进程被系统调度而占有CPU时，会发生CPU在新老进程之间切换，切换的内容是进程上下文，进程运行是在进程的上下文中执行的</li>\n<li>一个典型的上下文切换过程</li>\n</ul>\n<figure class=\"shiki c\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #61AFEF; font-weight: bold\">context_switch</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\"> </span><span style=\"color: #ABB2BF\">){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">   Push registers onto stack</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">   Save ptrs to code and data.</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">   Save stack pointer</span><span style=\"color: #7F848E\"> //以上语句保护当前进程上下文</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">   Pick next process to execute</span><span style=\"color: #7F848E\"> //选中/调度新进程</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #7F848E\">//以下语句恢复所选中/调度的进程的上下文</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">   Restore stack ptr of that process</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">   Restore ptrs to code and data.</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">   Pop registers</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">   Return</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div></div></figure>\n</li>\n</ul>\n<h4 id=\"进程状态及转换\"><a class=\"markdownIt-Anchor\" href=\"#进程状态及转换\"></a> 进程状态及转换</h4>\n<ul>\n<li>进程的状态\n<ul>\n<li>就绪状态（ready）：进程在内存中已经具备执行的条件，等待分配CPU</li>\n<li>运行状态（running）：进程占用CPU并正在执行</li>\n<li>阻塞状态（blocked）：也称为等待（waiting）状态——运行的进程由于发生某事件而放弃CPU</li>\n<li><img src=\"ComputerSystem/1.png\" alt=\"三状态模型\" /></li>\n<li><img src=\"ComputerSystem/2.png\" alt=\"五状态模型\" /></li>\n<li><img src=\"ComputerSystem/3.png\" alt=\"七状态模型\" /></li>\n</ul>\n</li>\n<li>有挂起功能的进程状态：\n<ul>\n<li>挂起就绪（ready suspended）</li>\n<li>挂起阻塞（blocked suspended）</li>\n<li>进程在运行态也可以被挂起，转换为挂起就绪状态</li>\n<li>阻塞状态的进程被挂起后，若阻塞事件或I/O请求完成，则进程状态转换为挂起就绪状态——仍然是挂起状态</li>\n<li>创建进程时若没有足够的内存空间，则转入挂起就绪状态</li>\n<li><strong>只有处于就绪态的进程</strong>才有可能被调度分配CPU运行</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程控制块pcb\"><a class=\"markdownIt-Anchor\" href=\"#进程控制块pcb\"></a> 进程控制块PCB</h4>\n<ul>\n<li>为了描述和控制进程运行的数据结构——进程控制块（Process Control Block），或称为进程描述符（Process Descriptor），进程存在的惟一标志\n<ol>\n<li>进程标识信息——内部标识符（PID）和外部标识符（进程名）</li>\n<li>现场信息——进程运行时CPU的即时状态——各寄存器的值</li>\n<li>控制信息——程序和数据地址、进程同步和通信机制信息、进程的资源清单和链接指针，进程状态、进程优先级……</li>\n</ol>\n</li>\n<li>操作系统根据PCB对进程进行控制和管理\n<ul>\n<li>查询进程现行状态及优先级</li>\n<li>恢复现场</li>\n<li>相关进程同步、通信</li>\n</ul>\n</li>\n<li>创建新进程时，建立/分配PCB，进程结束时回收PCB</li>\n<li>PCB由系统多个功能模块读写，须<strong>常驻内存</strong>，并进一步组织形成队列</li>\n</ul>\n<h4 id=\"进程控制\"><a class=\"markdownIt-Anchor\" href=\"#进程控制\"></a> 进程控制</h4>\n<ul>\n<li>\n<p>CPU的运行模式</p>\n<ul>\n<li>核心态（内核态），也称为管态（supervisor mode），Ring 0：内核代码、设备驱动、特权指令、直接访问物理内存空间、设备端口</li>\n<li>用户态，也称为目态，Ring 3：普通指令、保护模式安全限制、访问映射的虚拟地址空间、系统许可的映射端口</li>\n</ul>\n</li>\n<li>\n<p>不同于进程切换，也不一定引起进程切换或状态转换</p>\n</li>\n<li>\n<p>一般来说，当发生中断或系统调用时，用户进程暂停，CPU模式从用户态切换到核心态，执行系统服务例程，此时进程仍在原上下文中运行，仅模式变化</p>\n</li>\n<li>\n<p>进程控制——系统对进程生命周期的各个环节进行控制</p>\n<ul>\n<li>进程控制的职能是对系统中的所有进程实行有效的管理——对一个进程进行创建、撤销或终止，以及在某些进程状态间的转换控制</li>\n<li>允许一个进程创建和控制另一个进程，前者为父进程，后者为子进程</li>\n</ul>\n</li>\n<li>\n<p>进程控制通常由 <strong>原语（primitive）</strong> 完成 。</p>\n</li>\n<li>\n<p>原语的特性：</p>\n<ul>\n<li>由若干条指令组成，实现某个特定功能，在执行过程中不可被中断的程序段</li>\n<li><strong>不可分割</strong>的执行单位，<strong>不能并发执行</strong></li>\n<li>是操作系统核心（不是由进程而是由一组程序模块所组成）的一个组成部分，且<strong>常驻内存</strong></li>\n<li>通常在核心态/管态下执行</li>\n</ul>\n</li>\n<li>\n<p>进程控制原语</p>\n<ol>\n<li><strong>创建进程</strong>：建立PCB、填入信息、插入就绪队列，操作系统创建进程主要步骤<br />\n（1）命名进程：为新进程设置进程标志符；<br />\n（2）从PCB集合中为新进程申请一个空PCB；<br />\n（3）确定新进程的优先级；<br />\n（4）为新进程的程序段、数据段和用户栈分配内存空间；如果进程中需要共享某个已在内存的程序段，则必须建立共享程序段的链接指针；<br />\n（5）为新进程分配除内存外的其它各种资源；<br />\n（6）初始化PCB，将新进程的初始化信息写入进程控制块；<br />\n（7）如果就绪队列能够接纳新创建的进程，则将新进程插入到就绪队列；<br />\n（8）通知操作系统的记账、性能监控等管理模块<br />\n导致创建进程的事件：登录、作业调度、提供服务——系统内核直接调用创建原语创建新进程、应用请求——由用户调用操作系统提供的系统调用完成（Windows的API：CreateProcess）</li>\n<li><strong>撤消与终止进程</strong>：进程完成后，应退出系统而消亡，系统及时收回占有的全部资源以便其它进程使用，撤销原语撤销的是PCB，而非进程的程序段</li>\n<li><strong>阻塞与唤醒进程</strong>：进程阻塞是进程的自主行为，唤醒则是被动的</li>\n<li><strong>挂起与激活进程</strong>：既可以由该进程自己调用，也可由其它进程或系统调用，但激活原语只能由其它进程或系统调用</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"进程的互斥与同步\"><a class=\"markdownIt-Anchor\" href=\"#进程的互斥与同步\"></a> 进程的互斥与同步</h3>\n<h4 id=\"竞争和协作\"><a class=\"markdownIt-Anchor\" href=\"#竞争和协作\"></a> 竞争和协作</h4>\n<ul>\n<li>竞争，会引发以下两种极端情况：\n<ul>\n<li><strong>死锁（deadlock）</strong>：一组进程都陷入永远等待的状态</li>\n<li><strong>饥饿（starvation）</strong>：被调度程序长期忽视</li>\n</ul>\n</li>\n<li>协作——<strong>同步（synchronization）</strong>\n<ul>\n<li>一个进程的执行依赖于其协作进程的消息或信号</li>\n</ul>\n</li>\n<li>竞争——<strong>互斥（mutual exclusion）</strong>\n<ul>\n<li>互斥也是一种特殊的同步——以一定次序协调地使用共享资源</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"与时间有关的错误\"><a class=\"markdownIt-Anchor\" href=\"#与时间有关的错误\"></a> 与时间有关的错误</h4>\n<ul>\n<li>Bernstein条件\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">R(p_i)=\\{a_1,a_2,…,a_n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>，程序<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>在执行期间引用的变量集</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">{</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>b</mi><mi>m</mi></msub><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">W(p_i)=\\{b_1,b_2,…,b_m\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>，程序<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>在执行期间改变的变量集</li>\n<li>若两个程序的变量集交集之和为空集：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>∩</mo><mi>W</mi><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo><mo>∪</mo><mi>R</mi><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo><mo>∩</mo><mi>W</mi><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>∪</mo><mi>W</mi><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>∩</mo><mi>W</mi><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">R(p_1)∩W(p_2)∪R(p_2)∩W(p_1)∪W(p_1)∩W(p_2)=\\{   \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mclose\">}</span></span></span></span>，则并发进程的执行与时间无关</li>\n</ul>\n</li>\n<li>若两个进程共享了数据集，则可能存在制约关系，形成交互的并发进程</li>\n<li>执行的相对速度无法相互控制，可能会出现所谓与时间有关的错误</li>\n</ul>\n<h4 id=\"临界资源与临界区\"><a class=\"markdownIt-Anchor\" href=\"#临界资源与临界区\"></a> 临界资源与临界区</h4>\n<ul>\n<li>临界资源：在某段时间内只能允许一个进程使用的资源(<strong>打印机、磁带机等硬件设备和变量、队列等数据结构</strong>)</li>\n<li>临界区：进程中访问临界资源的代码段，几个进程若共享同一临界资源，它们必须以互斥的方式使用这个临界资源</li>\n<li>临界区调度原则：<br />\n1）一次至多一个进程能够执行其临界区代码；<br />\n2）如果已有进程在临界区运行，其它试图进入的进程应等待；<br />\n3）进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入<br />\n选择临界区调度策略时，不能因为该原则而造成进程饥饿或死锁<br />\n实现临界区管理有软件和硬件两种方式</li>\n</ul>\n<h5 id=\"软件方法管理临界区\"><a class=\"markdownIt-Anchor\" href=\"#软件方法管理临界区\"></a> 软件方法管理临界区</h5>\n<ul>\n<li>\n<p>实施依据是内存访问的基本互斥性——对内存同一地址的并发访问将被存储管理器序列化，而访问的顺序并无需事先指定，不需要硬件、操作系统或程序设计语言的任何支持</p>\n</li>\n<li>\n<p>Peterson算法（1981年）</p>\n<ul>\n<li>为每个进程设置标志<code>flag</code>用于表示该进程是否有意访问临界资源（进入临界区），又设置标志<code>turn</code>用于表示临界资源此时是否有其它进程在访问</li>\n<li>只有在对方进程的访问标志<code>flag</code>为<code>true</code>并且<code>turn</code>也为该进程标识时，才表明对方进程在访问临界资源，需要等待对方进程访问完并释放资源后才能访问；否则本进程不需要等待对方进程即可访问临界资源</li>\n</ul>\n</li>\n<li>\n<p>软件方法管理临界区的标志算法比较容易出现<strong>标志逻辑混乱</strong>的情况，其<strong>根本原因</strong>在于管理临界区标志要用两条指令：</p>\n<ul>\n<li>一条指令是看对方的标志</li>\n<li>一条指令是设置自己的标志</li>\n</ul>\n</li>\n<li>\n<p>进程并发可能导致进程在执行这两条指令时被另一个进程中断</p>\n</li>\n<li>\n<p>保证进程在执行这两条指令时不被中断，即可很容易地进行临界区管理</p>\n</li>\n</ul>\n<h5 id=\"硬件方式管理临界区\"><a class=\"markdownIt-Anchor\" href=\"#硬件方式管理临界区\"></a> 硬件方式管理临界区</h5>\n<ul>\n<li><strong>禁止中断法</strong>\n<ul>\n<li>在检查临界区标志的两条指令之前将中断关上，临界区访问完后系统才打开中断</li>\n<li>缺点：影响计算机效率、不能及时处理重要程序、对多CPU系统无效</li>\n</ul>\n</li>\n<li><strong>特殊指令法</strong>\n<ul>\n<li>特殊的硬件指令保证几个动作的原子性——不会被中断，不受到其它指令的干扰</li>\n<li>“测试并设置（Test and Set）”指令<code>TS</code>，或者交换（exchange）指令<code>SWAP / xchg</code></li>\n</ul>\n</li>\n<li><code>TS</code>指令：将布尔变量x与临界区关联起来——如果x为真，表示没有进程在临界区内，临界资源可用，并立即将x置为false，即阻止其它进程进入临界区，访问临界资源；若x为假，则表示有其它进程进入临界区，本进程需要等待。</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">TS</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (x </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    x </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">false</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">false</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div></div></figure>\n<ul>\n<li>TS指令实现互斥：</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> x </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">Pi</span><span style=\"color: #ABB2BF\"> ( ) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #61AFEF; font-weight: bold\">TS</span><span style=\"color: #ABB2BF\">(x));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    临界区 i</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    x </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<ul>\n<li>用交换指令实现互斥：</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> lock </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">false</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">Pi</span><span style=\"color: #ABB2BF\">() {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> ki </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">do</span><span style=\"color: #ABB2BF\"> {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #61AFEF; font-weight: bold\">SWAP</span><span style=\"color: #ABB2BF\">(ki, lock);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    } </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\">(ki);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    临界区i</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">SWAP</span><span style=\"color: #ABB2BF\">(ki, lock);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<h4 id=\"进程同步机制\"><a class=\"markdownIt-Anchor\" href=\"#进程同步机制\"></a> 进程同步机制</h4>\n<p>常见的同步机制有锁、信号量、管程和消息传递</p>\n<h5 id=\"信号量机制\"><a class=\"markdownIt-Anchor\" href=\"#信号量机制\"></a> 信号量机制</h5>\n<ul>\n<li>在这一体制下，进程在某一特殊点上被迫停止执行（阻塞）直到接收到一个对应的特殊变量值，这种特殊变量就是信号量(semaphore)，除了<strong>赋初值</strong>外，<strong>信号量的值只能由P操作和V操作进行修改</strong>，进程通过P、V这两个特殊操作在信号量所关联的系统资源上实现同步与互斥</li>\n<li>信号量表示<strong>系统资源的实体</strong></li>\n<li>具体实现时，信号量是一种<strong>记录型数据结构</strong>，有两个分量：一个是信号量的值，另一个是在信号量关联资源上阻塞的进程队列的队头指针<br />\n<img src=\"ComputerSystem/4.png\" alt=\"信号量\" /></li>\n<li>信号量在操作系统中的主要作用是<strong>封锁临界区</strong>、<strong>进程同步</strong>和<strong>维护资源计数</strong>。</li>\n<li>P操作和V操作原语的功能：\n<ul>\n<li><code>P(s)</code>：将信号量<code>s</code>的值减 1，若结果小于0，则调用<code>P(s)</code>的进程被阻塞，并进入信号量<code>s</code>的阻塞队列中；若结果不小于0，则调用<code>P(s)</code>的进程继续运行</li>\n<li><code>V(s)</code>：将信号量<code>s</code>的值加1，若结果不大于0，则调用<code>V(s)</code>的进程从该信号量阻塞队列中释放、唤醒一个处于等待状态的进程，将其转换为就绪状态，调用<code>V(s)</code>的进程继续运行；若结果大于0，则调用<code>V(s)</code>的进程继续运行</li>\n</ul>\n</li>\n<li>信号量的数据类型以及P、V操作原语的定义</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">typedef</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">semaphore</span><span style=\"color: #ABB2BF\"> {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> value;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">pcb</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">*</span><span style=\"color: #E5C07B\">list</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">};</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">semaphore</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #E06C75\">s</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">s</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">value</span><span style=\"color: #C678DD\">--</span><span style=\"color: #ABB2BF\">;            </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">s</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">value</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">)  </span><span style=\"color: #61AFEF; font-weight: bold\">block</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">s</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">list</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}                     </span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">semaphore</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #E06C75\">s</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">s</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">value</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">;            </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">s</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">value</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">&lt;=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">)  </span><span style=\"color: #61AFEF; font-weight: bold\">wakeup</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">s</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">list</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div></div></figure>\n<ul>\n<li>P操作意味进程申请一个资源，求而不得则阻塞进程，V操作意味着释放一个资源，若此时还有进程在等待获取该资源，则被唤醒</li>\n<li>若信号量的值为正数，该正数表示可对信号量可进行的P操作的次数，即可用的资源数。信号量的初值一般设为系统中相关资源的总数，对于互斥信号量，初值一般设为1</li>\n<li>若信号量的值为负，其绝对值表示有多个进程申请该资源而又不能得到，在阻塞队列等待，即在信号量阻塞队列中等待该资源的进程个数</li>\n<li>信号量机制实现进程互斥进入临界区</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">semaphore mutex </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">Pi</span><span style=\"color: #ABB2BF\">( ) {  </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">     </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">     临界区i</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">     </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<h4 id=\"进程同步的经典问题\"><a class=\"markdownIt-Anchor\" href=\"#进程同步的经典问题\"></a> 进程同步的经典问题</h4>\n<h5 id=\"生产者-消费者问题\"><a class=\"markdownIt-Anchor\" href=\"#生产者-消费者问题\"></a> 生产者-消费者问题</h5>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>个生产者进程和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>个消费者进程，连接在一块长度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>个单位的有界缓冲区上（故此问题又称有界缓冲问题）。其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">C_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>都是<strong>并发进程</strong>，只要缓冲区未满，生产者<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>生产的产品就可送入缓冲区；只要缓冲区不空，消费者进程<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">C_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>就可从缓冲区取走并消耗产品<br />\n<img src=\"ComputerSystem/5.png\" alt=\"生产者-消费者问题\" /></li>\n<li>在并发环境下生产者、消费者进程访问缓冲区的速度不协调、不匹配——<strong>不同步</strong>，或者没有做到互不影响地使用、更新缓冲区——<strong>互斥</strong>，所以会出现<strong>运行错误</strong>甚至是<strong>死锁</strong></li>\n<li>信号量机制解决多个生产者-消费者、共享多个缓冲区的生产者-消费者问题</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">item </span><span style=\"color: #E5C07B\">B</span><span style=\"color: #ABB2BF\">[k];</span><span style=\"color: #7F848E\">//缓冲区，长度 k</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">semaphore empty </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> k;</span><span style=\"color: #7F848E\">//可用的空缓冲区数</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">semaphore full </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\">//缓冲区内可用的产品数</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">semaphore m1 </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> m2 </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\">//互斥信号量</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> in </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\">//缓冲区放入位置</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> out </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\">//缓冲区取出位置</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">producer_i</span><span style=\"color: #ABB2BF\">() {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">produce</span><span style=\"color: #ABB2BF\">( );</span><span style=\"color: #7F848E\">//生产一个产品</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(empty);</span><span style=\"color: #56B6C2\">/</span><span style=\"color: #ABB2BF\">申请空缓冲区</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(m1);</span><span style=\"color: #7F848E\">//申请互斥使用缓冲区</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    append to </span><span style=\"color: #E5C07B\">B</span><span style=\"color: #ABB2BF\">[in];</span><span style=\"color: #7F848E\"> //产品放入缓冲</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    in </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> (in </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> k;</span><span style=\"color: #7F848E\">     //更新缓冲区指针</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(m1);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(full);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">consumer_j</span><span style=\"color: #ABB2BF\">() {    </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(full);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(m2); </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">take</span><span style=\"color: #ABB2BF\">( ) from </span><span style=\"color: #E5C07B\">B</span><span style=\"color: #ABB2BF\">[out];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    out </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> (out </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> k;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(m2);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(empty);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">consume</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<h5 id=\"读者-写者问题\"><a class=\"markdownIt-Anchor\" href=\"#读者-写者问题\"></a> 读者-写者问题</h5>\n<ul>\n<li>两组并发进程，读者和写者，共享一个文件F，要求：\n<ul>\n<li>允许多个读者进程同时读文件</li>\n<li>只允许一个写者进程写文件</li>\n<li>任何一个写者进程在完成写操作之前不允许其它读者或写者工作</li>\n<li>写者执行写操作前，应让已有的写者和读者全部退出</li>\n</ul>\n</li>\n<li>信号量机制解决读者-写者问题</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> readcount </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\">  //读进程计数器</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">semaphore ws </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">, mutex </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">reader_i</span><span style=\"color: #ABB2BF\">() {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  readcount</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\">(readcount </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(ws); </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  读文件;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  readcount</span><span style=\"color: #C678DD\">--</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\">(readcount </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(ws);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(mutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">writer_j</span><span style=\"color: #ABB2BF\">() {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(ws);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  写文件;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(ws);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<ul>\n<li>写者优先算法</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">semaphore  rmutex, wmutex, S;</span><span style=\"color: #7F848E\"> // S在写者到达后封锁读者</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">rmutex </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">; wmutex </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">; S </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">; </span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> count </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">process reader {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(S);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(rmutex)</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (count </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(wmutex)；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  count</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(rmutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(S);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  READ FILE;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(rmutex)；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  count</span><span style=\"color: #C678DD\">--</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (count </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(wmutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(rmutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">process writer{</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(S);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(wmutex)；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  WRITE the FILE;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(wmutex);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(S);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<h5 id=\"哲学家就餐问题\"><a class=\"markdownIt-Anchor\" href=\"#哲学家就餐问题\"></a> 哲学家就餐问题</h5>\n<ul>\n<li>五个哲学家围坐在一张圆桌前，每个哲学家面前有一碗意大利面和一只叉子，哲学家的生活由思考和进餐两个活动组成，进餐时需要两只叉子，但每个哲学家只有两只叉子，所以他们需要共享叉子</li>\n<li>算法1：给所有哲学家编号，奇数号的哲学家必须首先拿左边的筷子，偶数号的哲学家则反之。</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">semaphore chopsticks [</span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">];</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">; i</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">philmac_i</span><span style=\"color: #ABB2BF\">() {</span><span style=\"color: #7F848E\">//i=0,1,2,3,4</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">think</span><span style=\"color: #ABB2BF\">()；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\">(i </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">2</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[i])；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[(i </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">])；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\">{</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[(i </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> l) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">]);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[i]);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">eat</span><span style=\"color: #ABB2BF\">()；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[i])；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #61AFEF; font-weight: bold\">chopsticks</span><span style=\"color: #ABB2BF\">([i </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">] % 5))；</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<ul>\n<li>算法2：通过发放令牌最多允许4个哲学家同时吃面</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">semaphore </span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> {</span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">};</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">semaphore token </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">4</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\">//4个令牌</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">philmac_i</span><span style=\"color: #ABB2BF\">() {</span><span style=\"color: #7F848E\">//i=0,1,2,3,4 </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">think</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(token);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[i]);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[(i </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> l) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">]);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">eat</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[(i </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> l) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">]);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">chopsticks</span><span style=\"color: #ABB2BF\">[i]);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(token);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<ul>\n<li>管程解决哲学家就餐问题的算法：</li>\n</ul>\n<p>采用Hoare管程实现，算法思想是将哲学家的状态分为思考、饥饿、吃面，并且仅当哲学家左右两边的筷子都可用才允许他拿筷子，否则一只筷子也不拿</p>\n<h5 id=\"睡眠理发师问题\"><a class=\"markdownIt-Anchor\" href=\"#睡眠理发师问题\"></a> 睡眠理发师问题</h5>\n<ul>\n<li>理发店里有一个理发师，一把理发椅，N个供等候顾客休息的椅子。若无顾客，理发师躺在理发椅上睡觉。顾客到来时唤醒理发师，若理发师正在理发，新来的顾客坐在空闲的休息椅上等候，如果没有空椅子，顾客离开。</li>\n<li>进程<code>Barber()</code>和<code>Customer()</code>分别描述理发师和顾客，理发师和顾客之间是同步的关系，顾客之间是互斥关系，竞争理发师和休息椅。</li>\n<li>算法采用信号量机制，引入一个控制变量和3个信号量：\n<ul>\n<li>控制变量<code>waiting</code>用来记录等候理发的顾客数，初值为0；</li>\n<li>信号量<code>customers</code>用来关联表达等候理发的顾客数，并用作阻塞理发师进程，初值为0；</li>\n<li>信号量<code>barbers</code>用来记录正在等候顾客的理发师数，并用作阻塞顾客进程，初值为0；</li>\n<li>信号量<code>mutex</code>用于互斥，初值为1。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程通信\"><a class=\"markdownIt-Anchor\" href=\"#进程通信\"></a> 进程通信</h3>\n<p>进程通信（IPC：Inter-Process Communication）是进程之间数据的相互交换和信息的相互传递，是一种<code>高级通信机制</code></p>\n<h4 id=\"消息传递通信\"><a class=\"markdownIt-Anchor\" href=\"#消息传递通信\"></a> 消息传递通信</h4>\n<ul>\n<li>进程将<strong>通信数据封装在消息</strong>中，消息通过消息缓冲区在进程之间互相传递</li>\n<li><strong>消息</strong>是指进程之间以<strong>不连续</strong>的<strong>成组方式</strong>发送的信息</li>\n<li><strong>消息缓冲区</strong>应包含<strong>消息发送进程标识</strong>、<strong>消息接收进程标识</strong>、<strong>指向下一个消息缓冲区的指针</strong>、<strong>消息长度</strong>、<strong>消息正文</strong>等。缓冲区构成了进程通信的一个<strong>基本单位</strong></li>\n</ul>\n<h5 id=\"直接通信\"><a class=\"markdownIt-Anchor\" href=\"#直接通信\"></a> 直接通信</h5>\n<ul>\n<li>在直接通信方式下，发送进程将发送的数据封装到消息正文后，发送进程必须给出接收进程的标识，然后用发送原语将消息发送给接收进程</li>\n<li>收发消息的原语：\n<ul>\n<li><code>send</code>（接收进程标识，消息队列首指针）</li>\n<li><code>receive</code>（发送进程标识，接收区首地址指针）</li>\n</ul>\n</li>\n<li>在直接通信中隐含着发送进程与接收进程之间的同步问题</li>\n<li><code>send()</code>：\n<ul>\n<li>查找接收进程的PCB，存在，则申请一个存放消息的缓冲区，若消息缓冲区已满，则返回到非同步错误处理程序入口，进行特殊处理</li>\n<li>若接收进程因等待此消息的到来而处于阻塞状态，则唤醒此进程。将存放消息的缓冲区连接到接收进程的消息队列上</li>\n<li>两种同步方式\n<ul>\n<li>发送进程阻塞等待接收进程发回的确认信息</li>\n<li>发送进程发送完消息后，不阻塞等待接收进程的回送信息，而是继续执行；限定时间到仍未收到确认消息，重发或放弃</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>receive()</code>：\n<ul>\n<li>接收进程在其进程空间中确定一个接收区，复制/读取消息缓冲区中的内容，释放消息缓冲区</li>\n<li>若无消息可读，则阻塞接收进程至有消息发送来为止</li>\n<li>两种同步方式\n<ul>\n<li>接收进程调用<code>receive</code>原语并一直阻塞等待发送来的消息，直到接收到消息——与发送进程的第二种同步方式匹配</li>\n<li>接收进程调用<code>receive</code>原语后，不阻塞等待发送来的消息，而是继续执行——与发送进程的第一种同步方式匹配</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"间接通信\"><a class=\"markdownIt-Anchor\" href=\"#间接通信\"></a> 间接通信</h5>\n<ul>\n<li>消息传递的间接通信方式是指发送进程与接收进程之间<strong>通过邮箱</strong>来进行通信，发送进程将消息发送到邮箱，接收进程从邮箱接收消息\n<ul>\n<li>发送原语：<code>send(mailboxname, message)</code>;</li>\n<li>接收原语：<code>receive(mailboxname, message)</code>;</li>\n</ul>\n</li>\n<li>与直接通信比较，间接通信<strong>灵活性更大</strong>，不<strong>需要发送进程与接收进程同步</strong>，是一种方便、可靠的进程通信方式</li>\n</ul>\n<h4 id=\"共享内存通信\"><a class=\"markdownIt-Anchor\" href=\"#共享内存通信\"></a> 共享内存通信</h4>\n<ul>\n<li>共享内存通信分为\n<ul>\n<li>基于共享数据结构的通信方式——比较低效，只适于传递少量数据</li>\n<li>基于共享存储区的通信方式<br />\n<img src=\"ComputerSystem/6.png\" alt=\"共享内存通信\" /></li>\n</ul>\n</li>\n<li>共享内存通信的实现过程如下：\n<ul>\n<li>建立共享内存区——标识和长度等参数</li>\n<li>共享内存区的管理</li>\n<li>共享内存区的映射与断开</li>\n</ul>\n</li>\n<li>允许多个进程将共享内存映射到自己的地址空间，进程对各自所映射的地址段的读写操作代码应纳入临界区管理</li>\n</ul>\n<h4 id=\"管道通信\"><a class=\"markdownIt-Anchor\" href=\"#管道通信\"></a> 管道通信</h4>\n<ul>\n<li>管道是连接读、写进程的一个<strong>特殊文件</strong>，允许进程按<strong>FIFO方式</strong>传送数据，也能使进程同步执行操作。发送进程以字符流形式把数据送入管道，接收进程从管道中接收数据</li>\n<li>管道的实质是一个共享文件（文件系统的高速缓冲区中），进程对管道<strong>应该互斥使用</strong></li>\n<li>写进程把一定数量的数据写入<code>pipe</code>，就去睡眠等待，直到读进程取走数据后，将其唤醒</li>\n<li>命名管道（named pipe）用来在不同的地址空间之间进行通信，不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信，特别为服务器通过网络与客户端交互而设计，是一种<strong>永久通信机制</strong></li>\n<li>每一个命名管道都有一个<strong>唯一的名字</strong></li>\n</ul>\n<h3 id=\"进程调度\"><a class=\"markdownIt-Anchor\" href=\"#进程调度\"></a> 进程调度</h3>\n<ul>\n<li>由于进程总数一般多于CPU数，必然会出现竞争CPU的情况。进程调度的功能就是按一定策略、动态地把CPU分配给处于就绪队列中的某一进程执行</li>\n<li>两种基本的进程调度方式，<strong>抢占方式</strong>和<strong>非抢占方式</strong>，也称<strong>剥夺式（preemptive）<strong>和</strong>非剥夺式（non_preemptive）</strong> 调度</li>\n<li>剥夺原则有：<strong>优先权原则</strong>、<strong>短进程优先原则</strong>、<strong>时间片原则</strong>等</li>\n<li>可能引发进程调度的时机：\n<ul>\n<li>正在运行的进程运行完毕；</li>\n<li>运行中的进程要求I/O操作；</li>\n<li>执行某种原语操作(如P操作)导致进程阻塞；</li>\n<li>比正在运行的进程优先级更高的进程进入就绪队列；</li>\n<li>分配给运行进程的时间片已经用完</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程调度模型\"><a class=\"markdownIt-Anchor\" href=\"#进程调度模型\"></a> 进程调度模型</h4>\n<ul>\n<li>三级调度\n<ul>\n<li><strong>高级调度</strong>（High-Level Scheduling），作业调度\n<ul>\n<li>从后备作业中选若干个作业，分配必要的资源，建立相应的用户作业进程和系统服务进程（如输人、输出进程），将其程序和数据调入内存……</li>\n</ul>\n</li>\n<li><strong>中级调度</strong>（Intermediate-Level Scheduling），平衡调度\n<ul>\n<li>在内存紧张时，将一些暂时不能运行的进程对换到外存。当内存有空间时，再将其重新调入内存</li>\n</ul>\n</li>\n<li><strong>低级调度</strong>（Low-Level Scheduling），进程调度\n<ul>\n<li>根据一定的算法将CPU分派给就绪队列中的一进程</li>\n<li>最基本的、必须的一种调度<br />\n<img src=\"ComputerSystem/7.png\" alt=\"进程调度模型\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"调度算法选择评价准则\"><a class=\"markdownIt-Anchor\" href=\"#调度算法选择评价准则\"></a> 调度算法选择/评价准则</h4>\n<ul>\n<li>调度算法也称为调度策略 ，评价调度算法的参数：\n<ul>\n<li><strong>处理器利用率</strong>（CPU utilization）= CPU有效工作时间 / CPU总的运行时间</li>\n<li><strong>响应时间</strong>（response time）：交互环境下用户从键盘提交请求开始，到系统首次产生响应为止的时间；是分时和实时系统调度性能重要指标。</li>\n<li><strong>周转时间</strong>（turnaround time）：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mtext> </mtext><mo>=</mo><msub><mi>T</mi><mi>f</mi></msub><mtext>–</mtext><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_i =  T_f – T_s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"> </span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">–</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，即：周转时间 = 完成时刻 - 提交时刻；批处理系统重要指标</li>\n<li><strong>带权周转时间</strong>：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub><mo>=</mo><mtext> 作业的周转时间</mtext><msub><mi>T</mi><mi>i</mi></msub><mi mathvariant=\"normal\">/</mi><mtext>系统为作业提供的服务时间</mtext><mi>T</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_i = 作业的周转时间T_i / 系统为作业提供的服务时间Ts_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">业</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">周</span><span class=\"mord cjk_fallback\">转</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">间</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord cjk_fallback\">系</span><span class=\"mord cjk_fallback\">统</span><span class=\"mord cjk_fallback\">为</span><span class=\"mord cjk_fallback\">作</span><span class=\"mord cjk_fallback\">业</span><span class=\"mord cjk_fallback\">提</span><span class=\"mord cjk_fallback\">供</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">服</span><span class=\"mord cjk_fallback\">务</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">间</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，显然带权周转时间总大于1 。实质是，周转时间与系统为其提供服务的时间之比</li>\n<li><strong>平均作业周转时间</strong>：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Σ</mi><msub><mi>T</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">T = (ΣT_i) / n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">Σ</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span></span></span></span></li>\n<li><strong>平均作业带权周转时间</strong>：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Σ</mi><msub><mi>W</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">W = (ΣW_i) / n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">Σ</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span></span></span></span></li>\n<li><strong>系统吞吐量</strong>（throughput）：单位时间内完成的进程（任务/交易）数目</li>\n<li><strong>公平性</strong>：不出现饥饿情况</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"调度算法\"><a class=\"markdownIt-Anchor\" href=\"#调度算法\"></a> 调度算法</h4>\n<h5 id=\"先来先服务first-come-first-servedfcfs\"><a class=\"markdownIt-Anchor\" href=\"#先来先服务first-come-first-servedfcfs\"></a> 先来先服务（First-Come First-Served，FCFS）</h5>\n<ul>\n<li>按进程就绪的先后顺序来调度，到达得越早，就越先执行</li>\n<li>获得CPU的进程，未遇到其它情况时，一直运行下去</li>\n<li>是一种<strong>非抢占式</strong>算法，简单易实现</li>\n<li><strong>没有</strong>考虑<strong>执行时间长短</strong>、<strong>运行特性</strong>和<strong>资源</strong>的要求</li>\n<li>FCFS调度算法适用性\n<ul>\n<li>对<strong>长作业非常有利</strong>，对<strong>短作业不利</strong></li>\n<li>对<strong>CPU繁忙型</strong>的作业非常<strong>有利</strong>，对<strong>I/O繁忙型作业</strong>非常<strong>不利</strong>——进程I/O阻塞结束后需<strong>再次排队</strong></li>\n<li><strong>非抢占式算法</strong>，对<strong>响应时间要求高</strong>的进程<strong>不利</strong></li>\n<li>平均作业周转时间与作业提交的<strong>顺序</strong>有关</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"短作业优先shortest-job-firstsjf\"><a class=\"markdownIt-Anchor\" href=\"#短作业优先shortest-job-firstsjf\"></a> 短作业优先（Shortest-Job-First，SJF）</h5>\n<ul>\n<li>以进入系统的作业所要求的CPU服务时间为标准，总选取估计所需CPU时间最短的作业优先投入运行。\n<ul>\n<li>算法<strong>易于实现</strong>，<strong>效率不高</strong>，主要弱点是<strong>忽视了作业等待时间</strong>。</li>\n<li>对<strong>长作业不利</strong>，如果系统不断接收短作业，可能会出现<strong>饥饿</strong>现象。</li>\n<li><strong>非抢占式</strong>算法，对<strong>响应时间要求高</strong>的进程<strong>不利</strong>。</li>\n<li>SJF的<strong>平均作业周转时间</strong>比FCFS要<strong>小</strong>，故它的调度<strong>性能</strong>比FCFS<strong>好</strong>。</li>\n<li>实现SJF调度算法需要知道<strong>作业所需运行时间</strong>，而要精确知道一个作业的运行时间是<strong>办不到</strong>的。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"最短剩余时间优先shortest-remaining-time-firstsrtf\"><a class=\"markdownIt-Anchor\" href=\"#最短剩余时间优先shortest-remaining-time-firstsrtf\"></a> 最短剩余时间优先（Shortest Remaining Time First，SRTF）</h5>\n<ul>\n<li>若一就绪状态的新作业所需的CPU时间比当前正在执行的作业剩余任务所需CPU时间还短，SRTF将<strong>打断正在执行作业</strong>，将执行权分配给新作业</li>\n<li>SRTF将SJF算法改为<strong>抢占式</strong>，因此只要有新作业进入<strong>就绪队列</strong>，就可能会引发<strong>进程切换</strong>。</li>\n<li>SRTF调度算法适用性：\n<ul>\n<li><strong>长进程</strong>仍有可能出现<strong>饥饿</strong>现象</li>\n<li>必须计算运行、剩余时间，系统<strong>开销增大</strong></li>\n<li>因抢占式调度，系统<strong>性能</strong>会比SJF要<strong>好</strong></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"高响应比优先highest-response-ratio-firsthrrf\"><a class=\"markdownIt-Anchor\" href=\"#高响应比优先highest-response-ratio-firsthrrf\"></a> 高响应比优先（Highest Response Ratio First，HRRF）</h5>\n<ul>\n<li>是FCFS与SJF两种算法的<strong>折衷</strong>，既考虑作业<strong>等待</strong>时间，又考虑作业的<strong>运行</strong>时间，既照顾短作业又不使长作业等待过久，<strong>改善</strong>了调度<strong>性能</strong>，仍属于<strong>非抢占式算法</strong>\n<ul>\n<li>响应比为作业的响应时间与作业所需运行时间之比，简化为：响应比 ＝ 1 +（已等待的时间 / 估计运行时间）</li>\n</ul>\n</li>\n<li>HRRF算法适用性：\n<ul>\n<li>由定义可知，<strong>短作业</strong>容易得到<strong>较高响应比</strong>，长作业在等待了足够长的时间后，也将获得足够高的响应比，因此<strong>不会发生饥饿</strong>现象</li>\n<li>需要经常计算作业的响应比，导致<strong>额外的开销</strong></li>\n<li>HRRF算法的平均周转时间和平均带权周转时间都<strong>介于FCFS与SJF算法之间</strong>，比SJF算法差，比FCFS算法优</li>\n<li>虽然HRRF算法的平均周转时间和平均带权周转时间不及SJF算法，但是，在现实中其可以实现，结果也比较<strong>可靠</strong></li>\n<li>如果在算法中引入<strong>抢占调度</strong>，则算法过程会更复杂。因为所有作业的响应比是<strong>动态变化</strong>的，抢占时间的计算需要解多个方程得到</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"优先权highest-priority-firsthpf\"><a class=\"markdownIt-Anchor\" href=\"#优先权highest-priority-firsthpf\"></a> 优先权（Highest-Priority-First，HPF）</h5>\n<ul>\n<li>根据进程的<strong>优先权</strong>进行进程调度，每次总是选取优先权高的进程调度，也称<strong>优先级调度算法</strong>，一般是<strong>抢占式</strong>调度\n<ul>\n<li>优先权通常用一个整数表示，也叫优先数\n<ul>\n<li>Windows系统中有0~31共32个优先级，31最高</li>\n<li>Unix系统中，使用数值-20~+19来表示优先级，-20优先级最高</li>\n</ul>\n</li>\n<li>优先权可由<strong>系统或用户给定</strong>\n<ul>\n<li>静态优先权</li>\n<li>动态优先权</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"时间片轮转round-ribonrr\"><a class=\"markdownIt-Anchor\" href=\"#时间片轮转round-ribonrr\"></a> 时间片轮转（Round-Ribon，RR）</h5>\n<ul>\n<li>调度程序把CPU分配给进程使用一个规定的时段，称为一个<strong>时间片</strong>（如100ms），就绪队列中的进程轮流获得CPU的一个时间片。当一个时间片结束时，系统剥夺该进程执行权，等候下一轮调度，属于<strong>抢占式调度</strong>\n<ul>\n<li>时间片的长短，影响进程的进度</li>\n<li>需要从进程数、切换开销、系统效率和响应时间等方面综合考虑，确定时间片大小</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"多级反馈队列multilevel-feed-queuemfq\"><a class=\"markdownIt-Anchor\" href=\"#多级反馈队列multilevel-feed-queuemfq\"></a> 多级反馈队列（Multilevel-Feed-Queue，MFQ）</h5>\n<ul>\n<li>又称<strong>反馈循环队列</strong>，是一种<strong>基于时间片的进程多级队列调度算法的改进算法</strong>。系统设置多个就绪队列，<strong>最高级就绪队列的优先级最高</strong>，随着就绪队列级别的降低优先级依次下降，<strong>较高级就绪队列的进程获得较短的时间片</strong></li>\n<li>不需事先知道各进程所需运行时间，因而可行性较高，同时综合考虑了进程的时间和优先权因素，既照顾了短进程，又照顾了长进程，是一种<strong>综合调度算法</strong>，被广泛应用于各种操作系统中</li>\n</ul>\n<h4 id=\"多cpu系统中的调度\"><a class=\"markdownIt-Anchor\" href=\"#多cpu系统中的调度\"></a> 多CPU系统中的调度</h4>\n<ul>\n<li>多处理器系统的作用是利用系统内的多个CPU来并行执行用户进程，以提高系统的吞吐量或用来进行冗余操作以提高系统的可靠性</li>\n<li>系统的多个处理器在物理上处于同一机壳中，有一个单一的系统物理地址空间，多个处理器共享系统内存、外设等资源</li>\n<li>多CPU系统的类型主要有两种：\n<ul>\n<li><strong>主-从模式</strong>，只有一个主处理器，运行操作系统，管理整个系统资源，并负责为各从处理器分配任务，从处理器有多个，执行预先规定的任务及由主处理器分配的任务。这种类型的系统无法做到负载平衡，可靠性不高，<strong>很少使用</strong>。</li>\n<li><strong>对称处理器模式SMP（Symmetric MultiProcessor）</strong>，所有处理器都是相同的、平等的，共享一个操作系统，每个处理器都可以运行操作系统代码，管理系统资源。是目前比较常见的多CPU系统类型。</li>\n</ul>\n</li>\n<li>多处理器系统中，比较有代表性的进（线）程调度方式有以下几种方式：\n<ul>\n<li>自调度\n<ul>\n<li>设置一个公共的进程或线程的就绪队列</li>\n<li>不会出现处理器空闲</li>\n<li>处理器互斥访问该队列，容易形成系统瓶颈</li>\n<li>高速缓存的使用效率很低</li>\n<li>协作线程很难同时运行</li>\n</ul>\n</li>\n<li>组调度/群调度（Gang Scheduling）</li>\n<li>专用处理器分配</li>\n<li>动态调度\n<ul>\n<li>操作系统和进程共同进行调度</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多核cpu中的调度\"><a class=\"markdownIt-Anchor\" href=\"#多核cpu中的调度\"></a> 多核CPU中的调度</h4>\n<ul>\n<li>多核处理器是指在<strong>一枚处理器中集成两个或多个计算引擎（内核/core）</strong>，称为CMP（Chip multiprocessors）结构，可在特定的时钟周期内执行更多任务，通常采用共享二级Cache的结构</li>\n<li>对于多核CPU，优化操作系统任务调度算法是保证效率的关键\n<ul>\n<li>全局队列调度（多数系统）</li>\n<li>局部队列调度</li>\n</ul>\n</li>\n<li>中断处理——全局中断控制器也需要封装在芯片内部</li>\n<li>系统提供同步与互斥机制——需要利用硬件提供的“读－修改－写”的原子操作或其他同步互斥机制</li>\n</ul>\n<h3 id=\"死锁\"><a class=\"markdownIt-Anchor\" href=\"#死锁\"></a> 死锁</h3>\n<ul>\n<li>一个进程集合中的每个进程都在等待只能由该集合中的其它一个进程才能引发的事件，则称一组进程或系统此时发生了死锁</li>\n<li>死锁一旦发生，会使整个系统瘫痪而无法工作。因此，必须想办法解决死锁问题</li>\n</ul>\n<h4 id=\"死锁产生的原因\"><a class=\"markdownIt-Anchor\" href=\"#死锁产生的原因\"></a> 死锁产生的原因</h4>\n<ul>\n<li>并发进程<strong>对临界资源的竞争</strong></li>\n<li>并发进程<strong>推进顺序不当</strong></li>\n</ul>\n<h4 id=\"死锁产生的必要条件\"><a class=\"markdownIt-Anchor\" href=\"#死锁产生的必要条件\"></a> 死锁产生的必要条件</h4>\n<ul>\n<li>\n<p><strong>互斥条件</strong>（Mutual exclusion）：资源的使用是互斥的</p>\n</li>\n<li>\n<p><strong>请求与保持条件</strong>（Hold and wait）：已经得到某些资源的进程可以再申请新的资源。</p>\n</li>\n<li>\n<p><strong>不剥夺条件</strong>（No pre-emption）：系统或其它进程不能剥夺进程已经获得的资源。</p>\n</li>\n<li>\n<p><strong>环路等待条件</strong>（Circular wait）：系统中若干进程间形成等待环路</p>\n</li>\n<li>\n<p>只要破坏上述几个条件之一，即可<strong>防止死锁</strong></p>\n<ul>\n<li>破坏第1个条件，使资源可同时访问而不是互斥使用，<strong>可行性较差</strong></li>\n<li>破坏第2个条件，进程必须获得所需的所有资源才能运行——<strong>静态</strong>分配，<strong>严重降低资源利用效率</strong>。</li>\n<li>破坏第3个条件，采用<strong>剥夺式调度</strong>方法，<strong>只适用于CPU和内存分配</strong></li>\n<li>破坏条件4，采用<strong>层次分配</strong>策略——按此策略分配资源时系统不会发生死锁</li>\n<li>资源按序分配策略：进程不得在占用资源<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub><mo stretchy=\"false\">(</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r_j(1≤j≤m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>后再申请<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r_i(i&lt;j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n</li>\n<li>\n<p>进程-资源分配图</p>\n<ul>\n<li><strong>圆圈</strong>表示<strong>进程</strong>，<strong>资源类</strong>用<strong>方框</strong>表示，<strong>框中的圆点</strong>代表<strong>单个该类资源</strong>，<strong>有向边</strong>连接进程和资源</li>\n<li><strong>申请边</strong>从<strong>进程指向资源类方框</strong>，表示进程正在等待资源；<strong>分配边</strong>从<strong>单个资源圆点指向进程</strong>，表示进程已经获得资源</li>\n<li><img src=\"ComputerSystem/8.png\" alt=\"进程-资源分配图\" /></li>\n</ul>\n</li>\n<li>\n<p>根据进程-资源分配图定义个得出如下结论：</p>\n<ul>\n<li>如果进程-资源分配图中<strong>无环路</strong>，则此时系统<strong>没有发生死锁</strong></li>\n<li>如果进程-资源分配图中<strong>有环路</strong>，且每个资源类中<strong>仅有一个资源</strong>，则系统中<strong>发生了死锁</strong>，此时，<strong>环路</strong>是系统发生死锁的<strong>充要条件</strong>，<strong>环路中的进程便为死锁进程</strong></li>\n<li>如果进程-资源分配图中<strong>有环路</strong>，且涉及的资源类中<strong>有多个资源</strong>，则环路的存在只是产生死锁的<strong>必要条件</strong>而不是充分条件</li>\n</ul>\n</li>\n<li>\n<p>进程-资源分配图可用以下步骤化简：</p>\n<ul>\n<li>在资源分配图中，找出一个<strong>既非等待又非孤立</strong>的进程结点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，由于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>可获得它所需要的全部资源，且运行完后释放它所占有的全部资源，故可在资源分配图中<strong>消去</strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><strong>所有的申请边和分配边</strong>，使之成为既无申请边又无分配边的<strong>孤立</strong>结点；</li>\n<li>将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>所释放的资源分配给申请它们的进程，即在资源分配图中<strong>将这些进程对资源的申请边改为分配边</strong>；</li>\n<li>重复前两步骤，直到找不到符合条件的进程结点。</li>\n</ul>\n</li>\n<li>\n<p>经过化简后，若能<strong>消去资源分配图中的所有边</strong>，使所有进程都成为孤立结点，则称该图是<strong>可完全化简</strong>的，否则为<strong>不可化简</strong>的</p>\n</li>\n<li>\n<p>系统为死锁状态的<strong>充分条件</strong>是：当且仅当该状态的进程-资源分配图是<strong>不可完全简化</strong>的——<strong>死锁定理</strong>。</p>\n</li>\n</ul>\n<h4 id=\"死锁的避免\"><a class=\"markdownIt-Anchor\" href=\"#死锁的避免\"></a> 死锁的避免</h4>\n<ul>\n<li>死锁避免法是通过资源分配算法分析系统是否存在一个并发进程的状态序列，在<strong>确定不会进程循环等待</strong>的情况下，才将资源真正分配给进程，以保证并发进程不会产生死锁。</li>\n<li>死锁避免法能支持<strong>更高的进程并发度</strong>，<strong>动态地</strong>决定是否给进程分配资源——如果进程的资源请求方案会导致死锁，系统拒绝执行，反之，如果一个资源的分配会导致死锁，系统拒绝分配。</li>\n</ul>\n<h5 id=\"银行家调度算法\"><a class=\"markdownIt-Anchor\" href=\"#银行家调度算法\"></a> 银行家调度算法</h5>\n<ul>\n<li>\n<p>Dijkstra在1965年提出了避免死锁的银行家调度算法，该算法是以银行系统所采用的借贷策略（尽可能放贷、尽快回收资金）为基础而建立的算法模型。在此模型中，进程相当于贷款客户，系统资源相当于资金，调度程序相当于银行家（贷款经理）。</p>\n</li>\n<li>\n<p>进程约束条件：</p>\n<ul>\n<li>进程必须事先声明其资源需求</li>\n<li>进程每次提出部分资源申请并获得分配</li>\n<li>进程获得所需资源，执行完毕后，必须及时归还所占资源</li>\n</ul>\n</li>\n<li>\n<p>系统约束条件：</p>\n<ul>\n<li>若进程所请求得最大资源数不超过系统所有的资源总数，则系统一定分配资源给进程；</li>\n<li>系统保证在有限的时间内使资源不足而等待的进程获得资源</li>\n</ul>\n</li>\n<li>\n<p>思路</p>\n<ul>\n<li>在某一时刻，各进程已获得所需的部分资源。有一进程提出新的资源请求，系统将剩余资源试探性地分配给该进程。</li>\n<li>如果此时剩余资源能够满足余下的某些进程的需求，则将剩余资源分配给能<strong>充分满足</strong>的、<strong>资源需求缺口最大</strong>的进程，运行结束后释放的资源再并入系统的剩余资源集合。</li>\n<li>反复执行第2步，直到所有的进程都能够获得所需而运行结束。说明第1步的进程请求是可行的，系统处于安全状态，相应的进程执行序列称为系统的<strong>安全序列</strong>。</li>\n<li>如果所有的进程都试探过而不能将资源分配给进程，即不存在安全序列，则系统是不安全的。</li>\n</ul>\n</li>\n<li>\n<p>银行家算法所需的数据结构：假设系统中有n个进程，m类资源；</p>\n<ul>\n<li>系统当前资源剩余量向量<code>Available[m] = &#123; R1，R2，……，Rm &#125;</code>；</li>\n<li>n个进程对m类资源的需求声明矩阵<code>Claim[n][m]</code>，<code>Claim[i][j]</code>的值表示进程i对j类资源的总需求量；</li>\n<li>n个进程已获得的各类资源数量矩阵<code>Possession[n][m]</code>，<code>Possession[i][j]</code>的值<code>k</code>表示进程i已获得<code>k</code>个j类资源；</li>\n<li>n个进程的各类资源需求缺口矩阵<code>Shortage[n][m] = Claim – Possession</code>，<code>Shortage[i][j]</code>的值<code>s</code>表示进程i还需要（缺）<code>s</code>个j类资源；</li>\n<li>某进程i在某时刻发出的资源请求向量<code>Request[m]</code>，取值随具体情况而定。</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>前4个数据结构及其取值确定了系统在某一时刻的状态，如果算法尝试资源分配方案能够使得所有进程安全运行完毕，则说明该状态安全，资源分配方案可行。</p></blockquote>\n<ul>\n<li>\n<p>银行家算法细化说明</p>\n<ul>\n<li>判断请求向量<code>Request</code>的有效性——<strong>超过相应进程总需求量则报错</strong>，<strong>超过系统目前剩余量则阻塞</strong>；</li>\n<li>就系统资源剩余量对<code>Request</code>进行试分配：<br />\n<code>Available[*] = Available[*] - Request[*]</code>；<br />\n<code>Possession[i][*] = Possession[i][*] + Request[*]</code>；<br />\n<code>Shortage[i][*] = Shortage[i][*] - Request[*]</code>；</li>\n<li>执行安全性测试算法，若安全则确认试分配方案，否则进程i阻塞；</li>\n</ul>\n</li>\n<li>\n<p>执行安全性测试算法细化说明：</p>\n<ul>\n<li>定义工作向量<code>Rest[*] = Available[*]</code>，进程集合<code>Running&#123;*&#125;</code>，布尔量<code>possible = true</code>；</li>\n<li>从<code>Running</code>集合中找出<code>Pk</code>，满足条件<code>Shortage[k][*] &lt; Rest[*]</code>；</li>\n<li>找到合格的进程<code>Pk</code>，则释放其占用资源（<code>Rest[*] = Rest[*] + Possession[k][*]</code>），将其从<code>Running</code>集合中去掉，重复步骤②；</li>\n<li>找不到合格的进程<code>Pk</code>，<code>possible</code>为<code>false</code>，退出安全性测试算法；</li>\n<li>最终检查<code>Running</code>集合，为<strong>空</strong>则返回<strong>安全</strong>，非空则不安全。</li>\n</ul>\n</li>\n<li>\n<p>银行家算法是一个很经典的死锁避免算法，<strong>理论性很强</strong>，看起来似乎很完美，但其实现要求进程不相关，并且事先要知道进程总数和各进程所需资源情况，所以<strong>可行性并不高</strong>。</p>\n</li>\n</ul>\n<h4 id=\"检测与解除\"><a class=\"markdownIt-Anchor\" href=\"#检测与解除\"></a> 检测与解除</h4>\n<ul>\n<li>\n<p>死锁的检测算法可以采用<strong>基于死锁定理的检测</strong>（进程-资源分配图化简），也可以采用类似于银行家算法中的<strong>安全性测试算法</strong>，如果算法退出时<strong>仍有未结束</strong>的进程，则系统<strong>不安全</strong>，那些未结束的进程就是死锁的进程。</p>\n</li>\n<li>\n<p>只不过死锁检测的不是试分配之后的系统状态，而是<strong>系统当前状态</strong>，需要考虑检查每个进程还需要的资源能否满足要求。</p>\n</li>\n<li>\n<p>在系统中，需要决定<strong>死锁检测的频率</strong>。如果检测太频繁，会花大量的时间检测死锁，浪费CPU的处理时间；如果检测的频率太低，死锁进程和系统资源被锁定的时间过长，资源浪费大。</p>\n</li>\n<li>\n<p>通常的方法是在<strong>CPU的使用率下降到一定的阈值时实施检测</strong>。当死锁发生次数多，死锁进程数增加到一定程度时，CPU的处理任务减少，CPU空闲时间增多。</p>\n</li>\n<li>\n<p>在系统成功地检测到死锁后，常用的死锁解除方法有以下几种：</p>\n<ul>\n<li><strong>重启</strong>：重新启动死锁进程，甚至重启操作系统。</li>\n<li><strong>撤销</strong>：撤销死锁进程，回收资源，优先选择占用资源最多或者撤销代价最小的，撤销一个不行就继续选择撤销进程，直至解除死锁。</li>\n<li><strong>剥夺</strong>：剥夺死锁进程资源再分配，选择原则同上。</li>\n<li><strong>回滚</strong>：根据系统保存的检查点，使进程或系统回退到死锁前的状态。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#线程的基本概念\"></a> 线程的基本概念</h3>\n<h4 id=\"线程的引入\"><a class=\"markdownIt-Anchor\" href=\"#线程的引入\"></a> 线程的引入</h4>\n<ul>\n<li>在操作系统中再引入线程则是为了<strong>减少程序并发执行时所付出的时空开销</strong>，使操作系统<strong>并发粒度更小</strong>、<strong>并发性更好</strong>。</li>\n<li>线程是操作系统进程中<strong>能够独立执行的实体（控制流）</strong>，是<strong>处理器调度和分派的基本单位</strong></li>\n<li>线程是进程的<strong>组成部分</strong>，线程只拥有一些在运行中<strong>必不可少的资源</strong>（如<strong>程序计数器</strong>、<strong>一组寄存器</strong>和<strong>栈</strong>），与同属一个进程的其它线程<strong>共享进程所拥有的全部资源</strong></li>\n<li>多个线程间可<strong>并发</strong>执行</li>\n<li><strong>不同进程</strong>间的线程<strong>互不可见</strong>，同一进程内的线程间通信主要<strong>基于全局变量</strong></li>\n</ul>\n<h4 id=\"线程与进程的区别与联系\"><a class=\"markdownIt-Anchor\" href=\"#线程与进程的区别与联系\"></a> 线程与进程的区别与联系</h4>\n<ul>\n<li>线程具有许多传统进程所具有的特征，故又称为<strong>轻型进程</strong>(Light-Weight Process)或进程元；而把传统的进程称为<strong>重型进程</strong>(Heavy-Weight Process)，它<strong>相当于只有一个线程的任务</strong>。</li>\n<li>在引入了线程的操作系统中，通常一个进程都有若干个线程，<strong>至少需要有一个主线程</strong>。</li>\n<li>进程的<strong>再定义</strong>：进程是操作系统中进行<strong>除处理器外</strong>的资源分配和保护的基本单位，它有一个<strong>独立的虚拟地址空间</strong>，用来<strong>容纳进程映像</strong>(如与进程关联的程序与数据)，并<strong>以进程为单位对各种资源实施保护</strong>，如受保护地访问处理器、文件、外部设备及其它进程(进程间通信)</li>\n<li>线程与进程在调度、并发性、系统开销、拥有资源等方面有所区别</li>\n<li>在传统的操作系统中，拥有资源的基本单位和独立调度的基本单位都是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分配的基本单位，而把进程作为拥有资源的基本单位，使传统进程的两个属性分开，线程便能轻装运行，从而可显著地提高系统的并发程度。</li>\n<li>在同一进程中，<strong>线程的切换不会引起进程的切换</strong>，在<strong>由一个进程中的线程切换到另一个进程中的线程</strong>时，将会<strong>引起进程的切换</strong>。</li>\n<li>不论是传统的操作系统，还是支持线程的操作系统，进程都是拥有资源的独立单位，拥有自己的资源。</li>\n<li>一般地说，线程自己不拥有系统资源(只有一些必不可少的资源)，但可以<strong>访问、共享其隶属进程的资源</strong>——进程的代码段、数据段以及打开的文件、I/O设备等。</li>\n<li>在进行进程切换时，涉及到当前进程<strong>整个CPU环境的保存</strong>以及<strong>新被调度运行的进程的CPU环境</strong>的设置。</li>\n<li>而线程切换只需<strong>保存和设置少量寄存器</strong>的内容，并<strong>不涉及存储器管理</strong>方面的操作。可见，进程切换的开销也远大于线程切换的开销</li>\n</ul>\n<h4 id=\"线程的三种模式\"><a class=\"markdownIt-Anchor\" href=\"#线程的三种模式\"></a> 线程的三种模式</h4>\n<ul>\n<li>在操作系统内核实现的<strong>内核级线程</strong>（Kernel Level Thread，KLT），如Windows，OS/2等：线程管理的全部工作由操作系统内核<strong>在内核空间实现</strong>。系统为应用开发使用内核级线程提供了API，除了API函数调用外，应用程序<strong>不需要</strong>编写任何线程管理的其它代码，通过调用API函数，实现线程的创建和控制管理</li>\n<li>在用户空间实现的<strong>用户级线程</strong>（User Level Thread，ULT），如Java的线程库等：线程管理的全部工作由应用程序在用户空间实现，<strong>内核不知道线程的存在</strong>。用户级线程由用户空间运行的用户级线程库实现，应用开发通过线程库进行程序设计，<strong>用户级线程库</strong>是线程运行的<strong>支撑环境</strong></li>\n<li>同时支持两种线程的<strong>混合式线程</strong>实现，如Solaris系统。设计恰当的话，混合式线程既可以具备内核级线程实现的优点，又可以具备用户级线程实现的优点。用户级线程与内核级线程之间的关系可以有三种模型表示：<strong>一对一</strong>模型、<strong>多对一</strong>模型、<strong>多对多</strong>模型</li>\n</ul>\n<h3 id=\"管程的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#管程的基本概念\"></a> 管程的基本概念</h3>\n<ul>\n<li>\n<p>管程是一种比信号量机制更先进的<strong>进程同步机制</strong></p>\n</li>\n<li>\n<p>基本思想：把分散在各进程中的控制和管理临界资源的临界区<strong>集中</strong>起来统一管理</p>\n</li>\n<li>\n<p>实质上是把临界区集中并封装成<strong>抽象数据类型</strong>，其中包括与临界资源相关、仅限管程内部访问的公共变量，供管程外的进程调用以访问这些公共变量的接口过程，并提供互斥机制确保进程互斥地使用管程</p>\n</li>\n<li>\n<p>管程具有以下特点：</p>\n<ul>\n<li><strong>模块化</strong>——管程是一个基本程序单位，其中不仅有数据，还有对数据的操作；</li>\n<li><strong>隐蔽性</strong>——管程内与临界资源相关的数据相当于是管程的私有成员，仅限管程内部访问，通过管程申请使用该资源的进程无法直接访问，只能调用管程提供的接口过程；</li>\n<li><strong>互斥性</strong>——任一时刻只能有一个进程真正进入管程内部使用相应系统资源，其它进程必须等待，直至管程再次可用</li>\n</ul>\n</li>\n<li>\n<p>管程采用<strong>条件变量</strong>（condition variable）实现同步机制：</p>\n<ul>\n<li>让进入管程却因资源不足而阻塞的进程暂时放弃管程控制权（开放管程），进入该条件变量的等待队列</li>\n<li>条件变量只能在管程中通过两个原语操作——<code>wait</code>原语和<code>signal</code>原语</li>\n<li>一个进程<strong>已进入管程但无法继续执行</strong>，便在相应的条件变量x上调用<code>x.wait()</code>，将自己阻塞并移入x的等待队列中，放弃管程控制权（开放管程），另一进程可以通过对同一个条件变量执行<code>x.signal()</code>来唤醒之前在x上等待的进程</li>\n<li>条件变量仅起到维护等待队列的作用，不存在相关的值，也<strong>不能像信号量那样加减累计</strong><br />\n<img src=\"ComputerSystem/9.png\" alt=\"管程\" /></li>\n</ul>\n</li>\n<li>\n<p>管程与进程的区别：</p>\n<ul>\n<li>管程把共享变量上的同步操作集中起来，而临界区却分散在每个进程中；</li>\n<li>管程是为管理共享资源而建立的，进程主要是为实现系统并发性而引入的；</li>\n<li>管程被进程调用，<strong>管程和调用它的进程不能并行工作</strong>，而进程之间能并行工作，并发性是其固有特性；</li>\n<li>管程是语言或操作系统的组成部分，不必创建或撤销，而进程有生命周期</li>\n</ul>\n</li>\n<li>\n<p>阻塞进程被另一进程以signal原语唤醒时的管程互斥协调方法：</p>\n<ul>\n<li>执行signal的进程等待，直到被释放的进程退出管程或因等待另一个条件而阻塞</li>\n<li>被释放进程等待，直到执行signal的进程退出管程或因等待另一个条件而阻塞</li>\n</ul>\n</li>\n<li>\n<p>Hoare采用了第一种办法，Hansen选择了两者的折衷，规定signal原语必须位于管程过程的最后一步，于是当一个进程调用管程过程时执行了signal原语，也就意味着该进程立即退出管程</p>\n</li>\n<li>\n<p>Hoare方法使用信号量和P、V操作来实现对管程中过程的互斥调用，从而实现对共享资源互斥使用。</p>\n</li>\n<li>\n<p>Hoare管程的基本思路为：</p>\n<ul>\n<li>管程中设一互斥信号量<code>mutex</code>(初值为1)，用于进程互斥调用管程内部过程</li>\n<li>设置信号量<code>urgent</code>（初值为0）和计数器<code>urgent_count</code>（初值为0）</li>\n<li>设置信号量<code>x</code>（初值为0）用于阻塞等待资源的进程及相应的计数器<code>x_count</code>（初值为0）</li>\n</ul>\n</li>\n<li>\n<p>在管程的实现中，将上述1、2两条所引入的量封装在一个结构中，称为<code>InterfaceModule</code>。</p>\n</li>\n<li>\n<p>Hoare管程实现的主要代码：</p>\n</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">typedef</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">InterfaceModule</span><span style=\"color: #ABB2BF\">{</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    semaphore mutex </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\">//进程调用管程过程前使用的互斥信号量</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    semaphore urgent </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\">//发出signal的进程挂起自己的信号量</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> urgent_count </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\"> ;</span><span style=\"color: #7F848E\">//在urgent上等待的进程数</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">};</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">InterfaceModule IM;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">semaphore x;</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> x_count,</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">enter</span><span style=\"color: #ABB2BF\">(){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">mutex</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">leave</span><span style=\"color: #ABB2BF\">(){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">urgent</span><span style=\"color: #ABB2BF\"> _count </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">)</span><span style=\"color: #7F848E\"> //是否存在因执行signal而阻塞在urgent上的进程</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">urgent</span><span style=\"color: #ABB2BF\">);</span><span style=\"color: #7F848E\">//有的话先唤醒一个阻塞在urgent上的进程</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">mutex</span><span style=\"color: #ABB2BF\">);</span><span style=\"color: #7F848E\"> //没有的话直接开放管程</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">wait</span><span style=\"color: #ABB2BF\"> (){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    x_count</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">. </span><span style=\"color: #E06C75\">urgent_count</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">urgent</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">urgent</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(x);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    x_count</span><span style=\"color: #C678DD\">--</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">signal</span><span style=\"color: #ABB2BF\">(){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (x_count </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">urgent_count</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #61AFEF; font-weight: bold\">V</span><span style=\"color: #ABB2BF\">(x);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">P</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">urgent</span><span style=\"color: #ABB2BF\">);</span><span style=\"color: #E5C07B\">IM</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">urgent_count</span><span style=\"color: #C678DD\">--</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div></div></figure>\n<h4 id=\"进程同步的几个经典问题用管程来解决\"><a class=\"markdownIt-Anchor\" href=\"#进程同步的几个经典问题用管程来解决\"></a> 进程同步的几个经典问题，用管程来解决</h4>\n<h5 id=\"管程解决生产者-消费者问题\"><a class=\"markdownIt-Anchor\" href=\"#管程解决生产者-消费者问题\"></a> 管程解决生产者-消费者问题</h5>\n<ul>\n<li>采用<code>Hoare</code>管程实现，继承<code>Monitor</code>中原有的定义（如<code>wait</code>、<code>signal</code>等），自定义可供生产者、消费者进程调用的接口<code>put</code>和<code>get</code>过程。</li>\n<li>由于管程本身具备互斥机制，所以代码中没有针对多个生产者、消费者竞争使用缓冲区的信号量及操作，直接使用管程中的<code>enter</code>和<code>leave</code>。</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">Monitor p_c_mon{</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  item </span><span style=\"color: #E5C07B\">B</span><span style=\"color: #ABB2BF\">[k];</span><span style=\"color: #7F848E\">//缓冲区，长度k</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  condition empty, full;</span><span style=\"color: #7F848E\">//缓冲区空满对应的条件变量</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> in, out, count;</span><span style=\"color: #7F848E\"> //缓冲区存取位置，内容产品数</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">put</span><span style=\"color: #ABB2BF\">(item px){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> ( count </span><span style=\"color: #C678DD\">&gt;=</span><span style=\"color: #ABB2BF\"> k ) </span><span style=\"color: #E5C07B\">empty</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">wait</span><span style=\"color: #ABB2BF\">();</span><span style=\"color: #7F848E\"> //缓冲区已满，在empty上阻塞调用put的进程</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">B</span><span style=\"color: #ABB2BF\">[in] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> px; in </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\">(in </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> k;count</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">full</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">queue</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #E5C07B\">full</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">signal</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">get</span><span style=\"color: #ABB2BF\">(item </span><span style=\"color: #56B6C2\">&amp;</span><span style=\"color: #ABB2BF\"> gx){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> ( count </span><span style=\"color: #C678DD\">&lt;=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\"> ) </span><span style=\"color: #E5C07B\">full</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">wait</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    gx </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">B</span><span style=\"color: #ABB2BF\">[out]; out </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> (out </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> k; count</span><span style=\"color: #C678DD\">--</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">empty</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">queue</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #E5C07B\">empty</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">signal</span><span style=\"color: #ABB2BF\">( );</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">init</span><span style=\"color: #ABB2BF\">(){ in </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> out </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> count </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">enter</span><span style=\"color: #ABB2BF\">() {………}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">leave</span><span style=\"color: #ABB2BF\">() {………}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">producer_i</span><span style=\"color: #ABB2BF\"> () {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        生产一个产品x</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">p_c_mon</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">enter</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">p_c_mon</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">put</span><span style=\"color: #ABB2BF\">(x);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">p_c_mon</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">leave</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">consumer_j</span><span style=\"color: #ABB2BF\"> () {    </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">p_c_mon</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">enter</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">p_c_mon</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">get</span><span style=\"color: #ABB2BF\">(x);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">p_c_mon</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">leave</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        消费 x;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<h5 id=\"管程解决哲学家就餐问题的算法\"><a class=\"markdownIt-Anchor\" href=\"#管程解决哲学家就餐问题的算法\"></a> 管程解决哲学家就餐问题的算法</h5>\n<ul>\n<li>采用Hoare管程实现，算法思想是将哲学家的状态分为思考、饥饿、吃面，并且仅当哲学家左右两边的筷子都可用才允许他拿筷子，否则一只筷子也不拿。</li>\n</ul>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">Monitor phil_mac_mon{</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">enum</span><span style=\"color: #ABB2BF\"> { </span><span style=\"color: #E06C75\">thinking</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #E06C75\">hungry</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #E06C75\">eating</span><span style=\"color: #ABB2BF\"> } </span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  semaphore </span><span style=\"color: #E5C07B\">self</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">self_count</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  InterfaceModule IM;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">; i</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> thinking;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">self_count</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">test</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> k) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> ((</span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[(k </span><span style=\"color: #56B6C2\">-</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> eating) </span><span style=\"color: #56B6C2\">&amp;&amp;</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[k] </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> hungry) </span><span style=\"color: #56B6C2\">&amp;&amp;</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[(k </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> eating)){</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[k] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> eating;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #61AFEF; font-weight: bold\">signal</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">pickup</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">enter</span><span style=\"color: #ABB2BF\">(IM);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> hungry;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">test</span><span style=\"color: #ABB2BF\">(i);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> eating) </span><span style=\"color: #61AFEF; font-weight: bold\">wait</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">leave</span><span style=\"color: #ABB2BF\">(IM);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\">  </span><span style=\"color: #61AFEF; font-weight: bold\">putdown</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">enter</span><span style=\"color: #ABB2BF\">(IM);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">state</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> thinking;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">test</span><span style=\"color: #ABB2BF\">((i </span><span style=\"color: #56B6C2\">-</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">test</span><span style=\"color: #ABB2BF\">((i </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #56B6C2\">%</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">leave</span><span style=\"color: #ABB2BF\">(IM);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">cobegin</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">process</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">philmac_i</span><span style=\"color: #ABB2BF\">() {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #61AFEF; font-weight: bold\">think</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #E5C07B\">phil_mac_mon</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">pickup</span><span style=\"color: #ABB2BF\">(i);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #61AFEF; font-weight: bold\">eat</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">      </span><span style=\"color: #E5C07B\">phil_mac_mon</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">putdown</span><span style=\"color: #ABB2BF\">(i);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">coend</span></span></code></pre></div></div></figure>\n<h2 id=\"内存管理\"><a class=\"markdownIt-Anchor\" href=\"#内存管理\"></a> 内存管理</h2>\n<h3 id=\"内存管理概述\"><a class=\"markdownIt-Anchor\" href=\"#内存管理概述\"></a> 内存管理概述</h3>\n<h4 id=\"计算机存储系统的组成\"><a class=\"markdownIt-Anchor\" href=\"#计算机存储系统的组成\"></a> 计算机存储系统的组成</h4>\n<ul>\n<li>内存储器（Memory），是处理器能直接寻址的存储空间，由半导体器件制成，用来存放处理器执行时所需要的程序和数据，以及与硬盘等外部存储器交换的数据，程序和数据只有在内存中才能被处理器直接访问。</li>\n<li>外存储器也叫辅助存储器，用来存放需要长期保存的数据，外存储器的管理属于文件系统的范畴。</li>\n<li>内存储器分两部分：\n<ul>\n<li>一部分是系统区，用来存放操作系统以及一些标准子程序、例行程序等，这些是长驻内存的部分，系统区用户不能使用；</li>\n<li>另一部分称为用户区，分配给用户使用，用来存放用户的程序和数据等。内存管理的主要工作就是对内存储器中的用户区进行管理。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"内存管理的功能\"><a class=\"markdownIt-Anchor\" href=\"#内存管理的功能\"></a> 内存管理的功能</h4>\n<ul>\n<li><strong>内存的分配和回收</strong>：操作系统根据用户程序的请求，在<strong>内存中按照一定算法把找到一块空闲，将其分配给申请者；并负责把释放的内存空间收回</strong>，使之变为空闲区。</li>\n<li><strong>实现地址转换</strong>：用户程序中使用逻辑地址，而CPU访问内存时则按物理地址进行，内存管理必须进行地址转换工作，把<strong>逻辑地址转换成物理内存中与之对应的物理地址</strong>，这种地址转换工作也称为<strong>地址重定位</strong>。</li>\n<li><strong>内存的共享和保护</strong>：内存中不仅有系统程序，还有多个用户程序，为了防止各用户程序相互干扰和保护各用户区的信息不受破坏，系统必须负责隔离分配给各用户的内存区，<strong>保证各个用户程序或进程在各自规定的存储区域内操作</strong>，不破坏操作系统区的信息，并且互不干扰。</li>\n<li><strong>内存扩充</strong>：内存管理允许通过虚拟存储技术“扩充”内存容量。在计算机软、硬件系统的支持下，可以把磁盘等辅助存储器作为内存的扩充部分使用，<strong>使用户程序在所需内存在比实际物理内存容量大的情况下，也能在内存中运行</strong>。</li>\n</ul>\n","feature":true,"text":" 概论 操作系统的定义和功能 操作系统的定义 一组计算机程序的集合，主要用以控制和管理 计算机的硬件和软件资源，合理地组织计算机的工作流程，向应用程序和用户提供...","permalink":"/post/ComputerSystem","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"23 mins."},"categories":[{"name":"computer science","slug":"computer-science","count":2,"path":"api/categories/computer-science.json"}],"tags":[{"name":"computer science","slug":"computer-science","count":2,"path":"api/tags/computer-science.json"},{"name":"learning","slug":"learning","count":8,"path":"api/tags/learning.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%AE%BA\"><span class=\"toc-text\"> 概论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\"> 操作系统的定义和功能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\"> 操作系统的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\"> 操作系统的功能</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81\"><span class=\"toc-text\"> 操作系统的特征</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95\"><span class=\"toc-text\"> 操作系统的发展</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\"> 操作系统的分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\"> 批处理操作系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\"> 分时操作系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\"> 实时操作系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\"> 个人计算机操作系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\"> 网络操作系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\"> 分布式操作系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\"> 嵌入式操作系统</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\"> 操作系统的接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\"> 程序接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\"> 操作接口</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\"> 操作系统的设计实现方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91\"><span class=\"toc-text\"> 操作系统设计与开发</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\"> 操作系统的体系结构</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\"> 进程管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\"> 程序的执行方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\"> 程序的顺序执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\"> 程序的并发执行与并行执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E5%BC%95%E5%85%A5\"><span class=\"toc-text\"> 进程概念的引入</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%8E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\"> 进程的特征与控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\"> 进程的相关概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\"> 进程状态及转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97pcb\"><span class=\"toc-text\"> 进程控制块PCB</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\"> 进程控制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\"> 进程的互斥与同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AB%9E%E4%BA%89%E5%92%8C%E5%8D%8F%E4%BD%9C\"><span class=\"toc-text\"> 竞争和协作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E6%97%B6%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF\"><span class=\"toc-text\"> 与时间有关的错误</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA\"><span class=\"toc-text\"> 临界资源与临界区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E7%AE%A1%E7%90%86%E4%B8%B4%E7%95%8C%E5%8C%BA\"><span class=\"toc-text\"> 软件方法管理临界区</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%A1%AC%E4%BB%B6%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86%E4%B8%B4%E7%95%8C%E5%8C%BA\"><span class=\"toc-text\"> 硬件方式管理临界区</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\"> 进程同步机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\"> 信号量机制</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\"> 进程同步的经典问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\"> 生产者-消费者问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\"> 读者-写者问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98\"><span class=\"toc-text\"> 哲学家就餐问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%9D%A1%E7%9C%A0%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\"> 睡眠理发师问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\"> 进程通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\"> 消息传递通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\"> 直接通信</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\"> 间接通信</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\"> 共享内存通信</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\"> 管道通信</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\"> 进程调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\"> 进程调度模型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E9%80%89%E6%8B%A9%E8%AF%84%E4%BB%B7%E5%87%86%E5%88%99\"><span class=\"toc-text\"> 调度算法选择&#x2F;评价准则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> 调度算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1first-come-first-servedfcfs\"><span class=\"toc-text\"> 先来先服务（First-Come First-Served，FCFS）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88shortest-job-firstsjf\"><span class=\"toc-text\"> 短作业优先（Shortest-Job-First，SJF）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88shortest-remaining-time-firstsrtf\"><span class=\"toc-text\"> 最短剩余时间优先（Shortest Remaining Time First，SRTF）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88highest-response-ratio-firsthrrf\"><span class=\"toc-text\"> 高响应比优先（Highest Response Ratio First，HRRF）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E6%9D%83highest-priority-firsthpf\"><span class=\"toc-text\"> 优先权（Highest-Priority-First，HPF）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%ACround-ribonrr\"><span class=\"toc-text\"> 时间片轮转（Round-Ribon，RR）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97multilevel-feed-queuemfq\"><span class=\"toc-text\"> 多级反馈队列（Multilevel-Feed-Queue，MFQ）</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9Acpu%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\"> 多CPU系统中的调度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%A0%B8cpu%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\"> 多核CPU中的调度</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\"> 死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\"> 死锁产生的原因</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\"> 死锁产生的必要条件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D\"><span class=\"toc-text\"> 死锁的避免</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%93%B6%E8%A1%8C%E5%AE%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> 银行家调度算法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4\"><span class=\"toc-text\"> 检测与解除</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\"> 线程的基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5\"><span class=\"toc-text\"> 线程的引入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB\"><span class=\"toc-text\"> 线程与进程的区别与联系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 线程的三种模式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\"> 管程的基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E7%94%A8%E7%AE%A1%E7%A8%8B%E6%9D%A5%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\"> 进程同步的几个经典问题，用管程来解决</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\"> 管程解决生产者-消费者问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> 管程解决哲学家就餐问题的算法</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\"> 内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\"> 内存管理概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\"> 计算机存储系统的组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\"> 内存管理的功能</span></a></li></ol></li></ol></li></ol>","author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"计算机组成原理复习","uid":"9eabaac45732ecdc3be940d0aaa9e3ce","slug":"computer-organization","date":"2023-12-20T08:32:28.000Z","updated":"2024-03-17T09:30:11.989Z","comments":true,"path":"api/articles/computer-organization.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/cpu.jpg","text":" 计算机系统概论 计算机的性能指标 吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量。 响应时间：表征从输入有效到系统产生响应之间的时间度量，例如微秒、纳...","permalink":"/post/computer-organization","photos":[],"count_time":{"symbolsCount":"35k","symbolsTime":"32 mins."},"categories":[{"name":"computer science","slug":"computer-science","count":2,"path":"api/categories/computer-science.json"}],"tags":[{"name":"computer science","slug":"computer-science","count":2,"path":"api/tags/computer-science.json"},{"name":"learning","slug":"learning","count":8,"path":"api/tags/learning.json"}],"author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}