{"title":"最小生成树 Minimum Spanning Tree","uid":"3bb7227ed966054de259b7b7501c2568","slug":"3bb7227ed966054de259b7b7501c2568","date":"2023-06-23T08:05:39.000Z","updated":"2024-03-17T05:29:47.010Z","comments":true,"path":"api/articles/3bb7227ed966054de259b7b7501c2568.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","content":"<h2 id=\"最小生成树-Minimum-Spanning-Tree\"><a href=\"#最小生成树-Minimum-Spanning-Tree\" class=\"headerlink\" title=\"最小生成树 Minimum Spanning Tree\"></a>最小生成树 Minimum Spanning Tree</h2><p>加权无向图的最小生成树（Minimum  Spanning Tree，简称MST）是一棵生成树，其权（所有边的权值之和）不会大于其它任何生成树的权。</p>\n<p>一个带权连通图G（假定每条边上的权值均大于零）可能有多棵生成树.<br>每棵生成树中所有边上的权值之和可能不同。<br>其中边上的权值之和最小的生成树称为图的最小生成树。</p>\n<p>MST算法有很多，但其中最知名的是Prim算法和Kruskal算法</p>\n<h2 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h2><h3 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h3><p>从任何一个顶点开始作一棵单顶点MST，再为之增加V-1条边，每次增加的边都是将MST上的一个顶点和尚未在此MST上的一个顶点相连接的最小边。</p>\n<p>假设G&#x3D;(V，E)是一个具有n个顶点的带权连通图，T&#x3D;(U，TE)是G的最小生成树，其中U是T的顶点集，TE是T的边集，则由G构造从起始点v出发的最小生成树T的步骤如下：</p>\n<ol>\n<li>初始化U&#x3D;{v}。以v到其他顶点的所有边为候选边。</li>\n<li>重复以下步骤n-1次，使得其他n-1个顶点被加入到U中：<ol>\n<li>从候选边中挑选<strong>权值最小</strong>的边加入TE（所有候选边一定是连接两个顶点集U和V-U的边），设该边在V-U中的顶点是k，将顶点k加入U中。</li>\n<li>考察当前V-U中的所有顶点j，修改候选边：<strong>若(k，j)的权值小于原来和顶点j关联的候选边，则用(k，j)取代后者作为候选边</strong>。</li>\n</ol>\n</li>\n</ol>\n<p>寻找最小边在这里使用小根堆</p>\n<h3 id=\"基于堆的Prim算法代码\"><a href=\"#基于堆的Prim算法代码\" class=\"headerlink\" title=\"基于堆的Prim算法代码\"></a>基于堆的Prim算法代码</h3><div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">Edge</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> from, to, cost;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">Edge</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">u</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">v</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">w</span><span style=\"color: #ABB2BF\">):</span><span style=\"color: #61AFEF\">from</span><span style=\"color: #ABB2BF\">(u), </span><span style=\"color: #61AFEF\">to</span><span style=\"color: #ABB2BF\">(v), </span><span style=\"color: #61AFEF\">cost</span><span style=\"color: #ABB2BF\">(w) &#123;&#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">HeapNode</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> d, u;</span><span style=\"color: #7F848E; font-style: italic\"> // d表示点u到MST的距离</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">operator</span><span style=\"color: #ABB2BF\">&lt; (</span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">HeapNode</span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">rhs</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> d </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">rhs</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">d</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 小根堆</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">vector</span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\">Edge</span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> edges;</span><span style=\"color: #7F848E; font-style: italic\"> // edges存所有边</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">vector</span><span style=\"color: #C678DD\">&lt;int&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // G[i]是顶点i发出的所有边</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // i是否已经加入了MST</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // 每个点到MST的最小距离</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">Prim</span><span style=\"color: #ABB2BF\">() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    priority_queue</span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\">HeapNode</span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> Q;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> ans </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 总权值</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> INF;</span><span style=\"color: #7F848E; font-style: italic\"> // V是图的节点数</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 从点0开始</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">memset</span><span style=\"color: #ABB2BF\">(done, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">sizeof</span><span style=\"color: #ABB2BF\">(done));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">push</span><span style=\"color: #ABB2BF\">((HeapNode)&#123;</span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">&#125;);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">empty</span><span style=\"color: #ABB2BF\">()) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        HeapNode x </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">top</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">pop</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> u </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">x</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">u</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // u为队头元素的序号</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[u]) </span><span style=\"color: #C678DD\">continue</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 已经在MST中就跳过</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        ans </span><span style=\"color: #C678DD\">+=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">x</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">d</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 加上出队的队头元素到MST的距离</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u].</span><span style=\"color: #E06C75\">size</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) &#123;</span><span style=\"color: #7F848E; font-style: italic\"> // 更新最小生成树的权值</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            Edge</span><span style=\"color: #56B6C2\">&amp;</span><span style=\"color: #ABB2BF\"> e </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i]];</span><span style=\"color: #7F848E; font-style: italic\"> // 顶点to能修改最小距离</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">cost</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">cost</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">push</span><span style=\"color: #ABB2BF\">((HeapNode)&#123;</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">], </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">&#125;);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> ans;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span></code></pre></div><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>本段代码用邻接表来存图，输入可以使用</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> E; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) &#123;</span><span style=\"color: #7F848E; font-style: italic\"> // E是边数 </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> u, v, cost;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    cin </span><span style=\"color: #C678DD\">&gt;&gt;</span><span style=\"color: #ABB2BF\"> u </span><span style=\"color: #C678DD\">&gt;&gt;</span><span style=\"color: #ABB2BF\"> v </span><span style=\"color: #C678DD\">&gt;&gt;</span><span style=\"color: #ABB2BF\"> cost;</span><span style=\"color: #7F848E; font-style: italic\">  // 输入边的起点、终点和权值</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u].</span><span style=\"color: #61AFEF\">push_back</span><span style=\"color: #ABB2BF\">(i);</span><span style=\"color: #7F848E; font-style: italic\">  // 存储边的索引</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">push_back</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #61AFEF\">Edge</span><span style=\"color: #ABB2BF\">(u, v, cost));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[v].</span><span style=\"color: #61AFEF\">push_back</span><span style=\"color: #ABB2BF\">(i);</span><span style=\"color: #7F848E; font-style: italic\">  // 存储边的索引</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">push_back</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #61AFEF\">Edge</span><span style=\"color: #ABB2BF\">(v, u, cost));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span></code></pre></div><h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>Prim时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo>+</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(VlogV + ElogV)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span>。在稀疏图的情况下，E的数量通常远小于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>，因此可以将时间复杂度近似为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(ElogV)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span>。而在稠密图的情况下，E的数量接近<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>，时间复杂度会接近<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(V^2logV)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h2><h3 id=\"基本思路-1\"><a href=\"#基本思路-1\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h3><p>以边的长度（从小到大）为顺序来处理，若一条边与前面加入到MST中的边未形成环，则将这样的边加入到MST中，增加了V-1条边后停止。也就是说开始是一个森林，每个顶点就是一棵独立的树，然后逐渐把这些树合并（通过一条最小边），最后形成的一棵树就是MST。</p>\n<p>假设G&#x3D;(V，E)是一个具有n个顶点的带权连通图，T&#x3D;(U，TE)是G的最小生成树，则构造最小生成树的步骤如下：</p>\n<ol>\n<li>置U的初值等于V（即包含有G中的全部顶点），TE的初值为空集（即图T中每一个顶点都构成一个分量）。</li>\n<li>将图G中的边按权值从小到大的顺序依次选取：若选取的边未使生成树T形成回路，则加入TE；否则舍弃，直到TE中包含n-1条边为止。</li>\n</ol>\n<p>如果把一棵树看成一个集合，那么对于新加入的边，要判断它的两个顶点是否已经在同一个集合了？是的话就跳过，处理下一条边；不是的话就把这条边加入到MST，同时把该边两顶点所处的两个集合合并。这个实际就是不相交集合（Disjoint Set）的并查(Union-Find)操作。</p>\n<h3 id=\"Kruskal算法代码\"><a href=\"#Kruskal算法代码\" class=\"headerlink\" title=\"Kruskal算法代码\"></a>Kruskal算法代码</h3><div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edge</span><span style=\"color: #ABB2BF\"> &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> u, v, cost; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">cmp</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edge</span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">e1</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edge</span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">e2</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e1</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">cost</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e2</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">cost</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">edge </span><span style=\"color: #E5C07B\">es</span><span style=\"color: #ABB2BF\">[MAX_E];</span><span style=\"color: #7F848E; font-style: italic\"> // 存储边的信息</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">par</span><span style=\"color: #ABB2BF\">[MAX_V];</span><span style=\"color: #7F848E; font-style: italic\"> // 存储父节点</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// 初始化并查集</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">init_union_find</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">V</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">par</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> i;</span><span style=\"color: #7F848E; font-style: italic\"> // 初始时每个节点的父节点是自身</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// 查找根节点</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">x</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">par</span><span style=\"color: #ABB2BF\">[x] </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> x) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> x;</span><span style=\"color: #7F848E; font-style: italic\"> // 根节点的父节点是自身</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125; </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">par</span><span style=\"color: #ABB2BF\">[x] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">par</span><span style=\"color: #ABB2BF\">[x]);</span><span style=\"color: #7F848E; font-style: italic\"> // 路径压缩，将x的父节点设为根节点，加速后续查找</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// 合并集合</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">unite</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">x</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">y</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    x </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(x);</span><span style=\"color: #7F848E; font-style: italic\"> // 查找x的根节点</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    y </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(y);</span><span style=\"color: #7F848E; font-style: italic\"> // 查找y的根节点</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (x </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> y) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">par</span><span style=\"color: #ABB2BF\">[x] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> y;</span><span style=\"color: #7F848E; font-style: italic\"> // 将x的根节点设为y，合并两个集合</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// 判断两个节点是否属于同一个集合</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">same</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">x</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">y</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(x) </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(y);</span><span style=\"color: #7F848E; font-style: italic\"> // 若两个节点的根节点相同，则属于同一个集合</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">Kruskal</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">V</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">E</span><span style=\"color: #ABB2BF\">) &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">sort</span><span style=\"color: #ABB2BF\">(es, es </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> E, cmp);</span><span style=\"color: #7F848E; font-style: italic\"> // 按权值从小到大排序</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">init_union_find</span><span style=\"color: #ABB2BF\">(V);</span><span style=\"color: #7F848E; font-style: italic\"> // 并查集初始化 </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> res </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> E; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        edge e </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">es</span><span style=\"color: #ABB2BF\">[i];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #61AFEF\">same</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">u</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">v</span><span style=\"color: #ABB2BF\">)) &#123;</span><span style=\"color: #7F848E; font-style: italic\"> // u和v不属于一个集合</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #61AFEF\">unite</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">u</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">v</span><span style=\"color: #ABB2BF\">);</span><span style=\"color: #7F848E; font-style: italic\"> // 合并u和v集合的元素</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            res </span><span style=\"color: #C678DD\">+=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">cost</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> res;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span></code></pre></div><h3 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>Kruskal算法的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>E</mi><mo>+</mo><mi>E</mi><mi>α</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(ElogE + Eα(V))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>。在稀疏图的情况下，E的数量通常远小于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>，因此可以将时间复杂度近似为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(ElogE)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>。而在稠密图的情况下，E的数量接近<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>，时间复杂度会接近<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mi>α</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(Eα(V))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>。</p>\n","text":"最小生成树 Minimum Spanning Tree加权无向图的最小生成树（Minimum Spanning Tree，简称MST）是一棵生成树，其权（所有边...","permalink":"/post/3bb7227ed966054de259b7b7501c2568","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"algorithms","slug":"algorithms","count":8,"path":"api/tags/algorithms.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Minimum-Spanning-Tree\"><span class=\"toc-text\">最小生成树 Minimum Spanning Tree</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Prim%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Prim算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">基本思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E5%A0%86%E7%9A%84Prim%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">基于堆的Prim算法代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">注意</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Kruskal%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Kruskal算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1\"><span class=\"toc-text\">基本思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Kruskal%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">Kruskal算法代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-1\"><span class=\"toc-text\">分析</span></a></li></ol></li></ol>","author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"最短路径 Shortest Path","uid":"ea135958f52dc15115556a781c9e36cf","slug":"ea135958f52dc15115556a781c9e36cf","date":"2023-06-24T02:56:20.000Z","updated":"2024-03-17T05:29:57.892Z","comments":true,"path":"api/articles/ea135958f52dc15115556a781c9e36cf.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","text":"最短路径 Shortest Path加权有向图中每条路径都有值，其值是该路径上所有边的权值之和。最短路径 （Shortest Path）问题就是指求出两个给定顶...","permalink":"/post/ea135958f52dc15115556a781c9e36cf","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"algorithms","slug":"algorithms","count":8,"path":"api/tags/algorithms.json"}],"author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"机器人王国里的路径长度","uid":"3be01ecc0602fc98eccd555eb652a0f4","slug":"3be01ecc0602fc98eccd555eb652a0f4","date":"2023-06-20T13:09:12.000Z","updated":"2024-03-17T05:29:53.051Z","comments":true,"path":"api/articles/3be01ecc0602fc98eccd555eb652a0f4.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","text":"题目描述在一个机器人王国里，围绕首都分N层构建卫星城市。以首都为圆心，以路相连分出两个卫星城在第一个层，然后每个卫星城又有路相连分出两个卫星城在下一层，但每条路...","permalink":"/post/3be01ecc0602fc98eccd555eb652a0f4","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"tree","slug":"tree","count":2,"path":"api/tags/tree.json"}],"author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}