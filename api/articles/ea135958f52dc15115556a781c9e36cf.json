{"title":"最短路径 Shortest Path","uid":"ea135958f52dc15115556a781c9e36cf","slug":"ea135958f52dc15115556a781c9e36cf","date":"2023-06-24T02:56:20.000Z","updated":"2024-03-17T05:29:57.892Z","comments":true,"path":"api/articles/ea135958f52dc15115556a781c9e36cf.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","content":"<h2 id=\"最短路径-Shortest-Path\"><a href=\"#最短路径-Shortest-Path\" class=\"headerlink\" title=\"最短路径 Shortest Path\"></a>最短路径 Shortest Path</h2><p>加权有向图中每条路径都有值，其值是该路径上所有边的权值之和。最短路径 （Shortest Path）问题就是指求出两个给定顶点间权值最小的路径。</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>两个顶点s和t之间的一条最短路径 是从s到t的一条有向简单路径，而且此路径 具有以下的性质：不存在另一条这样的路径且有更小的权值。</p>\n<h3 id=\"最短路径树（Shortest-path-trees，-简称SPT）\"><a href=\"#最短路径树（Shortest-path-trees，-简称SPT）\" class=\"headerlink\" title=\"最短路径树（Shortest-path trees， 简称SPT）\"></a>最短路径树（Shortest-path trees， 简称SPT）</h3><p>给定一个图和一个指定的顶点s，则s的最短路径树是一个包含s以及由s可达的所有顶点的子图，它构成以s为根的一棵有向树，其中每条树路径都是图中的一条最短路径。最短路径树定义了从根到其它顶点的最短路径。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>图中最短路径问题主要是以下三类:</p>\n<ol>\n<li>源点－汇点最短路径</li>\n<li>单源最短路径</li>\n<li>全源最短路径</li>\n</ol>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>求图中最短路径的算法常用的有：</p>\n<ol>\n<li>Dijkstra算法</li>\n<li>Floyd-Warshall算法</li>\n<li>Bellman-Ford算法</li>\n</ol>\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><h4 id=\"边松弛（edge-relaxation）\"><a href=\"#边松弛（edge-relaxation）\" class=\"headerlink\" title=\"边松弛（edge relaxation）\"></a>边松弛（edge relaxation）</h4><p>检查一条给定的边，是否可以通过该边，对到其所指顶点的最短路径进行更新。</p>\n<p>不妨设有条边<code>e=(u,v)</code>，它的长度是<code>e.dist</code>， <code>d[i]</code>表示源点到顶点i的最短距离，则松弛操作如下： <code>if (d[v] &gt; d[u] + e.dist) d[v] = d[u] + e.dist</code> 上式的意思就是：如果从源点到u的最短距离加上u到v的长度小于当前源点到v的最短距离，那么更新源点到v的最短距离。 边松弛体现在Dijkstra算法和Bellman-Ford算法中</p>\n<h4 id=\"路径松弛（path-relaxation）\"><a href=\"#路径松弛（path-relaxation）\" class=\"headerlink\" title=\"路径松弛（path relaxation）\"></a>路径松弛（path relaxation）</h4><p>检查一个给定顶点，是否可以使得连接另外两个给定顶点的最短路径进行更新。</p>\n<p>不妨设现在有一个顶点x，还有另外两个顶点s和t。考虑能否通过x，使得s到t的最短距离变的更小，能的话，就进行路径松弛：<code>if (d[s][t] &gt; d[s][x] + d[x][t]) d[s][t] = d[s][x] + d[x][t]</code>上式的意思是：如果s到x的最短距离加上x到t的最短距离小于s到t的最短距离，那么更新s到t的最短距离。路径松弛体现在Floyd-Warshall算法中。</p>\n<h2 id=\"Dijkstra算法\"><a href=\"#Dijkstra算法\" class=\"headerlink\" title=\"Dijkstra算法\"></a>Dijkstra算法</h2><p>Dijkstra算法计算单源最短路径，它的基本思想：开始把源点放在SPT中，然后，每次增加一条边来构造SPT，所取的边总是可以给出从源点到尚未在SPT中的一个顶点的最短路径。也就是说，按照顶点与起始顶点的距离（通过SPT）为顺序来加入顶点。即：每次选不在SPT中距离源点最近的点加<br>入SPT。</p>\n<h3 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h3><ol>\n<li>初始化：顶点集S只包含源点，即S&#x3D;{v}，顶点集U包含除v外的其他顶点。</li>\n<li>从U中选取一个顶点u，它是源点v到U中最短路径长度最小的顶点，然后把顶点u加入S中（此时求出了源点v到顶点u的最短路径长度）。</li>\n<li>以顶点u为新考虑的中间点，修改顶点u的出边邻接点j的最短路径长度，此时源点v到顶点j的最短路径有两条，即一条经过顶点u，一条不经过顶点u。</li>\n<li>重复步骤2和3，直到S包含所有的顶点即U为空。</li>\n</ol>\n<h3 id=\"基于堆的Dijkstra算法代码\"><a href=\"#基于堆的Dijkstra算法代码\" class=\"headerlink\" title=\"基于堆的Dijkstra算法代码\"></a>基于堆的Dijkstra算法代码</h3><div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">Edge</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> from, to, dist;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">Edge</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">u</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">v</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">d</span><span style=\"color: #ABB2BF\">) : </span><span style=\"color: #61AFEF\">from</span><span style=\"color: #ABB2BF\">(u), </span><span style=\"color: #61AFEF\">to</span><span style=\"color: #ABB2BF\">(v), </span><span style=\"color: #61AFEF\">dist</span><span style=\"color: #ABB2BF\">(d) &#123;&#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">HeapNode</span><span style=\"color: #ABB2BF\"> &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> d, u;</span><span style=\"color: #7F848E; font-style: italic\"> // d表示该点到源点的距离，u是该点的编号</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">operator</span><span style=\"color: #ABB2BF\">&lt; (</span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">HeapNode</span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">rhs</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> d </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">rhs</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">d</span><span style=\"color: #ABB2BF\">; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span><span style=\"color: #7F848E; font-style: italic\"> // 小根堆</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">vector</span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\">Edge</span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> edges;</span><span style=\"color: #7F848E; font-style: italic\"> // edges存所有的边的信息</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">vector</span><span style=\"color: #C678DD\">&lt;int&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // G[i]是顶点i发出的所有边</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // 是否已经加入SPT</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // 每个点到源点的最短路径</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // 记录到顶点i的是哪条边</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">Dijkstra</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">s</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">V</span><span style=\"color: #ABB2BF\">) &#123;</span><span style=\"color: #7F848E; font-style: italic\"> // 计算所有顶点到顶点s的最短路径</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    priority_queue</span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\">HeapNode</span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> Q;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> INF;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[s] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 顶点s做源点</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">memset</span><span style=\"color: #ABB2BF\">(done, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">sizeof</span><span style=\"color: #ABB2BF\">(done));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">push</span><span style=\"color: #ABB2BF\">((HeapNode)&#123;</span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, s&#125;);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">empty</span><span style=\"color: #ABB2BF\">()) &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        HeapNode x </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">top</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">pop</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> u </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">x</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">u</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 把出队的队头元素的标号给u</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[u]) </span><span style=\"color: #C678DD\">continue</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 已经在SPT中就跳过</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 标记u在SPT中了</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u].</span><span style=\"color: #61AFEF\">size</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            Edge</span><span style=\"color: #56B6C2\">&amp;</span><span style=\"color: #ABB2BF\"> e </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i]];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">) &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">push</span><span style=\"color: #ABB2BF\">((HeapNode)&#123;</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">], </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">&#125;);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"></span></code></pre></div><h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>Dijkstra算法可以解决带有<strong>非负权值</strong>的<strong>单源最短路径</strong>问题，如果图中有负权值，则该算法不成立，因为它的前提是增加更多边时，路径的长度不会递减。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>利用优先队列实现的Dijkstra算法的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(ElogV)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span>，因为它是在一个规模最大是V的优先队列中进行V个插入，V个删除最小值，以及E个减少键值的操作。</p>\n<h2 id=\"Floyd-Warshall算法\"><a href=\"#Floyd-Warshall算法\" class=\"headerlink\" title=\"Floyd-Warshall算法\"></a>Floyd-Warshall算法</h2><p>Floyd-Warshall算法计算全源最短路径，它的本质是动态规划，用<code>d[i][j][k]</code>表示i到j的最短距离，而且该路径上的顶点的标号都小于等于k(除了源点和汇点)，那么下面的式子明显成立：<code>d[i][j][k] = min(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1])</code></p>\n<p>i到j中间标号最大是k的路径肯定是这样得到的：</p>\n<ol>\n<li>i到j，而且中间标号最大是k-1的最短路径，或者</li>\n<li>i到k，中间标号最大是k-1的最短路径加上了k到j，中间最大标号是k-1的最短路径。这两种情况里的小的就是要求的。</li>\n</ol>\n<p>这样就有了<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(V^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>的算法：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[MAXN][MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // 距离矩阵</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[MAXN][MAXN];</span><span style=\"color: #7F848E; font-style: italic\"> // 路径数组</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">FloydWarshall</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">V</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 初始化距离矩阵</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> j </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; j </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">j) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (i </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> j) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 同一顶点的距离为0</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            &#125; </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> INF;</span><span style=\"color: #7F848E; font-style: italic\"> // 不直接相连的顶点的距离设为无穷大</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">-</span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 初始化路径数组</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">     // 根据边的信息更新距离矩阵</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">size</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        Edge</span><span style=\"color: #56B6C2\">&amp;</span><span style=\"color: #ABB2BF\"> e </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">[i];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">from</span><span style=\"color: #ABB2BF\">][</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">from</span><span style=\"color: #ABB2BF\">][</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">from</span><span style=\"color: #ABB2BF\">][</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">from</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 计算最短路径</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> k </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; k </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">k) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> j </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; j </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">j) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][k] </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> INF </span><span style=\"color: #56B6C2\">&amp;&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[k][j] </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> INF </span><span style=\"color: #56B6C2\">&amp;&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][k] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[k][j]) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                    </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][k] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[k][j];</span><span style=\"color: #7F848E; font-style: italic\"> // 更新最短路径</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                    </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[k][j];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"></span></code></pre></div><h2 id=\"Bellman-Ford算法\"><a href=\"#Bellman-Ford算法\" class=\"headerlink\" title=\"Bellman-Ford算法\"></a>Bellman-Ford算法</h2><p>Bellman-Ford算法计算<strong>单源的最短路径</strong>。</p>\n<h3 id=\"基本思路\"><a href=\"#基本思路\" class=\"headerlink\" title=\"基本思路\"></a>基本思路</h3><p>为了计算一个从顶点s出发的最短路径，用<code>d[i]</code>表示源点s到i的最短路径，开始<code>d[s] = 0</code>，其它都是<strong>极大值</strong>，然后以任何顺序对每条边进行边松弛操作，完成V-1遍这样的操作，就可以得到各点到s的最短距离。</p>\n<p>我们可以用一个FIFO队列来保存这些顶点，每一遍处理的时候只检查这些顶点发出的边，对于沿着一条发出边 进行松弛时可能有效的所有顶点都放在一 个队列中，每次从队列中取一个顶点，并沿着它的所有边进行松弛。如果其中任何 一条边导致到达某个顶点的一条更短的路径，那么将该点放入队列中。</p>\n<h3 id=\"基于FIFO队列的Bellman-Ford算法\"><a href=\"#基于FIFO队列的Bellman-Ford算法\" class=\"headerlink\" title=\"基于FIFO队列的Bellman-Ford算法\"></a>基于FIFO队列的Bellman-Ford算法</h3><div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">bellman_ford</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">a</span><span style=\"color: #ABB2BF\">) &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    queue</span><span style=\"color: #C678DD\">&lt;int&gt;</span><span style=\"color: #ABB2BF\"> Q;</span><span style=\"color: #7F848E; font-style: italic\"> // FIFO队列</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">memset</span><span style=\"color: #ABB2BF\">(inq, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">sizeof</span><span style=\"color: #ABB2BF\">(inq));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">memset</span><span style=\"color: #ABB2BF\">(cnt, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">sizeof</span><span style=\"color: #ABB2BF\">(cnt));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> n; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> INF;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[s] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">inq</span><span style=\"color: #ABB2BF\">[s] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // inq[i] = true，表示顶点i在队列里</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">push</span><span style=\"color: #ABB2BF\">(s);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">empty</span><span style=\"color: #ABB2BF\">()) &#123; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> u </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">front</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">pop</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">inq</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">false</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> //u出队了，就不在队列里了</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u].</span><span style=\"color: #61AFEF\">size</span><span style=\"color: #ABB2BF\">(); i</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            Edge</span><span style=\"color: #56B6C2\">&amp;</span><span style=\"color: #ABB2BF\"> e </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i]];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> INF </span><span style=\"color: #56B6C2\">&amp;&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #E5C07B\">inq</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">]) &#123;</span><span style=\"color: #7F848E; font-style: italic\"> // 如果e.to不在队列里才入队，否则，不用再入队 </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                    </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">push</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">); </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                    </span><span style=\"color: #E5C07B\">inq</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                 </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">++</span><span style=\"color: #E5C07B\">cnt</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> n) </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">false</span><span style=\"color: #ABB2BF\">; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            &#125; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"></span></code></pre></div><h2 id=\"负环\"><a href=\"#负环\" class=\"headerlink\" title=\"负环\"></a>负环</h2><p>利用Bellman-Ford算法很容易来检查一个图是否存在负环。因为最多进行V-1遍所有边的松弛操作，所以V-1遍后看，是否有新的元素入队？有，就存在负环；否则，则没有。上述代码最后返回true就是无负环，返回false就是有负环。用FIFO队列不好判断哪些是一遍的操作，所以用了<code>cnt</code>数组，<code>cnt[i]</code>表示顶点i入队几次了，反正如果无负环，<code>cnt[i]</code>不会超过n，否则，最后必超过（可能是超过V-1遍操作后）。 </p>\n<p>Floyd_Warshall算法也能判断图中是否有负环，只要最后检查是否有d[i][i]是负的。上面程序最坏情况下运行时间仍和VE成正比，对于稠密图，运行时间可能不比Floyd好，对于稀疏图则最快可能快V倍。注意Floyd只能求所有的最短路径，不会因为你是求某点出发的最短路径而可以减少运行时间。实战中利用FIFO队列实现的Bellman-Ford算法效果相当好。</p>\n<p>目前对于求有负环的最短路径是NP困难的。</p>\n","text":"最短路径 Shortest Path加权有向图中每条路径都有值，其值是该路径上所有边的权值之和。最短路径 （Shortest Path）问题就是指求出两个给定顶...","permalink":"/post/ea135958f52dc15115556a781c9e36cf","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"algorithms","slug":"algorithms","count":8,"path":"api/tags/algorithms.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Shortest-Path\"><span class=\"toc-text\">最短路径 Shortest Path</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91%EF%BC%88Shortest-path-trees%EF%BC%8C-%E7%AE%80%E7%A7%B0SPT%EF%BC%89\"><span class=\"toc-text\">最短路径树（Shortest-path trees， 简称SPT）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">基本操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%B9%E6%9D%BE%E5%BC%9B%EF%BC%88edge-relaxation%EF%BC%89\"><span class=\"toc-text\">边松弛（edge relaxation）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E5%BE%84%E6%9D%BE%E5%BC%9B%EF%BC%88path-relaxation%EF%BC%89\"><span class=\"toc-text\">路径松弛（path relaxation）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Dijkstra%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Dijkstra算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">具体步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E5%A0%86%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">基于堆的Dijkstra算法代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">注意</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Floyd-Warshall%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Floyd-Warshall算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Bellman-Ford%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Bellman-Ford算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">基本思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8EFIFO%E9%98%9F%E5%88%97%E7%9A%84Bellman-Ford%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">基于FIFO队列的Bellman-Ford算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B4%9F%E7%8E%AF\"><span class=\"toc-text\">负环</span></a></li></ol>","author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"拓扑排序 Topological Sort","uid":"92091d0d673d2f304a54eaf158ea4630","slug":"92091d0d673d2f304a54eaf158ea4630","date":"2023-06-25T06:31:20.000Z","updated":"2024-03-17T05:30:05.842Z","comments":true,"path":"api/articles/92091d0d673d2f304a54eaf158ea4630.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","text":"拓扑排序 Topological Sort拓扑序列 Topological Order拓扑序列是一个有向无环图（Directed Acyclic Graph，简...","permalink":"/post/92091d0d673d2f304a54eaf158ea4630","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"algorithms","slug":"algorithms","count":8,"path":"api/tags/algorithms.json"}],"author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"最小生成树 Minimum Spanning Tree","uid":"3bb7227ed966054de259b7b7501c2568","slug":"3bb7227ed966054de259b7b7501c2568","date":"2023-06-23T08:05:39.000Z","updated":"2024-03-17T05:29:47.010Z","comments":true,"path":"api/articles/3bb7227ed966054de259b7b7501c2568.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","text":"最小生成树 Minimum Spanning Tree加权无向图的最小生成树（Minimum Spanning Tree，简称MST）是一棵生成树，其权（所有边...","permalink":"/post/3bb7227ed966054de259b7b7501c2568","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"algorithms","slug":"algorithms","count":8,"path":"api/tags/algorithms.json"}],"author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}