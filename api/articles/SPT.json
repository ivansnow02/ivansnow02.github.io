{"title":"最短路径 Shortest Path","uid":"ea135958f52dc15115556a781c9e36cf","slug":"SPT","date":"2023-06-24T02:56:20.000Z","updated":"2024-03-17T05:29:57.892Z","comments":true,"path":"api/articles/SPT.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","content":"<h2 id=\"最短路径-shortest-path\"><a class=\"markdownIt-Anchor\" href=\"#最短路径-shortest-path\"></a> 最短路径 Shortest Path</h2>\n<p>加权有向图中每条路径都有值，其值是该路径上所有边的权值之和。最短路径 （Shortest Path）问题就是指求出两个给定顶点间权值最小的路径。</p>\n<h3 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\"></a> 定义</h3>\n<p>两个顶点s和t之间的一条最短路径 是从s到t的一条有向简单路径，而且此路径 具有以下的性质：不存在另一条这样的路径且有更小的权值。</p>\n<h3 id=\"最短路径树shortest-path-trees-简称spt\"><a class=\"markdownIt-Anchor\" href=\"#最短路径树shortest-path-trees-简称spt\"></a> 最短路径树（Shortest-path trees， 简称SPT）</h3>\n<p>给定一个图和一个指定的顶点s，则s的最短路径树是一个包含s以及由s可达的所有顶点的子图，它构成以s为根的一棵有向树，其中每条树路径都是图中的一条最短路径。最短路径树定义了从根到其它顶点的最短路径。</p>\n<h3 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\"></a> 分类</h3>\n<p>图中最短路径问题主要是以下三类:</p>\n<ol>\n<li>源点－汇点最短路径</li>\n<li>单源最短路径</li>\n<li>全源最短路径</li>\n</ol>\n<h3 id=\"算法\"><a class=\"markdownIt-Anchor\" href=\"#算法\"></a> 算法</h3>\n<p>求图中最短路径的算法常用的有：</p>\n<ol>\n<li>Dijkstra算法</li>\n<li>Floyd-Warshall算法</li>\n<li>Bellman-Ford算法</li>\n</ol>\n<p>###　基本操作</p>\n<h4 id=\"边松弛edge-relaxation\"><a class=\"markdownIt-Anchor\" href=\"#边松弛edge-relaxation\"></a> 边松弛（edge relaxation）</h4>\n<p>检查一条给定的边，是否可以通过该边，对到其所指顶点的最短路径进行更新。</p>\n<p>不妨设有条边<code>e=(u,v)</code>，它的长度是<code>e.dist</code>， <code>d[i]</code>表示源点到顶点i的最短距离，则松弛操作如下： <code>if (d[v] &gt; d[u] + e.dist) d[v] = d[u] + e.dist</code> 上式的意思就是：如果从源点到u的最短距离加上u到v的长度小于当前源点到v的最短距离，那么更新源点到v的最短距离。 边松弛体现在Dijkstra算法和Bellman-Ford算法中</p>\n<h4 id=\"路径松弛path-relaxation\"><a class=\"markdownIt-Anchor\" href=\"#路径松弛path-relaxation\"></a> 路径松弛（path relaxation）</h4>\n<p>检查一个给定顶点，是否可以使得连接另外两个给定顶点的最短路径进行更新。</p>\n<p>不妨设现在有一个顶点x，还有另外两个顶点s和t。考虑能否通过x，使得s到t的最短距离变的更小，能的话，就进行路径松弛：<code>if (d[s][t] &gt; d[s][x] + d[x][t]) d[s][t] = d[s][x] + d[x][t]</code>上式的意思是：如果s到x的最短距离加上x到t的最短距离小于s到t的最短距离，那么更新s到t的最短距离。路径松弛体现在Floyd-Warshall算法中。</p>\n<h2 id=\"dijkstra算法\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra算法\"></a> Dijkstra算法</h2>\n<p>Dijkstra算法计算单源最短路径，它的基本思想：开始把源点放在SPT中，然后，每次增加一条边来构造SPT，所取的边总是可以给出从源点到尚未在SPT中的一个顶点的最短路径。也就是说，按照顶点与起始顶点的距离（通过SPT）为顺序来加入顶点。即：每次选不在SPT中距离源点最近的点加<br />\n入SPT。</p>\n<h3 id=\"具体步骤\"><a class=\"markdownIt-Anchor\" href=\"#具体步骤\"></a> 具体步骤</h3>\n<ol>\n<li>初始化：顶点集S只包含源点，即S={v}，顶点集U包含除v外的其他顶点。</li>\n<li>从U中选取一个顶点u，它是源点v到U中最短路径长度最小的顶点，然后把顶点u加入S中（此时求出了源点v到顶点u的最短路径长度）。</li>\n<li>以顶点u为新考虑的中间点，修改顶点u的出边邻接点j的最短路径长度，此时源点v到顶点j的最短路径有两条，即一条经过顶点u，一条不经过顶点u。</li>\n<li>重复步骤2和3，直到S包含所有的顶点即U为空。</li>\n</ol>\n<h3 id=\"基于堆的dijkstra算法代码\"><a class=\"markdownIt-Anchor\" href=\"#基于堆的dijkstra算法代码\"></a> 基于堆的Dijkstra算法代码</h3>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">Edge</span><span style=\"color: #ABB2BF\"> {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> from, to, dist;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">Edge</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">u</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">v</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">d</span><span style=\"color: #ABB2BF\">) : </span><span style=\"color: #61AFEF; font-weight: bold\">from</span><span style=\"color: #ABB2BF\">(u), </span><span style=\"color: #61AFEF; font-weight: bold\">to</span><span style=\"color: #ABB2BF\">(v), </span><span style=\"color: #61AFEF; font-weight: bold\">dist</span><span style=\"color: #ABB2BF\">(d) {}</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">};</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">HeapNode</span><span style=\"color: #ABB2BF\"> { </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> d, u;</span><span style=\"color: #7F848E\"> // d表示该点到源点的距离，u是该点的编号</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">operator</span><span style=\"color: #ABB2BF\">&lt; (</span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">HeapNode</span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">rhs</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> d </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">rhs</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">d</span><span style=\"color: #ABB2BF\">; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span><span style=\"color: #7F848E\"> // 小根堆</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">};</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">vector</span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\">Edge</span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> edges;</span><span style=\"color: #7F848E\"> // edges存所有的边的信息</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">vector</span><span style=\"color: #C678DD\">&lt;int&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E\"> // G[i]是顶点i发出的所有边</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E\"> // 是否已经加入SPT</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E\"> // 每个点到源点的最短路径</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[MAXN];</span><span style=\"color: #7F848E\"> // 记录到顶点i的是哪条边</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">Dijkstra</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">s</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">V</span><span style=\"color: #ABB2BF\">) {</span><span style=\"color: #7F848E\"> // 计算所有顶点到顶点s的最短路径</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    priority_queue</span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\">HeapNode</span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> Q;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> INF;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[s] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\"> // 顶点s做源点</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">memset</span><span style=\"color: #ABB2BF\">(done, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">sizeof</span><span style=\"color: #ABB2BF\">(done));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">push</span><span style=\"color: #ABB2BF\">((HeapNode){</span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, s});</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">empty</span><span style=\"color: #ABB2BF\">()) { </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        HeapNode x </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">top</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">pop</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> u </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">x</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">u</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\"> // 把出队的队头元素的标号给u</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[u]) </span><span style=\"color: #C678DD\">continue</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\"> // 已经在SPT中就跳过</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">done</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\"> // 标记u在SPT中了</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u].</span><span style=\"color: #61AFEF; font-weight: bold\">size</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) { </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            Edge</span><span style=\"color: #56B6C2\">&amp;</span><span style=\"color: #ABB2BF\"> e </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i]];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">) { </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">push</span><span style=\"color: #ABB2BF\">((HeapNode){</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">], </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">});</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div></div></figure>\n<h3 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\"></a> 注意</h3>\n<p>Dijkstra算法可以解决带有<strong>非负权值</strong>的<strong>单源最短路径</strong>问题，如果图中有负权值，则该算法不成立，因为它的前提是增加更多边时，路径的长度不会递减。</p>\n<h3 id=\"分析\"><a class=\"markdownIt-Anchor\" href=\"#分析\"></a> 分析</h3>\n<p>利用优先队列实现的Dijkstra算法的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(ElogV)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span>，因为它是在一个规模最大是V的优先队列中进行V个插入，V个删除最小值，以及E个减少键值的操作。</p>\n<h2 id=\"floyd-warshall算法\"><a class=\"markdownIt-Anchor\" href=\"#floyd-warshall算法\"></a> Floyd-Warshall算法</h2>\n<p>Floyd-Warshall算法计算全源最短路径，它的本质是动态规划，用<code>d[i][j][k]</code>表示i到j的最短距离，而且该路径上的顶点的标号都小于等于k(除了源点和汇点)，那么下面的式子明显成立：<code>d[i][j][k] = min(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1])</code></p>\n<p>i到j中间标号最大是k的路径肯定是这样得到的：</p>\n<ol>\n<li>i到j，而且中间标号最大是k-1的最短路径，或者</li>\n<li>i到k，中间标号最大是k-1的最短路径加上了k到j，中间最大标号是k-1的最短路径。这两种情况里的小的就是要求的。</li>\n</ol>\n<p>这样就有了<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>V</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(V^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>的算法：</p>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[MAXN][MAXN];</span><span style=\"color: #7F848E\"> // 距离矩阵</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[MAXN][MAXN];</span><span style=\"color: #7F848E\"> // 路径数组</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">FloydWarshall</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">V</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #7F848E\">    // 初始化距离矩阵</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> j </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; j </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">j) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (i </span><span style=\"color: #C678DD\">==</span><span style=\"color: #ABB2BF\"> j) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\"> // 同一顶点的距离为0</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            } </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\"> {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> INF;</span><span style=\"color: #7F848E\"> // 不直接相连的顶点的距离设为无穷大</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">-</span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\"> // 初始化路径数组</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E\">     // 根据边的信息更新距离矩阵</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">size</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        Edge</span><span style=\"color: #56B6C2\">&amp;</span><span style=\"color: #ABB2BF\"> e </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">[i];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">from</span><span style=\"color: #ABB2BF\">][</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">from</span><span style=\"color: #ABB2BF\">][</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">from</span><span style=\"color: #ABB2BF\">][</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">from</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span></span>\n<span class=\"line\"><span style=\"color: #7F848E\">    // 计算最短路径</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> k </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; k </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">k) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> j </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; j </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> V; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">j) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][k] </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> INF </span><span style=\"color: #56B6C2\">&amp;&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[k][j] </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> INF </span><span style=\"color: #56B6C2\">&amp;&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][k] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[k][j]) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                    </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i][k] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[k][j];</span><span style=\"color: #7F848E\"> // 更新最短路径</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                    </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[i][j] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[k][j];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div></div></figure>\n<h2 id=\"bellman-ford算法\"><a class=\"markdownIt-Anchor\" href=\"#bellman-ford算法\"></a> Bellman-Ford算法</h2>\n<p>Bellman-Ford算法计算<strong>单源的最短路径</strong>。</p>\n<h3 id=\"基本思路\"><a class=\"markdownIt-Anchor\" href=\"#基本思路\"></a> 基本思路</h3>\n<p>为了计算一个从顶点s出发的最短路径，用<code>d[i]</code>表示源点s到i的最短路径，开始<code>d[s] = 0</code>，其它都是<strong>极大值</strong>，然后以任何顺序对每条边进行边松弛操作，完成V-1遍这样的操作，就可以得到各点到s的最短距离。</p>\n<p>我们可以用一个FIFO队列来保存这些顶点，每一遍处理的时候只检查这些顶点发出的边，对于沿着一条发出边 进行松弛时可能有效的所有顶点都放在一 个队列中，每次从队列中取一个顶点，并沿着它的所有边进行松弛。如果其中任何 一条边导致到达某个顶点的一条更短的路径，那么将该点放入队列中。</p>\n<h3 id=\"基于fifo队列的bellman-ford算法\"><a class=\"markdownIt-Anchor\" href=\"#基于fifo队列的bellman-ford算法\"></a> 基于FIFO队列的Bellman-Ford算法</h3>\n<figure class=\"shiki cpp\"><div class='codeblock'><div class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></div><div class=\"code\"><pre class=\"shiki One Dark Pro\"><code><span class=\"line\"><span style=\"color: #C678DD\">bool</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF; font-weight: bold\">bellman_ford</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">) { </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    queue</span><span style=\"color: #C678DD\">&lt;int&gt;</span><span style=\"color: #ABB2BF\"> Q;</span><span style=\"color: #7F848E\"> // FIFO队列</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">memset</span><span style=\"color: #ABB2BF\">(inq, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">sizeof</span><span style=\"color: #ABB2BF\">(inq));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF; font-weight: bold\">memset</span><span style=\"color: #ABB2BF\">(cnt, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #C678DD\">sizeof</span><span style=\"color: #ABB2BF\">(cnt));</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> n; </span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">i) </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[i] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> INF;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[s] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">inq</span><span style=\"color: #ABB2BF\">[s] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\"> // inq[i] = true，表示顶点i在队列里</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">push</span><span style=\"color: #ABB2BF\">(s);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">empty</span><span style=\"color: #ABB2BF\">()) { </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> u </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">front</span><span style=\"color: #ABB2BF\">(); </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">pop</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">inq</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">false</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E\"> //u出队了，就不在队列里了</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">for</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> i </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">; i </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u].</span><span style=\"color: #61AFEF; font-weight: bold\">size</span><span style=\"color: #ABB2BF\">(); i</span><span style=\"color: #C678DD\">++</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            Edge</span><span style=\"color: #56B6C2\">&amp;</span><span style=\"color: #ABB2BF\"> e </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">edges</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i]];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #C678DD\">&lt;</span><span style=\"color: #ABB2BF\"> INF </span><span style=\"color: #56B6C2\">&amp;&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">d</span><span style=\"color: #ABB2BF\">[u] </span><span style=\"color: #56B6C2\">+</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">dist</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #E5C07B\">p</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">G</span><span style=\"color: #ABB2BF\">[u][i];</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #E5C07B\">inq</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">]) {</span><span style=\"color: #7F848E\"> // 如果e.to不在队列里才入队，否则，不用再入队 </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                    </span><span style=\"color: #E5C07B\">Q</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF; font-weight: bold\">push</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">); </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                    </span><span style=\"color: #E5C07B\">inq</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                 </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">++</span><span style=\"color: #E5C07B\">cnt</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #E5C07B\">e</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">to</span><span style=\"color: #ABB2BF\">] </span><span style=\"color: #C678DD\">&gt;</span><span style=\"color: #ABB2BF\"> n) </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">false</span><span style=\"color: #ABB2BF\">; </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            } </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        } </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    }</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">true</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div></div></figure>\n<h2 id=\"负环\"><a class=\"markdownIt-Anchor\" href=\"#负环\"></a> 负环</h2>\n<p>利用Bellman-Ford算法很容易来检查一个图是否存在负环。因为最多进行V-1遍所有边的松弛操作，所以V-1遍后看，是否有新的元素入队？有，就存在负环；否则，则没有。上述代码最后返回true就是无负环，返回false就是有负环。用FIFO队列不好判断哪些是一遍的操作，所以用了<code>cnt</code>数组，<code>cnt[i]</code>表示顶点i入队几次了，反正如果无负环，<code>cnt[i]</code>不会超过n，否则，最后必超过（可能是超过V-1遍操作后）。</p>\n<p>Floyd_Warshall算法也能判断图中是否有负环，只要最后检查是否有d[i][i]是负的。上面程序最坏情况下运行时间仍和VE成正比，对于稠密图，运行时间可能不比Floyd好，对于稀疏图则最快可能快V倍。注意Floyd只能求所有的最短路径，不会因为你是求某点出发的最短路径而可以减少运行时间。实战中利用FIFO队列实现的Bellman-Ford算法效果相当好。</p>\n<p>目前对于求有负环的最短路径是NP困难的。</p>\n","text":" 最短路径 Shortest Path 加权有向图中每条路径都有值，其值是该路径上所有边的权值之和。最短路径 （Shortest Path）问题就是指求出两个给...","permalink":"/post/SPT","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"algorithms","slug":"algorithms","count":8,"path":"api/tags/algorithms.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-shortest-path\"><span class=\"toc-text\"> 最短路径 Shortest Path</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\"> 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91shortest-path-trees-%E7%AE%80%E7%A7%B0spt\"><span class=\"toc-text\"> 最短路径树（Shortest-path trees， 简称SPT）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%B1%BB\"><span class=\"toc-text\"> 分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> 算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%B9%E6%9D%BE%E5%BC%9Bedge-relaxation\"><span class=\"toc-text\"> 边松弛（edge relaxation）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E5%BE%84%E6%9D%BE%E5%BC%9Bpath-relaxation\"><span class=\"toc-text\"> 路径松弛（path relaxation）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dijkstra%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> Dijkstra算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\"> 具体步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E5%A0%86%E7%9A%84dijkstra%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\"> 基于堆的Dijkstra算法代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\"> 注意</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90\"><span class=\"toc-text\"> 分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#floyd-warshall%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> Floyd-Warshall算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bellman-ford%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> Bellman-Ford算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\"> 基本思路</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8Efifo%E9%98%9F%E5%88%97%E7%9A%84bellman-ford%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> 基于FIFO队列的Bellman-Ford算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B4%9F%E7%8E%AF\"><span class=\"toc-text\"> 负环</span></a></li></ol>","author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"拓扑排序 Topological Sort","uid":"92091d0d673d2f304a54eaf158ea4630","slug":"TS","date":"2023-06-25T06:31:20.000Z","updated":"2024-03-17T05:30:05.842Z","comments":true,"path":"api/articles/TS.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","text":" 拓扑排序 Topological Sort 拓扑序列 Topological Order 拓扑序列是一个有向无环图（Directed Acyclic Grap...","permalink":"/post/TS","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"algorithms","slug":"algorithms","count":8,"path":"api/tags/algorithms.json"}],"author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"最小生成树 Minimum Spanning Tree","uid":"3bb7227ed966054de259b7b7501c2568","slug":"MST","date":"2023-06-23T08:05:39.000Z","updated":"2024-03-17T05:29:47.010Z","comments":true,"path":"api/articles/MST.json","keywords":"Code, Learning, Backend, Frontend","cover":"/img/DS.png","text":" 最小生成树 Minimum Spanning Tree 加权无向图的最小生成树（Minimum Spanning Tree，简称MST）是一棵生成树，其权（所...","permalink":"/post/MST","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"data structure","slug":"data-structure","count":11,"path":"api/categories/data-structure.json"}],"tags":[{"name":"data structure","slug":"data-structure","count":13,"path":"api/tags/data-structure.json"},{"name":"coding","slug":"coding","count":19,"path":"api/tags/coding.json"},{"name":"algorithms","slug":"algorithms","count":8,"path":"api/tags/algorithms.json"}],"author":{"name":"Ivan Snow","slug":"blog-author","avatar":"https://ivansnow02.github.io/img/avatar.png","link":"/","description":"目前就读于某大学的计算机科学与技术专业，在学习后端与CV中","socials":{"github":"https://github.com/ivansnow02","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}