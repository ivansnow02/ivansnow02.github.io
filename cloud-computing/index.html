<!DOCTYPE html><html lang="zh-CN"><head>
  <link rel="manifest" href="/manifest.json">
  <link rel="stylesheet" href="/css/custom.css">
  <link href="https://fastly.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" rel="stylesheet">
  <link href="/css/custom.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.loli.net">
  <link rel="preconnect" href="https://gstatic.loli.net" crossorigin>
  <link href="https://fonts.loli.net/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
<meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/img/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png"><meta name="msvalidate.01" content="5C885BB4F08198773FCB9D68FB7EFF0C"><meta name="google-site-verification" content="SU_V4YfQlQkkbm4IQUajehIwRUPbvIwErs1WJRMD0NQ"><link rel="alternate" href="/rss.xml" title="IOyuk1Nya's Blog" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="IOyuk1Nya's Blog" type="application/atom+xml"><link rel="alternate" type="application/json" title="IOyuk1Nya's Blog" href="https://blog.ivansnow02.xyz/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CJuliamo:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CJetBrains%20Mono:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.25"><link rel="modulepreload" href="/js/chunk-6NK3SN44.js"><link rel="modulepreload" href="/js/chunk-AZO4VBGZ.js"><link rel="modulepreload" href="/js/chunk-BPYIVRTA.js"><link rel="modulepreload" href="/js/chunk-LPZ6IRR4.js"><link rel="modulepreload" href="/js/chunk-WOOM3R6Q.js"><link rel="modulepreload" href="/js/copy-tex-2I2YH6US.js"><link rel="modulepreload" href="/js/index.esm-3KWC6NJD.js"><link rel="modulepreload" href="/js/post-JUZJSDUJ.js"><link rel="modulepreload" href="/js/quicklink-FZ4URYZU.js"><link rel="modulepreload" href="/js/search-4QXF47JZ.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="modulepreload" href="/js/tcomments-CXMVEAGL.js"><link rel="preload" href="https://blog.ivansnow02.xyz/blog-img/59bcba93d944d6057250d5ea80b18ec2390418501%202.png" as="image" fetchpriority="high"><meta name="keywords" content="computer science,cloud computing"><meta name="description" content="some notes about computer science"><link rel="canonical" href="https://blog.ivansnow02.xyz/cloud-computing/"><title>cloud_computing</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">cloud_computing</h1><div class="meta"><span class="item" title="创建时间：2025-04-17 08:16:40"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2025-04-17T08:16:40+08:00">2025-04-17</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>35k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>32 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Code Blog</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://blog.ivansnow02.xyz/blog-img/59bcba93d944d6057250d5ea80b18ec2390418501%202.png" loading="eager" decoding="async" fetchpriority="high" alt="IOyuk1Nya's Blog"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于computer science"><span itemprop="name">computer science<meta itemprop="position" content="0"></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.ivansnow02.xyz/cloud-computing/"><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/avatar.png"><meta itemprop="name" content="IOyuk1Nya"><meta itemprop="description" content="Just a Note., some notes about computer science"></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="IOyuk1Nya's Blog"></span><div class="body md" itemprop="articleBody"><h2 id="大数据与云计算"><a class="anchor" href="#大数据与云计算">#</a> 大数据与云计算</h2>
<h3 id="大数据时代"><a class="anchor" href="#大数据时代">#</a> 大数据时代</h3>
<h4 id="大数据定义"><a class="anchor" href="#大数据定义">#</a> 大数据定义</h4>
<p>指规模巨大，无法在合理时间内用主流 IT 系统进行采集、存储、管理、处理和分析，以支持决策的海量数据集。</p>
<h4 id="大数据特征-4v1c"><a class="anchor" href="#大数据特征-4v1c">#</a> 大数据特征 (4V+1C)</h4>
<ul>
<li><strong>Volume (量)</strong>: 数据量巨大 (PB 级常见)。</li>
<li><strong>Velocity (速)</strong>: 数据产生速度快，需要快速处理。</li>
<li><strong>Variety (类)</strong>: 格式多样 (结构化、半结构化、非结构化数据，如文本、音频、视频)。</li>
<li><strong>Value (值)</strong>: 初始价值密度低，需要处理才能提取重要价值。</li>
<li><strong>Complexity (复杂性)</strong>: 处理和分析难度大。</li>
</ul>
<h3 id="云计算大数据的计算"><a class="anchor" href="#云计算大数据的计算">#</a> 云计算 —— 大数据的计算</h3>
<h4 id="云计算和大数据关系"><a class="anchor" href="#云计算和大数据关系">#</a> 云计算和大数据关系</h4>
<ul>
<li>类比: G = f (x)，其中目标 (G) 通过云计算 (f) 对大数据 (x) 进行处理来实现。</li>
<li>云计算是处理大数据的<strong>手段</strong>。</li>
<li>两者相互依存：没有大数据，不需要云计算；没有云计算，无法有效处理大数据。</li>
</ul>
<h4 id="云计算的起源与定义"><a class="anchor" href="#云计算的起源与定义">#</a> 云计算的起源与定义</h4>
<ul>
<li>
<p><strong>初始概念</strong>：像公用事业 (水、电) 一样提供海量资源池，按需付费；从拥有资源转向共享资源 (类似公共交通 vs 私家车)</p>
</li>
<li>
<p><strong>定义</strong>:</p>
<ul>
<li><strong>长定义</strong>：一种商业计算模型，将任务分布在资源池上，提供按需的计算、存储和信息服务。</li>
<li><strong>短定义</strong>：通过网络提供按需、动态可扩展、廉价的计算服务。</li>
<li><strong>通用定义</strong>：一种分布式计算的商业模式，利用大量廉价机器构建可靠的海量资源池，通过网络按需访问。</li>
</ul>
</li>
</ul>
<h4 id="云计算的核心概念资源池"><a class="anchor" href="#云计算的核心概念资源池">#</a> 云计算的核心概念：资源池</h4>
<ul>
<li>“云” = 大规模的 (通常是<strong>廉价</strong>) 服务器集群。</li>
<li>资源被池化、虚拟化，并通过软件进行管理以实现可靠性和自我维护。</li>
<li>计算能力通过互联网作为商品提供。</li>
<li>用户动态按需访问资源，专注于业务逻辑。</li>
</ul>
<h4 id="云计算的关键特征-7个"><a class="anchor" href="#云计算的关键特征-7个">#</a> 云计算的关键特征 (7 个)</h4>
<ul>
<li><strong>超大规模</strong></li>
<li><strong>虚拟化</strong></li>
<li><strong>高可靠性</strong></li>
<li><strong>通用性</strong></li>
<li><strong>高可伸缩性</strong></li>
<li><strong>按需服务</strong></li>
<li><strong>极其廉价</strong> (规模经济)</li>
</ul>
<h4 id="云计算的商业特征"><a class="anchor" href="#云计算的商业特征">#</a> 云计算的商业特征</h4>
<ul>
<li>是一种商业模式 / 产业技术，不仅仅是学术研究。</li>
<li>注重<strong>实用性</strong>和<strong>经济性</strong>。</li>
<li>整合了成熟技术：互联网、分布式计算、虚拟化、自治管理。</li>
</ul>
<h3 id="云计算发展现状"><a class="anchor" href="#云计算发展现状">#</a> 云计算发展现状</h3>
<h4 id="服务模式分层"><a class="anchor" href="#服务模式分层">#</a> 服务模式分层</h4>
<ul>
<li><strong>IaaS (基础设施即服务)</strong>: 基础计算 / 存储 / 网络 (例如 Amazon EC2/S3, 阿里云 ECS)。面向系统开发者。(通用)</li>
<li><strong>PaaS (平台即服务)</strong>: 应用运行环境 (例如 Google App Engine, Azure, Hadoop)。面向应用开发者。</li>
<li><strong>SaaS (软件即服务)</strong>: 即用型应用程序 (例如 Salesforce CRM, Alexa Web)。面向最终用户。(专用)</li>
</ul>
<h4 id="部署模式"><a class="anchor" href="#部署模式">#</a> 部署模式</h4>
<ul>
<li><strong>公有云</strong>：对公众开放，由提供商管理。</li>
<li><strong>私有云</strong>：为单个组织服务，自行管理或由第三方管理。</li>
<li><strong>混合云</strong>：公有云和私有云的结合。</li>
</ul>
<h3 id="云计算实现机制"><a class="anchor" href="#云计算实现机制">#</a> 云计算实现机制</h3>
<h4 id="分层架构"><a class="anchor" href="#分层架构">#</a> 分层架构</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/2db4b87c98ac660c18ff0692c97fa3d9a38c07d91a211efd95943e9761f63d90.png" alt="picture 0"></p>
<ul>
<li><strong>物理资源层</strong>：计算机、存储、网络、数据库、软件。</li>
<li><strong>资源池层</strong>：对物理资源进行分组 (计算池、存储池、网络池、数据池、软件池)。</li>
<li><strong>管理中间件层</strong>：管理资源、任务、用户、安全。(关键组件)。包括用户 / 任务 / 资源 / 安全管理子模块 (负载均衡、故障处理、监控、认证 / 授权、计费等)。</li>
<li><strong>SOA (面向服务的架构) 层</strong>：将能力暴露为标准的 Web 服务 (接口、注册、发现、调用、工作流)。</li>
</ul>
<h3 id="云计算优势"><a class="anchor" href="#云计算优势">#</a> 云计算优势</h3>
<h4 id="成本效益"><a class="anchor" href="#成本效益">#</a> 成本效益</h4>
<ul>
<li>解决传统 IT 成本上升问题 (管理、电力 / 冷却)</li>
<li><strong>规模经济</strong>：大型数据中心单位成本显著降低 (网络、存储、管理)</li>
<li><strong>优化选址</strong>：部署在电力廉价 (水电)、气候凉爽、土地成本低的地区</li>
<li><strong>自动化</strong>：降低人力成本</li>
<li><strong>高利用率</strong>：云计算利用率约 80%，而传统 IT 仅 10-15%，总成本节省超过 30 倍</li>
</ul>
<h4 id="用户收益"><a class="anchor" href="#用户收益">#</a> 用户收益</h4>
<ul>
<li>低规格的客户端设备即可满足需求。</li>
<li>按需付费模式使得用户能以可承受的价格获得强大的资源。</li>
<li>无需购买 / 维护软件或担心硬件升级。</li>
<li>节省资源，环境友好。</li>
</ul>
<h4 id="核心架构思想"><a class="anchor" href="#核心架构思想">#</a> 核心架构思想</h4>
<ul>
<li>“团结就是力量” - 许多廉价的商用机器协同工作，提供大规模、可靠、高性能的服务 (类比：鱼群 vs 鲨鱼)。</li>
</ul>
<h2 id="复习题-习题"><a class="anchor" href="#复习题-习题">#</a> 复习题 (习题)</h2>
<ul>
<li>
<p><strong>大数据是如何形成的</strong><br>
数据产生方式的改变；人类的活动越来越依赖数据</p>
</li>
<li>
<p><strong>新摩尔定律 (Jim Gray 版本) 的含义</strong></p>
<ul>
<li>全球信息量呈指数增长：每 18 个月产生的新数据量等同于此前累积的全部数据总和</li>
<li>强调数据规模爆炸式扩大，说明对存储、计算和分析能力提出了更高要求</li>
<li>反映信息技术和社会活动对数据生成与处理的双重推动作用</li>
</ul>
</li>
<li>
<p><strong>云计算的特征</strong></p>
<ul>
<li>虚拟化：对计算、存储、网络资源进行抽象与隔离，提高利用率与灵活性。</li>
<li>按需服务：动态分配与释放资源，用户只为实际使用付费。</li>
<li>商用硬件：使用廉价大规模服务器构建资源池，降低总体成本。</li>
<li>通用性：支持多种应用场景与工作负载。</li>
<li>可靠性：通过冗余、故障检测与自动恢复保障服务可用。</li>
<li>可伸缩性：根据负载变化快速横向或纵向扩展资源。</li>
</ul>
</li>
<li>
<p><strong>云计算的分类</strong></p>
<ul>
<li>服务模型
<ul>
<li>IaaS（基础设施即服务）</li>
<li>PaaS（平台即服务）</li>
<li>SaaS（软件即服务）</li>
</ul>
</li>
<li>部署模式
<ul>
<li>公有云：第三方提供商面向公共的云服务。</li>
<li>私有云：组织内部或委托第三方私有部署。</li>
<li>混合云：公有云与私有云结合，兼顾灵活性与安全性。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>云计算的架构层次</strong></p>
<ol>
<li>物理层：物理服务器、存储、网络设备等硬件资源。</li>
<li>资源池层：通过虚拟化将物理资源划分为计算池、存储池、网络池等。</li>
<li>中间件层：负责资源管理、调度、监控、安全和计费等核心功能。</li>
<li>服务 / SOA 层：以标准化 API 或 Web 服务形式向用户暴露能力。</li>
</ol>
</li>
<li>
<p><strong>云计算相对于传统 IT 的成本优势</strong></p>
<ul>
<li>规模经济：大规模数据中心降低单位硬件和运维成本。</li>
<li>按需付费：避免闲置资源浪费，费用与使用量挂钩。</li>
<li>自动化运维：集中管理、自动部署和弹性伸缩减少人力成本。</li>
<li>高资源利用率：多租户共享提高硬件利用率，进一步降低总体投入。</li>
</ul>
</li>
</ul>
<h2 id="分布式计算"><a class="anchor" href="#分布式计算">#</a> 分布式计算</h2>
<h3 id="分布式计算概述"><a class="anchor" href="#分布式计算概述">#</a> 分布式计算概述</h3>
<h4 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h4>
<ul>
<li><strong>集中式计算</strong>:
<ul>
<li>所有数据和任务集中在一台计算机上处理。</li>
<li>该计算机负责管理和处理所有数据 / 任务，并提供服务给用户。</li>
</ul>
</li>
<li><strong>分布式计算</strong>:
<ul>
<li>利用多台计算机联合完成任务。</li>
<li>通过网络通信，按规则分配工作量和数据，协作完成处理任务。</li>
</ul>
</li>
</ul>
<h4 id="集中式-vs-分布式对比"><a class="anchor" href="#集中式-vs-分布式对比">#</a> 集中式 vs 分布式对比</h4>
<table>
<thead>
<tr>
<th style="text-align:left">对比项</th>
<th style="text-align:left">集中式计算</th>
<th style="text-align:left">分布式计算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>定义</strong></td>
<td style="text-align:left">计算资源集中一处处理管理</td>
<td style="text-align:left">计算资源分散多处处理管理</td>
</tr>
<tr>
<td style="text-align:left"><strong>资源分配</strong></td>
<td style="text-align:left">计算机集中处理管理所有资源</td>
<td style="text-align:left">资源分散在多台计算机上管理分配</td>
</tr>
<tr>
<td style="text-align:left"><strong>数据共享</strong></td>
<td style="text-align:left">数据集中存储，只能由该计算机访问共享</td>
<td style="text-align:left">数据可分布在多台计算机上，可共享访问</td>
</tr>
<tr>
<td style="text-align:left"><strong>处理能力</strong></td>
<td style="text-align:left">受单机硬件限制</td>
<td style="text-align:left">通过任务分配给多台计算机提高处理能力</td>
</tr>
<tr>
<td style="text-align:left"><strong>可靠性 / 安全性</strong></td>
<td style="text-align:left">单点故障 / 攻击影响整个系统</td>
<td style="text-align:left">单个计算机故障 / 攻击，其他计算机仍可继续计算任务</td>
</tr>
<tr>
<td style="text-align:left"><strong>成本</strong></td>
<td style="text-align:left">通常需大型机 / 高性能服务器，成本高</td>
<td style="text-align:left">可利用廉价计算机集群，成本相对较低</td>
</tr>
</tbody>
</table>
<h4 id="分布式计算优点"><a class="anchor" href="#分布式计算优点">#</a> 分布式计算优点</h4>
<ul>
<li><strong>高效性</strong>：利用多机处理能力，提高效率和吞吐量。</li>
<li><strong>可扩展性</strong>：通过增加节点扩展计算能力。</li>
<li><strong>容错性</strong>：通过备份和任务处理节点实现容错和高可靠性。</li>
<li><strong>低成本</strong>：利用廉价计算资源降低成本。</li>
<li><strong>数据局部性</strong>：利用计算节点附近数据，减少传输开销。</li>
</ul>
<h4 id="集中式计算优点"><a class="anchor" href="#集中式计算优点">#</a> 集中式计算优点</h4>
<ul>
<li><strong>简单性</strong>：统一管理，简化计算和管理复杂性。</li>
<li><strong>稳定性</strong>：单计算机保证计算和管理的稳定可靠性。</li>
<li><strong>统一性</strong>：统一管理控制数据和任务流程规则。</li>
<li><strong>安全性</strong>：单计算机管理保护数据和任务安全机密性。</li>
<li><strong>性能优化</strong>：单计算机优化资源使用，提高效率和性能。</li>
</ul>
<h4 id="分布式计算应用场景"><a class="anchor" href="#分布式计算应用场景">#</a> 分布式计算应用场景</h4>
<ul>
<li>大规模数据处理 (搜索引擎、数据挖掘、机器学习)</li>
<li>高性能计算 (科学计算、模拟、仿真)</li>
<li>分布式存储 (分布式文件系统、分布式数据库)</li>
<li>实时数据处理 (流计算、实时推荐)</li>
<li>区块链技术 (比特币、以太坊)</li>
</ul>
<h4 id="分布式计算原理-分而治之"><a class="anchor" href="#分布式计算原理-分而治之">#</a> 分布式计算原理 (分而治之)</h4>
<ul>
<li><strong>『分』</strong>: 将复杂庞大任务划分为小任务。</li>
<li><strong>『计算』</strong>: 子任务分配到不同节点并行执行。</li>
<li><strong>『合』</strong>: 汇总各节点结果得到最终结果。</li>
<li><strong>难点</strong>：任务划分、多节点通信方式。</li>
</ul>
<h4 id="分布式计算步骤"><a class="anchor" href="#分布式计算步骤">#</a> 分布式计算步骤</h4>
<ol>
<li><strong>设计分布式计算模型</strong>：决定组件如何运行、通信、管理节点。</li>
<li><strong>分布式任务分配</strong>：解决任务能否 / 如何分配到各节点。</li>
<li><strong>编写并执行分布式程序</strong>：使用特定框架 / 模型转化算法为实现，保证集群高效运行。</li>
</ol>
<h3 id="分布式计算的理论基础"><a class="anchor" href="#分布式计算的理论基础">#</a> 分布式计算的理论基础</h3>
<h4 id="acid原则-本地事务管理-内部一致性"><a class="anchor" href="#acid原则-本地事务管理-内部一致性">#</a> ACID 原则 (本地事务管理、内部一致性)</h4>
<ul>
<li><strong>原子性 (Atomicity)</strong>: 操作要么全成功，要么全失败，无中间状态。</li>
<li><strong>一致性 (Consistency)</strong>: 事务处理前后，不改变数据库原本的一致性约束。(<strong>核心目标</strong>)</li>
<li><strong>隔离性 (Isolation)</strong>: 并发事务间独立，互不干扰。 (手段：写锁、读锁、范围锁)</li>
<li><strong>持久性 (Duration)</strong>: 事务生效后，对数据库的改变永久保存。(手段: Commit Logging)</li>
<li><strong>困难</strong>: &quot;写入磁盘&quot; 非原子操作。</li>
<li><strong>手段</strong>：原子性、隔离性、持久性</li>
<li><strong>目标</strong>：一致性</li>
</ul>
<h4 id="acid原则缺点"><a class="anchor" href="#acid原则缺点">#</a> ACID 原则缺点</h4>
<ul>
<li><strong>性能开销</strong>：锁定、日志记录影响并发处理能力。</li>
<li><strong>扩展性</strong>：强制一致性，难扩展到大规模分布式系统多节点。</li>
<li><strong>难以维护</strong>：事务失败回滚复杂，需协调多组件交互。</li>
</ul>
<h4 id="cap理论-分布式事务-外部一致性"><a class="anchor" href="#cap理论-分布式事务-外部一致性">#</a> CAP 理论 (分布式事务、外部一致性)</h4>
<ul>
<li><strong>定义</strong>：分布式系统最多同时满足以下三项中的两项：
<ul>
<li><strong>一致性 (Consistency)</strong>: 所有节点访问同一份最新数据副本。</li>
<li><strong>可用性 (Availability)</strong>: 每次请求都能获取非错响应 (不保证最新数据)。</li>
<li><strong>分区容错性 (Partition tolerance)</strong>: 网络分区时，系统仍能继续运行。(分布式系统<strong>必须</strong>满足)</li>
</ul>
</li>
<li><strong>起源</strong>: Eric Brewer 提出猜想 (2000)，Seth Gilbert &amp; Nancy Lynch 证明 (2002)。</li>
</ul>
<h4 id="cap理论阐述"><a class="anchor" href="#cap理论阐述">#</a> CAP 理论阐述</h4>
<ul>
<li><strong>正常流程</strong>: N1, N2 数据一致 (V0)，均可用。网络正常，分区容错性满足。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/ba463d4a4ff080a698df315fb702b123581ee2092460774bda2d0e38707f857b.png" alt="picture 1"></li>
<li><strong>网络分区时</strong>: N1 与 N2 网络断开。用户向 N2 请求读数据。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/d1bfad52c77f0fdf4296748c1eace3c380925327d9d5fa39c7148afaa7056aef.png" alt="picture 2">
<ul>
<li><strong>选择一 (牺牲一致性 C, 保留可用性 A)</strong>: N2 无法同步 N1 的新数据 V1，响应旧数据 V0 给用户。(AP)</li>
<li><strong>选择二 (牺牲可用性 A, 保留一致性 C)</strong>: N2 阻塞等待，直到网络恢复、数据同步 M 完成，再响应最新数据 V1。(CP)</li>
</ul>
</li>
</ul>
<h4 id="cap权衡"><a class="anchor" href="#cap权衡">#</a> CAP 权衡</h4>
<ul>
<li><strong>(1) CA w/o P</strong>: 放弃分区容错性。假设节点间通信永远可靠。不是真正的分布式系统。(例: Oracle RAC 使用共享磁盘避免网络分区)</li>
<li><strong>(2) CP w/o A</strong>: 放弃可用性。保证强一致性，分区发生时可能导致请求超时或错误。(例: HBase RegionServer 宕机期间数据不可用)</li>
<li><strong>(3) AP w/o C</strong>: 放弃 (强) 一致性。保证高可用，分区发生时节点用本地数据提供服务，可能导致数据不一致。(例: Redis 分区后各节点返回本地数据) (<strong>主流选择</strong>)</li>
</ul>
<h4 id="base理论"><a class="anchor" href="#base理论">#</a> BASE 理论</h4>
<ul>
<li><strong>定义</strong>：对 CAP 中一致性和可用性权衡的结果，核心思想是即使无法做到强一致性，但应用可采用适合方式达到<strong>最终一致性</strong>。</li>
<li><strong>Basically Available (基本可用)</strong>: 系统在分区、部分节点故障时，仍能保证核心功能可用。</li>
<li><strong>Soft State (软状态)</strong>: 系统状态允许在不同节点间存在中间状态，不要求实时一致。</li>
<li><strong>Eventually Consistent (最终一致性)</strong>: 系统中所有数据副本经过一段时间后，最终能够达到一致状态。</li>
<li><strong>核心思想</strong>：牺牲强一致性换取高可用性和灵活性，适用于对一致性要求不高的场景。</li>
</ul>
<h4 id="base与acid对比"><a class="anchor" href="#base与acid对比">#</a> BASE 与 ACID 对比</h4>
<ul>
<li><strong>ACID</strong>: 传统数据库设计理念，追求<strong>强一致性</strong>模型。</li>
<li><strong>BASE</strong>: 大型分布式系统设计理念，通过牺牲强一致性获得<strong>高可用性</strong>。</li>
</ul>
<h4 id="一致性散列"><a class="anchor" href="#一致性散列">#</a> 一致性散列</h4>
<ul>
<li><strong>问题背景</strong>：分布式集群存储数据，如何将对象散列到不同机器？</li>
<li><strong>简单散列</strong>:  <code>server = hash(key) mod N</code>  (N 为机器数)。</li>
<li><strong>再散列问题 (Rehashing)</strong>: 当服务器数量 N 变化 (增 / 减机器) 时， <code>hash % N</code>  结果大多会改变，导致<strong>大部分 KV 对需要迁移</strong>。</li>
</ul>
<h4 id="一致性散列算法-consistent-hashing"><a class="anchor" href="#一致性散列算法-consistent-hashing">#</a> 一致性散列算法 (Consistent Hashing)</h4>
<ul>
<li><strong>定义</strong>：将整个哈希值空间 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi mathvariant="normal">.</mi><mi>g</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mn>0</mn><mtext> </mtext><msup><mn>2</mn><mn>128</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">e.g., 0 ~ 2^{128}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">128</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>) 组织成虚拟圆环。</li>
<li><strong>映射</strong>：将服务器和对象 Key 都通过哈希函数映射到环上。</li>
<li><strong>归属</strong>：对象存储在沿环顺时针遇到的第一个服务器上。</li>
<li><strong>应用</strong>：高流量动态网站的分布式缓存 (Redis, MemCache) 实现请求动态均衡。</li>
<li><strong>容错性</strong>：节点宕机 (Node C)，只影响其负责的数据 (对象 C)，这些数据重定位到下一个节点 (Node D)。对象 A, B, D 不受影响。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/428f0ecf55bd42a436e91cc034293b84cfd67d15efac7a4fd4abd858c7b661df.png" alt="picture 3"></li>
<li><strong>扩展性</strong>：增加节点 (Node X)，只影响新节点与其前一个节点之间的数据 (对象 C 需重定位到 Node X)。对象 A, B, D 不受影响。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/acc3b19003815406bc1bbbc8c30e4e6584b9cdb23a07e9c478cdb0addffa9d35.png" alt="picture 4"></li>
<li><strong>虚拟节点</strong>：为解决物理节点哈希分布不均问题，将每个物理服务器映射为多个虚拟节点分散在环上，使数据分布更均匀。权重高的服务器可分配更多虚拟节点。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/80742fb29ae26c125bdce4328491077f6a95838dc11adbd7d055a5219b88e114.png" alt="picture 5"></li>
</ul>
<h3 id="分布式系统概述"><a class="anchor" href="#分布式系统概述">#</a> 分布式系统概述</h3>
<h4 id="基础知识-大数据驱动"><a class="anchor" href="#基础知识-大数据驱动">#</a> 基础知识 (大数据驱动)</h4>
<ul>
<li><strong>驱动力</strong>：大数据技术需求推动分布式系统发展。</li>
<li><strong>演变</strong>：源于互联网公司大规模分布式存储系统需求。</li>
<li><strong>扩展方式</strong>:
<ul>
<li><strong>纵向扩展 (Scale Up)</strong>: 传统方式，使用更强服务器 (小型机 -&gt; 中型机 -&gt; 大型机)，成本高、稳定。</li>
<li><strong>横向扩展 (Scale Out)</strong>: 使用大量廉价普通服务器通过网络连接，成本低、故障率高。</li>
</ul>
</li>
<li><strong>挑战与解决</strong>:
<ul>
<li>故障率高 -&gt; 软件实现自动容错、保证数据一致性。</li>
<li>增加服务器 -&gt; 软件实现自动负载均衡，系统处理能力线性扩展。</li>
</ul>
</li>
</ul>
<h4 id="实例apache-hadoop"><a class="anchor" href="#实例apache-hadoop">#</a> 实例：Apache Hadoop</h4>
<ul>
<li><strong>定义</strong>: Apache 基金会开发的分布式存储与计算框架。</li>
<li><strong>创始人</strong>: Doug Cutting (就职 Yahoo 期间开发，现 Cloudera)。</li>
<li><strong>思想来源</strong>: Google 论文公开的 GFS, MapReduce, Bigtable 思想。</li>
<li><strong>发展简史</strong>:
<ul>
<li>2003-2004: Doug Cutting 基于 Google 论文实现 Nutch (DFS + MapReduce 微缩版)。</li>
<li>2005 秋: Nutch 子项目引入 Apache 基金会。</li>
<li>2006.3: MapReduce 和 NDFS (后改名 HDFS) 纳入 Hadoop 项目。</li>
</ul>
</li>
<li><strong>核心组件</strong>:
<ul>
<li><strong>HDFS (Hadoop Distributed File System)</strong>: 提供高可靠、高扩展、高吞吐率的分布式数据存储服务。</li>
<li><strong>MapReduce</strong>: 并行、分布式计算框架，易使用、高容错、高扩展。</li>
</ul>
</li>
<li><strong>云计算服务模型</strong>: Hadoop 通常属于 <strong>PaaS</strong> (平台即服务) 层，运行在 IaaS (如 AWS EC2/S3, 阿里云 ECS) 之上。</li>
</ul>
<h3 id="分布式系统的进阶"><a class="anchor" href="#分布式系统的进阶">#</a> 分布式系统的进阶</h3>
<h4 id="分布式存储系统-5个子方向"><a class="anchor" href="#分布式存储系统-5个子方向">#</a> 分布式存储系统 (5 个子方向)</h4>
<ol>
<li><strong>结构化存储</strong>：关系型数据库 (MySQL)。强一致性 (银行系统)，支持随机访问 (SQL, 索引)。</li>
<li><strong>非结构化存储</strong>：分布式文件系统 (GFS, HDFS)。存储海量数据 (网页)，配合批量处理。高扩展、高吞吐。不支持随机访问，不适用低延时、实时应用。</li>
<li><strong>半结构化存储</strong>: NoSQL, KV Store (对象存储)。解决非结构化存储随机访问性能差问题。通常<strong>抛弃 ACID</strong> 换取性能和扩展性。</li>
<li><strong>In-memory 存储</strong>: Memcached, Redis。数据存内存，读写高性能。</li>
<li><strong>NewSQL</strong>: Google Spanner。兼备 RDBMS (SQL, ACID) 和 NoSQL (扩展能力)。(目前工业界支持较少)</li>
</ol>
<h4 id="分布式计算系统"><a class="anchor" href="#分布式计算系统">#</a> 分布式计算系统</h4>
<ul>
<li>
<p><strong>分布式计算 vs 并行计算</strong>:</p>
<ul>
<li><strong>并行计算</strong>：目标是<strong>高性能</strong> (投入更多机器，数据量不变，计算更快)。无内置 &quot;容错&quot; 概念。</li>
<li><strong>分布式计算</strong>：目标是<strong>高可扩展性</strong> (投入更多机器，处理更大规模数据)。核心是<strong>容错</strong>。</li>
</ul>
</li>
<li>
<p><strong>分布式计算系统 (5 个子方向)</strong>:</p>
<ol>
<li><strong>传统基于消息的系统</strong>: MPI (Message Passing Interface)。框架灵活，约束少，<strong>不支持容错</strong> (或有限)。(MPICH2, OpenMPI)</li>
<li><strong>MapReduce 家族系统</strong>: MapReduce, Spark。程序结构有严格约束 (Map, Reduce 等高层操作)，抽象为 DAG。可扩展至超大规模集群，<strong>具备容错机制</strong>，但节点同步效率可能低。</li>
<li><strong>图计算系统</strong>: Pregel (BSP 模型), GraphLab (GAS 模型)。专门处理图结构数据。</li>
<li><strong>基于状态的系统</strong>: Piccolo, DistBelief, Parameter Server。适用于需要维护和同步全局状态的应用 (如大规模机器学习)。</li>
<li><strong>实时流处理系统</strong>: Apache Storm。高效实时处理流式数据，关注<strong>实时性</strong>。在连续数据窗口内执行 SQL 类操作。</li>
</ol>
</li>
</ul>
<h5 id="1-传统基于消息的系统-mpi"><a class="anchor" href="#1-传统基于消息的系统-mpi">#</a> 1. 传统基于消息的系统 (MPI)</h5>
<ul>
<li><strong>基本思想</strong>：程序分多个进程，进程间传递消息和数据。</li>
<li><strong>进程位置</strong>：可在同机不同线程、不同机器进程、甚至不同操作系统进程。</li>
<li><strong>通信模型</strong>:
<ul>
<li><strong>点对点通信</strong>：两进程间直接通信 (发送、接收)。</li>
<li><strong>集合通信</strong>：多进程间数据收集与分发 (广播、聚集、散布)。</li>
</ul>
</li>
<li><strong>示例</strong>:  <code>scatter</code>  (发散：将根进程数据分发给各进程),  <code>gather</code>  (收集：将各进程数据收集到根进程)。</li>
</ul>
<h5 id="2-mapreduce家族系统-mapreduce-spark"><a class="anchor" href="#2-mapreduce家族系统-mapreduce-spark">#</a> 2. MapReduce 家族系统 (MapReduce, Spark)</h5>
<ul>
<li><strong>MapReduce</strong>:
<ul>
<li><strong>批处理模型</strong>。</li>
<li>数据<strong>存储在磁盘</strong>上，适合大规模数据批处理。</li>
<li>磁盘 I/O 较多。</li>
</ul>
</li>
<li><strong>Spark</strong>:
<ul>
<li>支持<strong>流处理和批处理</strong>两种模型。</li>
<li>采用<strong>内存计算</strong>思想，更灵活、更快。</li>
</ul>
</li>
</ul>
<h5 id="3-图计算系统-pregelbsp-graphlabgas"><a class="anchor" href="#3-图计算系统-pregelbsp-graphlabgas">#</a> 3. 图计算系统 (Pregel/BSP &amp; GraphLab/GAS)</h5>
<ul>
<li><strong>Pregel (BSP 模型 - Bulk Synchronous Parallel)</strong>:
<ul>
<li>计算任务分若干<strong>超级步 (Supersteps)</strong>。</li>
<li>每步包含三个阶段: <strong>计算、通信、同步</strong>。</li>
<li>所有节点完成计算和通信后，等待同步，再进入下一步。</li>
<li><strong>同步通信模式</strong>：本轮计算结果在下一轮生效。</li>
</ul>
</li>
<li><strong>GraphLab (GAS 模型 - Gather, Apply, Scatter)</strong>:
<ul>
<li>计算任务分三个阶段:
<ul>
<li><strong>Gather</strong>: 从邻居节点收集信息。</li>
<li><strong>Apply</strong>: 根据收集的信息更新自身状态。</li>
<li><strong>Scatter</strong>: 将更新后的状态信息发送给邻居节点。</li>
</ul>
</li>
<li><strong>异步通信模式</strong>：本轮计算结果在本轮立即生效。算法收敛快，但可能存在数据不一致问题。</li>
<li>可在单机或分布式环境运行。Pregel 只能在分布式环境。</li>
</ul>
</li>
</ul>
<h5 id="5-实时流处理系统-storm"><a class="anchor" href="#5-实时流处理系统-storm">#</a> 5. 实时流处理系统 (Storm)</h5>
<ul>
<li><strong>定义</strong>：处理<strong>实时、连续、无界</strong>数据流的系统。</li>
<li><strong>特点</strong>:
<ul>
<li><strong>简单编程模型</strong>：类似 MapReduce 降低并行批处理复杂性，Storm 降低实时处理复杂性。</li>
<li><strong>多种编程语言</strong>：默认 Clojure, 支持 Java, Ruby, Python 等。</li>
<li><strong>容错性</strong>：管理工作进程和节点故障。</li>
<li><strong>横向扩展</strong>：计算在多线程、进程、服务器并行进行。</li>
<li><strong>可靠的消息处理</strong>：保证消息至少被完整处理一次。失败时从源头重试。</li>
<li><strong>快速</strong>：使用 ZeroMQ 作为底层消息队列，保证消息快速处理。</li>
</ul>
</li>
<li><strong>Storm vs MapReduce/Spark (数据与计算流向)</strong>:
<ul>
<li><strong>MapReduce/Spark</strong>: <strong>计算传递给数据</strong>。节点存储 / 缓存数据集，任务提交给节点。批量处理持久化<strong>全量数据</strong>。</li>
<li><strong>Storm</strong>: <strong>数据传递给计算</strong>。节点实现基本计算过程，数据项流经网络节点。动态处理大量生成<strong>小数据块</strong>。</li>
</ul>
</li>
</ul>
<h4 id="分布式资源管理系统"><a class="anchor" href="#分布式资源管理系统">#</a> 分布式资源管理系统</h4>
<ul>
<li><strong>需求背景</strong>:
<ul>
<li>多种计算框架 (MapReduce, Spark, Storm, MPI) 可能并存。</li>
<li>希望部署到<strong>公共集群</strong>，共享资源，统一管理。</li>
</ul>
</li>
<li><strong>目标</strong>：提高资源利用率、降低运维成本、方便数据共享。</li>
<li><strong>典型代表</strong>: Mesos, YARN。</li>
</ul>
<h5 id="统一管理调度平台特点"><a class="anchor" href="#统一管理调度平台特点">#</a> 统一管理调度平台特点</h5>
<ol>
<li><strong>支持多种计算框架</strong>：平台本身不耦合特定框架。</li>
<li><strong>扩展性</strong>：平台自身不应成为框架水平扩展的瓶颈。</li>
<li><strong>容错性</strong>：在保持原有框架容错性基础上，平台自身也应具备良好容错性。</li>
<li><strong>高资源利用率</strong>:
<ul>
<li><strong>静态资源分配 (问题)</strong>: 每个框架分配固定集群，利用率低 (e.g., 10-30%)。</li>
<li><strong>资源统一管理 (解决)</strong>: 统一管理调度各种框架，提升整体资源利用率 (e.g.,&gt;70%)。</li>
</ul>
</li>
<li><strong>细粒度的资源分配</strong>:
<ul>
<li><strong>粗粒度共享 (Coarse-Grained)</strong>: 整个节点分配给一个框架 / 任务。</li>
<li><strong>细粒度共享 (Fine-Grained)</strong>: 直接按任务实际需求 (CPU, 内存) 分配资源。(Mesos 方式)</li>
</ul>
</li>
</ol>
<h5 id="apache-hadoop-yarn-yet-another-resource-negotiator"><a class="anchor" href="#apache-hadoop-yarn-yet-another-resource-negotiator">#</a> Apache Hadoop YARN (Yet Another Resource Negotiator)</h5>
<ul>
<li><strong>背景</strong>：下一代 MapReduce (MRv2)，为解决 MRv1 扩展性差、不支持多计算框架问题。完全重写。</li>
<li><strong>架构</strong>:
<ul>
<li><strong>ResourceManager (RM)</strong>: 全局资源管理器 (Master)。负责资源分配与调度。功能简单，不易成瓶颈。</li>
<li><strong>NodeManager (NM)</strong>: 节点管理器 (Slave)。负责启动 / 监控 Container，上报资源使用情况给 RM。</li>
<li><strong>ApplicationMaster (AM)</strong>: 每个应用程序对应一个 AM。负责向 RM 申请资源，与 NM 交互启动 / 监控任务。<strong>(有具体应用的调度功能)</strong></li>
<li><strong>Container</strong>: YARN 中资源分配的基本单位 (CPU, 内存等)。</li>
</ul>
</li>
</ul>
<h5 id="apache-mesos"><a class="anchor" href="#apache-mesos">#</a> Apache Mesos</h5>
<ul>
<li><strong>架构</strong>:
<ul>
<li><strong>Mesos Master</strong>: 保存 Framework 和 Slave 状态。使用 Zookeeper 解决单点故障。<strong>全局资源调度器</strong>。</li>
<li><strong>Mesos Slave (Agent)</strong>: 运行任务，向 Master 汇报状态，运行 Executor。</li>
<li><strong>Framework</strong>: 计算框架，包含 Scheduler (向 Master 注册，接收资源 offer) 和 Executor (在 Slave 上运行具体任务，e.g., Hadoop TaskTracker)。</li>
</ul>
</li>
<li><strong>资源分配流程 (两层调度)</strong>:
<ol>
<li>Agent 向 Master 汇报空闲资源。</li>
<li>Master 根据策略将资源 Offer (e.g., &lt;Agent1, 4 CPU, 4GB RAM&gt;) 提供给某个 Framework (e.g., Framework 1)。</li>
<li>Framework Scheduler 回复 Master 是否接受 Offer，并告知要在该资源上运行的任务列表及资源需求。</li>
<li>Master 将任务信息发送给 Agent。</li>
<li>Agent 分配资源给 Framework 的 Executor，Executor 启动任务。</li>
</ol>
</li>
</ul>
<h5 id="mesos与yarn比较"><a class="anchor" href="#mesos与yarn比较">#</a> Mesos 与 YARN 比较</h5>
<ol>
<li><strong>框架担任的角色</strong>:
<ul>
<li><strong>Mesos</strong>: 计算框架需<strong>完全融入</strong> Mesos (部署 Scheduler 和 Executor)。添加新框架需部署。</li>
<li><strong>YARN</strong>: 框架仅是<strong>应用程序库</strong>。无需事先部署框架。YARN 运行和使用更方便。</li>
</ul>
</li>
<li><strong>调度机制 (均为双层调度)</strong>:
<ul>
<li><strong>Mesos</strong>: <strong>资源推送</strong>。Master 将资源 Offer 推给 Framework，由 Framework 决定是否接受及如何使用。<strong>Mesos 本身不知应用资源需求</strong>。</li>
<li><strong>YARN</strong>: <strong>资源请求</strong>。ApplicationMaster 向 YARN (RM) 汇报任务资源需求。<strong>YARN 根据需求为应用分配资源</strong>。</li>
</ul>
</li>
</ol>
<h3 id="课后习题"><a class="anchor" href="#课后习题">#</a> 课后习题</h3>
<ol>
<li>分布式计算的定义和特征是什么？</li>
<li>什么是 ACID 原则？</li>
<li>什么是 CAP 理论？</li>
<li>什么是 BASE 理论？</li>
<li>如何理解最终一致性？</li>
<li>各类分布式存储、分布式计算的区别与联系是什么？</li>
</ol>
<h3 id="课外思考"><a class="anchor" href="#课外思考">#</a> 课外思考</h3>
<ol>
<li>为什么日常生活中接触到的分布式系统越来越多了？</li>
<li>CAP 定理中几个关键因素为什么不能同时保证？不同组合有什么应用场景？</li>
<li>了解区块链背景后，说说你理解的区块链作为一种分布式系统背后的全新理念。</li>
</ol>
<h2 id="云计算架构"><a class="anchor" href="#云计算架构">#</a> 云计算架构</h2>
<h3 id="云计算的本质"><a class="anchor" href="#云计算的本质">#</a> 云计算的本质</h3>
<h4 id="革命性概念it作为服务"><a class="anchor" href="#革命性概念it作为服务">#</a> 革命性概念：IT 作为服务</h4>
<ul>
<li><strong>核心思想</strong>：云计算将所有 IT 资源包装成服务进行销售，类似电力公用事业（引用 Nicholas Carr《大转换》）。</li>
<li><strong>类比</strong>:
<ul>
<li><strong>蒸汽技术</strong>：难以远程传输，本地供给。</li>
<li><strong>发电厂</strong>：集中生产，远程供应，形成规模效应。人们放弃自有发电机。</li>
<li><strong>云计算</strong>：集中化 IT 资源，提供新的技术和商业模式。人们可放弃自有 IT 资产，不必因资产由他人掌握而不安。</li>
</ul>
</li>
<li><strong>社会影响</strong>：云计算不仅影响各行业，还引发伦理道德乃至政治问题（如数据主权、隐私、算法影响、跨境数据管理）。</li>
<li><strong>带来的机遇 / 平等性</strong>:
<ul>
<li>低门槛发布软件触达全球用户。</li>
<li>无需高昂初始投资即可使用先进平台。</li>
<li>降低对设备和位置的依赖。</li>
<li>支持多租户。</li>
<li>依托云商架构获得高可靠性 / 可用性。</li>
<li>弹性伸缩应对需求波动。</li>
<li>按需增长支持企业持续发展。</li>
</ul>
</li>
</ul>
<h4 id="云计算系统工程"><a class="anchor" href="#云计算系统工程">#</a> 云计算系统工程</h4>
<ul>
<li><strong>挑战</strong>：将大量计算资源组织在一起协同工作，需要系统性管理方法解决问题。</li>
<li><strong>关键问题</strong>:
<ul>
<li>如何在扩大规模的同时保证性能近线性增长？</li>
<li>如何在组件可能故障时保证系统整体稳定运行？</li>
<li>如何快速重组资源以新架构适应不同业务需求变化？</li>
</ul>
</li>
</ul>
<h4 id="云数据中心"><a class="anchor" href="#云数据中心">#</a> 云数据中心</h4>
<ul>
<li><strong>建设考量</strong>：需考虑持续性、能耗、安全、冷却、带宽、管理等，需自动化管理机制（故障检测定位、自动开关机）。</li>
<li><strong>模式</strong>:
<ul>
<li><strong>传统模式</strong>：建机房、布线、放置连接机器。规模受建筑限制（如微软都柏林数据中心）。</li>
<li><strong>基于集装箱模式</strong>: Google 首创，用集装箱作机房单元（可容纳上千台服务器），可堆叠 / 并排形成巨大数据中心（如华为 AIO 集装箱数据中心）。</li>
</ul>
</li>
</ul>
<h4 id="云的工作负载模式-掌握"><a class="anchor" href="#云的工作负载模式-掌握">#</a> 云的工作负载模式 (掌握)</h4>
<ol>
<li>
<p><strong>时开时停</strong>：使用一段时间后停止，按用量计费，停止时释放资源。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/44de281b321a1697a53e5577db31418deb2ebde5610637b44dbf6fe27cb8d4cb.png" alt="picture 6"></p>
</li>
<li>
<p><strong>用量迅速增长</strong>: IT 资源使用量随时间推移持续增长。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/62b318e28767d15643014374e548551f4c9a77c8df009a3cafa6044024f1f9a4.png" alt="picture 7"></p>
</li>
<li>
<p><strong>瞬时暴涨</strong>：特定时间点用量出现暴涨和暴跌。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/0f11ec53e41381d290463835e0f15120fe66fb315902664ebe9a8fcd44fd7f08.png" alt="picture 8"></p>
</li>
<li>
<p><strong>周期性增减</strong>: IT 资产用量呈现周期性增长和消减。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/0ef43a8d9467db51f32345f5b8c8d4a98c4dbf67cf1d796f831b030f088b0cae.png" alt="picture 9"></p>
</li>
</ol>
<h3 id="云计算的架构"><a class="anchor" href="#云计算的架构">#</a> 云计算的架构</h3>
<h4 id="计算架构的进化"><a class="anchor" href="#计算架构的进化">#</a> 计算架构的进化</h4>
<ul>
<li><strong>演进路径</strong>:
<ol>
<li>中央集权架构 (终端 + 主机)</li>
<li>客户机 / 服务器 (C/S) 架构</li>
<li>中间层架构 (三层架构)</li>
<li>浏览器 / 服务器 (B/S) 架构</li>
<li>C/S 与 B/S 混合架构</li>
<li><strong>面向服务的计算架构 (SOA)</strong>:
<ul>
<li>程序完成自身任务，同时暴露服务供其他程序通过统一接口调用。</li>
<li>云计算将<strong>一切</strong>作为服务（软件、IT 资源），是服务计算的极致体现。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="一般云计算架构的二维视角"><a class="anchor" href="#一般云计算架构的二维视角">#</a> 一般云计算架构的二维视角</h4>
<ul>
<li><strong>组成</strong>:
<ul>
<li><strong>前端</strong>：呈现给客户的部分 (客户设备、网络、访问界面如 Web 浏览器)。</li>
<li><strong>后端 (云)</strong>: 由各种组件构成 (服务器、存储、云管理软件等)。</li>
</ul>
</li>
<li><strong>内部结构</strong>: (见图) 硬件 -&gt; 基础架构 -&gt; 管理软件 (YARN, MapReduce 等) -&gt; 应用程序。强调并发、协调、容错、开放接口、数据密集、开放数据等特性。</li>
</ul>
<h5 id="基础架构的分层结构"><a class="anchor" href="#基础架构的分层结构">#</a> 基础架构的分层结构</h5>
<ol>
<li><strong>虚拟化层 (云的基石)</strong>: 将硬件转换为一致的 IT 资源（计算、存储），便于云管理软件细致管理（分配、动态增减）。</li>
<li><strong>Web 服务层 (无状态的云服务)</strong>: 将云资源通过方便界面提供给用户使用（屏蔽底层虚拟机复杂性）。</li>
<li><strong>服务总线层 / 通信中间件层 (云与用户的桥梁)</strong>: 封装服务，分离用户与虚拟化层，连接 Web 服务与用户。</li>
<li><strong>客户机用户界面层 (将云呈现给客户)</strong>: 将应用程序呈现给客户（通常是 Web 门户）。</li>
</ol>
<h5 id="rest架构云计算的软件架构"><a class="anchor" href="#rest架构云计算的软件架构">#</a> REST 架构：云计算的软件架构</h5>
<ul>
<li>基础设施四层之间采用<strong>无状态、基于服务的 REST</strong> (Representational State Transfer, 表征状态转移) 架构。</li>
<li><strong>基本思想</strong>：面向<strong>资源</strong>来抽象问题，与面向过程的编程有本质区别。</li>
<li><strong>核心概念</strong>:
<ul>
<li><strong>资源 (Resource)</strong>: 信息或数据本身 (如文章内容)。</li>
<li><strong>表征 (Representation)</strong>: 资源与用户交互时的表示形式 (如 HTML, PDF)。</li>
<li><strong>状态 (State)</strong>: 特定语境下才能产生的上下文信息 (如 “下一篇” 依赖 “当前篇”)。REST 强调<strong>无状态 (Stateless)</strong>，即状态由客户端维护并在请求时告知服务端。</li>
<li><strong>转移 (Transfer)</strong>: 服务端执行的、改变状态的动作 (如从 “当前篇” 转移到 “下一篇”)。</li>
</ul>
</li>
</ul>
<h3 id="云栈和云体"><a class="anchor" href="#云栈和云体">#</a> 云栈和云体</h3>
<ul>
<li><strong>云体 (Cloud Body)</strong>: 云计算的<strong>物质基础</strong>，软硬件环境资源集合（网络、服务器、存储器、交换机等通过网络连接）。</li>
<li><strong>云栈 (Cloud Stack) / 云平台</strong>：在云体上建造的<strong>运行环境</strong>，支持应用发布、运行、监控、调度、伸缩（如 Azure, App Engine, Cloud Foundry）。</li>
<li><strong>云计算 (Cloud Computing)</strong>: 利用云体和云平台进行的<strong>计算或处理</strong>。特点是按用量计费、资源可伸缩。包括云存储、云服务、在云上运行软件 / 算法。</li>
<li><strong>云 (Cloud)</strong>: 云体、云栈、云计算的<strong>结合体</strong>，有时也称为云端或云环境。</li>
</ul>
<h4 id="云栈-三层云栈架构-服务模式"><a class="anchor" href="#云栈-三层云栈架构-服务模式">#</a> 云栈 (三层云栈架构 - 服务模式)</h4>
<ul>
<li><strong>层次</strong>：每一层提供一种抽象，越往上离物理现实越远，易用性越高。通过服务 / 功能实现抽象。</li>
<li><strong>常见三层</strong>:
<ul>
<li><strong>IaaS (基础设施即服务)</strong>: 提供基础计算 / 存储 / 网络资源（如 EC2/S3, 阿里云 ECS）。面向系统管理员 / 开发者。<strong>(通用)</strong></li>
<li><strong>PaaS (平台即服务)</strong>: 提供应用程序运行环境（如 Google App Engine, Azure, Hadoop）。面向应用开发者。</li>
<li><strong>SaaS (软件即服务)</strong>: 提供特定应用软件功能（如 Salesforce CRM, Alexa Web）。面向最终用户。<strong>(专用)</strong></li>
</ul>
</li>
</ul>
<h4 id="云体"><a class="anchor" href="#云体">#</a> 云体</h4>
<ul>
<li><strong>与传统操作系统的对比</strong>:
<ul>
<li><strong>云环境</strong>：计算资源可 &gt; 1 CPU (多节点)，独立存储，提供通信通道。虚拟化提供灵活资源 (N 个 CPU)。</li>
<li><strong>传统 OS</strong>: 应用使用 CPU、内存 / 磁盘，与其他程序通信。OS 提供进程 / 线程、内存管理、文件系统、IPC / 网络等抽象，并负责控制调度。</li>
</ul>
</li>
</ul>
<h3 id="软件定义的数据中心-sddc"><a class="anchor" href="#软件定义的数据中心-sddc">#</a> 软件定义的数据中心 (SDDC)</h3>
<h4 id="数据中心的历史"><a class="anchor" href="#数据中心的历史">#</a> 数据中心的历史</h4>
<ul>
<li><strong>演进</strong>：集中 -&gt; 分散 -&gt; 再集中。新的集中模式（云）远超大型机时代。</li>
<li><strong>阶段</strong>: 60 年代 (大型机) -&gt; 80 年代 (微型计算机) -&gt; 90 年代 (C/S 推动 DC 发展) -&gt; 21 世纪 (IDC 出现，现代 DC)。</li>
</ul>
<h4 id="传统数据中心的问题"><a class="anchor" href="#传统数据中心的问题">#</a> 传统数据中心的问题</h4>
<ol>
<li><strong>机器过多</strong>：手动配置（OS、网络、注册、用户分配、软件）劳动密集。</li>
<li><strong>利用率过低</strong>：服务器利用率常低于 10%，浪费资源和电力（&gt;90% 成热量）。</li>
<li><strong>应用迁移困难</strong>：硬件升级换代导致应用迁移复杂（重配置、兼容性问题）。</li>
<li><strong>存储需求增长快</strong>：存储更新关键且复杂，设备异构性（厂商、接口）导致管理困难、不兼容。</li>
</ol>
<h4 id="什么是软件定义数据中心-sddc"><a class="anchor" href="#什么是软件定义数据中心-sddc">#</a> 什么是软件定义数据中心 (SDDC)？</h4>
<ul>
<li><strong>起源</strong>：服务器虚拟化技术的延伸。</li>
<li><strong>核心</strong>：将虚拟化范围从计算扩展到存储和网络，并提供软件工具管理这些虚拟化资源。</li>
<li><strong>定义 (IBM)</strong>: SDDC 将虚拟化的计算、存储、网络资源与标准化管理平台结合，跨虚拟化层实现管理标准化，支持基于策略的自动化，简化运营，更快以服务形式交付 IT 资源。</li>
</ul>
<h4 id="sddc-的分层模型与架构分析"><a class="anchor" href="#sddc-的分层模型与架构分析">#</a> SDDC 的分层模型与架构分析</h4>
<ol>
<li><strong>硬件基础设施</strong>：服务器、存储、网络设备 (最好支持硬件虚拟化)。</li>
<li><strong>软件抽象 (虚拟化层)</strong>: 硬件能力抽象为统一管理的资源池 (虚拟机、虚拟存储、虚拟网络)。</li>
<li><strong>软件定义 (控制层)</strong>: 对计算、存储、网络资源集中管理，提供权限、备份、高可用等特性 (如 vCenter)。</li>
<li><strong>服务的自动化配置 (编排层)</strong>: 按预设步骤自动部署服务 (如 vCAC)。</li>
</ol>
<h3 id="实践-openstack"><a class="anchor" href="#实践-openstack">#</a> 实践: OpenStack</h3>
<ul>
<li><strong>定义</strong>：云平台操作系统（分布式），统一管理多节点计算、存储、网络资源池，通过 Web 界面管理。</li>
<li><strong>重要性</strong>：市场需求大，人才缺口大。</li>
<li><strong>目标</strong>：提供实施简单、大规模扩展、丰富、标准统一的云计算管理平台。支持各类云环境。</li>
<li><strong>OpenStack 组件</strong>:
<ul>
<li><strong>Nova (计算)</strong>: 核心，管理 VM 生命周期。</li>
<li><strong>Horizon (仪表盘)</strong>: Web GUI 界面。</li>
<li><strong>Keystone (身份)</strong>: 认证与授权。</li>
<li><strong>Neutron (网络)</strong>: SDN 网络虚拟化管理。</li>
<li><strong>Cinder (块存储)</strong>: 持久化块存储服务。</li>
<li><strong>Swift (对象存储)</strong>: 分布式对象存储 (类 S3)。</li>
<li><strong>Glance (镜像)</strong>: 管理 VM 镜像。</li>
<li><strong>Ceilometer (监控)</strong>: 资源监控与计量。</li>
<li><strong>Heat (编排)</strong>: 基于模板编排复合云应用。</li>
</ul>
</li>
<li><strong>安装实践</strong>：使用 <strong>Packstack</strong> 工具安装。步骤包括初始化配置、网络配置、主机名解析、YUM 源配置、安装 Packstack。</li>
</ul>
<h3 id="课后习题-小结"><a class="anchor" href="#课后习题-小结">#</a> 课后习题 (小结)</h3>
<ol>
<li>云计算中的工作负载有哪几种模式？它们的特征是什么？</li>
<li>什么是 REST 设计风格？</li>
<li>如何理解 “云栈” 和 “云体” 的概念？</li>
<li>什么是软件定义的数据中心？它的特点是什么？</li>
</ol>
<h3 id="课外思考-小结"><a class="anchor" href="#课外思考-小结">#</a> 课外思考 (小结)</h3>
<ol>
<li>云计算的架构是如何演化的？</li>
<li>如何理解 “软件定义一切” 的说法？</li>
</ol>
<h3 id="动手实践-小结"><a class="anchor" href="#动手实践-小结">#</a> 动手实践 (小结)</h3>
<ul>
<li>任务：通过 OpenStack 官网了解项目情况。</li>
<li>任务：通过 Packstack 工具安装并体验 OpenStack。</li>
</ul>
<h2 id="虚拟化技术"><a class="anchor" href="#虚拟化技术">#</a> 虚拟化技术</h2>
<h3 id="虚拟化的定义"><a class="anchor" href="#虚拟化的定义">#</a> 虚拟化的定义</h3>
<h4 id="虚拟化历史"><a class="anchor" href="#虚拟化历史">#</a> 虚拟化历史</h4>
<ul>
<li><strong>起源</strong>: 20 世纪 50 年代。</li>
<li><strong>1959 年</strong>: Christopher Strachey 提出 “大型高速计算机中的时间共享” 论文。</li>
<li><strong>目的</strong>：最初为满足分时系统需求，解决早期 OS 单任务问题。</li>
<li><strong>早期应用</strong>: IBM 7044 是最早使用虚拟化技术的计算机之一，后大型机 / 小型机开始使用。</li>
</ul>
<h4 id="x86架构中的虚拟化演进"><a class="anchor" href="#x86架构中的虚拟化演进">#</a> x86 架构中的虚拟化演进</h4>
<ol>
<li><strong>纯软件『全虚拟化』</strong>: 无需硬件或 OS 修改。</li>
<li><strong>『半虚拟化模式』</strong>: 需修改客户机 OS 以提高性能。</li>
<li><strong>『硬件虚拟化』</strong>: Intel VT/AMD-V 等技术，用硬件代替软件实现虚拟化。</li>
</ol>
<h4 id="虚拟化概念"><a class="anchor" href="#虚拟化概念">#</a> 虚拟化概念</h4>
<ul>
<li><strong>广义</strong>：对计算资源的<strong>抽象</strong>，不仅仅是虚拟机。
<ul>
<li><strong>例</strong>：虚拟内存技术，抽象物理内存，提供连续地址空间给应用，实际数据可分页 / 分段 / 交换到外存。</li>
</ul>
</li>
<li><strong>狭义 (通常指)</strong>: 通过虚拟化技术将一台计算机虚拟为多台<strong>逻辑计算机 (虚拟机)</strong>。
<ul>
<li><strong>效果</strong>：提高硬件利用率 (一台服务器承载多台服务器负载)，实现用户任务和数据隔离，增强安全性。</li>
<li><strong>实现</strong>：一台计算机上运行多个逻辑计算机，各自运行不同 OS 和应用，相互独立。</li>
</ul>
</li>
</ul>
<h4 id="虚拟化技术主要分类-4大类"><a class="anchor" href="#虚拟化技术主要分类-4大类">#</a> 虚拟化技术主要分类 (4 大类)</h4>
<ol>
<li><strong>服务器虚拟化</strong>:
<ul>
<li>解决服务器利用率低 (&lt;15%)、数量剧增、部署复杂问题。</li>
<li>将多操作系统作为 VM 运行在单台物理服务器上。</li>
<li>聚合服务器集群为整合资源池，提高效率，降低成本。</li>
</ul>
</li>
<li><strong>软件定义的存储 (SDS)</strong>:
<ul>
<li>抽象内部磁盘 / 闪存为高性能存储池。</li>
<li>以软件形式交付，提高运维效率。</li>
</ul>
</li>
<li><strong>网络虚拟化</strong>:
<ul>
<li>以软件形式完整再现物理网络。</li>
<li>提供与物理网络相同功能 / 保证，并具备虚拟化运维优势和硬件独立性。</li>
</ul>
</li>
<li><strong>桌面虚拟化</strong>:
<ul>
<li>快速向分支机构、外包 / 海外 / 移动员工交付虚拟桌面和应用。</li>
<li>快速响应需求变化。</li>
</ul>
</li>
</ol>
<h4 id="虚拟化与云计算"><a class="anchor" href="#虚拟化与云计算">#</a> 虚拟化与云计算</h4>
<ul>
<li>虚拟化技术促进了云计算概念的产生，是其<strong>主要支撑技术</strong>之一。</li>
<li>核心优势：提高硬件利用率、实现用户任务 / 数据隔离、增强安全性。</li>
</ul>
<h3 id="服务器虚拟化"><a class="anchor" href="#服务器虚拟化">#</a> 服务器虚拟化</h3>
<h4 id="基本概念与架构"><a class="anchor" href="#基本概念与架构">#</a> 基本概念与架构</h4>
<ul>
<li><strong>定义</strong>：使用控制程序 (VMM) 隐藏物理平台特性，提供抽象、统一、模拟的计算环境 (虚拟机)。</li>
<li><strong>客户操作系统 (Guest OS)</strong>: 运行在虚拟机中的操作系统。</li>
<li><strong>虚拟机监控器 (Virtual Machine Monitor, VMM / Hypervisor)</strong>: 实现虚拟化的核心层。</li>
<li><strong>主机操作系统 (Host OS)</strong>: 运行 VMM 的操作系统 (仅限 Type II)。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/f99549e9b0fc5567fb073c11b99468f1b75148b176c09df0bb4f4513623f77f4.png" alt="picture 10"></li>
</ul>
<h4 id="hypervisor-类型"><a class="anchor" href="#hypervisor-类型">#</a> Hypervisor 类型</h4>
<ul>
<li><strong>Type I (裸金属架构)</strong>: VMM/Hypervisor 直接运行在硬件之上。(例: Xen, ACRN)<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/52c9c93cf3f9c0be20e7668f15051e41094087a8d44385ac14e28b3839b7c060.png" alt="picture 11">
<ul>
<li><strong>优点</strong>：效率高，扩展性、健壮性、性能更好。</li>
</ul>
</li>
<li><strong>Type II (寄居架构 / 托管架构)</strong>: VMM/Hypervisor 运行在 Host OS 之上，VM 作为 Host OS 的一个进程。(例: KVM, VMware Fusion, VirtualBox, Parallels Desktop)<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/c77396a3eed646d7bde7758786b0e05881af0c00c3a20aefe7310f4880d78029.png" alt="picture 12">
<ul>
<li><strong>优点</strong>：使用方便，与宿主 OS 兼容。桌面用户常用。</li>
</ul>
</li>
</ul>
<h4 id="x86架构对虚拟化的限制-ring特权级"><a class="anchor" href="#x86架构对虚拟化的限制-ring特权级">#</a> x86 架构对虚拟化的限制 (Ring 特权级)</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/6cb2051e27ed8f0359af546524df9d8a398999139a5d8f707eac3bbd4f25f4fa.png" alt="picture 13"></p>
<ul>
<li><strong>x86 Ring</strong>: Ring 0 (最高权限，OS 内核), Ring 3 (最低权限，用户应用)。</li>
<li><strong>特权指令</strong>：只能在 Ring 0 执行，直接访问硬件 / 内存。</li>
<li><strong>系统调用</strong>：应用 (Ring 3) -&gt; 内核 (Ring 0) 切换 -&gt; 内核代码执行 -&gt; 返回应用 (Ring 3)。(用户态 / 内核态切换)</li>
<li><strong>虚拟化难题</strong>: Host OS/VMM 运行在 Ring 0。Guest OS 被置于非 Ring 0 (如 Ring 1 或 Ring 3) 运行。当 Guest OS 尝试执行特权指令时，因权限不足导致<strong>出错 (trap)</strong>。</li>
</ul>
<h4 id="vmm-实现-guest-os-访问硬件的三种技术"><a class="anchor" href="#vmm-实现-guest-os-访问硬件的三种技术">#</a> VMM 实现 Guest OS 访问硬件的三种技术</h4>
<ol>
<li><strong>全虚拟化 (Full Virtualization)</strong></li>
<li><strong>半虚拟化 (Paravirtualization)</strong></li>
<li><strong>硬件辅助虚拟化 (Hardware-Assisted Virtualization)</strong></li>
</ol>
<h4 id="全虚拟化"><a class="anchor" href="#全虚拟化">#</a> 全虚拟化</h4>
<ul>
<li><strong>核心技术 (VMware, 1998)</strong>: <strong>二进制翻译 (Binary Translation, BT)</strong>。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/2b4e4788d9663b518c5874f9ca109730069ebf6fbac74aafde8e323f90908093.png" alt="picture 14"></p>
<ul>
<li><strong>原理</strong>:
<ul>
<li>VMM 捕获 Guest OS 的特权指令。</li>
<li><strong>翻译</strong>：将捕获的指令翻译成可在用户态运行的指令序列。</li>
<li><strong>缓存</strong>：翻译结果缓存，供后续使用。</li>
<li>用户级指令直接在 CPU 上运行 (速度接近物理机)。</li>
</ul>
</li>
<li><strong>特点</strong>:
<ul>
<li>Guest OS 无需任何修改，不知道自己被虚拟化。</li>
<li>VMM 与物理硬件完全解耦。</li>
<li>是唯一<strong>无需硬件辅助或 OS 辅助</strong>即可虚拟化敏感 / 特权指令的方案。</li>
</ul>
</li>
</ul>
<h4 id="半虚拟化"><a class="anchor" href="#半虚拟化">#</a> 半虚拟化</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/4eba6fa66c628d6a21347707088ace4542ece493d99457aef5fc76486923b448.png" alt="picture 15"></p>
<ul>
<li><strong>核心思想</strong>：修改 <strong>Guest OS 内核</strong>，将敏感 / 特权指令替换为对 VMM 的直接调用 (<strong>Hypercall</strong>)。</li>
<li><strong>Hypercall</strong>: 类似于系统调用，由 Guest OS 主动发起，请求 Hypervisor 服务。</li>
<li><strong>优点</strong>:
<ul>
<li>VMM 与 VM 相互配合，性能优于全虚拟化（早期）。</li>
<li>虚拟化代价 / 开销更低。</li>
</ul>
</li>
<li><strong>缺点</strong>:
<ul>
<li>需要修改 Guest OS，不支持未修改的 OS (如 Windows)。</li>
<li>兼容性、可移植性差。</li>
<li>内核深度修改导致生产环境技术支持和维护困难。</li>
</ul>
</li>
</ul>
<h4 id="硬件辅助虚拟化"><a class="anchor" href="#硬件辅助虚拟化">#</a> 硬件辅助虚拟化</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/f924bb691dbc50bd69ecc6b53a3d35532a17d8a2650c38f09ccd90e6c18a443e.png" alt="picture 16"></p>
<ul>
<li><strong>背景</strong>：解决软件虚拟化性能开销。</li>
<li><strong>技术</strong>: Intel VT-x (VMX), AMD AMD-V。</li>
<li><strong>核心</strong>: CPU 增加新的操作模式。
<ul>
<li><strong>根模式 (Root Mode)</strong>: VMM/Hypervisor 运行。</li>
<li><strong>非根模式 (Non-root Mode)</strong>: 虚拟机 (Guest OS) 运行。</li>
</ul>
</li>
<li><strong>原理</strong>:
<ul>
<li>Guest OS 在非根模式下执行。</li>
<li>执行敏感 / 特权指令时，CPU 自动触发 <strong>VM-Exit</strong>，控制权切换到根模式的 VMM。</li>
<li>VMM 处理指令后，通过 <strong>VM-Enter</strong> 将控制权交还给 Guest OS。</li>
</ul>
</li>
<li><strong>优点</strong>:
<ul>
<li>Hypervisor 无需费力识别 / 翻译敏感指令，极大提升虚拟化性能。</li>
<li>Guest OS 无需修改。</li>
</ul>
</li>
</ul>
<h4 id="虚拟化实现技术比较"><a class="anchor" href="#虚拟化实现技术比较">#</a> 虚拟化实现技术比较</h4>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">全虚拟化 (BT)</th>
<th style="text-align:left">半虚拟化 (Hypercall)</th>
<th style="text-align:left">硬件辅助虚拟化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Guest OS 修改</strong></td>
<td style="text-align:left">无须修改</td>
<td style="text-align:left"><strong>需要修改</strong></td>
<td style="text-align:left">无须修改</td>
</tr>
<tr>
<td style="text-align:left"><strong>兼容性</strong></td>
<td style="text-align:left">好</td>
<td style="text-align:left">差</td>
<td style="text-align:left">好</td>
</tr>
<tr>
<td style="text-align:left"><strong>性能</strong></td>
<td style="text-align:left">差 (相对)</td>
<td style="text-align:left">好 (早期)</td>
<td style="text-align:left"><strong>好</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>CPU 虚拟化</strong></td>
<td style="text-align:left">二进制代码翻译</td>
<td style="text-align:left">超级调用</td>
<td style="text-align:left">新指令 / 新操作模式</td>
</tr>
<tr>
<td style="text-align:left"><strong>内存虚拟化</strong></td>
<td style="text-align:left">影子页表 (SPT)</td>
<td style="text-align:left">内存管理半虚拟化</td>
<td style="text-align:left"><strong>嵌套页表 (NPT/EPT)</strong> (硬件扩展)</td>
</tr>
<tr>
<td style="text-align:left"><strong>I/O 虚拟化</strong></td>
<td style="text-align:left">设备模拟</td>
<td style="text-align:left">半虚拟化驱动</td>
<td style="text-align:left">设备模型 (直接访问)</td>
</tr>
</tbody>
</table>
<h3 id="商用虚拟机技术"><a class="anchor" href="#商用虚拟机技术">#</a> 商用虚拟机技术</h3>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">发布年份</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">技术特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>VMware</strong></td>
<td style="text-align:left">1999</td>
<td style="text-align:left">Type I, Type II</td>
<td style="text-align:left">商业产品先驱。支持 Type I (ESX Server) 和 Type II (Workstation)。提供完整虚拟化产品线 (桌面 / 应用 / 服务器)。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Xen</strong></td>
<td style="text-align:left">2003</td>
<td style="text-align:left">Type I</td>
<td style="text-align:left">开源。早期以<strong>半虚拟化</strong>为主。Linux 3.0 后稳定支持 Dom0/DomU。广泛部署 (硬件 / 车载等)。</td>
</tr>
<tr>
<td style="text-align:left"><strong>KVM/QEMU</strong></td>
<td style="text-align:left">2006/2003</td>
<td style="text-align:left">Type II</td>
<td style="text-align:left">基于 Linux 内核的开源方案。<strong>硬件辅助虚拟化</strong>为主 (硬件不支持时退回 QEMU 软件模拟)。目前广泛部署。</td>
</tr>
<tr>
<td style="text-align:left"><strong>ACRN</strong></td>
<td style="text-align:left">2018</td>
<td style="text-align:left">Type I</td>
<td style="text-align:left">嵌入式轻量级开源。代码量小 (~25K 行)。注重实时性 / 安全性，面向车载 / 物联网等场景。</td>
</tr>
</tbody>
</table>
<h3 id="新型硬件虚拟化"><a class="anchor" href="#新型硬件虚拟化">#</a> 新型硬件虚拟化</h3>
<h4 id="背景"><a class="anchor" href="#背景">#</a> 背景</h4>
<ul>
<li>GPU, FPGA 等新型硬件普及。</li>
<li>现有虚拟化技术主要面向通用硬件 (x86) 和软件栈 (Linux/Win)，无法高效承载新型硬件。</li>
<li>工业界 / 学术界探索新型硬件虚拟化方案，如 GPU/RDMA 直通独占式虚拟化。</li>
<li>RDMA/FPGA 等虚拟化尚处早期。</li>
</ul>
<h4 id="硬件虚拟化的代表"><a class="anchor" href="#硬件虚拟化的代表">#</a> 硬件虚拟化的代表</h4>
<ol>
<li><strong>GPU 虚拟化</strong>:
<ul>
<li>性能 / 扩展性 / 可用性相对 CPU 滞后。</li>
<li>传统方式: API 转发 (VMM 代理执行)，非完整硬件虚拟化，性能 / 扩展性不足。</li>
<li><strong>发展</strong>:
<ul>
<li>2013: AWS 推出商业化 GPU 实例。</li>
<li>2014: 主流 GPU 平台硬件辅助全虚拟化方案出现 (NVIDIA GPUvm, Intel gVirt)。</li>
<li>2017: Intel KVMGT (GPU 全虚拟化方案) 加入 Linux 内核 4.10。</li>
</ul>
</li>
</ul>
</li>
<li><strong>FPGA 虚拟化</strong>:
<ul>
<li>FPGA 是可重配置计算资源，与现有虚拟化框架不兼容，使用场景趋向独占。</li>
<li>FPGA 器件与开发生态 (工具链 / 库) 紧密耦合，特定型号需特定软件生成二进制文件。</li>
<li><strong>挑战</strong>：缺乏统一的二进制接口规范。</li>
</ul>
</li>
<li><strong>RDMA 虚拟化</strong>:
<ul>
<li>RDMA (远程直接内存访问): 通过 DMA 实现主机间内存直接访问。</li>
<li><strong>应用</strong>：近年在 HPC 等领域探索 RDMA 硬件虚拟化。</li>
<li><strong>实践</strong>: Microsoft Azure 尝试推出带 RDMA 网络支持的 VM 租赁服务。</li>
</ul>
</li>
<li><strong>NVM 虚拟化</strong>:
<ul>
<li>NVM (非易失性内存): 兼具内存高性能 (字节寻址) 和存储持久性。</li>
<li><strong>挑战</strong>：价格高、容量小、使用方式多变。虚拟化支持并投入云环境仍处研究起步阶段。</li>
</ul>
</li>
</ol>
<h4 id="硬件虚拟化的未来"><a class="anchor" href="#硬件虚拟化的未来">#</a> 硬件虚拟化的未来</h4>
<ol>
<li><strong>极端虚拟化</strong>:
<ul>
<li><strong>宏观</strong>：单机构建巨规模 / 巨型虚拟机 (因新型硬件增强单机能力)。</li>
<li><strong>微观</strong>：面向智能终端 / 极端受限环境的微型虚拟机 (便捷共享、高效抽象、按需重构、交互移动)。</li>
</ul>
</li>
<li><strong>异构硬件的融合和归一化</strong>:
<ul>
<li>基于 “软件定义” 原则，利用虚拟化融合 CPU, GPU, FPGA, RDMA 网卡，NVM, SSD 等异构硬件。</li>
<li>实现异构硬件归一化管理，提供统一编程接口。</li>
<li>根据应用需求动态选择后台执行硬件。</li>
</ul>
</li>
<li><strong>多硬件和特性的聚合和抽象</strong>:
<ul>
<li><strong>现状</strong>：虚拟化侧重 “一虚多”(单个物理资源 -&gt; 多个虚拟资源)。</li>
<li><strong>未来</strong>：利用新型硬件实现 “多虚一”，聚合多硬件 / 多特性，提升性能，突破单硬件物理极限。</li>
</ul>
</li>
</ol>
<h3 id="实践-xen-虚拟化技术"><a class="anchor" href="#实践-xen-虚拟化技术">#</a> 实践: Xen 虚拟化技术</h3>
<h4 id="xen-的历史"><a class="anchor" href="#xen-的历史">#</a> Xen 的历史</h4>
<ul>
<li><strong>2003</strong>: Ian Pratt (剑桥) 发表论文，提出基于<strong>半虚拟化</strong>的 Xen 项目。</li>
<li><strong>2005</strong>: Xen 3.0 支持 Intel VT/IA64，可运行<strong>完全未修改</strong>的操作系统。</li>
<li><strong>2007</strong>: Citrix 收购 XenSource。</li>
<li><strong>架构</strong>: Type I Hypervisor (裸金属)，直接运行在硬件上。
<ul>
<li><strong>Hypervisor</strong>: 最底层，直接与硬件交互。</li>
<li><strong>Domain 0 (Dom0)</strong>: 特权 VM，运行控制工具栈、物理设备驱动。</li>
<li><strong>Domain U (DomU)</strong>: 普通客户 VM (Guest OS)。</li>
</ul>
</li>
</ul>
<h4 id="xen-实际操作-概述"><a class="anchor" href="#xen-实际操作-概述">#</a> Xen 实际操作 (概述)</h4>
<ol>
<li>检查 CPU 是否支持 Xen 虚拟化。</li>
<li>安装 Xen 相关软件包。</li>
<li>创建虚拟机 (使用  <code>virt-manager</code>  或命令行工具)。
<ul>
<li>选择虚拟化方法 (Paravirtualized / Fully virtualized)。</li>
<li>配置 VM 名称、内存、CPU、存储、网络等。</li>
<li>安装 Guest OS。</li>
</ul>
</li>
</ol>
<h3 id="实践-kvm-虚拟化技术"><a class="anchor" href="#实践-kvm-虚拟化技术">#</a> 实践: KVM 虚拟化技术</h3>
<h4 id="kvm-简介"><a class="anchor" href="#kvm-简介">#</a> KVM 简介</h4>
<ul>
<li><strong>全称</strong>: Kernel Virtual Machine，Linux 内核提供的开源 Hypervisor，主流技术。</li>
<li><strong>要求</strong>：主机 x86 架构 + <strong>硬件虚拟化支持</strong> (Intel VT / AMD-V)。</li>
<li><strong>架构</strong>: Type II Hypervisor (寄居架构)。</li>
<li><strong>依赖</strong>：需修改过的 QEMU (qemu-kvm) 作为虚拟机上层控制和界面。</li>
<li><strong>技术</strong>：以<strong>硬件辅助虚拟化</strong>为主。硬件不支持时，退回 QEMU 软件模拟 (<strong>动态二进制翻译</strong>实现 CPU 虚拟化)。</li>
<li><strong>特点</strong>：能在不改变 Linux/Windows 镜像下运行多 VM，可配置个性化硬件环境。支持多种操作系统。</li>
</ul>
<h4 id="kvm-的基本安装操作-概述"><a class="anchor" href="#kvm-的基本安装操作-概述">#</a> KVM 的基本安装操作 (概述)</h4>
<ol>
<li>安装 KVM 及其依赖包 (qemu-kvm, libvirt, virt-manager 等)。</li>
<li>启动  <code>libvirtd</code>  服务，启动 Virtual Machine Manager ( <code>virt-manager</code> ) 图形界面。</li>
<li>配置桥接网络接口 (可选，使 VM 直接接入物理网络)。</li>
<li>创建虚拟机:
<ul>
<li>在  <code>virt-manager</code>  中新建 VM。</li>
<li>选择安装方式 (本地 ISO / 网络 / 导入磁盘等)。</li>
<li>配置 CPU、内存、存储、网络等。</li>
<li>安装 Guest OS。</li>
</ul>
</li>
</ol>
<h3 id="docker简介"><a class="anchor" href="#docker简介">#</a> Docker 简介</h3>
<h4 id="docker-为什么会出现-面临的问题"><a class="anchor" href="#docker-为什么会出现-面临的问题">#</a> Docker 为什么会出现？ (面临的问题)</h4>
<ol>
<li><strong>环境一致性问题</strong>：开发环境 (笔记本)、测试环境、生产环境配置各异，导致 “在我机器上能跑” 但在其他环境跑不起来。</li>
<li><strong>部署复杂性问题</strong>：配置应用运行环境需安装多种软件和依赖包 (Java/Tomcat/MySQL/JDBC 等)，过程繁琐、易出错且跨平台 (Win/Linux) 需重配，应用移植麻烦。</li>
<li><strong>交付标准化问题</strong>：传统交付物是程序 / 字节码，需附加部署文件和详细环境说明，运维部署易出错。</li>
</ol>
<h4 id="docker-是什么"><a class="anchor" href="#docker-是什么">#</a> Docker 是什么？</h4>
<ul>
<li>基于 <strong>Linux 容器技术</strong>发展来的<strong>轻量级容器虚拟化技术</strong>。</li>
<li><strong>核心思想</strong>：解决代码在本机能运行，但在其他机器部署运行失败的问题。</li>
<li><strong>实现方式</strong>：通过<strong>镜像 (Image)</strong> 将程序运行所需的环境、系统、配置、数据等自下而上打包，实现应用跨平台无缝运行，打破 “程序即应用” 观念。</li>
<li><strong>目标</strong>：提供系统平滑移植的<strong>标准化解决方案</strong>。</li>
</ul>
<h4 id="docker-理念"><a class="anchor" href="#docker-理念">#</a> Docker 理念</h4>
<ul>
<li><strong>核心目标</strong>: <strong>Build, Ship and Run Any App, Anywhere</strong> (构建、发布、运行任意应用在任意地方)。</li>
<li><strong>实现</strong>：通过应用组件的封装、分发、部署、运行等生命周期管理，使应用及其运行环境做到 “<strong>一次镜像，处处运行</strong>”。</li>
<li><strong>效果</strong>：实现跨平台、跨服务器部署，只需一次配置环境，一键部署，简化操作。</li>
</ul>
<h4 id="docker-定义总结"><a class="anchor" href="#docker-定义总结">#</a> Docker 定义总结</h4>
<ul>
<li>互联网行业热门技术，尤其在<strong>开发</strong>和<strong>运维</strong>方向，解决规模化、灵活化部署问题。</li>
<li>用于解决<strong>运行环境</strong>和<strong>配置问题</strong>，方便做<strong>持续集成</strong>，有助于整体发布的<strong>容器虚拟化技术</strong>。</li>
</ul>
<h4 id="容器与虚拟机比较"><a class="anchor" href="#容器与虚拟机比较">#</a> 容器与虚拟机比较</h4>
<ol>
<li><strong>传统虚拟机技术</strong>:
<ul>
<li>带环境安装的解决方案 (如 Win10 里跑 CentOS)。</li>
<li>对应用程序透明，模拟完整系统。</li>
<li>缺点: <strong>资源占用多</strong> (需完整 OS)、<strong>冗余步骤多</strong> (启动 OS)、<strong>启动慢</strong> (分钟级)。</li>
</ul>
</li>
<li><strong>容器虚拟化技术 (Docker/LXC)</strong>:
<ul>
<li>在<strong>操作系统层面</strong>实现虚拟化，<strong>直接复用宿主机操作系统内核</strong>。</li>
<li><strong>隔离进程</strong>而非模拟完整 OS，将软件运行所需资源打包到隔离容器中。</li>
<li><strong>优点</strong>: <strong>启动速度快</strong> (秒级)，<strong>占用体积小</strong> (MB 级 vs GB 级)。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>对比总结</strong>:
<ul>
<li>虚拟机：虚拟硬件 -&gt; 运行完整 Guest OS -&gt; 运行应用。<strong>重</strong>。</li>
<li>容器：直接运行于宿主内核 -&gt; 隔离应用进程。<strong>轻</strong>。</li>
<li>隔离性：虚拟机 &gt; 容器。</li>
</ul>
</li>
</ul>
<h4 id="docker-能干嘛"><a class="anchor" href="#docker-能干嘛">#</a> Docker 能干嘛？</h4>
<ol>
<li><strong>技术职位变化</strong>: Coder -&gt; Programmer -&gt; Software Engineer -&gt; <strong>DevOps Engineer</strong> (体现了开发运维一体化趋势)。</li>
<li><strong>一次构建、随处运行</strong>:
<ul>
<li><strong>更快速的应用交付和部署</strong>：打包应用及依赖成镜像，简化部署流程，节省配置测试时间。</li>
<li><strong>更便捷的升级和扩缩容</strong>：微服务架构下，容器如 “积木”，升级 / 扩容只需操作对应容器镜像 (分钟级甚至秒级)。</li>
<li><strong>更简单的系统运维</strong>：应用容器化后，开发 / 测试 / 生产环境高度一致，减少环境问题，易于定位修复 BUG。</li>
<li><strong>更高效的计算资源利用</strong>：内核级虚拟化，无 Hypervisor 额外开销，单机可运行更多容器，提升物理资源利用率。</li>
</ul>
</li>
<li><strong>应用场景</strong>:
<ul>
<li>借鉴标准集装箱思想，Docker 用于<strong>运输软件</strong> (封装应用和依赖)。</li>
<li>适用于各种应用场景 (静态网站、用户数据库、Web 前端、消息队列、数据库等)。</li>
<li>开发 -&gt; 测试 -&gt; 生产环境迁移，保证环境一致性。</li>
</ul>
</li>
<li><strong>使用企业</strong>：微博、美团、蘑菇街等众多互联网公司广泛应用 Docker 进行私有云实践和业务部署。</li>
</ol>
<h3 id="docker的安装"><a class="anchor" href="#docker的安装">#</a> Docker 的安装</h3>
<h4 id="下载与准备"><a class="anchor" href="#下载与准备">#</a> 下载与准备</h4>
<ul>
<li><strong>官网</strong>: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.docker.com">https://www.docker.com</a></li>
<li><strong>仓库</strong>: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hub.docker.com">https://hub.docker.com</a></li>
<li><strong>前提说明</strong>: Docker 依赖 Linux 内核。在 Windows/Mac 上部署 Docker，实质是先安装一个 Linux 虚拟机，然后在虚拟机内运行 Docker。</li>
<li><strong>系统要求</strong>: CentOS 7 (64-bit)，Linux 内核版本 &gt;= 3.8。</li>
<li><strong>查看内核</strong>:  <code>uname -r</code> ,  <code>cat /etc/redhat-release</code></li>
</ul>
<h4 id="docker-三要素"><a class="anchor" href="#docker-三要素">#</a> Docker 三要素</h4>
<ol>
<li><strong>镜像 (Image)</strong>:
<ul>
<li>用于创建 Docker 容器。一个镜像可创建多个容器。</li>
<li>本质是一个文件系统 (e.g.,  <code>centos:7</code>  包含最小化 CentOS 7 系统)。</li>
<li>类似 Java 的 <strong>类</strong> (静态定义)。</li>
</ul>
</li>
<li><strong>容器 (Container)</strong>:
<ul>
<li>用 Docker 镜像创建的<strong>运行实例</strong>。</li>
<li>类似虚拟化运行环境，应用程序 / 服务运行其中。</li>
<li>类似 Java 的 <strong>对象实例</strong> (运行时实体)。</li>
<li>提供标准隔离环境 (启动 / 停止 / 删除)。</li>
<li>看作<strong>简易版 Linux 环境</strong> + 运行的应用。</li>
</ul>
</li>
<li><strong>仓库 (Repository)</strong>:
<ul>
<li>集中存放<strong>镜像文件</strong>的场所。</li>
<li>类似 Maven 仓库 (存 jar) 或 Github 仓库 (存 git 项目)。</li>
<li>分<strong>公开仓库 (Public)</strong> 和<strong>私有仓库 (Private)</strong>。</li>
<li>最大公开仓库: <strong>Docker Hub</strong> (官方)。国内有阿里云、网易云等。</li>
</ul>
</li>
</ol>
<h4 id="docker-平台架构"><a class="anchor" href="#docker-平台架构">#</a> Docker 平台架构</h4>
<ul>
<li><strong>Client-Server 结构</strong>:
<ul>
<li><strong>Docker Client</strong>: 用户与 Docker 交互的命令行工具或 UI。</li>
<li><strong>Docker Daemon (守护进程)</strong>: 运行在主机上，接收并处理 Client 命令，管理容器。</li>
<li><strong>通信</strong>: Client 通过 Socket 与 Daemon 通信。</li>
</ul>
</li>
<li><strong>容器</strong>: Daemon 管理的运行时环境 (集装箱)。</li>
</ul>
<h4 id="docker-平台架构及通信原理简述"><a class="anchor" href="#docker-平台架构及通信原理简述">#</a> Docker 平台架构及通信原理简述</h4>
<ol>
<li>用户使用 <strong>Docker Client</strong> 与 <strong>Docker Daemon</strong> 建立通信并发送请求。</li>
<li><strong>Docker Daemon</strong> 作为 Server 接收请求。</li>
<li><strong>Docker Engine</strong> 执行内部工作，每个工作是一个 <strong>Job</strong>。</li>
<li>需要镜像时，从 <strong>Docker Registry</strong> 下载，通过 <strong>Graph driver</strong> 以 Graph 形式存储。</li>
<li>需创建网络时，通过 <strong>Network driver</strong> 创建配置容器网络。</li>
<li>需限制资源或执行指令时，通过 <strong>Exec driver</strong> 完成。</li>
<li>底层通过 <strong>Libcontainer</strong> (独立容器管理包) 实现对容器的具体操作 (Network/Exec driver 都调用它)。<strong>Namespace</strong> 实现资源隔离，<strong>Cgroups</strong> 实现资源控制。</li>
</ol>
<h4 id="docker-安装步骤"><a class="anchor" href="#docker-安装步骤">#</a> Docker 安装步骤</h4>
<h4 id="测试-hello-world"><a class="anchor" href="#测试-hello-world">#</a> 测试 hello-world</h4>
<ul>
<li><code>docker run hello-world</code> : 运行测试镜像。</li>
<li><strong>流程</strong>：本地无镜像 -&gt; 从 Docker Hub 拉取 -&gt; 运行容器 -&gt; 输出信息 -&gt; 容器退出。</li>
</ul>
<h4 id="底层原理-docker-为何比-vm-快"><a class="anchor" href="#底层原理-docker-为何比-vm-快">#</a> 底层原理: Docker 为何比 VM 快？</h4>
<ol>
<li><strong>更少的抽象层</strong>: Docker 无需 Hypervisor 实现硬件虚拟化，直接使用宿主机硬件。</li>
<li><strong>共享宿主机内核</strong>: Docker 容器共享宿主机 OS 内核，无需加载额外 OS 内核。避免了 VM 启动引导、加载 OS 内核等耗时过程。</li>
</ol>
<ul>
<li><strong>结果</strong>: VM 创建是分钟级，Docker 容器创建是秒级。</li>
</ul>
<h3 id="docker常用命令"><a class="anchor" href="#docker常用命令">#</a> Docker 常用命令</h3>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/cloud-computing/e350a74de6ee313b99b9080dc22f3bcce52541aa77e8f8c85a38830431330831.png" alt="picture 17"></p>
<h4 id="帮助启动类"><a class="anchor" href="#帮助启动类">#</a> 帮助启动类</h4>
<ul>
<li><code>systemctl start/stop/restart/status/enable docker</code></li>
<li><code>docker info</code> : 查看 Docker 系统信息。</li>
<li><code>docker version</code> : 查看 Docker 版本信息。</li>
<li><code>docker --help</code> : 查看 Docker 帮助。</li>
<li><code>docker COMMAND --help</code> : 查看具体命令帮助。</li>
</ul>
<h4 id="镜像命令"><a class="anchor" href="#镜像命令">#</a> 镜像命令</h4>
<ul>
<li><code>docker images</code>  /  <code>-a</code>  /  <code>-q</code>  /  <code>--digests</code>  /  <code>--no-trunc</code> : 列出本地镜像 (所有 / 仅 ID / 摘要 / 完整信息)。</li>
<li><code>docker search &lt;image_name&gt;</code> : 在 Docker Hub 搜索镜像。</li>
<li><code>docker pull &lt;image_name&gt;[:TAG]</code> : 下载镜像 (默认 latest)。</li>
<li><code>docker rmi &lt;image_name_or_id&gt;</code>  /  <code>-f</code> : 删除未使用镜像 (强制删除)。可删除多个。</li>
<li><code>docker system df</code> : 查看 Docker 资源占用 (镜像 / 容器 / 数据卷)。</li>
<li><strong>虚悬镜像 (Dangling Image)</strong>: 仓库名和 TAG 均为  <code>&lt;none&gt;</code>  的镜像。</li>
</ul>
<h4 id="容器命令"><a class="anchor" href="#容器命令">#</a> 容器命令</h4>
<ul>
<li><code>docker run [options] IMAGE [command] [arg...]</code> : 新建并启动容器。
<ul>
<li><code>-i</code> : 交互模式。</li>
<li><code>-t</code> : 分配伪终端。</li>
<li><code>-d</code> : 后台运行 (守护式容器)。</li>
</ul>
</li>
<li><code>docker ps</code>  /  <code>-a</code>  /  <code>-q</code> : 列出正在运行的容器 (所有 / 仅 ID)。</li>
<li><code>exit</code> : 退出<strong>并停止</strong>容器 (交互式)。</li>
<li><code>Ctrl+P+Q</code> : 退出容器但<strong>不停止</strong> (交互式)。</li>
<li><code>docker start/restart/stop/kill &lt;container_name_or_id&gt;</code> : 启动 / 重启 / 停止 / 强制停止容器。</li>
<li><code>docker rm &lt;container_name_or_id&gt;</code>  /  <code>-f</code> : 删除已停止的容器 (强制删除运行中容器)。</li>
<li><code>docker logs [options] &lt;container_name_or_id&gt;</code> : 查看容器日志 ( <code>-t</code>  时间戳， <code>-f</code>  跟随， <code>--tail N</code>  最后 N 条)。</li>
<li><code>docker top &lt;container_name_or_id&gt;</code> : 查看容器内运行的进程。</li>
<li><code>docker inspect &lt;container_name_or_id&gt;</code> : 查看容器内部细节 (JSON 格式)。</li>
<li><code>docker exec -it &lt;container_id&gt; /bin/bash</code> : 进入正在运行的容器并执行命令 (exit 不停止容器)。</li>
<li><code>docker attach &lt;container_id&gt;</code> : 重新附加到容器终端 (exit 会停止容器)。</li>
<li><code>docker cp &lt;container_id:src_path&gt; &lt;host_dest_path&gt;</code> : 从容器内拷贝文件到宿主机。</li>
</ul>
<h3 id="docker镜像"><a class="anchor" href="#docker镜像">#</a> Docker 镜像</h3>
<h4 id="镜像是什什么"><a class="anchor" href="#镜像是什什么">#</a> 镜像是什什么？</h4>
<ul>
<li>轻量级、可执行的独立软件包。</li>
<li>包含运行应用所需的一切：代码、运行时、库、环境变量、配置文件。</li>
<li>用于生成 Docker 容器实例。</li>
</ul>
<h4 id="分层的镜像"><a class="anchor" href="#分层的镜像">#</a> 分层的镜像</h4>
<ul>
<li><code>docker pull</code>  过程显示镜像是一层一层下载的。</li>
</ul>
<h4 id="联合文件系统-unionfs"><a class="anchor" href="#联合文件系统-unionfs">#</a> 联合文件系统 (UnionFS)</h4>
<ul>
<li>Docker 镜像由<strong>一层层文件系统</strong>组成，这种层级文件系统即 UnionFS。</li>
<li><strong>特性</strong>：分层、轻量级、高性能。支持将文件系统修改作为一次提交层层叠加。可将不同目录挂载到同一虚拟文件系统下，对外透明。</li>
<li><strong>基础</strong>: UnionFS 是 Docker 镜像的基础。镜像通过<strong>分层继承</strong>，基于基础镜像 (无父镜像) 制作应用镜像。</li>
</ul>
<h4 id="docker-镜像加载原理"><a class="anchor" href="#docker-镜像加载原理">#</a> Docker 镜像加载原理</h4>
<ul>
<li><strong>bootfs (boot file system)</strong>: 包含 bootloader 和 kernel。Linux 启动时加载，完成后内核接管内存，bootfs 被卸载。<strong>各发行版一致，可共享</strong>。</li>
<li><strong>rootfs (root file system)</strong>: 位于 bootfs 之上，包含  <code>/dev</code> ,  <code>/proc</code> ,  <code>/bin</code> ,  <code>/etc</code>  等标准目录和文件。代表不同操作系统发行版 (Ubuntu, CentOS)。<strong>不同发行版有差别</strong>。</li>
<li>精简 OS 的 rootfs 可以很小，只需基本命令 / 工具 / 库。</li>
</ul>
<h4 id="docker-镜像采用分层结构的好处"><a class="anchor" href="#docker-镜像采用分层结构的好处">#</a> Docker 镜像采用分层结构的好处</h4>
<ol>
<li><strong>镜像特点</strong>: Docker 镜像是<strong>只读</strong>的。容器启动时，在镜像顶部加载一个<strong>可写层 (容器层)</strong>。</li>
<li><strong>分层优点</strong>:
<ul>
<li><strong>共享资源</strong>：多个镜像若基于相同 Base 镜像构建，Host 只需存一份 Base 镜像。内存中也只需加载一份 Base 镜像，供所有容器共享。</li>
<li><strong>方便复制迁移与复用</strong>。</li>
</ul>
</li>
</ol>
<h4 id="docker-镜像-commit-操作"><a class="anchor" href="#docker-镜像-commit-操作">#</a> Docker 镜像 - commit 操作</h4>
<ul>
<li><code>docker commit -m &quot;message&quot; -a &quot;author&quot; &lt;container_id&gt; &lt;target_image_name&gt;[:TAG]</code></li>
<li>将<strong>容器的当前状态</strong> (包括其可写层的修改) 提交，生成一个新的镜像。</li>
</ul>
<h4 id="总结"><a class="anchor" href="#总结">#</a> 总结</h4>
<ul>
<li>Docker 镜像分层，支持通过扩展现有镜像创建新镜像 (类似 Java 继承)。</li>
<li>新镜像是从 Base 镜像一层层叠加生成。每次安装软件，都在现有镜像基础上增加一层。</li>
</ul>
<h3 id="容器数据卷-volume"><a class="anchor" href="#容器数据卷-volume">#</a> 容器数据卷 (Volume)</h3>
<h4 id="是什么"><a class="anchor" href="#是什么">#</a> 是什么？</h4>
<ul>
<li>用于<strong>持久化</strong>容器数据，解决容器删除后数据丢失问题。</li>
<li>是宿主机上的一个<strong>目录或文件</strong>，通过 Docker 挂载到容器中。</li>
<li><strong>独立于联合文件系统 (UFS)</strong>，生命周期独立于容器。</li>
</ul>
<h4 id="容器内添加数据卷"><a class="anchor" href="#容器内添加数据卷">#</a> 容器内添加数据卷</h4>
<ul>
<li><code>docker run -it -v /host_absolute_path:/container_path[:ro] &lt;image_name&gt;</code></li>
<li>将宿主机目录与容器内目录绑定。两者内容<strong>实时同步</strong>。</li>
<li><code>:ro</code>  表示只读挂载 (容器内不可写)。</li>
</ul>
<h4 id="容器数据卷的特点"><a class="anchor" href="#容器数据卷的特点">#</a> 容器数据卷的特点</h4>
<ol>
<li>可在容器间<strong>共享或重用</strong>。</li>
<li>容器与宿主机间<strong>数据共享</strong>，修改<strong>即时生效</strong>。</li>
<li>数据卷的更改<strong>不包含</strong>在镜像更新中 (commit 不会打包数据卷内容)。</li>
<li>数据卷生命周期持续到<strong>没有容器使用它为止</strong> (容器删除，数据卷<strong>不会</strong>被删除)。</li>
</ol>
<h4 id="数据卷的继承和共享"><a class="anchor" href="#数据卷的继承和共享">#</a> 数据卷的继承和共享</h4>
<ul>
<li><code>docker run -it --volumes-from &lt;source_container_name&gt; --name &lt;new_container_name&gt; &lt;image_name&gt;</code></li>
<li>新容器 ( <code>u2</code> ) 可以继承另一个容器 ( <code>u1</code> ) 挂载的数据卷。</li>
</ul>
<h3 id="dockerfile-解析"><a class="anchor" href="#dockerfile-解析">#</a> Dockerfile 解析</h3>
<h4 id="是什么-2"><a class="anchor" href="#是什么-2">#</a> 是什么？</h4>
<ul>
<li>用来<strong>构建 Docker 镜像</strong>的文本文件。</li>
<li>包含一系列<strong>命令和参数</strong>构成的脚本。</li>
<li>内容定义了镜像构建过程：执行代码、设置环境变量、安装依赖包、指定运行时环境、操作系统发行版等。</li>
<li>Docker 通过读取 Dockerfile 指令自动构建镜像。</li>
</ul>
<h4 id="dockerfile-镜像-容器的关系-类比"><a class="anchor" href="#dockerfile-镜像-容器的关系-类比">#</a> Dockerfile, 镜像，容器的关系 (类比)</h4>
<ul>
<li><strong>Dockerfile</strong>: 软件原材料 (中药处方)。 <strong>面向开发</strong>。</li>
<li><strong>Docker 镜像</strong>：软件交付品 (抓好的中药)。 成为<strong>交付标准</strong>。</li>
<li><strong>Docker 容器</strong>：软件镜像的运行态 (熬出的中药汤)。 涉及<strong>部署与运维</strong>。</li>
</ul>
<h4 id="dockerfile-构建过程解析"><a class="anchor" href="#dockerfile-构建过程解析">#</a> Dockerfile 构建过程解析</h4>
<ul>
<li><strong>基础知识</strong>:
<ol>
<li>每条保留字指令<strong>必须为大写字母</strong>且后跟至少一个参数。</li>
<li>指令按<strong>从上到下顺序执行</strong>。</li>
<li><code>#</code>  表示注释。</li>
<li>每条指令都会创建一个新的<strong>镜像层</strong>并对镜像进行提交。</li>
</ol>
</li>
<li><strong>大致流程</strong>:
<ol>
<li>Docker 从基础镜像运行一个容器。</li>
<li>执行一条指令，对容器作出修改。</li>
<li>执行类似  <code>docker commit</code>  的操作，提交一个新的镜像层。</li>
<li>Docker 再基于刚提交的镜像运行一个新容器。</li>
<li>重复 2-4 步，直到所有指令执行完毕。</li>
</ol>
</li>
</ul>
<h4 id="dockerfile-常用保留字指令"><a class="anchor" href="#dockerfile-常用保留字指令">#</a> Dockerfile 常用保留字指令</h4>
<ul>
<li><strong>FROM</strong>: 指定基础镜像。</li>
<li><strong>MAINTAINER</strong>: 镜像维护者姓名和邮箱 (已废弃，推荐用 LABEL)。</li>
<li><strong>WORKDIR</strong>: 指定容器工作目录 (后续 RUN/CMD/ENTRYPOINT/COPY/ADD 指令在此目录下执行)。</li>
<li><strong>ENV</strong>: 设置环境变量。</li>
<li><strong>VOLUME</strong>: 定义匿名数据卷，用于数据保存和持久化。</li>
<li><strong>EXPOSE</strong>: 声明容器运行时对外暴露的端口 (仅声明，实际端口映射在  <code>docker run -p</code>  指定)。</li>
<li><strong>ADD</strong>: 复制文件 / 目录到镜像。支持 URL，且<strong>自动解压</strong> tar 压缩包。</li>
<li><strong>COPY</strong>: 类似 ADD，复制文件 / 目录到镜像。<strong>不支持 URL 和自动解压</strong>。</li>
<li><strong>RUN</strong>: 在<strong>镜像构建时</strong>执行命令 (e.g., 安装软件)。</li>
<li><strong>CMD</strong>: 指定<strong>容器启动时</strong>默认执行的命令。Dockerfile 可有多个 CMD，只有最后一个生效。会被  <code>docker run</code>  后面的命令覆盖。</li>
<li><strong>ENTRYPOINT</strong>: 指定<strong>容器启动时</strong>执行的命令。<strong>不会</strong>被  <code>docker run</code>  后面的命令覆盖，参数会传递给 ENTRYPOINT 指定的程序。</li>
</ul>
<h4 id="run-cmd-entrypoint-对比"><a class="anchor" href="#run-cmd-entrypoint-对比">#</a> RUN, CMD, ENTRYPOINT 对比</h4>
<ul>
<li><strong>RUN</strong>: 构建时执行。</li>
<li><strong>CMD</strong>: 容器启动时执行 (默认命令，可被覆盖)。</li>
<li><strong>ENTRYPOINT</strong>: 容器启动时执行 (入口点，不可被覆盖，参数追加)。</li>
<li><strong>Note</strong>: RUN 在构建时运行并提交到镜像；CMD 在构建时不执行，在容器启动时执行，指定默认命令。</li>
</ul>
<h4 id="案例-自定义镜像-centosjava810"><a class="anchor" href="#案例-自定义镜像-centosjava810">#</a> 案例：自定义镜像 centosjava8:1.0</h4>
<ul>
<li><strong>需求</strong>：基于 CentOS 7，安装 vim, ifconfig, JDK 8。</li>
<li><strong>步骤</strong>:
<ol>
<li>准备基础环境 (CentOS 7 镜像，JDK tar 包)。</li>
<li>编写 Dockerfile (使用 FROM, MAINTAINER, ENV, WORKDIR, RUN, ADD, CMD 指令)。</li>
<li>构建镜像:  <code>docker build -t &lt;image_name&gt;:&lt;tag&gt; .</code>  (注意最后的点表示 Dockerfile 路径)。</li>
<li>运行容器:  <code>docker run -it &lt;image_name&gt;:&lt;tag&gt;</code> 。</li>
<li>验证 (检查 java -version, ifconfig)。</li>
</ol>
</li>
</ul>
<h3 id="虚悬镜像-dangling-image"><a class="anchor" href="#虚悬镜像-dangling-image">#</a> 虚悬镜像 (Dangling Image)</h3>
<h4 id="是什么-3"><a class="anchor" href="#是什么-3">#</a> 是什么？</h4>
<ul>
<li>镜像列表中，仓库名 (REPOSITORY) 和标签 (TAG) 都显示为  <code>&lt;none&gt;</code>  的镜像。</li>
<li>通常是由于构建了新镜像，覆盖了旧镜像的 TAG 导致旧镜像失去引用名。</li>
</ul>
<h4 id="查看"><a class="anchor" href="#查看">#</a> 查看</h4>
<ul>
<li><code>docker image ls -f dangling=true</code></li>
</ul>
<h4 id="删除"><a class="anchor" href="#删除">#</a> 删除</h4>
<ul>
<li><code>docker image prune</code> : 删除所有虚悬镜像。</li>
</ul>
<div class="tags"><a href="/tags/computer-science/" rel="tag"><i class="ic i-tag"></i>computer science</a><a href="/tags/learning/" rel="tag"><i class="ic i-tag"></i>learning</a><a href="/tags/cloud-computing/" rel="tag"><i class="ic i-tag"></i>cloud computing</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-eye"></i></span><span class="text">总访问量：</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/cloud-computing/">加载中...</span></span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2025-05-19 08:32:05" itemprop="dateModified" datetime="2025-05-19T08:32:05+08:00">2025-05-19</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>IOyuk1Nya<i class="ic i-at"><em>@</em></i>IOyuk1Nya's Blog</li><li class="link"><strong>本文链接：</strong><a href="https://blog.ivansnow02.xyz/cloud-computing/" title="cloud_computing">https://blog.ivansnow02.xyz/cloud-computing/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/software-engineering/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2024&#x2F;06&#x2F;16&#x2F;frYjsXpz1AteZvb.jpg" title="软件工程复习"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>computer science</span><h3>软件工程复习</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97"><span class="toc-number">1.</span> <span class="toc-text"> 大数据与云计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3"><span class="toc-number">1.1.</span> <span class="toc-text"> 大数据时代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 大数据定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81-4v1c"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 大数据特征 (4V+1C)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.</span> <span class="toc-text"> 云计算 —— 大数据的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 云计算和大数据关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 云计算的起源与定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%B5%84%E6%BA%90%E6%B1%A0"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 云计算的核心概念：资源池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E5%BE%81-7%E4%B8%AA"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 云计算的关键特征 (7 个)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%95%86%E4%B8%9A%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 云计算的商业特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6"><span class="toc-number">1.3.</span> <span class="toc-text"> 云计算发展现状</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E5%B1%82"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 服务模式分层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 部署模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text"> 云计算实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 分层架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BC%98%E5%8A%BF"><span class="toc-number">1.5.</span> <span class="toc-text"> 云计算优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 成本效益</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%94%B6%E7%9B%8A"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 用户收益</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 核心架构思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%E9%A2%98-%E4%B9%A0%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text"> 复习题 (习题)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text"> 分布式计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text"> 分布式计算概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F-vs-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 集中式 vs 分布式对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E4%BC%98%E7%82%B9"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 分布式计算优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E8%AE%A1%E7%AE%97%E4%BC%98%E7%82%B9"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 集中式计算优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.5.</span> <span class="toc-text"> 分布式计算应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-number">3.1.6.</span> <span class="toc-text"> 分布式计算原理 (分而治之)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.1.7.</span> <span class="toc-text"> 分布式计算步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">3.2.</span> <span class="toc-text"> 分布式计算的理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acid%E5%8E%9F%E5%88%99-%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-%E5%86%85%E9%83%A8%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.2.1.</span> <span class="toc-text"> ACID 原则 (本地事务管理、内部一致性)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#acid%E5%8E%9F%E5%88%99%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.2.</span> <span class="toc-text"> ACID 原则缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cap%E7%90%86%E8%AE%BA-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%A4%96%E9%83%A8%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.2.3.</span> <span class="toc-text"> CAP 理论 (分布式事务、外部一致性)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cap%E7%90%86%E8%AE%BA%E9%98%90%E8%BF%B0"><span class="toc-number">3.2.4.</span> <span class="toc-text"> CAP 理论阐述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cap%E6%9D%83%E8%A1%A1"><span class="toc-number">3.2.5.</span> <span class="toc-text"> CAP 权衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#base%E7%90%86%E8%AE%BA"><span class="toc-number">3.2.6.</span> <span class="toc-text"> BASE 理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#base%E4%B8%8Eacid%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.7.</span> <span class="toc-text"> BASE 与 ACID 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%A3%E5%88%97"><span class="toc-number">3.2.8.</span> <span class="toc-text"> 一致性散列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95-consistent-hashing"><span class="toc-number">3.2.9.</span> <span class="toc-text"> 一致性散列算法 (Consistent Hashing)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">3.3.</span> <span class="toc-text"> 分布式系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 基础知识 (大数据驱动)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8Bapache-hadoop"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 实例：Apache Hadoop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E9%98%B6"><span class="toc-number">3.4.</span> <span class="toc-text"> 分布式系统的进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-5%E4%B8%AA%E5%AD%90%E6%96%B9%E5%90%91"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 分布式存储系统 (5 个子方向)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 分布式计算系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E7%9A%84%E7%B3%BB%E7%BB%9F-mpi"><span class="toc-number">3.4.2.1.</span> <span class="toc-text"> 1. 传统基于消息的系统 (MPI)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-mapreduce%E5%AE%B6%E6%97%8F%E7%B3%BB%E7%BB%9F-mapreduce-spark"><span class="toc-number">3.4.2.2.</span> <span class="toc-text"> 2. MapReduce 家族系统 (MapReduce, Spark)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9B%BE%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F-pregelbsp-graphlabgas"><span class="toc-number">3.4.2.3.</span> <span class="toc-text"> 3. 图计算系统 (Pregel&#x2F;BSP &amp; GraphLab&#x2F;GAS)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AE%9E%E6%97%B6%E6%B5%81%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F-storm"><span class="toc-number">3.4.2.4.</span> <span class="toc-text"> 5. 实时流处理系统 (Storm)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text"> 分布式资源管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0%E7%89%B9%E7%82%B9"><span class="toc-number">3.4.3.1.</span> <span class="toc-text"> 统一管理调度平台特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#apache-hadoop-yarn-yet-another-resource-negotiator"><span class="toc-number">3.4.3.2.</span> <span class="toc-text"> Apache Hadoop YARN (Yet Another Resource Negotiator)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#apache-mesos"><span class="toc-number">3.4.3.3.</span> <span class="toc-text"> Apache Mesos</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mesos%E4%B8%8Eyarn%E6%AF%94%E8%BE%83"><span class="toc-number">3.4.3.4.</span> <span class="toc-text"> Mesos 与 YARN 比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text"> 课后习题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%A4%96%E6%80%9D%E8%80%83"><span class="toc-number">3.6.</span> <span class="toc-text"> 课外思考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text"> 云计算架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.1.</span> <span class="toc-text"> 云计算的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A9%E5%91%BD%E6%80%A7%E6%A6%82%E5%BF%B5it%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 革命性概念：IT 作为服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 云计算系统工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 云数据中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E6%A8%A1%E5%BC%8F-%E6%8E%8C%E6%8F%A1"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 云的工作负载模式 (掌握)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text"> 云计算的架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%9B%E5%8C%96"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 计算架构的进化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BA%8C%E7%BB%B4%E8%A7%86%E8%A7%92"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 一般云计算架构的二维视角</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.2.1.</span> <span class="toc-text"> 基础架构的分层结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rest%E6%9E%B6%E6%9E%84%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">4.2.2.2.</span> <span class="toc-text"> REST 架构：云计算的软件架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E6%A0%88%E5%92%8C%E4%BA%91%E4%BD%93"><span class="toc-number">4.3.</span> <span class="toc-text"> 云栈和云体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E6%A0%88-%E4%B8%89%E5%B1%82%E4%BA%91%E6%A0%88%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 云栈 (三层云栈架构 - 服务模式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%91%E4%BD%93"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 云体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-sddc"><span class="toc-number">4.4.</span> <span class="toc-text"> 软件定义的数据中心 (SDDC)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 数据中心的历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 传统数据中心的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83-sddc"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 什么是软件定义数据中心 (SDDC)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sddc-%E7%9A%84%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">4.4.4.</span> <span class="toc-text"> SDDC 的分层模型与架构分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-openstack"><span class="toc-number">4.5.</span> <span class="toc-text"> 实践: OpenStack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text"> 课后习题 (小结)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%A4%96%E6%80%9D%E8%80%83-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.7.</span> <span class="toc-text"> 课外思考 (小结)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.8.</span> <span class="toc-text"> 动手实践 (小结)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">5.</span> <span class="toc-text"> 虚拟化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text"> 虚拟化的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8E%86%E5%8F%B2"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 虚拟化历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x86%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96%E6%BC%94%E8%BF%9B"><span class="toc-number">5.1.2.</span> <span class="toc-text"> x86 架构中的虚拟化演进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.3.</span> <span class="toc-text"> 虚拟化概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%BB%E8%A6%81%E5%88%86%E7%B1%BB-4%E5%A4%A7%E7%B1%BB"><span class="toc-number">5.1.4.</span> <span class="toc-text"> 虚拟化技术主要分类 (4 大类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97"><span class="toc-number">5.1.5.</span> <span class="toc-text"> 虚拟化与云计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text"> 服务器虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 基本概念与架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hypervisor-%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text"> Hypervisor 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x86%E6%9E%B6%E6%9E%84%E5%AF%B9%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E9%99%90%E5%88%B6-ring%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="toc-number">5.2.3.</span> <span class="toc-text"> x86 架构对虚拟化的限制 (Ring 特权级)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vmm-%E5%AE%9E%E7%8E%B0-guest-os-%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">5.2.4.</span> <span class="toc-text"> VMM 实现 Guest OS 访问硬件的三种技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">5.2.5.</span> <span class="toc-text"> 全虚拟化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">5.2.6.</span> <span class="toc-text"> 半虚拟化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%BE%85%E5%8A%A9%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">5.2.7.</span> <span class="toc-text"> 硬件辅助虚拟化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E6%AF%94%E8%BE%83"><span class="toc-number">5.2.8.</span> <span class="toc-text"> 虚拟化实现技术比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.</span> <span class="toc-text"> 商用虚拟机技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%9E%8B%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text"> 新型硬件虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E4%BB%A3%E8%A1%A8"><span class="toc-number">5.4.2.</span> <span class="toc-text"> 硬件虚拟化的代表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="toc-number">5.4.3.</span> <span class="toc-text"> 硬件虚拟化的未来</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-xen-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">5.5.</span> <span class="toc-text"> 实践: Xen 虚拟化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xen-%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">5.5.1.</span> <span class="toc-text"> Xen 的历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xen-%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.5.2.</span> <span class="toc-text"> Xen 实际操作 (概述)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-kvm-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">5.6.</span> <span class="toc-text"> 实践: KVM 虚拟化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kvm-%E7%AE%80%E4%BB%8B"><span class="toc-number">5.6.1.</span> <span class="toc-text"> KVM 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kvm-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.6.2.</span> <span class="toc-text"> KVM 的基本安装操作 (概述)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E7%AE%80%E4%BB%8B"><span class="toc-number">5.7.</span> <span class="toc-text"> Docker 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.1.</span> <span class="toc-text"> Docker 为什么会出现？ (面临的问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.7.2.</span> <span class="toc-text"> Docker 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E7%90%86%E5%BF%B5"><span class="toc-number">5.7.3.</span> <span class="toc-text"> Docker 理念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E5%AE%9A%E4%B9%89%E6%80%BB%E7%BB%93"><span class="toc-number">5.7.4.</span> <span class="toc-text"> Docker 定义总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%AF%94%E8%BE%83"><span class="toc-number">5.7.5.</span> <span class="toc-text"> 容器与虚拟机比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">5.7.6.</span> <span class="toc-text"> Docker 能干嘛？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">5.8.</span> <span class="toc-text"> Docker 的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%87%86%E5%A4%87"><span class="toc-number">5.8.1.</span> <span class="toc-text"> 下载与准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">5.8.2.</span> <span class="toc-text"> Docker 三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84"><span class="toc-number">5.8.3.</span> <span class="toc-text"> Docker 平台架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%8F%8A%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-number">5.8.4.</span> <span class="toc-text"> Docker 平台架构及通信原理简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.8.5.</span> <span class="toc-text"> Docker 安装步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-hello-world"><span class="toc-number">5.8.6.</span> <span class="toc-text"> 测试 hello-world</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-docker-%E4%B8%BA%E4%BD%95%E6%AF%94-vm-%E5%BF%AB"><span class="toc-number">5.8.7.</span> <span class="toc-text"> 底层原理: Docker 为何比 VM 快？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.9.</span> <span class="toc-text"> Docker 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E5%90%AF%E5%8A%A8%E7%B1%BB"><span class="toc-number">5.9.1.</span> <span class="toc-text"> 帮助启动类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">5.9.2.</span> <span class="toc-text"> 镜像命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.9.3.</span> <span class="toc-text"> 容器命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E9%95%9C%E5%83%8F"><span class="toc-number">5.10.</span> <span class="toc-text"> Docker 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%98%AF%E4%BB%80%E4%BB%80%E4%B9%88"><span class="toc-number">5.10.1.</span> <span class="toc-text"> 镜像是什什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">5.10.2.</span> <span class="toc-text"> 分层的镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-unionfs"><span class="toc-number">5.10.3.</span> <span class="toc-text"> 联合文件系统 (UnionFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">5.10.4.</span> <span class="toc-text"> Docker 镜像加载原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E9%95%9C%E5%83%8F%E9%87%87%E7%94%A8%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">5.10.5.</span> <span class="toc-text"> Docker 镜像采用分层结构的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-%E9%95%9C%E5%83%8F-commit-%E6%93%8D%E4%BD%9C"><span class="toc-number">5.10.6.</span> <span class="toc-text"> Docker 镜像 - commit 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.10.7.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7-volume"><span class="toc-number">5.11.</span> <span class="toc-text"> 容器数据卷 (Volume)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.11.1.</span> <span class="toc-text"> 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">5.11.2.</span> <span class="toc-text"> 容器内添加数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.11.3.</span> <span class="toc-text"> 容器数据卷的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="toc-number">5.11.4.</span> <span class="toc-text"> 数据卷的继承和共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile-%E8%A7%A3%E6%9E%90"><span class="toc-number">5.12.</span> <span class="toc-text"> Dockerfile 解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">5.12.1.</span> <span class="toc-text"> 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile-%E9%95%9C%E5%83%8F-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB-%E7%B1%BB%E6%AF%94"><span class="toc-number">5.12.2.</span> <span class="toc-text"> Dockerfile, 镜像，容器的关系 (类比)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">5.12.3.</span> <span class="toc-text"> Dockerfile 构建过程解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile-%E5%B8%B8%E7%94%A8%E4%BF%9D%E7%95%99%E5%AD%97%E6%8C%87%E4%BB%A4"><span class="toc-number">5.12.4.</span> <span class="toc-text"> Dockerfile 常用保留字指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run-cmd-entrypoint-%E5%AF%B9%E6%AF%94"><span class="toc-number">5.12.5.</span> <span class="toc-text"> RUN, CMD, ENTRYPOINT 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F-centosjava810"><span class="toc-number">5.12.6.</span> <span class="toc-text"> 案例：自定义镜像 centosjava8:1.0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F-dangling-image"><span class="toc-number">5.13.</span> <span class="toc-text"> 虚悬镜像 (Dangling Image)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">5.13.1.</span> <span class="toc-text"> 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B"><span class="toc-number">5.13.2.</span> <span class="toc-text"> 查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">5.13.3.</span> <span class="toc-text"> 删除</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-organization/" rel="bookmark" title="计算机组成原理复习">计算机组成原理复习</a></li><li><a href="/ComputerSystem/" rel="bookmark" title="操作系统复习">操作系统复习</a></li><li><a href="/DataBaseLearning/" rel="bookmark" title="数据库系统概论概念整理">数据库系统概论概念整理</a></li><li><a href="/sql-lab/" rel="bookmark" title="SQL代码复习">SQL代码复习</a></li><li><a href="/computer-network/" rel="bookmark" title="计算机网络">计算机网络</a></li><li><a href="/ai-fundamental/" rel="bookmark" title="人工智能基础">人工智能基础</a></li><li><a href="/Compilers/" rel="bookmark" title="编译技术笔记">编译技术笔记</a></li><li><a href="/computer-graphics/" rel="bookmark" title="计算机图形学">计算机图形学</a></li><li><a href="/software-engineering/" rel="bookmark" title="软件工程复习">软件工程复习</a></li><li class="active"><a href="/cloud-computing/" rel="bookmark" title="cloud_computing">cloud_computing</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="IOyuk1Nya" src="/img/avatar.png"><p class="name" itemprop="name">IOyuk1Nya</p><div class="description" itemprop="description">some notes about computer science</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">50</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">24</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ivansnow02" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;ivansnow02"><i class="ic i-github"></i></a><a href="mailto:eone2017@protonmail.com" rel="external nofollow noreferrer" class="item email" title="mailto:eone2017@protonmail.com"><i class="ic i-envelope"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/links/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/software-engineering/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于computer science">computer science</a></div><span><a href="/DataBaseLearning/">数据库系统概论概念整理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cs/" title="分类于计算机科学">计算机科学</a><i class="ic i-angle-right"></i><a href="/categories/cs/408/" title="分类于408">408</a><i class="ic i-angle-right"></i><a href="/categories/cs/408/ds/" title="分类于数据结构">数据结构</a></div><span><a href="/cs/408/ds/TS/">拓扑排序 Topological Sort</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/trash/" title="分类于trash">trash</a></div><span><a href="/XJP/">习近平新时代中国特色社会主义思想概论</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithms/" title="分类于algorithms">algorithms</a></div><span><a href="/AlgorithmIntroduction/">算法导论笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于computer science">computer science</a></div><span><a href="/ComputerSystem/">操作系统复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cs/" title="分类于计算机科学">计算机科学</a><i class="ic i-angle-right"></i><a href="/categories/cs/408/" title="分类于408">408</a><i class="ic i-angle-right"></i><a href="/categories/cs/408/ds/" title="分类于数据结构">数据结构</a></div><span><a href="/cs/408/ds/DataStructureTest01/">数据结构题目01</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Java/" title="分类于Java">Java</a></div><span><a href="/java-learning/">Java学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Redis/" title="分类于Redis">Redis</a></div><span><a href="/Redis-Learning-02-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Redis的快速入门</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Physics/" title="分类于Physics">Physics</a></div><span><a href="/%E7%89%A9%E7%90%86%E5%A4%8D%E4%B9%A0/">物理复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cs/" title="分类于计算机科学">计算机科学</a><i class="ic i-angle-right"></i><a href="/categories/cs/408/" title="分类于408">408</a><i class="ic i-angle-right"></i><a href="/categories/cs/408/ds/" title="分类于数据结构">数据结构</a></div><span><a href="/cs/408/ds/MST/">最小生成树 Minimum Spanning Tree</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">IOyuk1Nya @ Code Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">820k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">12:26</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div><script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script><div id="busuanzi-wrap"><span class="ic i-eye"></span><span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span> | <span class="ic i-user"></span><span id="busuanzi_container_site_uv">本站访客量 <span id="busuanzi_value_site_uv"></span> 次</span></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
    path: `cloud-computing/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: true,
    katex: true,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="undefined/undefined" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0&amp;features=default,fetch" defer="defer"></script><script src="/js/siteInit.js?v=0.4.25" type="module" fetchpriority="high" defer="defer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script>
    Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/';
  </script>
</body></html>