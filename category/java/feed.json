{
    "version": "https://jsonfeed.org/version/1",
    "title": "Snow's Blog • All posts by \"java\" category",
    "description": "some notes about computer science",
    "home_page_url": "https://blog.ivansnow02.xyz",
    "items": [
        {
            "id": "https://blog.ivansnow02.xyz/java-learning/",
            "url": "https://blog.ivansnow02.xyz/java-learning/",
            "title": "Java学习",
            "date_published": "2024-11-03T02:59:18.000Z",
            "content_html": "<h2 id=\"java概述\"><a class=\"anchor\" href=\"#java概述\">#</a> Java 概述</h2>\n<h3 id=\"java语言的主要特点\"><a class=\"anchor\" href=\"#java语言的主要特点\">#</a> Java 语言的主要特点</h3>\n<ul>\n<li>简单性</li>\n<li>面向对象</li>\n<li>跨平台</li>\n<li>安全性</li>\n<li>多线程</li>\n<li>动态性</li>\n</ul>\n<h3 id=\"初始java程序\"><a class=\"anchor\" href=\"#初始java程序\">#</a> 初始 Java 程序</h3>\n<p>Java 源文件以 “java” 结尾，此文件中<strong>最多只能有一个类被声明为 public</strong>，保存时源文件名需与 public 类名相同，如果文件中不存在 public 类，源文件名无要求。</p>\n<p>一个源文件包含几个类就可以编译出几个.class 文件。</p>\n<h2 id=\"基本程序设计\"><a class=\"anchor\" href=\"#基本程序设计\">#</a> 基本程序设计</h2>\n<h3 id=\"常量\"><a class=\"anchor\" href=\"#常量\">#</a> 常量</h3>\n<p>符号常量： <code>final</code>  修饰的变量，一旦赋值后不可更改。</p>\n<h3 id=\"类型转换\"><a class=\"anchor\" href=\"#类型转换\">#</a> 类型转换</h3>\n<p><img loading=\"lazy\" data-src=\"https://blog.ivansnow02.xyz/blog-img/images/java-learning/85bfcba51b1dccf3fe9bbad3b7a8e45a96c54baaf89d3ca283296a9c6fb98b96.png\" alt=\"picture 0\" /></p>\n<h3 id=\"位运算\"><a class=\"anchor\" href=\"#位运算\">#</a> 位运算</h3>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>用法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>~</td>\n<td><code>~a</code></td>\n<td>按位取反</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td><code>a &amp; b</code></td>\n<td>按位与</td>\n</tr>\n<tr>\n<td>|</td>\n<td><code>a \\| b</code></td>\n<td>按位或</td>\n</tr>\n<tr>\n<td>^</td>\n<td><code>a ^ b</code></td>\n<td>按位异或</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td><code>a &lt;&lt; b</code></td>\n<td>左移</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td><code>a &gt;&gt; b</code></td>\n<td>右移</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;</td>\n<td><code>a &gt;&gt;&gt; b</code></td>\n<td>无符号右移</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"流程控制\"><a class=\"anchor\" href=\"#流程控制\">#</a> 流程控制</h2>\n<h3 id=\"标准输入与scanner类\"><a class=\"anchor\" href=\"#标准输入与scanner类\">#</a> 标准输入与 Scanner 类</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Scanner</span> in <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Scanner</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\\\\ <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>in<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td><code>hasNext()</code></td>\n<td>判断是否还有输入</td>\n</tr>\n<tr>\n<td>String</td>\n<td><code>next()</code></td>\n<td>读取一个字符串</td>\n</tr>\n<tr>\n<td>T</td>\n<td><code>nextT()</code></td>\n<td>读取一个 T 类型的值</td>\n</tr>\n<tr>\n<td>String</td>\n<td><code>nextLine()</code></td>\n<td>读取一行字符串</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td><code>hasNextT()</code></td>\n<td>判断下一个输入是否为 T 类型</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td><code>hasNextT(int radix)</code></td>\n<td>判断下一个输入是否为 T 类型，radix 为进制</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"标准输出\"><a class=\"anchor\" href=\"#标准输出\">#</a> 标准输出</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, World!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>printf</code>  方法</p>\n<table>\n<thead>\n<tr>\n<th>标志</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-</td>\n<td>左对齐</td>\n</tr>\n<tr>\n<td>+</td>\n<td>显示正负号</td>\n</tr>\n<tr>\n<td>0</td>\n<td>数字前补 0</td>\n</tr>\n<tr>\n<td>#</td>\n<td>显示八进制或十六进制前缀</td>\n</tr>\n<tr>\n<td>空格</td>\n<td>正数前加空格</td>\n</tr>\n<tr>\n<td>,</td>\n<td>数字以逗号分隔</td>\n</tr>\n<tr>\n<td>(</td>\n<td>负数用括号括起来</td>\n</tr>\n</tbody>\n<tbody>\n<tr>\n<td>格式</td>\n<td>说明</td>\n</tr>\n<tr>\n<td>---</td>\n<td>---</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>整数</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>浮点数</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>科学计数法</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>通用浮点数</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>散列码</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>字符</td>\n</tr>\n<tr>\n<td>%b</td>\n<td>布尔值</td>\n</tr>\n<tr>\n<td>%t</td>\n<td>日期时间</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>换行</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>十六进制整数</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>八进制整数</td>\n</tr>\n<tr>\n<td>%a</td>\n<td>十六进制浮点数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"面向对象\"><a class=\"anchor\" href=\"#面向对象\">#</a> 面向对象</h2>\n<h3 id=\"面向对象编程的特性\"><a class=\"anchor\" href=\"#面向对象编程的特性\">#</a> 面向对象编程的特性</h3>\n<h4 id=\"封装\"><a class=\"anchor\" href=\"#封装\">#</a> 封装</h4>\n<p>将对象的属性和行封装起来构成新的类型，并隐藏内部实现细节，只向用户提供对象的外部可调用操作</p>\n<p>封装最大的好处是降低了软件系统的耦合程度。实现了代码的可重用性和可维护性。</p>\n<h4 id=\"继承\"><a class=\"anchor\" href=\"#继承\">#</a> 继承</h4>\n<p>继承性是类与类之间的一种关系，通过继承，可以在无需重新编写原有类的情况下，实现代码的扩展和重用。</p>\n<ul>\n<li>具有父类的全部属性和行为</li>\n<li>能对继承的属性和行为进行修改和扩充。</li>\n<li>极大提升了可重用性和可维护性</li>\n</ul>\n<h4 id=\"多态\"><a class=\"anchor\" href=\"#多态\">#</a> 多态</h4>\n<p>多态性是指在父类中定义的属性和行为被子类继承之后，可以具有不同的数据类型或表现形式。</p>\n<ul>\n<li>单个类：多态性在单个类中表现为方法重载：一个类可以有多个名字相同、形参列表不同的方法，在使用时由传递给它们的实参来决定使用哪个方法。</li>\n<li>在多个类中主要表现为继承结构中的方法覆盖：父类和子类中具有相同的方法头，不同的代码实现，运行时再决定调用哪个方法。</li>\n</ul>\n<h3 id=\"对象与构造方法\"><a class=\"anchor\" href=\"#对象与构造方法\">#</a> 对象与构造方法</h3>\n<p>要比较两个对象的内容是否相等，即对象实体值，必须在类里实现专门的方法，所有类的父类 <code>Object</code>  中有一个方法 <code>equals()</code> 。</p>\n<p>因对象数组中每个元素都是对象，所以每个元素都需单独实例化（还需用 <code>new</code>  实例化每个元素）</p>\n<h3 id=\"方法重载\"><a class=\"anchor\" href=\"#方法重载\">#</a> 方法重载</h3>\n<p>定义方法时使用相同的方法名，不同的形参列表，叫方法重载（overloading）方法重载是实现 “多态” 的一种方法。</p>\n<ul>\n<li>形参列表不同是指参数个数不同，或者对应位置上参数类型不同。</li>\n<li>重载方法<strong>返回类型、修饰符可以相同，也可不同</strong>，它不决定是否是重载方法</li>\n</ul>\n<h4 id=\"定位重载函数的顺序\"><a class=\"anchor\" href=\"#定位重载函数的顺序\">#</a> 定位重载函数的顺序</h4>\n<p>原则：</p>\n<ul>\n<li>查找同名方法，没有则报错</li>\n<li>比较形参和实参的数目是否相等，如果多个方法符合条件，这些方法进入候选集</li>\n<li>候选集中\n<ul>\n<li>如果对应位置上的每个参数类型完全匹配，为最佳方法，</li>\n<li>如果无匹配的可以通过扩展转换找出最佳匹配方法，选择原则为：源类型与目标类型的距离越近越好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"this关键字\"><a class=\"anchor\" href=\"#this关键字\">#</a>  <code>this</code>  关键字</h3>\n<p><code>this</code>  表示当前对象</p>\n<p>当通过一个对象引用调用它的成员方法时，系统会将当前对象的别名 <code>this</code>  传递到被调方法中，所以， <code>this</code>  只能在成员方法中可见。</p>\n<h4 id=\"使用this访问对象成员\"><a class=\"anchor\" href=\"#使用this访问对象成员\">#</a> 使用 <code>this</code>  访问对象成员</h4>\n<p>特别是局部变量和成员变量重名时，利用 <code>this</code>  可以限定某个变量是成员变量。</p>\n<h4 id=\"构造方法中用this调用本类的另一构造方法\"><a class=\"anchor\" href=\"#构造方法中用this调用本类的另一构造方法\">#</a> 构造方法中，用 <code>this</code>  调用本类的另一构造方法</h4>\n<p>在一个构造方法中，调用另一个重载的构造方法：形式为： <code>this([实参])</code>  这条语句必须是构造方法的第一条语句，且只能出现一次。</p>\n<h4 id=\"返回当前对象\"><a class=\"anchor\" href=\"#返回当前对象\">#</a> 返回当前对象</h4>\n<p>在方法中，利用 <code>return this</code>  可以返回当前对象，从而可以继续调用该类或其子类的成员。</p>\n<h3 id=\"参数传递\"><a class=\"anchor\" href=\"#参数传递\">#</a> 参数传递</h3>\n<p>调用方法时，先将实参赋给形参，然后再执行操作。JAVA 传参数总是采用<strong>按值传递</strong>的方式，所谓值传递就是将实参值的副本传递给被调方法的形参。</p>\n<h4 id=\"基本数据类型\"><a class=\"anchor\" href=\"#基本数据类型\">#</a> 基本数据类型</h4>\n<p>基本数据类型的传递是将实参的值传递给形参，形参的改变不会影响实参。</p>\n<h4 id=\"引用数据类型\"><a class=\"anchor\" href=\"#引用数据类型\">#</a> 引用数据类型</h4>\n<ul>\n<li>如果形参一直指向同一个对象，那么通过形参改变对象的内容，会影响实参。</li>\n<li>如果形参指向了另一个对象，那么通过形参改变对象的内容，不会影响实参。</li>\n</ul>\n<h3 id=\"static修饰符\"><a class=\"anchor\" href=\"#static修饰符\">#</a>  <code>static</code>  修饰符</h3>\n<ul>\n<li>与类相关的静态成员称为类变量或类方法，</li>\n<li>与实例相关的普通成员称为实例变量或实例方法。</li>\n<li><code>static</code>  关键字可以修饰字段、方法、语句块和类（只能修饰内部类）</li>\n</ul>\n<h4 id=\"static修饰字段\"><a class=\"anchor\" href=\"#static修饰字段\">#</a>  <code>static</code>  修饰字段</h4>\n<p><code>static</code>  字段也称类 / 静态数据，被类的所有对象共享。</p>\n<p>当系统第一次准备使用该类时，系统会为该类的 <code>static</code>  字段分配内存空间，存储在方法区中。此时类变量开始生效，直到类被卸载。该类所占有的内存才垃圾回收机制回收。</p>\n<p><code>static</code>  变量被该类的所有对象所共享，只能是类一级的成员，不能声<br />\n明为方法的局部变量。而实例变量则是属于一个对象实例。</p>\n<p><code>static</code>  变量可以被同一类的其他方法直接访问。<br />\n其他类可以通过此 <code>static</code>  成员所属类的类名访问它，而无需先创建对象。</p>\n<h4 id=\"static修饰方法\"><a class=\"anchor\" href=\"#static修饰方法\">#</a> static 修饰方法</h4>\n<p>静态方法是属于类的，而不是属于对象的。静态方法只能访问静态域和静态方法，不能访问实例域和实例方法。</p>\n<p>静态方法属于定义它的类，而且无需创建对象就</p>\n<ul>\n<li>可直接通过类名访问它。</li>\n<li>通过对象引用（无论是否为 <code>null</code> ）调用，但实例方法必须通过非 null 的对象引用调用。</li>\n</ul>\n<p>静态方法不能使用 <code>this</code>  和 <code>super</code>  关键字，因为静态方法在对象创建之前就已经存在。</p>\n<h4 id=\"static修饰代码块\"><a class=\"anchor\" href=\"#static修饰代码块\">#</a> static 修饰代码块</h4>\n<p>静态语句块不属于任何一个方法，当类被加载时，虚拟机会执行静态块中的语句，且在类型的生命周期中只执行一次。<br />\n所以，可以利用静态块在类的加载阶段做一些初始化操作，如初始化静态数据。</p>\n<h3 id=\"访问控制\"><a class=\"anchor\" href=\"#访问控制\">#</a> 访问控制</h3>\n<table>\n<thead>\n<tr>\n<th rowspan=\"2\">修饰符</th>\n<th rowspan=\"2\">权限</th>\n<th colspan=\"3\">修饰对象</th>\n<th colspan=\"4\">可见性</th>\n</tr>\n<tr>\n<th>类</th>\n<th>字段</th>\n<th>方法</th>\n<th>同类</th>\n<th>同包</th>\n<th>不同包子类</th>\n<th>不同包非子类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>public</code></td>\n<td>公有</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n</tr>\n<tr>\n<td><code>protected</code></td>\n<td>保护</td>\n<td></td>\n<td>√</td>\n<td>√</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n<td></td>\n</tr>\n<tr>\n<td>默认</td>\n<td>包访问</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>*</td>\n<td>*</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>private</code></td>\n<td>私有</td>\n<td></td>\n<td>√</td>\n<td>√</td>\n<td>*</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"继承-2\"><a class=\"anchor\" href=\"#继承-2\">#</a> 继承</h3>\n<ul>\n<li>Java 只支持单继承，默认父类是 <code>Object</code></li>\n<li>父类中声明为 <code>private</code>  的字段和方法，子类不可见。</li>\n<li>子类可以添加字段和方法，可以通过定义重名的属性隐藏父类属性（比较少用），也可以通过定义重名方法覆盖父类方法。</li>\n<li>子类不会自动获得父类的构造方法，子类在构造方法中如果要调用父类的构造方法，可以使用 <code>super</code>  调用，而且该调用必须是子类构造方法的<strong>第一条语句</strong>。</li>\n</ul>\n<h3 id=\"final修饰符\"><a class=\"anchor\" href=\"#final修饰符\">#</a>  <code>final</code>  修饰符</h3>\n<h4 id=\"final常量\"><a class=\"anchor\" href=\"#final常量\">#</a>  <code>final</code>  常量</h4>\n<p><code>final</code>  修饰的常量只能赋值一次，之后不能再修改。它可以是局部常量也可以是成员常量。</p>\n<ul>\n<li>局部常量必须在读取之前被赋值，</li>\n<li>成员常量必须在声明时或者在构造方法中被初始化。</li>\n</ul>\n<div class=\"note warning\">\n<ul>\n<li>基本数据类型的常量值不能改变</li>\n<li>引用类型不能指向其他对象，但可以改变对象的内容</li>\n</ul>\n</div>\n<div class=\"note info\">\n<p><code>final</code>  常量的几个常见用法</p>\n<ul>\n<li>blank  <code>final</code> s (空 <code>final</code> )<br />\n 当由同一个类生成的不同对象希望可以有不同的 <code>final</code>  字段值时，可以在定义该字段时只声明不赋值，通过构造方法对每个对象的 <code>final</code>  字段进行赋值。</li>\n<li><code>final</code>  参数<br />\n <code>final</code>  修饰形参，如果修饰的是基本数据类型，表示形参在传入后值不变，如果修饰的是引用类型，表示形参的引用值被赋值后，就不会指向新的对象。</li>\n<li><code>static final</code>  静态常量<br />\n是类一级的全局常量，只用于修饰字段而不能用于局部变量，它需要在类型被加载时就完成初始化操作。因此，一定要在<strong>定义时</strong>或者在 <code>static</code>  块中就给定初始值。</li>\n</ul>\n</div>\n<h4 id=\"final类\"><a class=\"anchor\" href=\"#final类\">#</a>  <code>final</code>  类</h4>\n<p><code>final</code>  修饰的类不能被继承</p>\n<h4 id=\"final方法\"><a class=\"anchor\" href=\"#final方法\">#</a>  <code>final</code>  方法</h4>\n<p><code>final</code>  修饰的方法不能被子类重写</p>\n<h2 id=\"类的进阶设计\"><a class=\"anchor\" href=\"#类的进阶设计\">#</a> 类的进阶设计</h2>\n<h3 id=\"对象类型转换\"><a class=\"anchor\" href=\"#对象类型转换\">#</a> 对象类型转换</h3>\n<h4 id=\"向上转型\"><a class=\"anchor\" href=\"#向上转型\">#</a> 向上转型</h4>\n<p>使用向上转型的对象引用可以调用父类中的方法，但不能调用子类中扩展的方法。</p>\n<h4 id=\"向下转型\"><a class=\"anchor\" href=\"#向下转型\">#</a> 向下转型</h4>\n<p>向下转型是将父类对象转换为子类对象，需要强制类型转换，但是在转换之前需要使用 <code>instanceof</code>  判断是否可以转换。</p>\n<h3 id=\"方法重写\"><a class=\"anchor\" href=\"#方法重写\">#</a> 方法重写</h3>\n<p>方法重写是指子类重新定义父类的方法，方法名、参数列表、返回类型必须与父类中被重写的方法一致。</p>\n<ul>\n<li>访问权限：子类方法的访问权限不能小于父类方法的访问权限。</li>\n<li>返回类型：子类方法的返回类型必顽与父类方法的返回类型一致，或者是父类方法返回类型的子类。</li>\n<li>异常：子类方法不能抛出比父类方法更多的异常，但可以抛出更少的异常，或者不抛出异常。</li>\n<li><code>final</code>  方法不能被重写；不能一个是 <code>static</code>  方法，一个是实例方法。</li>\n</ul>\n<h3 id=\"动态绑定\"><a class=\"anchor\" href=\"#动态绑定\">#</a> 动态绑定</h3>\n<div class=\"note warning\">\n<p>Java 绑定规则如下：</p>\n<ul>\n<li>被 <code>final</code> 、 <code>static</code> 、 <code>private</code>  修饰的方法执行静态绑定，与编译时类型的方法体进行绑定。</li>\n<li>其余实例方法执行动态绑定，与对象的运行时类型的方法体进行绑定。</li>\n<li>成员变量（包括静态变量和实例变量）执行静态绑定，与引用类型的成员变量绑定。</li>\n</ul>\n</div>\n<h3 id=\"抽象方法\"><a class=\"anchor\" href=\"#抽象方法\">#</a> 抽象方法</h3>\n<p>抽象方法是没有方法体的方法，只有声明，没有实现。</p>\n<ul>\n<li>访问权限：抽象方法不能是 <code>private</code> ，因为 <code>private</code>  方法不能被继承。</li>\n<li>不能被 <code>final</code>  和 <code>static</code>  修饰。</li>\n</ul>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"抽象类\"><a class=\"anchor\" href=\"#抽象类\">#</a> 抽象类</h3>\n<p>抽象类是包含抽象方法的类，抽象类不能被实例化，只能被继承。</p>\n<ul>\n<li>抽象类可以包含零个到多个成员变量、普通方法，也可以含零个到多个抽象方法。</li>\n<li>抽象类不能被 <code>final</code>  修饰。</li>\n<li>一个类只要有一个方法是抽象方法，这个类就要定义成抽象类。</li>\n</ul>\n<h3 id=\"接口\"><a class=\"anchor\" href=\"#接口\">#</a> 接口</h3>\n<p>接口是一种特殊的抽象类，接口中的方法都是抽象方法，接口中的成员变量都是 <code>public static final</code>  类型的常量。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">InterfaceName</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">// 常量</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">MAX</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token comment\">// 抽象方法</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>所有的方法都是公开的抽象方法，所以，方法可以省略 <code>public</code>  和 <code>abstract</code>  关键字。</li>\n<li>所有的字段都是公开的静态常量，所以，字段可省略 <code>public static final</code> <br />\n 关键字。需要定义时赋初值。</li>\n<li>类似抽象类，接口不能被实例化，只能被实现。</li>\n<li>接口可以继承其他接口（不能是类），而且支持多继承，多个接口用 <code>,</code>  分割。这一点与类不同。</li>\n</ul>\n<p>重写接口方法时，访问权限只能是 <code>public</code> ，因为接口中的方法默认是 <code>public</code>  的。</p>\n<h3 id=\"接口与抽象类的区别\"><a class=\"anchor\" href=\"#接口与抽象类的区别\">#</a> 接口与抽象类的区别</h3>\n<p>抽象类与接口是进行抽象的两种机制，有相似性，也有区别。</p>\n<ul>\n<li>语法上：抽象类用关键字 <code>abstract class</code>  定义，可定义成员变量和非抽象方法；接口用 <code>interface</code>  定义，接口内只有公开的静态常量、成员方法都是公开的，且只能是抽象方法、默认方法或静态方法。</li>\n<li>使用上：抽象类是用来被单继承的，而一个类可以实现多个接口。</li>\n<li>设计上：抽象类作为父类，与子类之间存在 “is-a” 关系，即父子类本质上是一种类型。接口只能表示类支持接口的行，具有接口的功能。因此接口和实现类之间表示的是 “like-a” 关系。因此，在设计上，如果父子类型本质上是一种类型，那父类可设计成抽象类，如果子类型只是想额外具有一些特性，则可以将父类型设计成接口，而且这些接口不易过大，应该设计成多个专题的小接口。这也是面向对象设计的一个重要原则 — 接口隔离原则。</li>\n</ul>\n<h3 id=\"内部类\"><a class=\"anchor\" href=\"#内部类\">#</a> 内部类</h3>\n<ul>\n<li>内部类仍是一个独立的类，在编译外部类时，内部类也会被编译成独立的 <code>class</code>  文件，文件名前面冠以外部类的类型和 <code>$</code>  符号，如 <code>OuterClass$InnerClass</code> 。</li>\n<li>内部类是外部类的成员，因此，内部类可以访问外部类的成员，无论是否为 <code>private</code> 。如果内部类声明成 <code>static</code> ，相应的，只能访问外部类的静态成员。</li>\n<li>内部类可作为外部类的成员，也可作为方法的成员（局部内部类）。如果作为外部类的成员，则可以使用 4 种访问权限修饰符，如果作为方法成员则没有访问权限修饰符。</li>\n</ul>\n<h4 id=\"实例内部类\"><a class=\"anchor\" href=\"#实例内部类\">#</a> 实例内部类</h4>\n<ul>\n<li>\n<p>实例内部类是最常见的内部类，它是外部类的一个成员，可以访问外部类的所有成员。</p>\n</li>\n<li>\n<p>在外部类的静态方法和外部类以外的地方创建内部类的实例，需要先创建外部类的实例，再通过外部类的实例创建内部类的实例。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">OuterClass</span> outer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OuterClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">OuterClass<span class=\"token punctuation\">.</span>InnerClass</span> inner <span class=\"token operator\">=</span> outer<span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InnerClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>在外部类中不能直接访问内部类的实例成员，需要通过内部类的实例访问。</p>\n</li>\n<li>\n<p>在内部类中可以直接访问外部类的实例成员，如果内部类和外部类有同名成员，可以通过 <code>OuterClass.this.member</code>  访问外部类的成员。</p>\n</li>\n<li>\n<p>内部类不能与外部类重名</p>\n</li>\n</ul>\n<h4 id=\"静态内部类\"><a class=\"anchor\" href=\"#静态内部类\">#</a> 静态内部类</h4>\n<p>静态内部类是 <code>static</code>  修饰的内部类，它是外部类的一个静态成员，它与所属的外部类而不是外部对象相关联。</p>\n<ul>\n<li>\n<p>通过外部类名直接访问静态内部类的静态成员</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">OuterClass<span class=\"token punctuation\">.</span>InnerClass</span> inner <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OuterClass<span class=\"token punctuation\">.</span>InnerClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>静态内部类中可定义<strong>静态成员和实例成员</strong>。外部类以外的其他类可通过类名访问静态内部类中的静态成员，如果要访问静态内部类中的实例成员，则必须通过静态内部类的实例。</p>\n</li>\n<li>\n<p>类似于类的静态方法，静态内部类可以直接访问外部类的静态成员，如果要访问外部类的实例成员，则需要通过外部类的实例去访问。</p>\n</li>\n<li>\n<p>接口中可以定义内部类，且默认是 <code>static</code>  内部类，这种类可以被某个接口的所有不同实现所共用。</p>\n</li>\n</ul>\n<h4 id=\"局部内部类\"><a class=\"anchor\" href=\"#局部内部类\">#</a> 局部内部类</h4>\n<ul>\n<li>局部内部类是指定义在方法内的内部类。其有效范围只在定义它的方法内。</li>\n<li>局部内部类遵循如下规则：\n<ul>\n<li>局部内部类与局部变量一样，不能使用访问修饰符和 <code>static</code>  修饰符。</li>\n<li>在局部内部类中可以访问外部类的所有成员。</li>\n<li>在局部内部类中<strong>只可以读取方法常量</strong>，或<strong>初始化后不再改变的变量</strong>。</li>\n<li>如果方法中的成员与外部类成员同名，则可用 <code>OuterClass.this</code>  访问外部类中的实例成员  <code>OuterClass.this.MemberName</code>  或用 <code>OuterClass.MemberName</code>  访问外部类的静态成员。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"匿名内部类\"><a class=\"anchor\" href=\"#匿名内部类\">#</a> 匿名内部类</h4>\n<ul>\n<li>匿名类是指没有类名只有类体的内部类，如果<strong>程序定义某个类却只需要创建一个对象</strong>，这时可以考虑使用匿名内部类。</li>\n<li>由于匿名类没有类名，所以创建匿名类的对象时需要用到该匿名类的父类或接口，而且匿名类的定义和对象创建是同时进行的，因此，在定义的同时，使用 <code>new</code>  语句来声明对象。</li>\n</ul>\n<div class=\"note warning\">\n<p>匿名内部类的特点：</p>\n<ul>\n<li>匿名类和局部内部类一样，可以访问外部类的所有成员。其他局部内部类的特性也适用于匿名内部类。</li>\n<li>匿名类没有名字，所以<strong>不能定义构造方法</strong>，但可定义<strong>非静态字段</strong>，<strong>重写父类型方法</strong>。</li>\n<li>匿名内部类编译后对应的字节码文件名为： <code>外部类$数字序号（序号从1开始）</code> 。</li>\n<li>匿名类常用方式是<strong>向方法传参</strong>，当匿名内部类重写的父类（接口）只有一个方法时，建议使用 <code>Lambda</code>  表达式。</li>\n</ul>\n</div>\n<h2 id=\"异常处理\"><a class=\"anchor\" href=\"#异常处理\">#</a> 异常处理</h2>\n<h3 id=\"异常类\"><a class=\"anchor\" href=\"#异常类\">#</a> 异常类</h3>\n<ul>\n<li>运行时异常（ <code>Runtime Exception</code> ）：是一种不检查异常，是程序员编程时的错误，如数组越界、空指针等。</li>\n<li>受检异常（ <code>Checked Exception</code> ）：是一种检查异常，是程序员无法控制的异常，如文件不存在、网络中断等。</li>\n</ul>\n<h3 id=\"异常处理机制\"><a class=\"anchor\" href=\"#异常处理机制\">#</a> 异常处理机制</h3>\n<ul>\n<li>声明异常<br />\n不捕获异常，而只是声明方法有可能抛出的异常，从而让该方法的上层调用方法捕获异常。</li>\n<li>捕获处理异常<br />\n Java 运行时系统捕获异常并找到相应异常的捕获处理代码并运行，这一过程称为捕获处理异常。如果系统找不到捕获异常代码，程序将终止。</li>\n</ul>\n<h3 id=\"捕获处理异常\"><a class=\"anchor\" href=\"#捕获处理异常\">#</a> 捕获处理异常</h3>\n<p>说明：</p>\n<ul>\n<li><code>try</code>  语句：发生异常时，将跳过 <code>try</code>  块中异常点后面的语句，且异常处理需要更多的时间和资源。因此，应当仔细分析代码，尽量缩减 <code>try</code>  代码块。</li>\n<li><code>catch</code>  语句可以有<strong>零个或多个</strong>， <code>finally</code>  语句可以有<strong>零个或一个</strong>。</li>\n<li><code>catch</code>  语句：设计捕获异常代码要注意其顺序，按照从 “特殊到一般” 的顺序来设计。将子类的 <code>catch</code>  块放在前面，父类的 <code>catch</code>  块放在后面。</li>\n<li>从 java7 开始，多个异常可以写在一个 <code>catch</code>  中，它们之间用竖线隔开，但需要注意，用 <code>|</code>  操作符合并的异常不要出现互为父子的关系。</li>\n<li><code>finally</code>  语句是可选项。如果有该语句，无论是否捕获或处理异常，即使 <code>try</code>  或者 <code>catch</code>  块中包含 <code>break</code>  或 <code>return</code>  语句， <code>finally</code>  块里的语句也会被执行。 <code>finally</code>  语句一般用来在最后做一些资源回收工作，比如在 <code>try</code>  语句中打开了文件流，可以在 <code>finally</code>  中确保文件被有效关闭。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>getMessage()-&gt;String</code></td>\n<td>返回异常的详细信息字符串</td>\n</tr>\n<tr>\n<td><code>toString()-&gt;String</code></td>\n<td>返回异常类全名 + 异常信息</td>\n</tr>\n<tr>\n<td><code>printStackTrace()</code></td>\n<td>打印异常的堆栈信息</td>\n</tr>\n<tr>\n<td><code>getStackTrace()-&gt;StackTraceElement[]</code></td>\n<td>返回和异常对象相关的堆栈跟踪元素数组</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"带资源的try语句\"><a class=\"anchor\" href=\"#带资源的try语句\">#</a> 带资源的 try 语句</h3>\n<p>注意：<br />\n可以被自动关闭的资源有一个前提，这个资源的类已经实现了 <code>java.lang.AutoCloseable</code>  接口，这个接口有一个方法： <code>void close()</code> 。</p>\n<h3 id=\"throw抛出异常和throws声明异常\"><a class=\"anchor\" href=\"#throw抛出异常和throws声明异常\">#</a> throw 抛出异常和 throws 声明异常</h3>\n<h4 id=\"抛出异常\"><a class=\"anchor\" href=\"#抛出异常\">#</a> 抛出异常</h4>\n<p>检测到错误的程序可以创建一个合适的异常对象并抛出它，这就称为抛出一个异常。<br />\nJava 中有两种方法抛出异常。</p>\n<ul>\n<li>Java 运行时环境自动抛出异常：系统定义的 <code>RuntimeException</code>  类及其子类和 <code>Error</code>  都可以由系统自动抛出。</li>\n<li>语句 <code>throw</code>  抛出异常：用户程序想在一定条件下显式抛出异常，这必须借助于 <code>throw</code>  语句抛出。Java 用 <code>throw</code>  语句抛出异常。</li>\n</ul>\n<h4 id=\"声明异常\"><a class=\"anchor\" href=\"#声明异常\">#</a> 声明异常</h4>\n<ul>\n<li>定义方法时，如果方法可能出现异常，但该方法不想或不能自己捕获处理这种异常，那就必须在声明方法时用 <code>throws</code>  声明可能发生的异常。</li>\n<li>对于不受查异常（ <code>Runtime Exception</code>  和 <code>Error</code> ），Java 不要求在方法头中显示声明，但是，其它异常就一定要在方法头中显示声明。</li>\n</ul>\n<h2 id=\"常用类\"><a class=\"anchor\" href=\"#常用类\">#</a> 常用类</h2>\n<h3 id=\"object类\"><a class=\"anchor\" href=\"#object类\">#</a> Object 类</h3>\n<h3 id=\"string类\"><a class=\"anchor\" href=\"#string类\">#</a> String 类</h3>\n<h3 id=\"泛型集合\"><a class=\"anchor\" href=\"#泛型集合\">#</a> 泛型集合</h3>\n<h3 id=\"arrays类\"><a class=\"anchor\" href=\"#arrays类\">#</a> Arrays 类</h3>\n<h3 id=\"collections类\"><a class=\"anchor\" href=\"#collections类\">#</a> Collections 类</h3>\n<h2 id=\"io流\"><a class=\"anchor\" href=\"#io流\">#</a> IO 流</h2>\n<h3 id=\"file类\"><a class=\"anchor\" href=\"#file类\">#</a> File 类</h3>\n<h3 id=\"文件流\"><a class=\"anchor\" href=\"#文件流\">#</a> 文件流</h3>\n<h3 id=\"缓冲流\"><a class=\"anchor\" href=\"#缓冲流\">#</a> 缓冲流</h3>\n<h3 id=\"字节字符转换流\"><a class=\"anchor\" href=\"#字节字符转换流\">#</a> 字节字符转换流</h3>\n<h2 id=\"线程\"><a class=\"anchor\" href=\"#线程\">#</a> 线程</h2>\n<h3 id=\"线程概念\"><a class=\"anchor\" href=\"#线程概念\">#</a> 线程概念</h3>\n<h3 id=\"线程的创建\"><a class=\"anchor\" href=\"#线程的创建\">#</a> 线程的创建</h3>\n<h4 id=\"继承thread类\"><a class=\"anchor\" href=\"#继承thread类\">#</a> 继承 Thread 类</h4>\n<h4 id=\"实现runnable接口\"><a class=\"anchor\" href=\"#实现runnable接口\">#</a> 实现 Runnable 接口</h4>\n<h4 id=\"实现callable接口\"><a class=\"anchor\" href=\"#实现callable接口\">#</a> 实现 Callable 接口</h4>\n<h2 id=\"图形用户界面\"><a class=\"anchor\" href=\"#图形用户界面\">#</a> 图形用户界面</h2>\n<h3 id=\"jframe类\"><a class=\"anchor\" href=\"#jframe类\">#</a> JFrame 类</h3>\n<h3 id=\"布局管理器\"><a class=\"anchor\" href=\"#布局管理器\">#</a> 布局管理器</h3>\n<h3 id=\"事件处理\"><a class=\"anchor\" href=\"#事件处理\">#</a> 事件处理</h3>\n<h4 id=\"事件处理机制\"><a class=\"anchor\" href=\"#事件处理机制\">#</a> 事件处理机制</h4>\n<h4 id=\"事件和事件分类\"><a class=\"anchor\" href=\"#事件和事件分类\">#</a> 事件和事件分类</h4>\n<h4 id=\"事件监听器\"><a class=\"anchor\" href=\"#事件监听器\">#</a> 事件监听器</h4>\n<h4 id=\"回调与事件监听器的实现\"><a class=\"anchor\" href=\"#回调与事件监听器的实现\">#</a> 回调与事件监听器的实现</h4>\n<h2 id=\"网络编程\"><a class=\"anchor\" href=\"#网络编程\">#</a> 网络编程</h2>\n<h3 id=\"tcpip通信\"><a class=\"anchor\" href=\"#tcpip通信\">#</a> TCP/IP 通信</h3>\n",
            "tags": [
                "coding",
                "Java"
            ]
        }
    ]
}