<!DOCTYPE html><html lang="zh-CN"><head>
  <link rel="manifest" href="/manifest.json">
  <link rel="stylesheet" href="/css/custom.css">
  <link href="https://fastly.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" rel="stylesheet">
  <link href="/css/custom.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.loli.net">
  <link rel="preconnect" href="https://gstatic.loli.net" crossorigin="">
  <link href="https://fonts.loli.net/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
<meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/img/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png"><meta name="msvalidate.01" content="5C885BB4F08198773FCB9D68FB7EFF0C"><meta name="google-site-verification" content="SU_V4YfQlQkkbm4IQUajehIwRUPbvIwErs1WJRMD0NQ"><link rel="alternate" href="/rss.xml" title="Snow's Blog" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Snow's Blog" type="application/atom+xml"><link rel="alternate" type="application/json" title="Snow's Blog" href="https://blog.ivansnow02.xyz/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CJuliamo:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CJetBrains%20Mono:400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext" media="none" onload="this.media='all'"><link rel="stylesheet" href="/css/app.css?v=0.4.14"><link rel="modulepreload" href="/js/chunk-2FUZD5TY.js"><link rel="modulepreload" href="/js/chunk-ARAOOFSL.js"><link rel="modulepreload" href="/js/chunk-E3UZYSYJ.js"><link rel="modulepreload" href="/js/chunk-NQYVAKVO.js"><link rel="modulepreload" href="/js/chunk-QFYDMXPZ.js"><link rel="modulepreload" href="/js/copy-tex-PJE4SH5D.js"><link rel="modulepreload" href="/js/index.esm-Y7XZFAGL.js"><link rel="modulepreload" href="/js/post-MBX4MI4K.js"><link rel="modulepreload" href="/js/quicklink-BBD3FDVT.js"><link rel="modulepreload" href="/js/search-JEV3TAG4.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="modulepreload" href="/js/tcomments-UURMOCFH.js"><link rel="preload" href="https://s2.loli.net/2024/06/16/vN51cCT6pUtjnK7.png" as="image" fetchpriority="high"><meta name="keywords" content="computer science,"><meta name="description" content="some notes about computer science"><link rel="canonical" href="https://blog.ivansnow02.xyz/ComputerSystem/"><title>操作系统复习</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">操作系统复习</h1><div class="meta"><span class="item" title="创建时间：2024-03-07 12:51:59"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2024-03-07T12:51:59+08:00">2024-03-07</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>83k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>1:15</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Code Blog</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://s2.loli.net/2024/06/16/vN51cCT6pUtjnK7.png" loading="eager" decoding="async" fetchpriority="high" alt="Snow's Blog"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement="" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于computer science"><span itemprop="name">computer science<meta itemprop="position" content="0"></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.ivansnow02.xyz/ComputerSystem/"><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/avatar.png"><meta itemprop="name" content="Ivan Snow"><meta itemprop="description" content="Just a Note., some notes about computer science"></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Snow's Blog"></span><div class="body md" itemprop="articleBody"><h2 id="概论"><a class="anchor" href="#概论">#</a> 概论</h2>
<h3 id="操作系统的定义和功能"><a class="anchor" href="#操作系统的定义和功能">#</a> 操作系统的定义和功能</h3>
<h4 id="操作系统的定义"><a class="anchor" href="#操作系统的定义">#</a> 操作系统的定义</h4>
<ul>
<li>一组计算机程序的集合，主要用以控制和管理 计算机的硬件和软件资源，合理地组织计算机的工作流程，向应用程序和用户提供方便、快捷、友好的使用接口</li>
</ul>
<h4 id="操作系统的功能"><a class="anchor" href="#操作系统的功能">#</a> 操作系统的功能 😊</h4>
<ul>
<li>进程管理</li>
<li>存储管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h4 id="操作系统的特征"><a class="anchor" href="#操作系统的特征">#</a> 操作系统的特征 😎</h4>
<ul>
<li>并发</li>
<li>共享</li>
<li>虚拟</li>
<li>异步</li>
</ul>
<h3 id="操作系统的发展"><a class="anchor" href="#操作系统的发展">#</a> 操作系统的发展</h3>
<ol>
<li>手工操作时代</li>
<li>早期单道批处理系统时代</li>
<li>多道批处理系统时代</li>
</ol>
<h3 id="操作系统的分类"><a class="anchor" href="#操作系统的分类">#</a> 操作系统的分类 😊</h3>
<h4 id="批处理操作系统"><a class="anchor" href="#批处理操作系统">#</a> 批处理操作系统</h4>
<ul>
<li>主要特征
<ul>
<li>用户脱机工作</li>
<li>成批处理作业</li>
<li>单 / 多道程序运行</li>
<li>作业周转时间长</li>
</ul>
</li>
</ul>
<h4 id="分时操作系统"><a class="anchor" href="#分时操作系统">#</a> 分时操作系统</h4>
<ul>
<li>主要特征：
<ul>
<li><strong>同时性</strong>。允许各终端用户同时工作，系统分时响应用户请求（使用 CPU 并不同时）</li>
<li><strong>交互性</strong>。支持联机的操作方式，用户可以在终端上通过操作系统进行人 - 机对话，随时控制和调试程序，以交互的方式工作</li>
<li><strong>独立性</strong>。用户之间彼此独立的工作，好象独占一台计算机系统一样，互不干扰</li>
<li><strong>及时性</strong>。用户请求能在较短的时间内得到响应</li>
</ul>
</li>
</ul>
<h4 id="实时操作系统"><a class="anchor" href="#实时操作系统">#</a> 实时操作系统</h4>
<ul>
<li>系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行</li>
</ul>
<h4 id="个人计算机操作系统"><a class="anchor" href="#个人计算机操作系统">#</a> 个人计算机操作系统</h4>
<ul>
<li>主要特点：
<ul>
<li>图形用户接口</li>
<li>开放性</li>
<li>多媒体支持</li>
<li>应用软件丰富</li>
<li>操作系统管理性能高</li>
</ul>
</li>
</ul>
<h4 id="网络操作系统"><a class="anchor" href="#网络操作系统">#</a> 网络操作系统</h4>
<ul>
<li>除具备通常操作系统功能外，还具备联网功能，支持网络体系结构和各种网络通信协议，提供网络互连能力，支持可靠、有效、安全的数据传输</li>
<li>主要采用客户机 / 服务器 (C/S) 工作方式
<ul>
<li>客户机一般由微型计算机承担，主动从本地向服务器提出服务请求</li>
<li>服务器接收客户机请求、处理请求的服务、返回服务结果。一般由高档微机、小、中、大型机承担</li>
</ul>
</li>
<li>对等模式：网络中的每台计算机同时具有客户端和服务器两种功能</li>
</ul>
<h4 id="分布式操作系统"><a class="anchor" href="#分布式操作系统">#</a> 分布式操作系统</h4>
<ul>
<li>特点：
<ul>
<li>计算机网络系统的高级形式，由多台计算机组成，计算机之间没有主次之分</li>
<li>数据和控制及任务的分布性、整体性、资源共享的透明性、各节点的自制性和协同性</li>
</ul>
</li>
</ul>
<h4 id="嵌入式操作系统"><a class="anchor" href="#嵌入式操作系统">#</a> 嵌入式操作系统</h4>
<ul>
<li>
<p>指运行在嵌入式 (计算机) 环境中，对整个系统各种部件和资源进行统一协调、处理、指挥和控制的系统软件。它具有通常操作系统的基本功能</p>
</li>
<li>
<p>与一般操作系统有很大不同，主要体现在微型化、可定制、实时性、可靠性、易移植、开发工具与使用环境密切相关等特点</p>
</li>
</ul>
<h3 id="操作系统的接口"><a class="anchor" href="#操作系统的接口">#</a> 操作系统的接口</h3>
<h4 id="程序接口"><a class="anchor" href="#程序接口">#</a> 程序接口</h4>
<ul>
<li>系统调用：“系统调用” 可以获得操作系统的底层服务，从而进一步使用或访问系统管理的各种软硬件资源。不同的操作系统提供的系统调用的种类、数量和名字不尽相同</li>
<li>API（application programming interface）
<ul>
<li>常用的 Windows 系统，微软公司只公布了相关的 API，它是一种应用程序编程接口，是在操作系统系统调用的基础经过规范整理出来，面向社会公布的唯一的接口方式</li>
<li>由于不是直接的系统调用，其效率有所损失。微软公司没有发布全部的 API，也为开发程序带来了一定的难度</li>
</ul>
</li>
<li>系统调用 &amp; POSIX 标准
<ul>
<li>系统调用内部的具体实现与硬件相关，直接使用会产生问题：
<ul>
<li>接口复杂，使用困难</li>
<li>应用程序的跨平台可移植性受到很大限制</li>
</ul>
</li>
<li>POSIX 标准：专门规定内核的系统调用接口标准，操作系统若遵循此标准，则应用程序在不同操作系统之间就具有可移植性
<ul>
<li>Unix/Linux 遵循此标准</li>
<li>Windows NT-based 系统不能直接支持新版 POSIX 接口</li>
</ul>
</li>
</ul>
</li>
<li>系统调用的处理过程
<ol>
<li>应用程序使用系统调用时会产生一条指令（陷入指令或访管指令），该指令中存放了对应系统调用的功能号，有时还附带传递给内核的参数： <code>系统调用—功能号—入口地址表—入口地址</code></li>
<li>处理机在执行到该访管指令时发出相应的中断信号给 “陷阱处理机制”</li>
<li>陷阱处理机制启动相关的内核函数完成该系统调用所要求的功能：保护 CPU 现场、获取功能号、根据功能号查找对应内核函数入口地址表、转到入口地址执行内核函数、内核函数执行完，中断处理结束</li>
<li>恢复 CPU 现场，继续执行中断点的下一条指令</li>
</ol>
</li>
<li>注意：执行系统调用时，应用程序从用户态（目态）转到了核心态（管态），即执行内核函数时必须在核心态下运行，但访管指令本身是在用户态下执行的</li>
</ul>
<h4 id="操作接口"><a class="anchor" href="#操作接口">#</a> 操作接口</h4>
<ul>
<li>命令界面（CLI，Command Line Interface ）
<ul>
<li>简单命令的一般形式：命令 参数 1 参数 2 … 参数 n</li>
<li>Windows 操作系统的基本命令：type、erase、attrib、copy、xcopy、dir、cd、md、rd、tree、ver 等</li>
</ul>
</li>
<li>图形界面（ GUI，Graphics User Interface ）</li>
<li>作业控制命令
<ul>
<li>专为批处理作业的用户提供的，所以也称批处理用户接口。操作系统提供一个作业控制语言 JCL（Job Control Language），它由一组作业控制语句、作业控制操作命令及相应语法规范组成</li>
<li>用户利用作业控制语言书写批处理作业控制说明书，操作系统解释作业控制说明书，按其要求一步步地运行用户作业。
<ul>
<li>DOS 下的批处理命令是一种简单的作业控制语言（.bat）</li>
<li>UNIX 的 Shell 语言是现代计算机一种功能强大的作业控制语言</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="操作系统的设计实现方法"><a class="anchor" href="#操作系统的设计实现方法">#</a> 操作系统的设计实现方法</h3>
<h4 id="操作系统设计与开发"><a class="anchor" href="#操作系统设计与开发">#</a> 操作系统设计与开发</h4>
<ul>
<li>操作系统设计与开发特点
<ul>
<li>与硬件关联</li>
<li>复杂程度高</li>
<li>生产周期长</li>
</ul>
</li>
<li>操作系统的设计原则
<ul>
<li>可靠性</li>
<li>方便性</li>
<li>高效率</li>
<li>易维护性</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
</li>
</ul>
<h4 id="操作系统的体系结构"><a class="anchor" href="#操作系统的体系结构">#</a> 操作系统的体系结构</h4>
<ul>
<li>无结构操作系统</li>
<li>模块化结构</li>
<li>分层结构</li>
<li>客户 / 服务器结构（微内核）</li>
<li>虚拟机结构</li>
<li>面向对象结构</li>
</ul>
<h2 id="进程管理"><a class="anchor" href="#进程管理">#</a> 进程管理</h2>
<h3 id="程序的执行方式"><a class="anchor" href="#程序的执行方式">#</a> 程序的执行方式</h3>
<h4 id="程序的顺序执行"><a class="anchor" href="#程序的顺序执行">#</a> 程序的顺序执行 😊</h4>
<ul>
<li><strong>一个具有独立功能的程序独占处理器直至最终结束的过程称为程序的顺序执行</strong>
<ul>
<li>程序设计中的顺序控制结构仅能控制程序内部指令的执行序列</li>
<li>程序的顺序执行意味着运行时程序间的执行序列也是顺序的 —— 一个程序执行完了，才能执行另一个程序</li>
</ul>
</li>
<li>顺序执行的特性：
<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
<li>程序的顺序执行方式便于程序的编制与调试，但不利于充分利用计算机系统资源，运行效率低下</li>
</ul>
</li>
</ul>
<h4 id="程序的并发执行与并行执行"><a class="anchor" href="#程序的并发执行与并行执行">#</a> 程序的并发执行与并行执行 😎</h4>
<ul>
<li>为了提高系统的运行效率，允许 “同时” 执行多个程序</li>
<li>并行（parallel）：多个事件在同一时刻发生</li>
<li>并发（concurrent）：多个事件在同一时期内发生</li>
<li>显然，<strong>并行是并发的特例</strong>，程序并行执行的硬件前提是系统中有多个 CPU</li>
<li>并发的<strong>本质</strong>是一个 CPU 在多个程序运行过程中的<strong>时分复用</strong></li>
<li>并发执行的特性：
<ul>
<li><strong>间断性</strong></li>
<li><strong>开放 / 交互性</strong></li>
<li><strong>不可再现性</strong></li>
<li>进行并发程序设计时应当避免由于程序间开放交互引起的不可再现性而产生运行时错误</li>
</ul>
</li>
</ul>
<h4 id="进程概念的引入"><a class="anchor" href="#进程概念的引入">#</a> 进程概念的引入</h4>
<ul>
<li>程序（program）：静态的代码文件（*.exe）</li>
<li>进程（process）：程序在某个数据集合上的一次执行，系统资源分配的基本单位</li>
<li>作业（job）：批处理系统要装入系统运行处理的一系列程序步骤和数据</li>
</ul>
<h3 id="进程的特征与控制"><a class="anchor" href="#进程的特征与控制">#</a> 进程的特征与控制</h3>
<h4 id="进程的相关概念"><a class="anchor" href="#进程的相关概念">#</a> 进程的相关概念</h4>
<ul>
<li>
<p>进程有以下特征</p>
<ul>
<li>结构性</li>
<li>动态性</li>
<li>独立性</li>
<li>并发性</li>
</ul>
</li>
<li>
<p>进程分类：系统进程、用户进程</p>
</li>
<li>
<p>进程上下文（process context）</p>
<ul>
<li>用户级上下文（user-level context）：进程的代码区、数据区、用户栈区和共享存储区</li>
<li>系统级上下文（system-level context）：PCB、内存管理信息、进程环境块、系统栈</li>
<li>寄存器上下文（register context）</li>
<li>一个进程被系统调度而占有 CPU 时，会发生 CPU 在新老进程之间切换，切换的内容是进程上下文，进程运行是在进程的上下文中执行的</li>
<li>一个典型的上下文切换过程</li>
</ul>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token function">context_switch</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   Push registers onto stack</pre></td></tr><tr><td data-num="3"></td><td><pre>   Save ptrs to code and data<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   Save stack pointer <span class="token comment">// 以上语句保护当前进程上下文</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   Pick next process to execute <span class="token comment">// 选中 / 调度新进程</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token comment">// 以下语句恢复所选中 / 调度的进程的上下文</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   Restore stack ptr of that process</pre></td></tr><tr><td data-num="8"></td><td><pre>   Restore ptrs to code and data<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   Pop registers</pre></td></tr><tr><td data-num="10"></td><td><pre>   Return</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="进程状态及转换"><a class="anchor" href="#进程状态及转换">#</a> 进程状态及转换 😎</h4>
<ul>
<li>
<p>进程的状态</p>
<ul>
<li>就绪状态（ready）：进程在内存中已经具备执行的条件，等待分配 CPU</li>
<li>运行状态（running）：进程占用 CPU 并正在执行</li>
<li>阻塞状态（blocked）：也称为等待（waiting）状态 —— 运行的进程由于发生某事件而放弃 CPU</li>
<li><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/1c3111038fa4c670ecafae5eaa588c619a7fe681bc545ce13a4334db27bbea3c.png" alt="三状态模型"></li>
<li><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/bad9788a79ef73a696074331e1535447862032d33e0cda0077cd477ce2a268a7.png" alt="五状态模型"></li>
<li><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/dd878f98c4cf7400be91dd615c330ba97d08cbcfbd3c975481414a04e0d5007a.png" alt="七状态模型"></li>
</ul>
</li>
<li>
<p>有挂起功能的进程状态：</p>
<ul>
<li>挂起就绪（ready suspended）</li>
<li>挂起阻塞（blocked suspended）</li>
<li>进程在运行态也可以被挂起，转换为挂起就绪状态</li>
<li>阻塞状态的进程被挂起后，若阻塞事件或 I/O 请求完成，则进程状态转换为挂起就绪状态 —— 仍然是挂起状态</li>
<li>创建进程时若没有足够的内存空间，则转入挂起就绪状态</li>
<li><strong>只有处于就绪态的进程</strong>才有可能被调度分配 CPU 运行</li>
</ul>
</li>
</ul>
<h4 id="进程控制块pcb"><a class="anchor" href="#进程控制块pcb">#</a> 进程控制块 PCB</h4>
<ul>
<li>为了描述和控制进程运行的数据结构 —— 进程控制块（Process Control Block），或称为进程描述符（Process Descriptor），进程存在的惟一标志
<ol>
<li>进程标识信息 —— 内部标识符（PID）和外部标识符（进程名）</li>
<li>现场信息 —— 进程运行时 CPU 的即时状态 —— 各寄存器的值</li>
<li>控制信息 —— 程序和数据地址、进程同步和通信机制信息、进程的资源清单和链接指针，进程状态、进程优先级……</li>
</ol>
</li>
<li>操作系统根据 PCB 对进程进行控制和管理
<ul>
<li>查询进程现行状态及优先级</li>
<li>恢复现场</li>
<li>相关进程同步、通信</li>
</ul>
</li>
<li>创建新进程时，建立 / 分配 PCB，进程结束时回收 PCB</li>
<li>PCB 由系统多个功能模块读写，须<strong>常驻内存</strong>，并进一步组织形成队列</li>
</ul>
<h4 id="进程控制"><a class="anchor" href="#进程控制">#</a> 进程控制 😊</h4>
<ul>
<li>
<p>CPU 的运行模式</p>
<ul>
<li><strong>核心态</strong>（内核态），也称为管态（supervisor mode），Ring 0：内核代码、设备驱动、特权指令、直接访问物理内存空间、设备端口</li>
<li><strong>用户态</strong>，也称为目态，Ring 3：普通指令、保护模式安全限制、访问映射的虚拟地址空间、系统许可的映射端口</li>
</ul>
</li>
<li>
<p>不同于进程切换，也不一定引起进程切换或状态转换</p>
</li>
<li>
<p>一般来说，当<strong>发生中断或系统调用</strong>时，用户进程暂停，CPU 模式从用户态切换到核心态，执行系统服务例程，此时进程仍在原上下文中运行，仅模式变化</p>
</li>
<li>
<p>进程控制 —— 系统对进程生命周期的各个环节进行控制</p>
<ul>
<li>进程控制的职能是对<strong>系统中的所有进程实行有效的管理 —— 对一个进程进行创建、撤销或终止，以及在某些进程状态间的转换控制</strong></li>
<li>允许一个进程创建和控制另一个进程，前者为父进程，后者为子进程</li>
</ul>
</li>
<li>
<p>进程控制通常由 <strong>原语（primitive）</strong> 完成 。</p>
</li>
<li>
<p>原语的特性：</p>
<ul>
<li>由若干条指令组成，实现某个特定功能，在<strong>执行过程中不可被中断的程序段</strong></li>
<li><strong>不可分割</strong>的执行单位，<strong>不能并发执行</strong></li>
<li>是操作系统核心（不是由进程而是由一组程序模块所组成）的一个组成部分，且<strong>常驻内存</strong></li>
<li>通常在<strong>核心态 / 管态</strong>下执行</li>
</ul>
</li>
<li>
<p>进程控制原语</p>
<ol>
<li><strong>创建进程</strong>：建立 PCB、填入信息、插入就绪队列，操作系统创建进程主要步骤<br>
（1）命名进程：为新进程设置进程标志符；<br>
（2）从 PCB 集合中为新进程申请一个空 PCB；<br>
（3）确定新进程的优先级；<br>
（4）为新进程的程序段、数据段和用户栈分配内存空间；如果进程中需要共享某个已在内存的程序段，则必须建立共享程序段的链接指针；<br>
（5）为新进程分配除内存外的其它各种资源；<br>
（6）初始化 PCB，将新进程的初始化信息写入进程控制块；<br>
（7）如果就绪队列能够接纳新创建的进程，则将新进程插入到就绪队列；<br>
（8）通知操作系统的记账、性能监控等管理模块<br>
导致创建进程的事件：登录、作业调度、提供服务 —— 系统内核直接调用创建原语创建新进程、应用请求 —— 由用户调用操作系统提供的系统调用完成（Windows 的 API：CreateProcess）</li>
<li><strong>撤消与终止进程</strong>：进程完成后，应退出系统而消亡，系统及时收回占有的全部资源以便其它进程使用，撤销原语撤销的是 PCB，而非进程的程序段</li>
<li><strong>阻塞与唤醒进程</strong>：进程阻塞是进程的自主行为，唤醒则是被动的</li>
<li><strong>挂起与激活进程</strong>：既可以由该进程自己调用，也可由其它进程或系统调用，但激活原语只能由其它进程或系统调用</li>
</ol>
</li>
</ul>
<h3 id="进程的互斥与同步"><a class="anchor" href="#进程的互斥与同步">#</a> 进程的互斥与同步</h3>
<h4 id="竞争和协作"><a class="anchor" href="#竞争和协作">#</a> 竞争和协作</h4>
<ul>
<li>竞争，会引发以下两种极端情况：
<ul>
<li><strong>死锁（deadlock）</strong>：一组进程都陷入永远等待的状态</li>
<li><strong>饥饿（starvation）</strong>：被调度程序长期忽视</li>
</ul>
</li>
<li>协作 ——<strong> 同步（synchronization）</strong>
<ul>
<li>一个进程的执行依赖于其协作进程的消息或信号</li>
</ul>
</li>
<li>竞争 ——<strong> 互斥（mutual exclusion）</strong>
<ul>
<li>互斥也是一种特殊的同步 —— 以一定次序协调地使用共享资源</li>
</ul>
</li>
</ul>
<h4 id="与时间有关的错误"><a class="anchor" href="#与时间有关的错误">#</a> 与时间有关的错误</h4>
<ul>
<li>Bernstein 条件
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R(p_i)=\{a_1,a_2,…,a_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在执行期间引用的变量集</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mi>m</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">W(p_i)=\{b_1,b_2,…,b_m\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，程序<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在执行期间改变的变量集</li>
<li>若两个程序的变量集交集之和为空集：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∪</mo><mi>R</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∪</mo><mi>W</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R(p_1)∩W(p_2)∪R(p_2)∩W(p_1)∪W(p_1)∩W(p_2)=\{   \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mclose">}</span></span></span></span>，则并发进程的执行与时间无关</li>
</ul>
</li>
<li>若两个进程共享了数据集，则可能存在制约关系，形成交互的并发进程</li>
<li>执行的相对速度无法相互控制，可能会出现所谓与时间有关的错误</li>
</ul>
<h4 id="临界资源与临界区"><a class="anchor" href="#临界资源与临界区">#</a> 临界资源与临界区 😊</h4>
<ul>
<li><strong>临界资源</strong>：在某段时间内只能允许一个进程使用的资源 (打印机、磁带机等硬件设备和变量、队列等数据结构)</li>
<li><strong>临界区</strong>：进程中访问临界资源的代码段，几个进程若共享同一临界资源，它们必须以互斥的方式使用这个临界资源</li>
<li>临界区调度原则：<br>
1）一次至多一个进程能够执行其临界区代码；<br>
2）如果已有进程在临界区运行，其它试图进入的进程应等待；<br>
3）进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入<br>
选择临界区调度策略时，不能因为该原则而造成进程饥饿或死锁<br>
实现临界区管理有软件和硬件两种方式</li>
</ul>
<h5 id="软件方法管理临界区"><a class="anchor" href="#软件方法管理临界区">#</a> 软件方法管理临界区</h5>
<ul>
<li>
<p>实施依据是内存访问的基本互斥性 —— 对内存同一地址的并发访问将被存储管理器序列化，而访问的顺序并无需事先指定，不需要硬件、操作系统或程序设计语言的任何支持</p>
</li>
<li>
<p>Peterson 算法（1981 年）</p>
<ul>
<li>为每个进程设置标志 <code>flag</code>  用于表示该进程是否有意访问临界资源（进入临界区），又设置标志 <code>turn</code>  用于表示临界资源此时是否有其它进程在访问</li>
<li>只有在对方进程的访问标志 <code>flag</code>  为 <code>true</code>  并且 <code>turn</code>  也为该进程标识时，才表明对方进程在访问临界资源，需要等待对方进程访问完并释放资源后才能访问；否则本进程不需要等待对方进程即可访问临界资源</li>
</ul>
</li>
<li>
<p>软件方法管理临界区的标志算法比较容易出现<strong>标志逻辑混乱</strong>的情况，其<strong>根本原因</strong>在于管理临界区标志要用两条指令：</p>
<ul>
<li>一条指令是看对方的标志</li>
<li>一条指令是设置自己的标志</li>
</ul>
</li>
<li>
<p>进程并发可能导致进程在执行这两条指令时被另一个进程中断</p>
</li>
<li>
<p>保证进程在执行这两条指令时不被中断，即可很容易地进行临界区管理</p>
</li>
</ul>
<h5 id="硬件方式管理临界区"><a class="anchor" href="#硬件方式管理临界区">#</a> 硬件方式管理临界区</h5>
<ul>
<li><strong>禁止中断法</strong>
<ul>
<li>在检查临界区标志的两条指令之前将中断关上，临界区访问完后系统才打开中断</li>
<li>缺点：影响计算机效率、不能及时处理重要程序、对多 CPU 系统无效</li>
</ul>
</li>
<li><strong>特殊指令法</strong>
<ul>
<li>特殊的硬件指令保证几个动作的原子性 —— 不会被中断，不受到其它指令的干扰</li>
<li>“测试并设置（Test and Set）” 指令 <code>TS</code> ，或者交换（exchange）指令 <code>SWAP / xchg</code></li>
</ul>
</li>
<li><code>TS</code>  指令：将布尔变量 x 与临界区关联起来 —— 如果 x 为真，表示没有进程在临界区内，临界资源可用，并立即将 x 置为 false，即阻止其它进程进入临界区，访问临界资源；若 x 为假，则表示有其它进程进入临界区，本进程需要等待。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> <span class="token function">TS</span> <span class="token punctuation">(</span><span class="token keyword">bool</span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    x <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><ul>
<li>TS 指令实现互斥：</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> x <span class="token operator">=</span> <span class="token boolean">true</span>；</pre></td></tr><tr><td data-num="2"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="3"></td><td><pre>  process <span class="token function">Pi</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TS</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    临界区 i</pre></td></tr><tr><td data-num="6"></td><td><pre>    x <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="8"></td><td><pre>coend</pre></td></tr></tbody></table></figure><ul>
<li>用交换指令实现互斥：</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> lock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="3"></td><td><pre>  process <span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">bool</span> ki <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">do</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token function">SWAP</span><span class="token punctuation">(</span>ki<span class="token punctuation">,</span> lock<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>ki<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    临界区i</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">SWAP</span><span class="token punctuation">(</span>ki<span class="token punctuation">,</span> lock<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="11"></td><td><pre>coend</pre></td></tr></tbody></table></figure><h4 id="进程同步机制"><a class="anchor" href="#进程同步机制">#</a> 进程同步机制 😎</h4>
<p>常见的同步机制有<strong>锁、信号量、管程和消息传递</strong></p>
<h5 id="信号量机制"><a class="anchor" href="#信号量机制">#</a> 信号量机制</h5>
<ul>
<li>
<p>在这一体制下，进程在某一特殊点上被迫停止执行（阻塞）直到接收到一个对应的特殊变量值，这种特殊变量就是信号量 (semaphore)，除了<strong>赋初值</strong>外，<strong>信号量的值只能由 P 操作和 V 操作进行修改</strong>，进程通过 P、V 这两个特殊操作在信号量所关联的系统资源上实现同步与互斥</p>
</li>
<li>
<p>信号量表示<strong>系统资源的实体</strong></p>
</li>
<li>
<p>具体实现时，信号量是一种<strong>记录型数据结构</strong>，有两个分量：一个是信号量的值，另一个是在信号量关联资源上阻塞的进程队列的队头指针<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/81dff4723a9ef98ea32a6092f527d4198477052f941f71999fa3daebf22f5985.png" alt="图 3"></p>
</li>
<li>
<p>信号量在操作系统中的主要作用是<strong>封锁临界区</strong>、<strong>进程同步</strong>和<strong>维护资源计数</strong>。</p>
</li>
<li>
<p>P 操作和 V 操作原语的功能：</p>
<ul>
<li><code>P(s)</code> ：将信号量 <code>s</code>  的值减 1，若结果小于 0，则调用 <code>P(s)</code>  的进程被阻塞，并进入信号量 <code>s</code>  的阻塞队列中；若结果不小于 0，则调用 <code>P(s)</code>  的进程继续运行</li>
<li><code>V(s)</code> ：将信号量 <code>s</code>  的值加 1，若结果不大于 0，则调用 <code>V(s)</code>  的进程从该信号量阻塞队列中释放、唤醒一个处于等待状态的进程，将其转换为就绪状态，调用 <code>V(s)</code>  的进程继续运行；若结果大于 0，则调用 <code>V(s)</code>  的进程继续运行</li>
</ul>
</li>
<li>
<p>信号量的数据类型以及 P、V 操作原语的定义</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">int</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">struct</span> <span class="token class-name">pcb</span> <span class="token operator">*</span>list<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">}</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span>semaphore <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  s<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>            </pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token function">block</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">}</span>                     </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">V</span><span class="token punctuation">(</span>semaphore <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  s<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>            </pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token function">wakeup</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><ul>
<li>P 操作意味进程申请一个资源，求而不得则阻塞进程，V 操作意味着释放一个资源，若此时还有进程在等待获取该资源，则被唤醒</li>
<li>若信号量的值为正数，该正数表示可对信号量可进行的 P 操作的次数，即可用的资源数。信号量的初值一般设为系统中相关资源的总数，对于互斥信号量，初值一般设为 1</li>
<li>若信号量的值为负，其绝对值表示有多个进程申请该资源而又不能得到，在阻塞队列等待，即在信号量阻塞队列中等待该资源的进程个数</li>
<li>信号量机制实现进程互斥进入临界区</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="3"></td><td><pre>  process <span class="token function">Pi</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>  </pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>     临界区i</pre></td></tr><tr><td data-num="6"></td><td><pre>     <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="8"></td><td><pre>coend</pre></td></tr></tbody></table></figure><h4 id="进程同步的经典问题"><a class="anchor" href="#进程同步的经典问题">#</a> 进程同步的经典问题</h4>
<h5 id="生产者-消费者问题"><a class="anchor" href="#生产者-消费者问题">#</a> 生产者 - 消费者问题</h5>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个生产者进程和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个消费者进程，连接在一块长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个单位的有界缓冲区上（故此问题又称有界缓冲问题）。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 都是<strong>并发进程</strong>，只要缓冲区未满，生产者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 生产的产品就可送入缓冲区；只要缓冲区不空，消费者进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 就可从缓冲区取走并消耗产品<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/747f038b3dca8065508aef8392d4d4b1b425d4d609176153340742859bf5d295.png" alt="图 4"></p>
</li>
<li>
<p>在并发环境下生产者、消费者进程访问缓冲区的速度不协调、不匹配 ——<strong> 不同步</strong>，或者没有做到互不影响地使用、更新缓冲区 ——<strong> 互斥</strong>，所以会出现<strong>运行错误</strong>甚至是<strong>死锁</strong></p>
</li>
<li>
<p>信号量机制解决多个生产者 - 消费者、共享多个缓冲区的生产者 - 消费者问题</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>item B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 缓冲区，长度 k</span></pre></td></tr><tr><td data-num="2"></td><td><pre>semaphore empty <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token comment">// 可用的空缓冲区数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 缓冲区内可用的产品数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>semaphore m1 <span class="token operator">=</span> m2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 互斥信号量</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 缓冲区放入位置</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 缓冲区取出位置</span></pre></td></tr><tr><td data-num="7"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="8"></td><td><pre>process <span class="token function">producer_i</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">produce</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 生产一个产品</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span>申请空缓冲区</pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>m1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 申请互斥使用缓冲区</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    append to B<span class="token punctuation">[</span>in<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 产品放入缓冲</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    in <span class="token operator">=</span> <span class="token punctuation">(</span>in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> k<span class="token punctuation">;</span>     <span class="token comment">// 更新缓冲区指针</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>m1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="19"></td><td><pre>process <span class="token function">consumer_j</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    </pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">take</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> from B<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    out <span class="token operator">=</span> <span class="token punctuation">(</span>out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="30"></td><td><pre>coend</pre></td></tr></tbody></table></figure><h5 id="读者-写者问题"><a class="anchor" href="#读者-写者问题">#</a> 读者 - 写者问题</h5>
<ul>
<li>两组并发进程，读者和写者，共享一个文件 F，要求：
<ul>
<li>允许多个读者进程同时读文件</li>
<li>只允许一个写者进程写文件</li>
<li>任何一个写者进程在完成写操作之前不允许其它读者或写者工作</li>
<li>写者执行写操作前，应让已有的写者和读者全部退出</li>
</ul>
</li>
<li>信号量机制解决读者 - 写者问题</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> readcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 读进程计数器</span></pre></td></tr><tr><td data-num="2"></td><td><pre>semaphore ws <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="4"></td><td><pre>process <span class="token function">reader_i</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  readcount<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  读文件<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  readcount<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="15"></td><td><pre>process <span class="token function">writer_j</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  写文件<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="20"></td><td><pre>coend</pre></td></tr></tbody></table></figure><ul>
<li>写者优先算法</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>semaphore  rmutex<span class="token punctuation">,</span> wmutex<span class="token punctuation">,</span> S<span class="token punctuation">;</span> <span class="token comment">// S 在写者到达后封锁读者</span></pre></td></tr><tr><td data-num="2"></td><td><pre>rmutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> wmutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="5"></td><td><pre>process reader <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">P</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="9"></td><td><pre>  count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  READ FILE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="14"></td><td><pre>  count<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="18"></td><td><pre>process writer<span class="token punctuation">{</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="21"></td><td><pre>  WRITE the FILE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="25"></td><td><pre>coend</pre></td></tr></tbody></table></figure><h5 id="哲学家就餐问题"><a class="anchor" href="#哲学家就餐问题">#</a> 哲学家就餐问题</h5>
<ul>
<li>五个哲学家围坐在一张圆桌前，每个哲学家面前有一碗意大利面和一只叉子，哲学家的生活由思考和进餐两个活动组成，进餐时需要两只叉子，但每个哲学家只有两只叉子，所以他们需要共享叉子</li>
<li>算法 1：给所有哲学家编号，奇数号的哲学家必须首先拿左边的筷子，偶数号的哲学家则反之。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>semaphore chopsticks <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="4"></td><td><pre>process <span class="token function">philmac_i</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//i=0,1,2,3,4</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token function">P</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token function">P</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">else</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token function">P</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> l<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token function">P</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span><span class="token function">chopsticks</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>；</pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="20"></td><td><pre>coend</pre></td></tr></tbody></table></figure><ul>
<li>算法 2：通过发放令牌最多允许 4 个哲学家同时吃面</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>semaphore chopsticks<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>semaphore token <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//4 个令牌</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="5"></td><td><pre>process <span class="token function">philmac_i</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//i=0,1,2,3,4 </span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> l<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> l<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="17"></td><td><pre>coend</pre></td></tr></tbody></table></figure><ul>
<li>管程解决哲学家就餐问题的算法：</li>
</ul>
<p>采用 Hoare 管程实现，算法思想是将哲学家的状态分为思考、饥饿、吃面，并且仅当哲学家左右两边的筷子都可用才允许他拿筷子，否则一只筷子也不拿</p>
<h5 id="睡眠理发师问题"><a class="anchor" href="#睡眠理发师问题">#</a> 睡眠理发师问题</h5>
<ul>
<li>理发店里有一个理发师，一把理发椅，N 个供等候顾客休息的椅子。若无顾客，理发师躺在理发椅上睡觉。顾客到来时唤醒理发师，若理发师正在理发，新来的顾客坐在空闲的休息椅上等候，如果没有空椅子，顾客离开。</li>
<li>进程 <code>Barber()</code>  和 <code>Customer()</code>  分别描述理发师和顾客，理发师和顾客之间是同步的关系，顾客之间是互斥关系，竞争理发师和休息椅。</li>
<li>算法采用信号量机制，引入一个控制变量和 3 个信号量：
<ul>
<li>控制变量 <code>waiting</code>  用来记录等候理发的顾客数，初值为 0；</li>
<li>信号量 <code>customers</code>  用来关联表达等候理发的顾客数，并用作阻塞理发师进程，初值为 0；</li>
<li>信号量 <code>barbers</code>  用来记录正在等候顾客的理发师数，并用作阻塞顾客进程，初值为 0；</li>
<li>信号量 <code>mutex</code>  用于互斥，初值为 1。</li>
</ul>
</li>
</ul>
<h3 id="进程通信"><a class="anchor" href="#进程通信">#</a> 进程通信 😊</h3>
<ul>
<li>进程通信（IPC：Inter-Process Communication）是<strong>进程之间数据的相互交换和信息的相互传递</strong>，是一种 <code>高级通信机制</code></li>
</ul>
<h4 id="消息传递通信"><a class="anchor" href="#消息传递通信">#</a> 消息传递通信</h4>
<ul>
<li>进程将<strong>通信数据封装在消息</strong>中，消息通过消息缓冲区在进程之间互相传递</li>
<li><strong>消息</strong>是指进程之间以<strong>不连续</strong>的<strong>成组方式</strong>发送的信息</li>
<li><strong>消息缓冲区</strong>应包含<strong>消息发送进程标识</strong>、<strong>消息接收进程标识</strong>、<strong>指向下一个消息缓冲区的指针</strong>、<strong>消息长度</strong>、<strong>消息正文</strong>等。缓冲区构成了进程通信的一个<strong>基本单位</strong></li>
</ul>
<h5 id="直接通信"><a class="anchor" href="#直接通信">#</a> 直接通信</h5>
<ul>
<li>在直接通信方式下，发送进程将发送的数据封装到消息正文后，发送进程必须给出接收进程的标识，然后用发送原语将消息发送给接收进程</li>
<li>收发消息的原语：
<ul>
<li><code>send</code> （接收进程标识，消息队列首指针）</li>
<li><code>receive</code> （发送进程标识，接收区首地址指针）</li>
</ul>
</li>
<li>在直接通信中隐含着发送进程与接收进程之间的同步问题</li>
<li><code>send()</code> ：
<ul>
<li>查找接收进程的 PCB，存在，则申请一个存放消息的缓冲区，若消息缓冲区已满，则返回到非同步错误处理程序入口，进行特殊处理</li>
<li>若接收进程因等待此消息的到来而处于阻塞状态，则唤醒此进程。将存放消息的缓冲区连接到接收进程的消息队列上</li>
<li>两种同步方式
<ul>
<li>发送进程阻塞等待接收进程发回的确认信息</li>
<li>发送进程发送完消息后，不阻塞等待接收进程的回送信息，而是继续执行；限定时间到仍未收到确认消息，重发或放弃</li>
</ul>
</li>
</ul>
</li>
<li><code>receive()</code> ：
<ul>
<li>接收进程在其进程空间中确定一个接收区，复制 / 读取消息缓冲区中的内容，释放消息缓冲区</li>
<li>若无消息可读，则阻塞接收进程至有消息发送来为止</li>
<li>两种同步方式
<ul>
<li>接收进程调用 <code>receive</code>  原语并一直阻塞等待发送来的消息，直到接收到消息 —— 与发送进程的第二种同步方式匹配</li>
<li>接收进程调用 <code>receive</code>  原语后，不阻塞等待发送来的消息，而是继续执行 —— 与发送进程的第一种同步方式匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="间接通信"><a class="anchor" href="#间接通信">#</a> 间接通信</h5>
<ul>
<li>消息传递的间接通信方式是指发送进程与接收进程之间<strong>通过邮箱</strong>来进行通信，发送进程将消息发送到邮箱，接收进程从邮箱接收消息
<ul>
<li>发送原语： <code>send(mailboxname, message)</code> ;</li>
<li>接收原语： <code>receive(mailboxname, message)</code> ;</li>
</ul>
</li>
<li>与直接通信比较，间接通信<strong>灵活性更大</strong>，不<strong>需要发送进程与接收进程同步</strong>，是一种方便、可靠的进程通信方式</li>
</ul>
<h4 id="共享内存通信"><a class="anchor" href="#共享内存通信">#</a> 共享内存通信</h4>
<ul>
<li>
<p>共享内存通信分为</p>
<ul>
<li>基于共享数据结构的通信方式 —— 比较低效，只适于传递少量数据</li>
<li>基于共享存储区的通信方式<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/c868f1c9897cbead1fba597ef183d3c94759fe469fe18b249b4266fc8eb9693f.png" alt="图 5"></li>
</ul>
</li>
<li>
<p>共享内存通信的实现过程如下：</p>
<ul>
<li>建立共享内存区 —— 标识和长度等参数</li>
<li>共享内存区的管理</li>
<li>共享内存区的映射与断开</li>
</ul>
</li>
<li>
<p>允许多个进程将共享内存映射到自己的地址空间，进程对各自所映射的地址段的读写操作代码应纳入临界区管理</p>
</li>
</ul>
<h4 id="管道通信"><a class="anchor" href="#管道通信">#</a> 管道通信</h4>
<ul>
<li>管道是连接读、写进程的一个<strong>特殊文件</strong>，允许进程按<strong> FIFO 方式</strong>传送数据，也能使进程同步执行操作。发送进程以字符流形式把数据送入管道，接收进程从管道中接收数据</li>
<li>管道的实质是一个共享文件（文件系统的高速缓冲区中），进程对管道<strong>应该互斥使用</strong></li>
<li>写进程把一定数量的数据写入 <code>pipe</code> ，就去睡眠等待，直到读进程取走数据后，将其唤醒</li>
<li>命名管道（named pipe）用来在不同的地址空间之间进行通信，不仅可以在本机上实现两个进程间的通信，还可以跨网络实现两个进程间的通信，特别为服务器通过网络与客户端交互而设计，是一种<strong>永久通信机制</strong></li>
<li>每一个命名管道都有一个<strong>唯一的名字</strong></li>
</ul>
<h3 id="进程调度"><a class="anchor" href="#进程调度">#</a> 进程调度</h3>
<ul>
<li>由于进程总数一般多于 CPU 数，必然会出现竞争 CPU 的情况。进程调度的功能就是按一定策略、动态地把 CPU 分配给处于就绪队列中的某一进程执行</li>
<li>两种基本的进程调度方式，<strong>抢占方式</strong>和<strong>非抢占方式</strong>，也称<strong>剥夺式（preemptive）<strong>和</strong>非剥夺式（non_preemptive）</strong> 调度</li>
<li>剥夺原则有：<strong>优先权原则</strong>、<strong>短进程优先原则</strong>、<strong>时间片原则</strong>等</li>
<li>可能引发进程调度的时机：
<ul>
<li>正在运行的进程运行完毕；</li>
<li>运行中的进程要求 I/O 操作；</li>
<li>执行某种原语操作 (如 P 操作) 导致进程阻塞；</li>
<li>比正在运行的进程优先级更高的进程进入就绪队列；</li>
<li>分配给运行进程的时间片已经用完</li>
</ul>
</li>
</ul>
<h4 id="进程调度模型"><a class="anchor" href="#进程调度模型">#</a> 进程调度模型 😎</h4>
<ul>
<li>三级调度
<ul>
<li><strong>高级调度</strong>（High-Level Scheduling），作业调度
<ul>
<li>从后备作业中选若干个作业，分配必要的资源，建立相应的用户作业进程和系统服务进程（如输人、输出进程），将其程序和数据调入内存……</li>
</ul>
</li>
<li><strong>中级调度</strong>（Intermediate-Level Scheduling），平衡调度
<ul>
<li>在内存紧张时，将一些暂时不能运行的进程对换到外存。当内存有空间时，再将其重新调入内存</li>
</ul>
</li>
<li><strong>低级调度</strong>（Low-Level Scheduling），进程调度
<ul>
<li>根据一定的算法将 CPU 分派给就绪队列中的一进程</li>
<li>最基本的、必须的一种调度<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/a297919e31adfb5e12cded4bba3a0975f710c118efbd16b60ea550951bf901d3.png" alt="图 6"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="调度算法选择评价准则"><a class="anchor" href="#调度算法选择评价准则">#</a> 调度算法选择 / 评价准则</h4>
<ul>
<li>调度算法也称为调度策略 ，评价调度算法的参数：
<ul>
<li><strong>处理器利用率</strong>（CPU utilization）=&nbsp;CPU 有效工作时间 / CPU 总的运行时间</li>
<li><strong>响应时间</strong>（response time）：交互环境下用户从键盘提交请求开始，到系统首次产生响应为止的时间；是分时和实时系统调度性能重要指标。</li>
<li><strong>周转时间</strong>（turnaround time）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mtext>&nbsp;</mtext><mo>=</mo><msub><mi>T</mi><mi>f</mi></msub><mtext>–</mtext><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_i&nbsp;=  T_f – T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">–</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即：周转时间 = 完成时刻 - 提交时刻；批处理系统重要指标</li>
<li><strong>带权周转时间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub><mo>=</mo><mtext>&nbsp;作业的周转时间</mtext><msub><mi>T</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mtext>系统为作业提供的服务时间</mtext><mi>T</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i =&nbsp;作业的周转时间T_i / 系统为作业提供的服务时间Ts_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&nbsp;</span><span class="mord cjk_fallback">作业的周转时间</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord cjk_fallback">系统为作业提供的服务时间</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，显然带权周转时间总大于 1 。实质是，周转时间与系统为其提供服务的时间之比</li>
<li><strong>平均作业周转时间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">T = (ΣT_i) / n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span></span></span></span></li>
<li><strong>平均作业带权周转时间</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><msub><mi>W</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">W = (ΣW_i) / n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span></span></span></span></li>
<li><strong>系统吞吐量</strong>（throughput）：单位时间内完成的进程（任务 / 交易）数目</li>
<li><strong>公平性</strong>：不出现饥饿情况</li>
</ul>
</li>
</ul>
<h4 id="调度算法"><a class="anchor" href="#调度算法">#</a> 调度算法 😎</h4>
<h5 id="先来先服务first-come-first-servedfcfs"><a class="anchor" href="#先来先服务first-come-first-servedfcfs">#</a> 先来先服务（First-Come First-Served，FCFS）</h5>
<ul>
<li>按进程就绪的先后顺序来调度，到达得越早，就越先执行</li>
<li>获得 CPU 的进程，未遇到其它情况时，一直运行下去</li>
<li>是一种<strong>非抢占式</strong>算法，简单易实现</li>
<li><strong>没有</strong>考虑<strong>执行时间长短</strong>、<strong>运行特性</strong>和<strong>资源</strong>的要求</li>
<li>FCFS 调度算法适用性
<ul>
<li>对<strong>长作业非常有利</strong>，对<strong>短作业不利</strong></li>
<li>对<strong> CPU 繁忙型</strong>的作业非常<strong>有利</strong>，对<strong> I/O 繁忙型作业</strong>非常<strong>不利</strong> —— 进程 I/O 阻塞结束后需<strong>再次排队</strong></li>
<li><strong>非抢占式算法</strong>，对<strong>响应时间要求高</strong>的进程<strong>不利</strong></li>
<li>平均作业周转时间与作业提交的<strong>顺序</strong>有关</li>
</ul>
</li>
</ul>
<h5 id="短作业优先shortest-job-firstsjf"><a class="anchor" href="#短作业优先shortest-job-firstsjf">#</a> 短作业优先（Shortest-Job-First，SJF）</h5>
<ul>
<li>以进入系统的作业所要求的 CPU 服务时间为标准，总选取估计所需 CPU 时间最短的作业优先投入运行。
<ul>
<li>算法<strong>易于实现</strong>，<strong>效率不高</strong>，主要弱点是<strong>忽视了作业等待时间</strong>。</li>
<li>对<strong>长作业不利</strong>，如果系统不断接收短作业，可能会出现<strong>饥饿</strong>现象。</li>
<li><strong>非抢占式</strong>算法，对<strong>响应时间要求高</strong>的进程<strong>不利</strong>。</li>
<li>SJF 的<strong>平均作业周转时间</strong>比 FCFS 要<strong>小</strong>，故它的调度<strong>性能</strong>比 FCFS<strong> 好</strong>。</li>
<li>实现 SJF 调度算法需要知道<strong>作业所需运行时间</strong>，而要精确知道一个作业的运行时间是<strong>办不到</strong>的。</li>
</ul>
</li>
</ul>
<h5 id="最短剩余时间优先shortest-remaining-time-firstsrtf"><a class="anchor" href="#最短剩余时间优先shortest-remaining-time-firstsrtf">#</a> 最短剩余时间优先（Shortest Remaining Time First，SRTF）</h5>
<ul>
<li>若一就绪状态的新作业所需的 CPU 时间比当前正在执行的作业剩余任务所需 CPU 时间还短，SRTF 将<strong>打断正在执行作业</strong>，将执行权分配给新作业</li>
<li>SRTF 将 SJF 算法改为<strong>抢占式</strong>，因此只要有新作业进入<strong>就绪队列</strong>，就可能会引发<strong>进程切换</strong>。</li>
<li>SRTF 调度算法适用性：
<ul>
<li><strong>长进程</strong>仍有可能出现<strong>饥饿</strong>现象</li>
<li>必须计算运行、剩余时间，系统<strong>开销增大</strong></li>
<li>因抢占式调度，系统<strong>性能</strong>会比 SJF 要<strong>好</strong></li>
</ul>
</li>
</ul>
<h5 id="高响应比优先highest-response-ratio-firsthrrf"><a class="anchor" href="#高响应比优先highest-response-ratio-firsthrrf">#</a> 高响应比优先（Highest Response Ratio First，HRRF）</h5>
<ul>
<li>是 FCFS 与 SJF 两种算法的<strong>折衷</strong>，既考虑作业<strong>等待</strong>时间，又考虑作业的<strong>运行</strong>时间，既照顾短作业又不使长作业等待过久，<strong>改善</strong>了调度<strong>性能</strong>，仍属于<strong>非抢占式算法</strong>
<ul>
<li>响应比为作业的响应时间与作业所需运行时间之比，简化为：响应比 ＝ 1 +（已等待的时间 / 估计运行时间）</li>
</ul>
</li>
<li>HRRF 算法适用性：
<ul>
<li>由定义可知，<strong>短作业</strong>容易得到<strong>较高响应比</strong>，长作业在等待了足够长的时间后，也将获得足够高的响应比，因此<strong>不会发生饥饿</strong>现象</li>
<li>需要经常计算作业的响应比，导致<strong>额外的开销</strong></li>
<li>HRRF 算法的平均周转时间和平均带权周转时间都<strong>介于 FCFS 与 SJF 算法之间</strong>，比 SJF 算法差，比 FCFS 算法优</li>
<li>虽然 HRRF 算法的平均周转时间和平均带权周转时间不及 SJF 算法，但是，在现实中其可以实现，结果也比较<strong>可靠</strong></li>
<li>如果在算法中引入<strong>抢占调度</strong>，则算法过程会更复杂。因为所有作业的响应比是<strong>动态变化</strong>的，抢占时间的计算需要解多个方程得到</li>
</ul>
</li>
</ul>
<h5 id="优先权highest-priority-firsthpf"><a class="anchor" href="#优先权highest-priority-firsthpf">#</a> 优先权（Highest-Priority-First，HPF）</h5>
<ul>
<li>根据进程的<strong>优先权</strong>进行进程调度，每次总是选取优先权高的进程调度，也称<strong>优先级调度算法</strong>，一般是<strong>抢占式</strong>调度
<ul>
<li>优先权通常用一个整数表示，也叫优先数
<ul>
<li>Windows 系统中有 0~31 共 32 个优先级，31 最高</li>
<li>Unix 系统中，使用数值 - 20~+19 来表示优先级，-20 优先级最高</li>
</ul>
</li>
<li>优先权可由<strong>系统或用户给定</strong>
<ul>
<li>静态优先权</li>
<li>动态优先权</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="时间片轮转round-ribonrr"><a class="anchor" href="#时间片轮转round-ribonrr">#</a> 时间片轮转（Round-Ribon，RR）</h5>
<ul>
<li>调度程序把 CPU 分配给进程使用一个规定的时段，称为一个<strong>时间片</strong>（如 100ms），就绪队列中的进程轮流获得 CPU 的一个时间片。当一个时间片结束时，系统剥夺该进程执行权，等候下一轮调度，属于<strong>抢占式调度</strong>
<ul>
<li>时间片的长短，影响进程的进度</li>
<li>需要从进程数、切换开销、系统效率和响应时间等方面综合考虑，确定时间片大小</li>
</ul>
</li>
</ul>
<h5 id="多级反馈队列multilevel-feed-queuemfq"><a class="anchor" href="#多级反馈队列multilevel-feed-queuemfq">#</a> 多级反馈队列（Multilevel-Feed-Queue，MFQ）</h5>
<ul>
<li>又称<strong>反馈循环队列</strong>，是一种<strong>基于时间片的进程多级队列调度算法的改进算法</strong>。系统设置多个就绪队列，<strong>最高级就绪队列的优先级最高</strong>，随着就绪队列级别的降低优先级依次下降，<strong>较高级就绪队列的进程获得较短的时间片</strong></li>
<li>不需事先知道各进程所需运行时间，因而可行性较高，同时综合考虑了进程的时间和优先权因素，既照顾了短进程，又照顾了长进程，是一种<strong>综合调度算法</strong>，被广泛应用于各种操作系统中</li>
</ul>
<h4 id="多cpu系统中的调度"><a class="anchor" href="#多cpu系统中的调度">#</a> 多 CPU 系统中的调度</h4>
<ul>
<li>多处理器系统的作用是利用系统内的多个 CPU 来并行执行用户进程，以提高系统的吞吐量或用来进行冗余操作以提高系统的可靠性</li>
<li>系统的多个处理器在物理上处于同一机壳中，有一个单一的系统物理地址空间，多个处理器共享系统内存、外设等资源</li>
<li>多 CPU 系统的类型主要有两种：
<ul>
<li><strong>主 - 从模式</strong>，只有一个主处理器，运行操作系统，管理整个系统资源，并负责为各从处理器分配任务，从处理器有多个，执行预先规定的任务及由主处理器分配的任务。这种类型的系统无法做到负载平衡，可靠性不高，<strong>很少使用</strong>。</li>
<li><strong>对称处理器模式 SMP（Symmetric MultiProcessor）</strong>，所有处理器都是相同的、平等的，共享一个操作系统，每个处理器都可以运行操作系统代码，管理系统资源。是目前比较常见的多 CPU 系统类型。</li>
</ul>
</li>
<li>多处理器系统中，比较有代表性的进（线）程调度方式有以下几种方式：
<ul>
<li>自调度
<ul>
<li>设置一个公共的进程或线程的就绪队列</li>
<li>不会出现处理器空闲</li>
<li>处理器互斥访问该队列，容易形成系统瓶颈</li>
<li>高速缓存的使用效率很低</li>
<li>协作线程很难同时运行</li>
</ul>
</li>
<li>组调度 / 群调度（Gang Scheduling）</li>
<li>专用处理器分配</li>
<li>动态调度
<ul>
<li>操作系统和进程共同进行调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多核cpu中的调度"><a class="anchor" href="#多核cpu中的调度">#</a> 多核 CPU 中的调度</h4>
<ul>
<li>多核处理器是指在<strong>一枚处理器中集成两个或多个计算引擎（内核 /core）</strong>，称为 CMP（Chip multiprocessors）结构，可在特定的时钟周期内执行更多任务，通常采用共享二级 Cache 的结构</li>
<li>对于多核 CPU，优化操作系统任务调度算法是保证效率的关键
<ul>
<li>全局队列调度（多数系统）</li>
<li>局部队列调度</li>
</ul>
</li>
<li>中断处理 —— 全局中断控制器也需要封装在芯片内部</li>
<li>系统提供同步与互斥机制 —— 需要利用硬件提供的 “读－修改－写” 的原子操作或其他同步互斥机制</li>
</ul>
<h3 id="死锁"><a class="anchor" href="#死锁">#</a> 死锁 😎</h3>
<ul>
<li><strong>一个进程集合中的每个进程都在等待只能由该集合中的其它一个进程才能引发的事件</strong>，则称一组进程或系统此时发生了死锁</li>
<li>死锁一旦发生，会使整个系统瘫痪而无法工作。因此，必须想办法解决死锁问题</li>
</ul>
<h4 id="死锁产生的原因"><a class="anchor" href="#死锁产生的原因">#</a> 死锁产生的原因</h4>
<ul>
<li>并发进程<strong>对临界资源的竞争</strong></li>
<li>并发进程<strong>推进顺序不当</strong></li>
</ul>
<h4 id="死锁产生的必要条件"><a class="anchor" href="#死锁产生的必要条件">#</a> 死锁产生的必要条件 😎</h4>
<ul>
<li>
<p><strong>互斥条件</strong>（Mutual exclusion）：资源的使用是互斥的</p>
</li>
<li>
<p><strong>请求与保持条件</strong>（Hold and wait）：已经得到某些资源的进程可以再申请新的资源。</p>
</li>
<li>
<p><strong>不剥夺条件</strong>（No pre-emption）：系统或其它进程不能剥夺进程已经获得的资源。</p>
</li>
<li>
<p><strong>环路等待条件</strong>（Circular wait）：系统中若干进程间形成等待环路</p>
</li>
<li>
<p>只要破坏上述几个条件之一，即可<strong>防止死锁</strong></p>
<ul>
<li>破坏第 1 个条件，使资源可同时访问而不是互斥使用，<strong>可行性较差</strong></li>
<li>破坏第 2 个条件，进程必须获得所需的所有资源才能运行 ——<strong> 静态</strong>分配，<strong>严重降低资源利用效率</strong>。</li>
<li>破坏第 3 个条件，采用<strong>剥夺式调度</strong>方法，<strong>只适用于 CPU 和内存分配</strong></li>
<li>破坏条件 4，采用<strong>层次分配</strong>策略 —— 按此策略分配资源时系统不会发生死锁</li>
<li>资源按序分配策略：进程不得在占用资源<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r_j(1≤j≤m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 后再申请<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r_i(i&lt;j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>
<p>进程 - 资源分配图</p>
<ul>
<li><strong>圆圈</strong>表示<strong>进程</strong>，<strong>资源类</strong>用<strong>方框</strong>表示，<strong>框中的圆点</strong>代表<strong>单个该类资源</strong>，<strong>有向边</strong>连接进程和资源</li>
<li><strong>申请边</strong>从<strong>进程指向资源类方框</strong>，表示进程正在等待资源；<strong>分配边</strong>从<strong>单个资源圆点指向进程</strong>，表示进程已经获得资源</li>
<li><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/f583fda244f86a4bd2a5b51d564f07268ae4916bd6e9b3aba3f5fe3fb66a890a.png" alt="图 7"></li>
</ul>
</li>
<li>
<p>根据进程 - 资源分配图定义个得出如下结论：</p>
<ul>
<li>如果进程 - 资源分配图中<strong>无环路</strong>，则此时系统<strong>没有发生死锁</strong></li>
<li>如果进程 - 资源分配图中<strong>有环路</strong>，且每个资源类中<strong>仅有一个资源</strong>，则系统中<strong>发生了死锁</strong>，此时，<strong>环路</strong>是系统发生死锁的<strong>充要条件</strong>，<strong>环路中的进程便为死锁进程</strong></li>
<li>如果进程 - 资源分配图中<strong>有环路</strong>，且涉及的资源类中<strong>有多个资源</strong>，则环路的存在只是产生死锁的<strong>必要条件</strong>而不是充分条件</li>
</ul>
</li>
<li>
<p>进程 - 资源分配图可用以下步骤化简：</p>
<ul>
<li>在资源分配图中，找出一个<strong>既非等待又非孤立</strong>的进程结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可获得它所需要的全部资源，且运行完后释放它所占有的全部资源，故可在资源分配图中<strong>消去</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><strong> 所有的申请边和分配边</strong>，使之成为既无申请边又无分配边的<strong>孤立</strong>结点；</li>
<li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 所释放的资源分配给申请它们的进程，即在资源分配图中<strong>将这些进程对资源的申请边改为分配边</strong>；</li>
<li>重复前两步骤，直到找不到符合条件的进程结点。</li>
</ul>
</li>
<li>
<p>经过化简后，若能<strong>消去资源分配图中的所有边</strong>，使所有进程都成为孤立结点，则称该图是<strong>可完全化简</strong>的，否则为<strong>不可化简</strong>的</p>
</li>
<li>
<p>系统为死锁状态的<strong>充分条件</strong>是：当且仅当该状态的进程 - 资源分配图是<strong>不可完全简化</strong>的 ——<strong> 死锁定理</strong>。</p>
</li>
</ul>
<h4 id="死锁的避免"><a class="anchor" href="#死锁的避免">#</a> 死锁的避免 😎</h4>
<ul>
<li>死锁避免法是通过资源分配算法分析系统是否存在一个并发进程的状态序列，在<strong>确定不会进程循环等待</strong>的情况下，才将资源真正分配给进程，以保证并发进程不会产生死锁。</li>
<li>死锁避免法能支持<strong>更高的进程并发度</strong>，<strong>动态地</strong>决定是否给进程分配资源 —— 如果进程的资源请求方案会导致死锁，系统拒绝执行，反之，如果一个资源的分配会导致死锁，系统拒绝分配。</li>
</ul>
<h5 id="银行家调度算法"><a class="anchor" href="#银行家调度算法">#</a> 银行家调度算法 😎</h5>
<ul>
<li>
<p>Dijkstra 在 1965 年提出了避免死锁的银行家调度算法，该算法是以银行系统所采用的借贷策略（尽可能放贷、尽快回收资金）为基础而建立的算法模型。在此模型中，进程相当于贷款客户，系统资源相当于资金，调度程序相当于银行家（贷款经理）。</p>
</li>
<li>
<p>进程约束条件：</p>
<ul>
<li>进程必须事先声明其资源需求</li>
<li>进程每次提出部分资源申请并获得分配</li>
<li>进程获得所需资源，执行完毕后，必须及时归还所占资源</li>
</ul>
</li>
<li>
<p>系统约束条件：</p>
<ul>
<li>若进程所请求得最大资源数不超过系统所有的资源总数，则系统一定分配资源给进程；</li>
<li>系统保证在有限的时间内使资源不足而等待的进程获得资源</li>
</ul>
</li>
<li>
<p>思路</p>
<ul>
<li>在某一时刻，各进程已获得所需的部分资源。有一进程提出新的资源请求，系统将剩余资源试探性地分配给该进程。</li>
<li>如果此时剩余资源能够满足余下的某些进程的需求，则将剩余资源分配给能<strong>充分满足</strong>的、<strong>资源需求缺口最大</strong>的进程，运行结束后释放的资源再并入系统的剩余资源集合。</li>
<li>反复执行第 2 步，直到所有的进程都能够获得所需而运行结束。说明第 1 步的进程请求是可行的，系统处于安全状态，相应的进程执行序列称为系统的<strong>安全序列</strong>。</li>
<li>如果所有的进程都试探过而不能将资源分配给进程，即不存在安全序列，则系统是不安全的。</li>
</ul>
</li>
<li>
<p>银行家算法所需的数据结构：假设系统中有 n 个进程，m 类资源；</p>
<ul>
<li>系统当前资源剩余量向量 <code>Available[m] = { R1，R2，……，Rm }</code> ；</li>
<li>n 个进程对 m 类资源的需求声明矩阵 <code>Claim[n][m]</code> ， <code>Claim[i][j]</code>  的值表示进程 i 对 j 类资源的总需求量；</li>
<li>n 个进程已获得的各类资源数量矩阵 <code>Possession[n][m]</code> ， <code>Possession[i][j]</code>  的值 <code>k</code>  表示进程 i 已获得 <code>k</code>  个 j 类资源；</li>
<li>n 个进程的各类资源需求缺口矩阵 <code>Shortage[n][m] = Claim – Possession</code> ， <code>Shortage[i][j]</code>  的值 <code>s</code>  表示进程 i 还需要（缺） <code>s</code>  个 j 类资源；</li>
<li>某进程 i 在某时刻发出的资源请求向量 <code>Request[m]</code> ，取值随具体情况而定。</li>
</ul>
</li>
</ul>
<blockquote>
<p>前 4 个数据结构及其取值确定了系统在某一时刻的状态，如果算法尝试资源分配方案能够使得所有进程安全运行完毕，则说明该状态安全，资源分配方案可行。</p>
</blockquote>
<ul>
<li>
<p>银行家算法细化说明</p>
<ul>
<li>判断请求向量 <code>Request</code>  的有效性 ——<strong> 超过相应进程总需求量则报错</strong>，<strong>超过系统目前剩余量则阻塞</strong>；</li>
<li>就系统资源剩余量对 <code>Request</code>  进行试分配：<br>
 <code>Available[*] = Available[*] - Request[*]</code> ；<br>
 <code>Possession[i][*] = Possession[i][*] + Request[*]</code> ；<br>
 <code>Shortage[i][*] = Shortage[i][*] - Request[*]</code> ；</li>
<li>执行安全性测试算法，若安全则确认试分配方案，否则进程 i 阻塞；</li>
</ul>
</li>
<li>
<p>执行安全性测试算法细化说明：</p>
<ul>
<li>定义工作向量 <code>Rest[*] = Available[*]</code> ，进程集合 <code>Running{*}</code> ，布尔量 <code>possible = true</code> ；</li>
<li>从 <code>Running</code>  集合中找出 <code>Pk</code> ，满足条件 <code>Shortage[k][*] &lt; Rest[*]</code> ；</li>
<li>找到合格的进程 <code>Pk</code> ，则释放其占用资源（ <code>Rest[*] = Rest[*] + Possession[k][*]</code> ），将其从 <code>Running</code>  集合中去掉，重复步骤②；</li>
<li>找不到合格的进程 <code>Pk</code> ， <code>possible</code>  为 <code>false</code> ，退出安全性测试算法；</li>
<li>最终检查 <code>Running</code>  集合，为<strong>空</strong>则返回<strong>安全</strong>，非空则不安全。</li>
</ul>
</li>
<li>
<p>银行家算法是一个很经典的死锁避免算法，<strong>理论性很强</strong>，看起来似乎很完美，但其实现要求进程不相关，并且事先要知道进程总数和各进程所需资源情况，所以<strong>可行性并不高</strong>。</p>
</li>
</ul>
<h4 id="检测与解除"><a class="anchor" href="#检测与解除">#</a> 检测与解除</h4>
<ul>
<li>
<p>死锁的检测算法可以采用<strong>基于死锁定理的检测</strong>（进程 - 资源分配图化简），也可以采用类似于银行家算法中的<strong>安全性测试算法</strong>，如果算法退出时<strong>仍有未结束</strong>的进程，则系统<strong>不安全</strong>，那些未结束的进程就是死锁的进程。</p>
</li>
<li>
<p>只不过死锁检测的不是试分配之后的系统状态，而是<strong>系统当前状态</strong>，需要考虑检查每个进程还需要的资源能否满足要求。</p>
</li>
<li>
<p>在系统中，需要决定<strong>死锁检测的频率</strong>。如果检测太频繁，会花大量的时间检测死锁，浪费 CPU 的处理时间；如果检测的频率太低，死锁进程和系统资源被锁定的时间过长，资源浪费大。</p>
</li>
<li>
<p>通常的方法是在<strong> CPU 的使用率下降到一定的阈值时实施检测</strong>。当死锁发生次数多，死锁进程数增加到一定程度时，CPU 的处理任务减少，CPU 空闲时间增多。</p>
</li>
<li>
<p>在系统成功地检测到死锁后，常用的死锁解除方法有以下几种：</p>
<ul>
<li><strong>重启</strong>：重新启动死锁进程，甚至重启操作系统。</li>
<li><strong>撤销</strong>：撤销死锁进程，回收资源，优先选择占用资源最多或者撤销代价最小的，撤销一个不行就继续选择撤销进程，直至解除死锁。</li>
<li><strong>剥夺</strong>：剥夺死锁进程资源再分配，选择原则同上。</li>
<li><strong>回滚</strong>：根据系统保存的检查点，使进程或系统回退到死锁前的状态。</li>
</ul>
</li>
</ul>
<h3 id="线程的基本概念"><a class="anchor" href="#线程的基本概念">#</a> 线程的基本概念</h3>
<h4 id="线程的引入"><a class="anchor" href="#线程的引入">#</a> 线程的引入</h4>
<ul>
<li>在操作系统中再引入线程则是为了<strong>减少程序并发执行时所付出的时空开销</strong>，使操作系统<strong>并发粒度更小</strong>、<strong>并发性更好</strong>。</li>
<li>线程是操作系统进程中<strong>能够独立执行的实体（控制流）</strong>，是<strong>处理器调度和分派的基本单位</strong></li>
<li>线程是进程的<strong>组成部分</strong>，线程只拥有一些在运行中<strong>必不可少的资源</strong>（如<strong>程序计数器</strong>、<strong>一组寄存器</strong>和<strong>栈</strong>），与同属一个进程的其它线程<strong>共享进程所拥有的全部资源</strong></li>
<li>多个线程间可<strong>并发</strong>执行</li>
<li><strong>不同进程</strong>间的线程<strong>互不可见</strong>，同一进程内的线程间通信主要<strong>基于全局变量</strong></li>
</ul>
<h4 id="线程与进程的区别与联系"><a class="anchor" href="#线程与进程的区别与联系">#</a> 线程与进程的区别与联系</h4>
<ul>
<li>线程具有许多传统进程所具有的特征，故又称为<strong>轻型进程</strong> (Light-Weight Process) 或进程元；而把传统的进程称为<strong>重型进程</strong> (Heavy-Weight Process)，它<strong>相当于只有一个线程的任务</strong>。</li>
<li>在引入了线程的操作系统中，通常一个进程都有若干个线程，<strong>至少需要有一个主线程</strong>。</li>
<li>进程的<strong>再定义</strong>：进程是操作系统中进行<strong>除处理器外</strong>的资源分配和保护的基本单位，它有一个<strong>独立的虚拟地址空间</strong>，用来<strong>容纳进程映像</strong> (如与进程关联的程序与数据)，并<strong>以进程为单位对各种资源实施保护</strong>，如受保护地访问处理器、文件、外部设备及其它进程 (进程间通信)</li>
<li>线程与进程在调度、并发性、系统开销、拥有资源等方面有所区别</li>
<li>在传统的操作系统中，拥有资源的基本单位和独立调度的基本单位都是进程。而在引入线程的操作系统中，则把线程作为 CPU 调度和分配的基本单位，而把进程作为拥有资源的基本单位，使传统进程的两个属性分开，线程便能轻装运行，从而可显著地提高系统的并发程度。</li>
<li>在同一进程中，<strong>线程的切换不会引起进程的切换</strong>，在<strong>由一个进程中的线程切换到另一个进程中的线程</strong>时，将会<strong>引起进程的切换</strong>。</li>
<li>不论是传统的操作系统，还是支持线程的操作系统，进程都是拥有资源的独立单位，拥有自己的资源。</li>
<li>一般地说，线程自己不拥有系统资源 (只有一些必不可少的资源)，但可以<strong>访问、共享其隶属进程的资源</strong> —— 进程的代码段、数据段以及打开的文件、I/O 设备等。</li>
<li>在进行进程切换时，涉及到当前进程<strong>整个 CPU 环境的保存</strong>以及<strong>新被调度运行的进程的 CPU 环境</strong>的设置。</li>
<li>而线程切换只需<strong>保存和设置少量寄存器</strong>的内容，并<strong>不涉及存储器管理</strong>方面的操作。可见，进程切换的开销也远大于线程切换的开销</li>
</ul>
<h4 id="线程的三种模式"><a class="anchor" href="#线程的三种模式">#</a> 线程的三种模式</h4>
<ul>
<li>在操作系统内核实现的<strong>内核级线程</strong>（Kernel Level Thread，KLT），如 Windows，OS/2 等：线程管理的全部工作由操作系统内核<strong>在内核空间实现</strong>。系统为应用开发使用内核级线程提供了 API，除了 API 函数调用外，应用程序<strong>不需要</strong>编写任何线程管理的其它代码，通过调用 API 函数，实现线程的创建和控制管理</li>
<li>在用户空间实现的<strong>用户级线程</strong>（User Level Thread，ULT），如 Java 的线程库等：线程管理的全部工作由应用程序在用户空间实现，<strong>内核不知道线程的存在</strong>。用户级线程由用户空间运行的用户级线程库实现，应用开发通过线程库进行程序设计，<strong>用户级线程库</strong>是线程运行的<strong>支撑环境</strong></li>
<li>同时支持两种线程的<strong>混合式线程</strong>实现，如 Solaris 系统。设计恰当的话，混合式线程既可以具备内核级线程实现的优点，又可以具备用户级线程实现的优点。用户级线程与内核级线程之间的关系可以有三种模型表示：<strong>一对一</strong>模型、<strong>多对一</strong>模型、<strong>多对多</strong>模型</li>
</ul>
<h3 id="管程的基本概念"><a class="anchor" href="#管程的基本概念">#</a> 管程的基本概念</h3>
<ul>
<li>
<p>管程是一种比信号量机制更先进的<strong>进程同步机制</strong></p>
</li>
<li>
<p>基本思想：把分散在各进程中的控制和管理临界资源的临界区<strong>集中</strong>起来统一管理</p>
</li>
<li>
<p>实质上是把临界区集中并封装成<strong>抽象数据类型</strong>，其中包括与临界资源相关、仅限管程内部访问的公共变量，供管程外的进程调用以访问这些公共变量的接口过程，并提供互斥机制确保进程互斥地使用管程</p>
</li>
<li>
<p>管程具有以下特点：</p>
<ul>
<li><strong>模块化</strong> —— 管程是一个基本程序单位，其中不仅有数据，还有对数据的操作；</li>
<li><strong>隐蔽性</strong> —— 管程内与临界资源相关的数据相当于是管程的私有成员，仅限管程内部访问，通过管程申请使用该资源的进程无法直接访问，只能调用管程提供的接口过程；</li>
<li><strong>互斥性</strong> —— 任一时刻只能有一个进程真正进入管程内部使用相应系统资源，其它进程必须等待，直至管程再次可用</li>
</ul>
</li>
<li>
<p>管程采用<strong>条件变量</strong>（condition variable）实现同步机制：</p>
<ul>
<li>让进入管程却因资源不足而阻塞的进程暂时放弃管程控制权（开放管程），进入该条件变量的等待队列</li>
<li>条件变量只能在管程中通过两个原语操作 —— <code>wait</code>  原语和 <code>signal</code>  原语</li>
<li>一个进程<strong>已进入管程但无法继续执行</strong>，便在相应的条件变量 x 上调用 <code>x.wait()</code> ，将自己阻塞并移入 x 的等待队列中，放弃管程控制权（开放管程），另一进程可以通过对同一个条件变量执行 <code>x.signal()</code>  来唤醒之前在 x 上等待的进程</li>
<li>条件变量仅起到维护等待队列的作用，不存在相关的值，也<strong>不能像信号量那样加减累计</strong><br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/42be1498945a7ccc8d90886b3e467f6f95efd33eb47bc3132f081e97f51b3180.png" alt="图 8"></li>
</ul>
</li>
<li>
<p>管程与进程的区别：</p>
<ul>
<li>管程把共享变量上的同步操作集中起来，而临界区却分散在每个进程中；</li>
<li>管程是为管理共享资源而建立的，进程主要是为实现系统并发性而引入的；</li>
<li>管程被进程调用，<strong>管程和调用它的进程不能并行工作</strong>，而进程之间能并行工作，并发性是其固有特性；</li>
<li>管程是语言或操作系统的组成部分，不必创建或撤销，而进程有生命周期</li>
</ul>
</li>
<li>
<p>阻塞进程被另一进程以 signal 原语唤醒时的管程互斥协调方法：</p>
<ul>
<li>执行 signal 的进程等待，直到被释放的进程退出管程或因等待另一个条件而阻塞</li>
<li>被释放进程等待，直到执行 signal 的进程退出管程或因等待另一个条件而阻塞</li>
</ul>
</li>
<li>
<p>Hoare 采用了第一种办法，Hansen 选择了两者的折衷，规定 signal 原语必须位于管程过程的最后一步，于是当一个进程调用管程过程时执行了 signal 原语，也就意味着该进程立即退出管程</p>
</li>
<li>
<p>Hoare 方法使用信号量和 P、V 操作来实现对管程中过程的互斥调用，从而实现对共享资源互斥使用。</p>
</li>
<li>
<p>Hoare 管程的基本思路为：</p>
<ul>
<li>管程中设一互斥信号量 <code>mutex</code>  (初值为 1)，用于进程互斥调用管程内部过程</li>
<li>设置信号量 <code>urgent</code> （初值为 0）和计数器 <code>urgent_count</code> （初值为 0）</li>
<li>设置信号量 <code>x</code> （初值为 0）用于阻塞等待资源的进程及相应的计数器 <code>x_count</code> （初值为 0）</li>
</ul>
</li>
<li>
<p>在管程的实现中，将上述 1、2 两条所引入的量封装在一个结构中，称为 <code>InterfaceModule</code> 。</p>
</li>
<li>
<p>Hoare 管程实现的主要代码：</p>
</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">InterfaceModule</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 进程调用管程过程前使用的互斥信号量</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    semaphore urgent <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 发出 signal 的进程挂起自己的信号量</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> urgent_count <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span><span class="token comment">// 在 urgent 上等待的进程数</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">}</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>InterfaceModule IM<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>semaphore x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> x_count<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token function">P</span><span class="token punctuation">(</span>IM<span class="token punctuation">.</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">void</span> <span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>IM<span class="token punctuation">.</span>urgent _count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 是否存在因执行 signal 而阻塞在 urgent 上的进程</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">V</span><span class="token punctuation">(</span>IM<span class="token punctuation">.</span>urgent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 有的话先唤醒一个阻塞在 urgent 上的进程</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">else</span> <span class="token function">V</span><span class="token punctuation">(</span>IM<span class="token punctuation">.</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 没有的话直接开放管程</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">void</span> <span class="token function">wait</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    x_count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>IM<span class="token punctuation">.</span> urgent_count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">V</span><span class="token punctuation">(</span>IM<span class="token punctuation">.</span>urgent<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">else</span> <span class="token function">V</span><span class="token punctuation">(</span>IM<span class="token punctuation">.</span>urgent<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    x_count<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x_count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    IM<span class="token punctuation">.</span>urgent_count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">V</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token function">P</span><span class="token punctuation">(</span>IM<span class="token punctuation">.</span>urgent<span class="token punctuation">)</span><span class="token punctuation">;</span>IM<span class="token punctuation">.</span>urgent_count<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">}</span></pre></td></tr></tbody></table></figure><h4 id="进程同步的几个经典问题用管程来解决"><a class="anchor" href="#进程同步的几个经典问题用管程来解决">#</a> 进程同步的几个经典问题，用管程来解决</h4>
<h5 id="管程解决生产者-消费者问题"><a class="anchor" href="#管程解决生产者-消费者问题">#</a> 管程解决生产者 - 消费者问题</h5>
<ul>
<li>采用 <code>Hoare</code>  管程实现，继承 <code>Monitor</code>  中原有的定义（如 <code>wait</code> 、 <code>signal</code>  等），自定义可供生产者、消费者进程调用的接口 <code>put</code>  和 <code>get</code>  过程。</li>
<li>由于管程本身具备互斥机制，所以代码中没有针对多个生产者、消费者竞争使用缓冲区的信号量及操作，直接使用管程中的 <code>enter</code>  和 <code>leave</code> 。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>Monitor p_c_mon<span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  item B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 缓冲区，长度 k</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  condition empty<span class="token punctuation">,</span> full<span class="token punctuation">;</span><span class="token comment">// 缓冲区空满对应的条件变量</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">int</span> in<span class="token punctuation">,</span> out<span class="token punctuation">,</span> count<span class="token punctuation">;</span> <span class="token comment">// 缓冲区存取位置，内容产品数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>item px<span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> count <span class="token operator">&gt;=</span> k <span class="token punctuation">)</span> empty<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 缓冲区已满，在 empty 上阻塞调用 put 的进程</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    B<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> px<span class="token punctuation">;</span> in <span class="token operator">=</span><span class="token punctuation">(</span>in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> k<span class="token punctuation">;</span>count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>full<span class="token punctuation">.</span>queue<span class="token punctuation">)</span> full<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span>item <span class="token operator">&amp;</span> gx<span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span> count <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span> full<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    gx <span class="token operator">=</span> B<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span> out <span class="token operator">=</span> <span class="token punctuation">(</span>out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> k<span class="token punctuation">;</span> count<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>empty<span class="token punctuation">.</span>queue<span class="token punctuation">)</span> empty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> in <span class="token operator">=</span> out <span class="token operator">=</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>………<span class="token punctuation">}</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>………<span class="token punctuation">}</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="19"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="20"></td><td><pre>process <span class="token function">producer_i</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        生产一个产品x</pre></td></tr><tr><td data-num="23"></td><td><pre>        p_c_mon<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        p_c_mon<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        p_c_mon<span class="token punctuation">.</span><span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="28"></td><td><pre>process <span class="token function">consumer_j</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    </pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        p_c_mon<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        p_c_mon<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        p_c_mon<span class="token punctuation">.</span><span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        消费 x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="36"></td><td><pre>coend</pre></td></tr></tbody></table></figure><h5 id="管程解决哲学家就餐问题的算法"><a class="anchor" href="#管程解决哲学家就餐问题的算法">#</a> 管程解决哲学家就餐问题的算法</h5>
<ul>
<li>采用 Hoare 管程实现，算法思想是将哲学家的状态分为思考、饥饿、吃面，并且仅当哲学家左右两边的筷子都可用才允许他拿筷子，否则一只筷子也不拿。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre>Monitor phil_mac_mon<span class="token punctuation">{</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">enum</span> <span class="token punctuation">{</span> thinking<span class="token punctuation">,</span> hungry<span class="token punctuation">,</span> eating <span class="token punctuation">}</span> state<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  semaphore self<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">int</span> self_count<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  InterfaceModule IM<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> thinking<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    self_count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">[</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">!=</span> eating<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>state<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> hungry<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>state<span class="token punctuation">[</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">!=</span> eating<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      state<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> eating<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">void</span> <span class="token function">pickup</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">enter</span><span class="token punctuation">(</span>IM<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> hungry<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> eating<span class="token punctuation">)</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">leave</span><span class="token punctuation">(</span>IM<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token keyword">void</span>  <span class="token function">putdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token function">enter</span><span class="token punctuation">(</span>IM<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> thinking<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token function">leave</span><span class="token punctuation">(</span>IM<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">}</span></pre></td></tr><tr><td data-num="31"></td><td><pre>cobegin</pre></td></tr><tr><td data-num="32"></td><td><pre>  process <span class="token function">philmac_i</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></pre></td></tr><tr><td data-num="34"></td><td><pre>      <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>      phil_mac_mon<span class="token punctuation">.</span><span class="token function">pickup</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>      <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>      phil_mac_mon<span class="token punctuation">.</span><span class="token function">putdown</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token punctuation">}</span></pre></td></tr><tr><td data-num="40"></td><td><pre>coend</pre></td></tr></tbody></table></figure><h2 id="内存管理"><a class="anchor" href="#内存管理">#</a> 内存管理</h2>
<h3 id="内存管理概述"><a class="anchor" href="#内存管理概述">#</a> 内存管理概述</h3>
<h4 id="计算机存储系统的组成"><a class="anchor" href="#计算机存储系统的组成">#</a> 计算机存储系统的组成</h4>
<ul>
<li>内存储器（Memory），是处理器能直接寻址的存储空间，由半导体器件制成，用来存放处理器执行时所需要的程序和数据，以及与硬盘等外部存储器交换的数据，程序和数据只有在内存中才能被处理器直接访问。</li>
<li>外存储器也叫辅助存储器，用来存放需要长期保存的数据，外存储器的管理属于文件系统的范畴。</li>
<li>内存储器分两部分：
<ul>
<li>一部分是系统区，用来存放操作系统以及一些标准子程序、例行程序等，这些是长驻内存的部分，系统区用户不能使用；</li>
<li>另一部分称为用户区，分配给用户使用，用来存放用户的程序和数据等。内存管理的主要工作就是对内存储器中的用户区进行管理。</li>
</ul>
</li>
</ul>
<h4 id="内存管理的功能"><a class="anchor" href="#内存管理的功能">#</a> 内存管理的功能</h4>
<ul>
<li><strong>内存的分配和回收</strong>：操作系统根据用户程序的请求，在<strong>内存中按照一定算法把找到一块空闲，将其分配给申请者；并负责把释放的内存空间收回</strong>，使之变为空闲区。</li>
<li><strong>实现地址转换</strong>：用户程序中使用逻辑地址，而 CPU 访问内存时则按物理地址进行，内存管理必须进行地址转换工作，把<strong>逻辑地址转换成物理内存中与之对应的物理地址</strong>，这种地址转换工作也称为<strong>地址重定位</strong>。</li>
<li><strong>内存的共享和保护</strong>：内存中不仅有系统程序，还有多个用户程序，为了防止各用户程序相互干扰和保护各用户区的信息不受破坏，系统必须负责隔离分配给各用户的内存区，<strong>保证各个用户程序或进程在各自规定的存储区域内操作</strong>，不破坏操作系统区的信息，并且互不干扰。</li>
<li><strong>内存扩充</strong>：内存管理允许通过虚拟存储技术 “扩充” 内存容量。在计算机软、硬件系统的支持下，可以把磁盘等辅助存储器作为内存的扩充部分使用，<strong>使用户程序在所需内存在比实际物理内存容量大的情况下，也能在内存中运行</strong>。</li>
</ul>
<h4 id="计算机存储系统的结构"><a class="anchor" href="#计算机存储系统的结构">#</a> 计算机存储系统的结构</h4>
<h5 id="处理器寄存器和高速缓存"><a class="anchor" href="#处理器寄存器和高速缓存">#</a> 处理器寄存器和高速缓存</h5>
<ul>
<li>处理器寄存器主要包括<strong>通用寄存器</strong>、<strong>指令寄存器</strong>、<strong>地址寄存器</strong>和<strong>数据缓冲寄存器</strong>等一系列寄存器，用于存储器中与控制流和数据流相关的信息。它容量小处，速度快，一般以字（word）为单位。一个计算机系统一般包括几十个甚至上百个寄存器。</li>
<li><strong>高速缓存</strong>（Cache）是为了解决处理器与内存之间速度不匹配而引入的。其<strong>存储容量比处理器寄存器</strong>大，访问速度比寄存器慢，但远比内存快。</li>
<li>当处理器要读取数据时，首先访问高速缓存，如果所要访问的数据已经在高速缓存中，则直接从高速缓存中读取信息；如果要访问的数据不在高速缓存中，那就需要从内存中读取信息。随着硬件技术的发展，现在已经将高速缓存封装在处理器芯片中，所以常将高速缓存与处理器寄存器归到一个层次。</li>
</ul>
<h5 id="内存储器"><a class="anchor" href="#内存储器">#</a> 内存储器</h5>
<ul>
<li>内存储器也称为内存，属于主机范畴。内存中存储处理器执行时所需要的代码和数据。<strong>内存的空间远大于高速缓存，但内存中的数据断电即消失</strong>，无法永久储存。一个计算机系统中所配备的内存容量是衡量计算机性能的一个重要的指标，计算机最大内存容量受到计算机系统结构的限制。</li>
</ul>
<h5 id="外存储器"><a class="anchor" href="#外存储器">#</a> 外存储器</h5>
<ul>
<li>外存储器是计算机系统中最大规模的存储器，用来存储各种数据和软件。<strong>外存储器容量巨大并能够永久存储信息，断电后数据不会丢失</strong>，外存储器的价格低但是访问速度慢。外存储器包括各种磁盘、磁带、光盘以及其他移动存储设备。磁盘中的硬盘是计算机系统中大量联机信息的保存者，硬盘常常作为内存的补充，用来实现虚拟存储系统。</li>
</ul>
<h4 id="地址的表示与地址转换"><a class="anchor" href="#地址的表示与地址转换">#</a> 地址的表示与地址转换 😎</h4>
<h5 id="物理地址空间"><a class="anchor" href="#物理地址空间">#</a> 物理地址空间</h5>
<ul>
<li>当程序运行时，它将被装入内存中的某段空间内，此时程序和数据的实际地址不可能同原来的逻辑地址一致，<strong>程序在物理内存中的实际存储单元称为物理地址，也叫绝对地址</strong>，物理地址的总体就构成了用户程序实际运行的物理地址空间。不同程序的物理地址空间绝对不能冲突。</li>
<li>在以下章节中，如无特别说明，<strong>地址编址和地址长度的单位都是字节（Byte）</strong>。</li>
</ul>
<h5 id="逻辑地址空间"><a class="anchor" href="#逻辑地址空间">#</a> 逻辑地址空间</h5>
<ul>
<li>高级语言编写的源程序通过编译或汇编后得到目标程序。<strong>目标程序使用的地址称为逻辑地址，也叫相对地址</strong>，一个用户作业的目标程序的逻辑地址集合称为该作业的<strong>逻辑地址空间</strong>。作业的逻辑地址空间可以是一维的，这时逻辑地址限制在从 0 开始顺序排列的地址空间内；也可以是二维的，这时整个用户作业被分为若干段，每段有不同的段号，<strong>段内地址从 0 开始</strong>。</li>
</ul>
<h5 id="地址转换"><a class="anchor" href="#地址转换">#</a> 地址转换</h5>
<ul>
<li><strong>只有把程序和数据的逻辑地址转换为物理地址，程序才能正确运行</strong>，该过程称为地址转换或地址重定位。地址转换有静态重定位和动态重定位两种方式。</li>
</ul>
<h6 id="静态重定位"><a class="anchor" href="#静态重定位">#</a> 静态重定位</h6>
<ul>
<li>这种方式是在用户作业装入内存时由装入程序 (装配程序) 实现从逻辑地址到物理地址的转换，<strong>地址转换在作业执行前一次完成</strong></li>
<li>静态重定位方式的优点是<strong>实现简单</strong>，从逻辑地址到物理地址变换<strong>不需要专门的硬件</strong>便能完成；<strong>缺点是必须为程序分配一段连续的存储空间</strong>，并且程序在<strong>执行过程中不能在内存中移动</strong>。</li>
</ul>
<h6 id="动态重定位"><a class="anchor" href="#动态重定位">#</a> 动态重定位</h6>
<ul>
<li>在程序执行过程中，CPU 在<strong>访问程序和数据之前</strong>才实现从逻辑地址到物理地址的转换，称为动态重定位。动态重定位必须借助于<strong>硬件地址转换机构</strong>来实现。硬件系统中设置了一个<strong>定位寄存器</strong>，当操作系统为某程序分配了一块内存区域后，装入程序直接把用户程序装入到所分配的区域中，然后把该内存区域的起始地址置入定位寄存器中。在程序执行过程中随着每条指令或数据的访问，需要进行地址转换时，只需将逻辑地址与定位寄存器中的值相加就可得到物理地址。这种地址转换方式是在程序执行过程中动态进行的，所以称动态重定位。</li>
<li>采用动态重定位时，由于装入内存的用户程序仍保持逻辑地址，所以可以<strong>实现程序在内存中的移动</strong>。在程序执行过程中，若把程序移动到另一块内存区域后，只要改变定位寄存器中的内容，该程序仍可正确执行。但采用静态定位时，程序在执行过程中是不能移动的。</li>
<li>动态重定位的优点是<strong>内存的使用更加灵活</strong>，<strong>容易实现内存的动态扩充和共享</strong>；缺点是实现过程中<strong>需要附加硬件支持</strong>，内存的管理也更加复杂。</li>
</ul>
<h4 id="覆盖与交换技术"><a class="anchor" href="#覆盖与交换技术">#</a> 覆盖与交换技术</h4>
<h5 id="覆盖技术"><a class="anchor" href="#覆盖技术">#</a> 覆盖技术</h5>
<ul>
<li>一个程序通常由若干个功能上独立的程序段组成，在运行时，并不是所有的程序段都同时进入内存执行。这样，我们就可以按照程序自身的逻辑结构，让不同时执行的程序段先后共享同一块内存区域，这就是<strong>覆盖技术</strong>。</li>
<li>覆盖技术先将程序必需的部分代码和数据调入内存，其余部分先放在外存中，当要访问的程序或数据不在内存时，由操作系统负责将其从外存中调入，这就解决了在较小的内存空间中运行较大程序的问题。</li>
<li>覆盖技术首先将大的用户程序划分为一个个相对独立的程序单位，将程序执行时不需要同时装入内存的程序单位组成一个个覆盖段，<strong>每个覆盖段的长度不能超过已有内存空间大小</strong>。各个覆盖段分先后顺序进入到所分配的内存空间中，后进入内存的覆盖段将先进入的段覆盖。</li>
<li>覆盖技术的<strong>缺点</strong>：
<ul>
<li>覆盖技术<strong>对用户不透明</strong>，用户在编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加了编程复杂度。</li>
<li>从外存装入覆盖文件，是以<strong>时间的延长</strong>来<strong>换取空间的节省</strong>。</li>
</ul>
</li>
</ul>
<h5 id="交换技术"><a class="anchor" href="#交换技术">#</a> 交换技术</h5>
<ul>
<li>为了释放部分内存空间，由操作系统根据需要，<strong>将某些暂时不运行的进程或程序段从内存移到外存的交换区中</strong>；<strong>当内存空间富余时再给被移出的进程或程序段重新分配内存</strong>，让其进入内存，这就是交换技术，又称为 “<strong>对换</strong>” 或 “<strong>滚进 / 滚出</strong> (roll-in/roll-out)。</li>
<li>交换技术能够<strong>提高系统的性能和多道度</strong>，从内存到外存的交换为换出，从外存到内存的交换为换入。通过不断的换入、换出，使得用户看来好像内存扩大了，从而实现了<strong>内存扩充</strong>的目的。</li>
<li>根据每次交换的单位不同，交换技术在实现中有种情况：
<ul>
<li>以整个进程为单位的交换：每次换入或换出的是一个进程，此策略多用于早期的分时系统中，以实现在小型机上的分时运行。</li>
<li>以进程的一部分为单位的交换：在现代操作系统中，借助于页式或段式内存管理，先将进程的内存空间划分为若干页面或段，然后以页面或段为基本单位进行交换。在操作系统中，常见的有页面置换（在页式存储管理中介绍）和段置换（在段式存储管理中介绍），这也是虚拟存储技术的基础。</li>
</ul>
</li>
</ul>
<h5 id="覆盖技术和交换技术的比较"><a class="anchor" href="#覆盖技术和交换技术的比较">#</a> 覆盖技术和交换技术的比较</h5>
<ul>
<li>与覆盖技术相比，交换技术<strong>不要求用户给出程序段之间的逻辑覆盖结构</strong>。</li>
<li>交换发生在<strong>进程或作业之间</strong>，而覆盖发生在<strong>同一进程或作业内</strong>。</li>
<li>覆盖<strong>只能覆盖那些与覆盖段无关</strong>的程序段。</li>
</ul>
<h3 id="分区内存管理"><a class="anchor" href="#分区内存管理">#</a> 分区内存管理</h3>
<h4 id="单一连续内存管理"><a class="anchor" href="#单一连续内存管理">#</a> 单一连续内存管理</h4>
<h5 id="单一连续内存管理基本思想"><a class="anchor" href="#单一连续内存管理基本思想">#</a> 单一连续内存管理基本思想</h5>
<ul>
<li>单一连续内存管理适用于<strong>单用户单任务操作系统</strong>，是最简单的内存管理方式。单一连续内存管理将内存空间分为<strong>系统区</strong>和<strong>用户区</strong>，系统区存放操作系统<strong>常驻内存的代码和数据</strong>，用户区全部分配给<strong>一个用户</strong>作业使用。在这种方式下，在任一时刻主存储器<strong>最多只有一道程序</strong>，各个作业只能按次序一个一个地装入主存储器运行。</li>
<li>通常，<strong>系统区</strong>位于内存底部的<strong>低地址</strong>部分，<strong>用户区</strong>位于内存顶部的<strong>高地址</strong>部分。</li>
</ul>
<h5 id="单一连续内存管理内存的分配与回收"><a class="anchor" href="#单一连续内存管理内存的分配与回收">#</a> 单一连续内存管理内存的分配与回收</h5>
<ul>
<li>由于内存中的用户区只能装入一个程序运行，所以该程序被装入内存时，就从内存用户区的基地址开始，<strong>连续存放</strong>。在运行过程中，该程序独占内存，直到退出，操作系统收回内存再分配给下一个程序使用</li>
</ul>
<h5 id="单一连续内存管理地址转换与内存保护"><a class="anchor" href="#单一连续内存管理地址转换与内存保护">#</a> 单一连续内存管理地址转换与内存保护</h5>
<ul>
<li>单一连续内存管理多采用<strong>静态重定位</strong>来进行地址转换。操作系统设置一个<strong>界限寄存器</strong>用来设置内存中系统区和用户区的地址界限；通过装入程序把目标模块装入到从界限地址开始的区域</li>
<li><strong>内存保护</strong>由<strong>装入程序</strong>来执行，装入时由装入程序检查物理地址是否超过界限地址，超过则可以装入；否则产生<strong>地址错误</strong>，不能装入。这样，用户的程序总是被装入到合法的用户区域内，而不会进入系统区。</li>
<li>采用静态重定位的优点是实现简单，无需硬件地址变换机构支持。缺点是作业只能分配到一个连续存储区域中，程序执行期间不能在内存中移动，无法实现程序共享。</li>
<li>单一连续内存管理也可以采用<strong>动态重定位</strong>方式来转换地址。系统设置一个<strong>定位寄存器</strong>，它既用来指出内存中的系统区和用户区的<strong>地址界限</strong>，又作为用户区的<strong>基地址</strong>；装入程序把程序装入到从界限地址开始的区域，但不同时进行地址转换；而是在程序<strong>执行过程</strong>中动态地将<strong>逻辑地址与定位寄存器中的值相加</strong>就可得到绝对地址</li>
</ul>
<h5 id="单一连续内存管理缺点"><a class="anchor" href="#单一连续内存管理缺点">#</a> 单一连续内存管理缺点</h5>
<ul>
<li>内存利用率低。用户程序所需空间一般均小于内存用户区空间，剩余的内存空间也不能被其它用户使用。</li>
<li>CPU 利用率低。当运行中的程序进行 I/O 操作时，CPU 会处于空闲等待状态。</li>
<li>外设利用率低。用户控制所有资源，有些资源在运行期间可能并不使用，也不能为其它用户使用。</li>
<li>不能进行内存扩充。当内存容量小于某一程序所需要的内存空间时，该程序便无法运行。</li>
</ul>
<h4 id="固定分区内存管理"><a class="anchor" href="#固定分区内存管理">#</a> 固定分区内存管理</h4>
<h5 id="固定分区内存管理基本思想"><a class="anchor" href="#固定分区内存管理基本思想">#</a> 固定分区内存管理基本思想</h5>
<ul>
<li>固定分区内存管理是预先把可分配的内存空间分割成若干个大小固定的连续区域，每个区域的大小可以相同，也可以不同，每个区域称为一个分区。每个分区可以装入且只能装入一个用户作业。这样，分区后的内存中就可以装入多道程序，从而支持多道程序并发设计。</li>
</ul>
<h5 id="固定分区内存管理分区的划分"><a class="anchor" href="#固定分区内存管理分区的划分">#</a> 固定分区内存管理分区的划分</h5>
<ul>
<li>
<p>分区大小相等</p>
<ul>
<li>所有分区的大小都相等，这种方式适合<strong>计算机工业控制系统</strong>。因为在计算机工业控制系统中，所有控制对象都具有相同的条件，完成相同的控制任务和控制指标。</li>
<li>该方式的缺点是：因为分区大小都一样，所以较小的进程装在分区里会浪费内存，而较大的进程则无法装入内存运行。</li>
</ul>
</li>
<li>
<p>分区大小不等</p>
<ul>
<li>把可分配的内存空间分割为大小不等的多个分区，大的分区可以分配给大的进程，小的分区可以分配给小的进程。与分区大小相等分配方式比较，分区大小不等的分配方式使得内存的分配更加灵活，内存的浪费更少。</li>
</ul>
</li>
</ul>
<h5 id="固定分区的内存分配"><a class="anchor" href="#固定分区的内存分配">#</a> 固定分区的内存分配</h5>
<ul>
<li>为了说明各分区的分配和使用情况，系统设置一张 “内存分配表”</li>
<li>内存分配表指出了各分区的<strong>起始地址</strong>和<strong>分区的长度</strong>，<strong>占用标志位</strong>指示该分区是否被使用，当占用的标志位为 “0” 时，表示该分区尚未被占用。</li>
<li>只<strong>能将那些占用标志为 “0” 的分区分配给用户作业使用</strong>，当某一分区被分配给一个作业后，就在占用标志栏<strong>填上占用该分区的作业名</strong></li>
</ul>
<h5 id="固定分区的地址转换与内存保护"><a class="anchor" href="#固定分区的地址转换与内存保护">#</a> 固定分区的地址转换与内存保护</h5>
<ul>
<li>静态重定位：装入程序在进行地址转换时检查其绝对地址是否在指定的分区中，若是，则可把程序装入，否则不能装入。固定分区方式的内存回收很简单，只需 ** 将内存分配表中相应分区的占用标志位置成 “0”** 即可。</li>
<li>动态重定位：计算机系统设置了一对地址寄存器 ——<strong> 上限 / 下限寄存器</strong>；当一个进程占有 CPU 执行时，操作系统就从内存分配表中取出相应的地址放进上限 / 下限寄存器；硬件的地址转换机构根据<strong>下限寄存器</strong>中保存的<strong>基地址 B1</strong> 与<strong>逻辑地址</strong>相加就得到<strong>绝对地址</strong>；硬件的地址转换机构同时把绝对地址和上限 / 下限寄存器中保存的地址进行比较，就可以实现<strong>存储保护</strong>。</li>
</ul>
<h5 id="固定分区分配的优点和缺点"><a class="anchor" href="#固定分区分配的优点和缺点">#</a> 固定分区分配的优点和缺点</h5>
<ul>
<li>固定分区的划分在<strong>操作系统初始化时完成</strong>。在系统启动时，系统管理员根据系统要运行的作业的需要来划分分区。当用户作业进入分区时，按照用户作业的大小从分区表中选择适当的空闲分区。</li>
<li>优点：
<ul>
<li>与单一连续分配方式比较，固定分区分配方式使得系统资源的利用率和吞吐量有一定的提高。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>内存空间的利用率不高</li>
<li>由于每个分区大小固定，这样就限制了可容纳的程序的大小。在装入一个程序时，若找不到足够大的分区，则无法装入。</li>
</ul>
</li>
</ul>
<h4 id="可变分区内存管理"><a class="anchor" href="#可变分区内存管理">#</a> 可变分区内存管理</h4>
<h5 id="可变分区内存管理基本思想"><a class="anchor" href="#可变分区内存管理基本思想">#</a> 可变分区内存管理基本思想</h5>
<ul>
<li><strong>事先不确定分区的大小，也不确定分区的数目</strong>。当某一用户作业申请内存时，检查内存中是否有一块能满足该作业的连续存储空间，若有就把这一空间划出一块区域给该用户使用，这种方式就称作可变分区内存管理。</li>
<li>分区的<strong>大小</strong>是按作业的<strong>实际需要量</strong>来定的，分区的个数也是<strong>随机</strong>的，所以可变分区内存分配可以克服固定分区方式中的内存的浪费现象。</li>
<li>可变分区克服了固定分区内存利用率低的问题，更适合<strong>多道程序环境</strong>。</li>
<li>操作系统也可以通过<strong>链表</strong>方式来管理空闲分区，将所有的空闲分区通过前向和后向指针串在一起组成双向空闲分区链</li>
<li>空闲区链表管理比空闲区表格管理较为<strong>复杂</strong>但其优点是<strong>链表自身不占用存储单元</strong>。为了方便检索空闲分区链，每个空闲分区的首部还设置有分区状态和分区大小标志，这样，系统查找分区链时可直接得知分区的大小和分配情况，省去了查询空闲分区表的时间。</li>
<li>不论是空闲区链表管理还是空闲区表格管理，链和表中的空闲区都可按一定规则排列，例如，按空闲区从大到小排列或从小到大排列，以方便空闲区的查找和回收。</li>
</ul>
<h5 id="可变分区的内存分配算法"><a class="anchor" href="#可变分区的内存分配算法">#</a> 可变分区的内存分配算法</h5>
<h6 id="最先适应分配算法"><a class="anchor" href="#最先适应分配算法">#</a> 最先适应分配算法</h6>
<ul>
<li>每次分配时，总是<strong>从头顺序查找</strong>未分配区表或空闲区链表，将找到的<strong>第一个能满足长度要求</strong>的空闲区分配给用户作业使用。从该空闲分区中分割一部分给作业，另一部分仍作为空闲分区；如果空闲分区全部查找完也不能满足该作业要求，则系统不能为该作业分配内存。</li>
<li><strong>首先利用内存中的低地址空闲分区</strong>，保留了大的高地址空闲分区，以便能容纳大的用户作业。</li>
<li>缺点：每次都是从未分配分区表或空闲区链表的开始查找空闲分区，低地址段的空闲分区被不断分割，形成了许多小的、难以利用的空闲分区，称为 “<strong>碎片</strong>”；同时每次都从开始查找，<strong>花费时间较长</strong>。</li>
</ul>
<h6 id="循环首次适应分配算法"><a class="anchor" href="#循环首次适应分配算法">#</a> 循环首次适应分配算法</h6>
<ul>
<li><strong>循环首次适应法</strong>是对最先适应法的改进。为作业分配内存时，系统不是从空闲分区表的开始处开始查找，而是从<strong>上次为作业分配分区后的位置</strong>开始查找，找到第一个满足作业大小的空闲分区，分配并分割该空闲分区。</li>
<li>该分区分配算法克服了首次适应算法的缺点，使得空闲分区的分布更加均匀，查找空闲分区所需要的时间更短。但是，小分区或 “<strong>碎片</strong>” 问题仍然不能解决。</li>
</ul>
<h6 id="最优适应分配算法"><a class="anchor" href="#最优适应分配算法">#</a> 最优适应分配算法</h6>
<ul>
<li>从空闲区中挑选一个能满足作业要求的<strong>最小分区</strong>，这样可以避免分割一个更大的区域，使大作业比较容易装入。</li>
<li>可把空闲区按长度<strong>递增排列</strong>，查找时总是从<strong>最小的一个区</strong>开始，直到找到一个满足要求的区为止。</li>
<li>收回一个分区时也必须对空闲区链<strong>重新排列</strong>。</li>
<li>最优适应分配算法找出的分区一般都是无法正好满足作业的内存要求，分割后剩下的空闲区很小，无法再次使用，成为 “<strong>碎片</strong>”。另外，这些小的空闲区占据了空闲区表的开始部分，<strong>增加了查找空闲区表或空闲区链的时间开销</strong>。</li>
</ul>
<h6 id="最坏适应分配算法"><a class="anchor" href="#最坏适应分配算法">#</a> 最坏适应分配算法</h6>
<ul>
<li>从空闲区中挑选一个<strong>最大的区</strong>给作业使用，这样可使分割后剩下的空闲区仍然比较大，仍然能满足以后的作业装入要求，也<strong>减少了内存中 “碎片” 的大小和个数</strong>。</li>
<li>可把空闲区按长度以<strong>递减顺序</strong>排列，查找时只要看第一个分区能否满足作业要求，若能满足，则分配给该作业使用。</li>
<li>最坏适应分配算法的查找效率很高，<strong>对中、小作业有利</strong>。</li>
<li>最坏适应分配算法缺点：随着系统的运行，大空闲区会不断减少，这样，<strong>大的作业可能会无法装入内存</strong>。</li>
</ul>
<h6 id="快速适应算法"><a class="anchor" href="#快速适应算法">#</a> 快速适应算法</h6>
<ul>
<li>把不同长度的空闲区归类，为每种长度的空闲区设立单独的<strong>空闲区链表</strong>。这样，系统中存在多个空闲分区链。</li>
<li>为作业分配内存时，根据作业大小查找空闲分区表，找到能够容纳它的<strong>最小的空闲分区链表的起始指针</strong>，然后再从相应的空闲分区链中取第一个空闲分区分配给该作业即可。</li>
<li>优点是查找空闲分区<strong>迅速</strong>，找到的空闲分区是能容纳它的最小空闲区，这样能够保留大的空闲分区。</li>
<li>缺点是<strong>回收分区较困难</strong>，<strong>算法复杂</strong>，<strong>系统开销大</strong>。</li>
</ul>
<h6 id="对比分析"><a class="anchor" href="#对比分析">#</a> 对比分析</h6>
<ul>
<li>从搜索空闲区速度及内存利用率来看，每种算法各有其优劣势。如果空闲区按从小到大排列，则最先适应分配算法等于最优适应分配算法。反之，如果空闲区按从大到小排列，则最先适用分配算法等于最坏适应分配算法。空闲区按从小到大排列时，最先适应分配算法能尽可能使用低地址区，从而，在高地址空间有较多较大的空闲区来容纳大的作业。循环首次适应分配算法会使存储器空间得到均衡使用。最优适应分配算法的内存利用率最好，因为，它把刚好或最接近申请要求的空闲区分给作业；但是它可能会导致空闲区分割下来的部分很小。</li>
</ul>
<h5 id="可变分区的地址转换与内存保护"><a class="anchor" href="#可变分区的地址转换与内存保护">#</a> 可变分区的地址转换与内存保护</h5>
<ul>
<li>可变分区内存管理是采用<strong>动态重定位</strong>方式来装入作业的，其地址转换由<strong>硬件机构</strong>完成。硬件设置了两个专门的寄存器：基址寄存器和限长寄存器。</li>
<li><strong>基址寄存器</strong>存放分配给作业使用的分区的<strong>起始地址</strong></li>
<li><strong>限长寄存器</strong>存放该分区的存储<strong>空间的长度</strong>。</li>
<li>当用户作业占有 CPU 运行时，操作系统把分配给该作业的分区的起始地址和长度送入基址寄存器和限长寄存器，启动作业执行时由<strong>硬件</strong>根据基址寄存器进行地址转换得到绝对地址</li>
<li>当逻辑地址<strong>小于限长值</strong>时，则由<strong>逻辑地址加基址寄存器</strong>的值就可得到绝对地址；当逻辑地址<strong>大于限长值</strong>时，就表示作业欲访问的内存地址<strong>超出了所分得的内存区域</strong>，<strong>禁止访问</strong>该地址，起到了存储保护的目的。</li>
<li>在多道程序系统中，只需要<strong>一对基址 / 限长寄存器</strong>就足够了。因为当作业在执行过程中出现等待时，操作系统把基址 / 限长寄存器的内容随同该作业的其它信息，如 PSW，通用寄存器的内容等一起保存起来。当作业 - 被选中执行时，则把选中作业的基址 / 限长值再送入基址 / 限长寄存器。</li>
<li>世界上最早的巨型机 CDC6600 便采用这一方案</li>
<li>系统运行一段时间后，内存被多次分配和回收，会产生许多不连续的空闲空间。有可能出现这样的现象：内存中每一块空闲空间都不能满足某一作业的内存请求，而所有空闲空间的总和却能满足该作业。这时可采用<strong>紧凑技术</strong>把内存中的作业改变存放区域，使分散的空闲区能够汇聚成一个大的空闲区，从而有利于大作业的装入</li>
<li>紧凑技术可以汇聚内存中的空闲区，但也<strong>增加了系统的开销</strong>，而且不是任何时候都能对一道程序进行移动的。</li>
</ul>
<h3 id="页式内存管理"><a class="anchor" href="#页式内存管理">#</a> 页式内存管理 😎</h3>
<h4 id="页式内存管理基本思想"><a class="anchor" href="#页式内存管理基本思想">#</a> 页式内存管理基本思想</h4>
<ul>
<li><strong>页</strong>：将用户进程的<strong>逻辑地址空间</strong>划分为大小相等的区，每一个区称为一页或一个页面，并对各页从 0 开始编号，如第 0 页、第 1 页等。</li>
<li><strong>物理块</strong>：将<strong>物理内存</strong>也划分成与页大小相等的区，每一个区称为一个物理块 (block)，或称为块、页框，也同样对它们加以编号，如 0 号块、1 号块等。</li>
<li>物理块的尺寸大小通常会取 2 的幂次。物理块的大小由计算机硬件决定，<strong>页的大小由物理块的大小决定</strong>。如 Intel 80386 系列处理器系统和 Motorola 68030 处理器系统的块的大小为 4096B，IBM AS/400 的块的大小为 512B</li>
<li>内存分配的<strong>基本单位</strong>是页，当装入一个用户程序时，按页为单位，每一页装入一个物理块中，一个用户进程装入到内存中时各个物理块之间不需要连续。</li>
<li>进程的<strong>最后一页经常装不满一块</strong>，所以会在最后一块内形成不可利用的碎片，称之为 “<strong>页内碎片</strong>”。而其他页在装入内存时，都能填满所在的物理块。</li>
<li>逻辑地址形式：进程的<strong>逻辑地址</strong>可以用<strong>页号</strong>和<strong>页内偏移</strong>表示，页的大小与物理块的大小相等。</li>
<li>如果进程的<strong>逻辑地址</strong>是 A，<strong>页面大小</strong>是 L，则页号 P 和页内偏移 d 为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>I</mi><mi>N</mi><mi>T</mi><mo stretchy="false">[</mo><mi>A</mi><mi mathvariant="normal">/</mi><mi>L</mi><mo stretchy="false">]</mo><mtext>&nbsp;&nbsp;&nbsp;</mtext><mi>d</mi><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">P=INT[A/L]\ \ \ d = [A] \% L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">NT</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mord">/</span><span class="mord mathnormal">L</span><span class="mclose">]</span><span class="mspace">&nbsp;</span><span class="mspace">&nbsp;</span><span class="mspace">&nbsp;</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span><span class="mord">%</span><span class="mord mathnormal">L</span></span></span></span></li>
</ul>
<h4 id="页式存储管理的内存的分配与回收"><a class="anchor" href="#页式存储管理的内存的分配与回收">#</a> 页式存储管理的内存的分配与回收</h4>
<ul>
<li>页式存储管理在进行内存分配时，以物理块为单位进行分配，一个作业有多少页，在装入内存时就必须给它分配多少个物理块。但是，和分区式内存管理不同的是分配给作业的物理块可以是<strong>不连续</strong>的。</li>
<li>在进行内存分配时，首先，操作系统为进入内存的每个用户作业建立一张<strong>页表</strong>，页表用来指出逻辑地址中的页号与内存中物理块号的对应关系。</li>
<li>同时，在页式存储管理系统中还存在一张<strong>作业表</strong>，作业表中的每个登记项登记了每个作业的<strong>页表始址和长度</strong></li>
<li>页表的表项中除了有页号和块号外，还有<strong>存取控制字段</strong>，用于实现<strong>对内存物理块的保护</strong>。页表的长度由<strong>用户进程的长度</strong>决定，每个在内存中的用户进程都会建立一张页表。如果进程不处于运行状态，页表的起始地址和长度存放在进程的 PCB 中。</li>
<li>只有某一进程被调度运行时，系统才会从运行进程的 PCB 中将页表起始地址和长度装入页表寄存器。所以，<strong>一个处理器只需要一个页表寄存器</strong>。</li>
</ul>
<h4 id="页式存储管理的地址转换"><a class="anchor" href="#页式存储管理的地址转换">#</a> 页式存储管理的地址转换 😎</h4>
<ul>
<li>在页式存储管理中，进程的逻辑地址到物理地址的转换需要硬件来完成，该硬件为<strong>地址转换机构</strong><br>
当处理器要访问某逻辑地址时，地址转换机构自动从逻辑地址的<strong>低地址部分得到页内偏移</strong>，<strong>从高地址部分得到页号</strong>。</li>
<li>将<strong>页号</strong>与页表寄存器中的<strong>页表长度</strong>比较，如果页号大于或等于页表长度，表示该页在页表中没有相应项，本次所访问的地址已经超越进程的地址空间，则产生<strong>地址越界中断</strong>；否则，从页表寄存器得到页表在内存中的<strong>起始地址</strong>。用<strong>页号</strong>作为索引查找页表，得到<strong>页表项</strong>，从而可以查到该页在内存中的<strong>物理块号</strong>。</li>
<li>最后，将<strong>页内偏移</strong>装入物理地址寄存器的<strong>低位字段</strong>中，将<strong>物理块号</strong>装入物理地址寄存器的<strong>高位字段</strong>中，此时物理地址寄存器中的内容就是<strong>物理地址</strong><br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/5a6086c2539e80879eb65e7ada05df01dfa3eab25833bf5e9e4dedb12af808a1.png" alt="页式存储管理的地址转换"></li>
</ul>
<h4 id="快表"><a class="anchor" href="#快表">#</a> 快表 😎</h4>
<ul>
<li>由地址转换过程可见，处理器每运行一条指令总是<strong>先根据指令的逻辑地址</strong>，通过<strong>访问内存中的页表</strong>才能得到<strong>物理地址</strong>，根据物理地址再去<strong>访问内存</strong>才能得到需要的指令，即处理器需要<strong>两次</strong>访问内存。同样，处理器要<strong>访问</strong>一个数据也需要<strong>两次</strong>访问内存。</li>
<li>为了提高程序的运行速度，可以将最近访问过的页的页表项信息存放在<strong>高速缓存</strong>中，高速缓存也称为 “联想存储器”，其中的<strong>页表</strong>称为 “<strong>快表</strong>”。</li>
<li>计算机系统中通常都设置一个专用的高速缓冲存储器，用来存放页表的一部分，称为<strong>相联存储器</strong>（associative memory），存放在相联存储器中的页表称快表。</li>
<li>相联存储器的访问速度比内存快，但造价高，故一般都是小容量的，例如 8~16 个单元。高速缓冲存储器由半导体实现，其工作周期与 CPU 的工作周期接近，所以访问快表的速度远快于访问内存中页表的速度。</li>
<li>借助于快表，<strong>物理地址</strong>形成的过程是：
<ul>
<li>按逻辑地址中的页号查快表，若该页已登记在快表中，则由<strong>块号</strong>和<strong>块内偏移</strong>形成<strong>绝对地址</strong>；</li>
<li>若快表中查不到页号，则只能再查内存中的<strong>页表</strong>来形成绝对地址，同时<strong>将该页登记到快表中</strong>。</li>
<li>当快表填满后，又要在快表中登记新页时，则需在快表中按<strong>一定策略淘汰一个旧的登记项</strong>，最简单的策略是 “先进先出”，即总是淘汰最先登记的那一页。</li>
</ul>
</li>
<li>多道程序中，当某道程序让出处理器时，应<strong>同时让出相联存储器</strong>。由于快表是动态变化的，所以让出相联存储器时应把快表保护好以便再执行时使用。当一道程序占用处理器时，除设置页表寄存器外还应将它的<strong>快表送入相联存储器</strong>中。</li>
</ul>
<h4 id="页的共享和保护"><a class="anchor" href="#页的共享和保护">#</a> 页的共享和保护</h4>
<ul>
<li>页式存储管理有利于<strong>实现多个作业共享程序和数据</strong>。在多道程序系统中，编译程序、编辑程序、解释程序、公共子程序、公用数据等都是可共享的，这些共享的信息在内存中只要保留一个副本。</li>
<li>在实现共享时，必须<strong>区分数据的共享和程序的共享</strong>。</li>
<li>实现数据共享时，可<strong>允许不同的作业对共享的数据页使用不同的页号</strong>，只要让各自页表中的有关表目指向共享的数据物理块。</li>
<li>实现程序共享时，由于页式存储的逻辑地址空间是连续的，所以<strong>程序运行前它们的页号应该是确定</strong>的。</li>
<li>实现信息共享必须解决信息的保护问题。常用的办法是在页表中增加一些<strong>标志位</strong>，用来指出该页的信息是：读 / 写；只读；只可执行；不可访问等，在指令执行时进行核对。</li>
</ul>
<h4 id="多级页表"><a class="anchor" href="#多级页表">#</a> 多级页表</h4>
<ul>
<li>
<p>为了快速查找页表页在内存中的物理块号，为这些页表页再设计一个地址索引表，即<strong>页目录表</strong>。页目录表的表项中包含每个页表页所在的内存物理块号和相关信息。</p>
</li>
<li>
<p>页表页中的每个表项记录了<strong>每个页的页号和对应的物理块号</strong><br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/35f0d231b59cf217ee60cf44f512bdc3e52359be1077bfc6331dbb73d3372825.png" alt="图 10"></p>
</li>
<li>
<p>二级页表的逻辑地址被划分为三部分：<strong>页目录</strong>、<strong>页表页</strong>、<strong>页内偏移</strong></p>
</li>
<li>
<p>地址转换过程：</p>
<ul>
<li>首先由<strong>页目录表寄存器</strong>提供当前运行进程的页目录表（一级页表）在内存中的<strong>起始地址</strong>；</li>
<li>由页目录表（一级页表）在内存中的<strong>起始地址</strong>加上<strong>页目录号</strong>（即需要查找的页表某页在页目录中的编号）, 得到页表某页的<strong>物理块号</strong>；</li>
<li>通过页表某页的<strong>物理块号</strong>得到<strong>该页表页</strong>（二级页表中的一页），由<strong>页表页号</strong>（某页在页表页中的编号）查询该页表页（二级页表中的一页）项，得到对应的<strong>物理块号</strong>；</li>
<li>最后将该物理块号加上页内偏移，最终得到物理地址<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/4b8d8ab2e93259f4bc30b029554d59743cdc3a3c37eb61df2072db6cae69610a.png" alt="图 11"></li>
</ul>
</li>
<li>
<p>二级页表地址变换获取内存信息需要<strong>三次</strong>访问内存：第一次访问的是<strong>页目录表</strong>，第二次访问的是<strong>页表页</strong>，第三次访问通过<strong>物理地址获取内存信息</strong>。</p>
</li>
</ul>
<h3 id="段式存储管理"><a class="anchor" href="#段式存储管理">#</a> 段式存储管理</h3>
<h4 id="段式存储管理的基本原理"><a class="anchor" href="#段式存储管理的基本原理">#</a> 段式存储管理的基本原理</h4>
<ul>
<li>事实上，一个程序往往由一个程序段、若干子程序数组段和工作区段所组成，每个段都从 “0” 开始编址，<strong>段内地址是连续</strong>的。因此，可以按照程序的逻辑段结构，将一个程序按段为单位来分配内存，一段占用一块连续的内存地址空间，段与段之间不需要连续。</li>
<li>分段式存储管理是以段为单位进行内存分配，逻辑地址空间是一个<strong>二维空间</strong>，分为<strong>段号</strong>和<strong>段内偏移</strong>两部分</li>
<li>页式存储管理中，<strong>逻辑地址分页用户不可见</strong>，连续的逻辑地址空间根据<strong>内存物理块</strong>的大小自动分页。</li>
<li>段式存储管理中，由用户来决定逻辑地址如何分段。用户在编程时，每个段的最大长度受到<strong>地址结构</strong>的限制，每个程序中允许的<strong>最多段数</strong>也受限制。</li>
<li>分段存储管理中操作系统为每个作业创建一张段表，每个段在段表中占有一项。<strong>段表</strong>中有<strong>段号</strong>、<strong>段长</strong>、段在内存的<strong>起始地址</strong>和<strong>存取控制字段</strong>等信息。</li>
<li>段式存储管理系统还包括一张作业表，每个作业在作业表中有一个<strong>登记项</strong>。</li>
<li>在段式存储管理中，对内存的分配类似于<strong>可变分区内存分配方式</strong>，因此其内存分配算法可以参照可变分区内存分配算法来设计</li>
</ul>
<h4 id="段式存储管理的地址转换和内存保护"><a class="anchor" href="#段式存储管理的地址转换和内存保护">#</a> 段式存储管理的地址转换和内存保护</h4>
<ul>
<li>
<p>段地址转换借助于<strong>段表</strong>完成。<strong>段表寄存器</strong>用来存放当前占用处理器的作业的<strong>段表始址</strong>和<strong>长度</strong>，查询段表得到每段在内存的起始地址，将<strong>段的起始地址加上段内偏移</strong>则得到<strong>物理地址</strong><br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/9e30e2909e4ec1a4df947098afe8474474645679e444e6e3b5c06be2576e6564.png" alt="图 12"></p>
</li>
<li>
<p>段地址转换过程如下：</p>
<ul>
<li>将 CPU 给出的逻辑地址由<strong>段号</strong>和<strong>段内地址</strong>（即段内偏移）构成；</li>
<li>查询<strong>段表寄存器</strong>得到段表在内存的<strong>起始地址</strong>；</li>
<li>将段号带入<strong>查询段表</strong>，得到该段在内存的<strong>起始地址</strong>和<strong>段长</strong>；</li>
<li>将段内地址与段长比较，如果段内地址大于段长，则发出<strong>越界中断</strong>；否则合法。段在内存的起<strong>始地址与段内地址相加</strong>，就为该逻辑地址对应的内存<strong>物理地址</strong>。</li>
</ul>
</li>
<li>
<p>利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号超过段表长则产生越界中断，再利用段表项中的段长与逻辑地址中的段内偏移比较，检查是否产生越界中断。</p>
</li>
<li>
<p>对段的越权保护可通过在段表中增加相应的存取控制权限字段来实现。权限字段显示对段的读、写是否允许，用它来检查对该段内地址的访问操作是否合法。只有当每次操作都在合法的权限范围内，才能正常完成访问操作，否则出错。</p>
</li>
</ul>
<h4 id="段的共享"><a class="anchor" href="#段的共享">#</a> 段的共享</h4>
<ul>
<li>在段式存储管理中，所谓段的共享，事实上就是<strong>共享分区</strong>，为此计算机系统要提供<strong>多对基址 / 限长寄存器</strong>。这样，几个作业所共享的例行程序就可放在一个公共的分区中，只要让各道的共享部分有相同的<strong>基址 / 限长值</strong>。</li>
<li>由于段号仅仅用于段之间的相互访问，段内程序的执行和访问<strong>只使用段内地址</strong>，因此不会出现页共享时出现的问题，对数据段和代码段的共享都不要求段号相同。当然<strong>对共享区的信息必须进行保护</strong>，如规定只能读出不能写入，欲想往该区域写入信息时将遭到拒绝并产生中断</li>
</ul>
<h4 id="分段和分页的比较"><a class="anchor" href="#分段和分页的比较">#</a> 分段和分页的比较</h4>
<ul>
<li>段是信息的<strong>逻辑单位</strong>，由源程序的逻辑结构所决定，<strong>用户可见</strong>，段长可根据用户需要来规定，段起始地址可以从任何地址开始。在分段方式中，源程序 (段号，段内偏移) 经连结装配后仍保持<strong>二维结构</strong>。</li>
<li>页是信息的<strong>物理单位</strong>，与源程序的逻辑结构无关，<strong>用户不可见</strong>，页长由系统确定，页面只能以页大小的整倍数地址开始。在分页方式中，源程序 (页号，页内偏移) 经连结装配后变成了<strong>一维结构</strong>。</li>
</ul>
<h4 id="段页式存储管理"><a class="anchor" href="#段页式存储管理">#</a> 段页式存储管理</h4>
<ul>
<li>页式存储基于存储器的物理结构，存储利用率高，便于管理，但难以实现存储共享、保护和动态扩充；段式存储基于应用程序的结构，有利于模块化程序设计，便于段的扩充、动态链接、共享和保护，但往往会形成段之间的碎片，浪费存储空间。</li>
<li>可以把两者结合起来，在分段式存储管理的基础上实现分页式存储管理，这就是段页式存储管理。</li>
<li>段页式存储管理的基本原理：
<ul>
<li>程序根据自身的逻辑结构划分成若干段，这是段页式存储管理的<strong>段式特征</strong>。</li>
<li>内存的物理地址空间划分成大小相等的物理块，这是段页式存储管理的<strong>页式特征</strong>。</li>
<li>将每一段的<strong>线性地址空间划分成与物理块大小相等的页面</strong>，于是形成了段页式存储管理。</li>
<li>逻辑地址分 3 个部分：<strong>段号</strong>、<strong>段内页号</strong>和<strong>页内位移</strong>，对于用户来说，虚拟地址应该由段号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 和段内位移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>d</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">d'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 组成，用户看不到如何分页。而是由操作系统自动把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>d</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">d'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 解释成两部分：段内页号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 和页内位移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>，也就是说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>d</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>p</mi><mo>×</mo><mtext>块长</mtext><mo>+</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">d'=p×块长+d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">块长</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>。</li>
<li>段页式存储管理的数据结构包括段表和页表，段表中包括<strong>段号</strong>、该段页表的<strong>起始地址</strong>、<strong>页表长度</strong>等信息，页表中包括<strong>页号</strong>、对应的<strong>物理块号</strong>等信息<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/e1bee3bf25561ac662000e9c596576d4f141dc2e0028f9e1430f5c587125f2f5.png" alt="图 13"></li>
<li>段页式存储管理的<strong>动态地址转换机构</strong>由段表、页表和快表构成，操作系统把正在运行的作业的<strong>段表起始地址</strong>装入<strong>段表寄存器</strong>中，操作系统从<strong>逻辑地址</strong>中取出<strong>段号</strong>和<strong>段内页号</strong>，用<strong>段号</strong>作为<strong>索引查询快表中</strong>的段表，如果从快表得到<strong>页表起始地址</strong>和<strong>页表长度</strong>，再查询快表中的页表，从而得到所在页面对应的<strong>内存物理块号</strong>，将该<strong>物理块号与页内位移拼接</strong>，即为所需要的<strong>物理地址</strong>。如果不能从快表得到段和页的信息，则需要用<strong>段号作为索引查询内存中的段表</strong>，得到<strong>页表长度</strong>和<strong>页表的起始地址</strong>。再以<strong>页号作为索引查询页表</strong>，得到该页所对应的<strong>物理块号</strong>，同时将段表中的<strong>相应段信息</strong>和<strong>页表中的相应信息</strong>写入<strong>快表</strong>，并将<strong>物理块号与页内位移拼接</strong>，就可以得到<strong>物理地址</strong>。<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/f0c3e1f3b92883b2f53ceffeb72f2f472536a2c3d4033458504fc59f5cda2b35.png" alt="图 14"></li>
</ul>
</li>
</ul>
<h3 id="虚拟存储技术"><a class="anchor" href="#虚拟存储技术">#</a> 虚拟存储技术</h3>
<h4 id="程序局部性原理"><a class="anchor" href="#程序局部性原理">#</a> 程序局部性原理</h4>
<ul>
<li>即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。局部性原理表现在时间局部性和空间局部性两个方面。</li>
<li><strong>时间局部性</strong>是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。例如，很多程序中存在大量的循环、临时变量和子程序调用等。</li>
<li><strong>空间局部性</strong>是指一旦程序访问了某个存储单元，则不久之后其附近的存储单元也将被访问。例如程序中对数组、链表或堆栈进行操作。</li>
<li>程序的局部性原理说明：<strong>程序的一次性装入内存与全部驻留内存都是不必要的</strong>。</li>
</ul>
<h4 id="虚拟存储技术的基本思想"><a class="anchor" href="#虚拟存储技术的基本思想">#</a> 虚拟存储技术的基本思想 😎</h4>
<ul>
<li>
<p>虚拟存储技术的思想：将外存作为内存的扩充，作业运行不需要将作业的全部信息放入内存，将暂时不运行的作业信息放在外存，通过内存与外存之间的对换，使系统逐步将作业信息放入内存，最终达到能够运行整个作业，从逻辑上扩充内存的目的。</p>
</li>
<li>
<p>虚拟存储器定义：虚拟存储器是指具有<strong>请求调入</strong>功能和<strong>置换</strong>功能，能够从逻辑上对内存空间进行扩展，允许用户的<strong>逻辑地址空间大于物理内存地址空间</strong>的存储器系统<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/b14273ddb7f0364b083f04e9c54b6b4ddb261a5bfb64085848721ffef332c0f0.png" alt="图 15"></p>
</li>
<li>
<p>虚拟存储器的容量由计算机的<strong>地址结构</strong>和<strong>辅助存储器</strong>的容量决定，与实际的主存储器的容量无关。</p>
</li>
<li>
<p>虚拟存储技术的实现基础是<strong>内存的分页或分段管理</strong>，采用的是进程的分页或分段在内存与外存之间对换</p>
</li>
<li>
<p>虚拟存储技术允许进程的逻辑地址空间比物理内存空间大，即<strong>小空间能够运行大程序</strong>，打破了程序运行受内存空间的约束，使操作系统不但能够接纳更大的作业，而且还能接纳更多的作业，提高了系统的<strong>多道度</strong>和<strong>性能</strong>。</p>
</li>
</ul>
<h3 id="请求分页虚拟存储管理"><a class="anchor" href="#请求分页虚拟存储管理">#</a> 请求分页虚拟存储管理</h3>
<h4 id="请求分页虚拟存储管理的基本原理"><a class="anchor" href="#请求分页虚拟存储管理的基本原理">#</a> 请求分页虚拟存储管理的基本原理</h4>
<ul>
<li>请求分页虚拟存储管理是在页式存储管理的基础上增加了<strong>请求调页</strong>和<strong>页面置换</strong>功能，其基本原理如下：
<ul>
<li>首先，物理的内存空间被划分为<strong>等长的物理块</strong>，并对块编号。同时，用户程序也进行分页，这些与页式存储管理相同。</li>
<li>在用户程序开始执行前，不将该程序的所有页都一次性装入内存，而是先放在外存。当程序被调度投入运行时，系统先将少数页装入内存，随着程序运行，如果所访问的页在内存中，则对其管理与分页存储管理情况相同。</li>
<li>若发现所要访问的数据或指令不在内存中，就会产生<strong>缺页中断</strong>，到外存寻找包含所需数据或指令的页，并将其装入到内存的空闲块中。</li>
<li>在装入一页的过程中，若发现内存无空闲块或分配给该进程的物理块已用完，则需要通过页面置换功能从已在内存的页中挑选一个将其淘汰，释放所占用的物理块后将新的页面装入该块，进程继续运行。</li>
<li>被淘汰的页面如果刚才被修改过，则还需要将其<strong>回写到外存</strong>，以保留其最新内容。</li>
</ul>
</li>
</ul>
<h4 id="请求分页虚拟存储管理的硬件支持"><a class="anchor" href="#请求分页虚拟存储管理的硬件支持">#</a> 请求分页虚拟存储管理的硬件支持</h4>
<h5 id="请求分页的页表机制"><a class="anchor" href="#请求分页的页表机制">#</a> 请求分页的页表机制</h5>
<ul>
<li>在虚拟存储管理中，页表除了要完成从逻辑地址到物理地址的转换外，还需要提供页面置换的相关信息。因此，页表中除了有<strong>页号</strong>和<strong>物理块号</strong>等信息外，还增加了页的<strong>状态位</strong>、<strong>外存地址</strong>、<strong>修改位</strong>、<strong>访问字段</strong>等信息</li>
<li><strong>状态位</strong>：用于标志一页是否已装入内存。如果该页已在内存，则该页所对应的状态位置 “1”；否则置 “0”。</li>
<li><strong>外存地址</strong>：页在外存中的地址。当需要将某页调入内存时，需要查询页表中的外存地址项得到该页在外存的地址，在外存找到该页。</li>
<li><strong>修改位</strong>：页在内存中是否被修改过的标志，用来确定如果该页被换出内存时，是否需要再回写入外存。如果该页在内存里没有被修改过，那么该页中的内容和在外存中的内容是一致的，则被换出内存时不需要再写入外存，节约了写入外存的时间。如果该页在内存中已经被修改过了，被换出内存时需要再写入外存。</li>
<li><strong>访问字段</strong>：标志页在内存时是否被访问过。用于进行页面置换时考虑是否将该页换出内存。如果该页被访问过，在进行页面置换时，系统会考虑该页可能以后会被再次访问而不将其换出。</li>
</ul>
<h5 id="缺页中断机构"><a class="anchor" href="#缺页中断机构">#</a> 缺页中断机构</h5>
<ul>
<li>
<p>在进程运行过程中，当发现所访问的页不在内存时，缺页中断机构便产生一个缺页（Page fault）中断信号，操作系统接到此信号后，就运行缺页中断处理程序，将所需要的页调入内存。缺页中断与一般中断类似，都需要经历<strong>保护 CPU 环境</strong>、<strong>分析中断原因</strong>、<strong>转入中断程序处理</strong>、<strong>中断处理后恢复 CPU 环境</strong>等步骤。</p>
</li>
<li>
<p>但缺页中断与一般中断也有不同：</p>
<ul>
<li><strong>CPU 检测中断的时间不同</strong>。对一般的中断信号，CPU 是在一条指令执行完后检测其是否存在，检测时间以一个指令周期为间隔。而对缺页中断信号，CPU 在一条指令执行期间，只要有中断信息就可检测，不需要等待一个指令周期。因此，CPU 检测缺页中断更及时。</li>
<li><strong>CPU 可以多次处理</strong>。如果在一个指令周期中多次检测到缺页中断，CPU 都会及时处理。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/e57cd1355d7f09c422478722d9314858733d915f1f3ff0e5f51d91c3de8a46aa.png" alt="图 16"></li>
</ul>
</li>
<li>
<p><strong>缺页中断处理流程</strong>：</p>
<ul>
<li>先查看<strong>内存是否有空闲块</strong>，若有则按该<strong>页在外存中的地址</strong>将该页找出并装入内存，<strong>在页表中填上它占用的块号</strong>且<strong>修改标志位</strong>。</li>
<li>若内存已<strong>没有空闲块</strong>，则必须<strong>先淘汰已在内存中的某一页</strong>，再将所需的页装入，对页表和内存分配表作相应的修改。</li>
</ul>
</li>
<li>
<p>淘汰某页时，要查看该页的<strong>修改位</strong>来判断该页是否修改过，若该页在执行过程中<strong>没有被修改过</strong>，那么<strong>不必重新写回到存储器</strong>中，而<strong>已修改过的页</strong>调出时必须再<strong>将该页写回到外存</strong>中。</p>
</li>
</ul>
<h5 id="地址转换机构"><a class="anchor" href="#地址转换机构">#</a> 地址转换机构</h5>
<ul>
<li>
<p>请求分页虚拟存储技术是在<strong>程序执行过程</strong>中逐步将程序页面调入内存的，所以从逻辑地址到物理地址的转换是在程序运行过程中完成的，是<strong>动态重定位装入</strong><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/7ad7686e85434d1c40c30e855cd46968f8687e8eeca1060abd018b43924b8666.png" alt="图 17"></p>
</li>
<li>
<p>当进程被调度时，操作系统将进程 PCB 中的页表起始地址和长度装入<strong>页表寄存器</strong>中。</p>
</li>
<li>
<p>CPU 从逻辑地址中取得页号，根据页号查询快表，如果快表中有该页的内存块号，则将内存块号与页内偏移一起作为该页在内存的物理地址；如果快表中没有该页的内存块号，则 CPU 从页表寄存器得到页表在内存中的起始地址，查询页表，得到该页的内存块号，则将该块号与页内偏移一起作为该页在内存中的物理地址，同时将该页的页号和内存块号写入快表，以备下次查询时使用。</p>
</li>
<li>
<p>如果查询页表而没有得到该页的内存块号，即表示该页不在内存，产生一个缺页中断信号，请求操作系统将该页调入内存。</p>
</li>
<li>
<p>在调入一页的过程中，如果进程空间没有空余的物理块，则系统需要调出一页后再将该新页调入内存。同时系统修改页表，从页表中去除调出的页面，加上调入的页面。当这些工作完成后，处理器返回用户进程，继续执行被中断的指令。</p>
</li>
</ul>
<h4 id="页面分配策略与页面调度算法"><a class="anchor" href="#页面分配策略与页面调度算法">#</a> 页面分配策略与页面调度算法 😎</h4>
<ul>
<li>请求分页虚拟存储管理支持多个进程同时装入内存，操作系统为各个进程分别分配部分物理块，并将各自的部分页调入内存，在实施中涉及到以下三个策略：
<ul>
<li>页面<strong>分配</strong>策略：分配策略决定系统应该给一个进程分配多少<strong>物理块</strong>，进程才能运行。</li>
<li>页面<strong>调入</strong>策略：页面调入策略决定如何将进程所需要的<strong>页面调入到内存</strong>。</li>
<li>页面<strong>置换</strong>策略：页面置换策略决定内存中的哪些页面被<strong>换出内存</strong>。</li>
</ul>
</li>
</ul>
<h5 id="页面分配策略"><a class="anchor" href="#页面分配策略">#</a> 页面分配策略</h5>
<h6 id="固定分配方式"><a class="anchor" href="#固定分配方式">#</a> 固定分配方式</h6>
<ul>
<li>
<p>为每个进程分配固定数量的物理块，其数量在进程创建时，由进程的类型（交互性、批处理或应用性）或根据用户的要求确定，在进程的整个运行期间都<strong>不再改变</strong>。</p>
</li>
<li>
<p>具体的分配方式包括按进程平均分配法、进程按比例分配法和进程优先权分配法等。</p>
</li>
<li>
<p><strong>进程平均分配</strong>法：将内存中所有可分配的物理块平均分配给进入系统的各个进程。如果有 m 个<strong>内存物理块</strong>，n 个<strong>进程</strong>，则每个进程分得的<strong>内存物理块数</strong>为 m/n 取整数（小数部分不计）。</p>
<ul>
<li>该分配方法实现简单，但没考虑各个进程大小不一，常常会<strong>造成内存的浪费</strong>。</li>
<li>该分配方式另一个特点：分配给每个进程的物理块数会随着内存中进程数的多少而变化。</li>
</ul>
</li>
<li>
<p><strong>进程按比例分配</strong>法：根据进程的大小，进程<strong>按照比例</strong>分配内存物理块数。如果系统中有 m 个内存物理块，n 个并发进程，每个进程的页面数为 S<sub>i</sub>。则系统中每个进程能够分得的内存物理块数 b<sub>i</sub> 为（b<sub>i</sub> 取整）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>÷</mo><mo stretchy="false">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>S</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_i=(mS_i)\div(\sum\limits_{i=1}^n S_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.3291em;vertical-align:-0.9777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3514em;"><span style="top:-2.1223em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.95em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><strong>进程优先权分配</strong>法：<strong>高优先级</strong>的、<strong>时间要求紧迫</strong>的进程，操作系统给其分配较多的内存物理块，使其能够快速完成。在实际应用中，将<strong>按比例分配法和进程优先级结合</strong>起来考虑，系统把内存中可以分配的物理块分为两部分，一部分按照比例分配给各并发进程，另一部分根据进程的优先级进行适当增加。</p>
</li>
</ul>
<h6 id="可变分配方式"><a class="anchor" href="#可变分配方式">#</a> 可变分配方式</h6>
<ul>
<li>可变分配方式是指分配给进程的物理块数，在该进程的运行期间可以<strong>动态变化</strong>。它用来<strong>解决由于事先分配给进程的物理块太少而导致的频繁缺页问题</strong>。</li>
<li>具体实现时，先为每一进程分配必要数量的物理块，使之可以开始运行，系统中余下的空闲物理块组成一个空闲物理块队列，当某一进程在运行过程中发生缺页时，系统从空闲物理块队列中取出一个空闲块分配给该进程。只要该空闲队列中还有物理块，凡发生缺页的进程都可以才该队列中申请并获得物理块。</li>
</ul>
<h6 id="进程的最小物理块数"><a class="anchor" href="#进程的最小物理块数">#</a> 进程的最小物理块数</h6>
<ul>
<li>最小物理块数是保证进程正常运行所需要的<strong>最小内存块数</strong>。进程需要的最小物理块数与计算机的硬件结构有关，取决于计算机的<strong>指令格式</strong>、<strong>功能</strong>和<strong>寻址方式</strong>。</li>
</ul>
<h5 id="页面调入策略"><a class="anchor" href="#页面调入策略">#</a> 页面调入策略</h5>
<h6 id="请求页调入"><a class="anchor" href="#请求页调入">#</a> 请求页调入</h6>
<ul>
<li>请求页调入简称请调，是指在 CPU 需要访问进程某页面时，发现所访问的页面不在内存，CPU 发出缺页中断信号，请求将该页调入内存。操作系统接收到缺页中断请求后，为之分配物理块并从外存将该页调入内存。</li>
<li>每个进程在刚开始执行时，所需的页面很多，会产生多次缺页中断，页面被逐一调入内存。根据程序的局部性原理，当进程运行一段时间后，所需要的页面会逐步减少，缺页中断次数会逐渐下降，最后趋向于很低的水平，进程运行进入相对平稳阶段。</li>
<li>请求页调入策略的优点是只有在需要时才将页面调入内存，<strong>节省了内存空间</strong>。</li>
<li>请求页调入策略的缺点：
<ul>
<li>在进程初次执行时，<strong>开始阶段</strong>会有大量的页调入内存，这时的<strong>进程切换开销很大</strong>。</li>
<li>发生缺页中断时操作系统会调入页面，而每次又仅调入一个页面，启动磁盘作 I/O 的频率很高。由于每次启动磁盘时会产生一个时间延迟，因此，会造成系统<strong>用于 I/O 的时间增长</strong>，系统效率降低。</li>
<li>对于执行<strong>顺序跳跃性大</strong>的程序，<strong>缺页情况变化大</strong>，难以趋向稳定的水平，从而引起系统不稳定。</li>
</ul>
</li>
</ul>
<h6 id="预先页调入"><a class="anchor" href="#预先页调入">#</a> 预先页调入</h6>
<ul>
<li>预先页调入简称预调，是指由操作系统根据某种算法，预先估计进程可能要访问的页面，并在处理器需要访问页面之前先将页面预先调入内存。</li>
<li>该调入策略的优点是一次可将多个页面调入内存，减少了缺页中断的次数和 I/O 操作次数，系统付出的开销减少。如果预先动态估计准确率高，该调入策略会大大提高系统效率。</li>
<li>调入策略的缺点：
<ul>
<li>如果预先动态估计准确率较低，调入的页面不被使用的可能性大，系统效率较低。</li>
<li>如果程序员不能预先提供所需程序部分的信息，则该调度策略难以实施。</li>
</ul>
</li>
<li>在实际应用中，页面调入会将请求页调入和预先页调入结合起来。在进程<strong>刚开始执行</strong>时或每次<strong>缺页中断</strong>时，<strong>采用预先页调入</strong>。在进程<strong>运行稳定后</strong>，如果发现缺页，系统可采用<strong>请求页调入</strong></li>
</ul>
<h5 id="页面置换策略"><a class="anchor" href="#页面置换策略">#</a> 页面置换策略</h5>
<ul>
<li>当需要从外存调入页到内存时，如果当前内存没有空闲物理块，则操作系统需要将某些页置换出内存，再将新的页面换入内存。选择被置换出的页有两种策略：全局置换和局部置换</li>
</ul>
<h6 id="全局置换"><a class="anchor" href="#全局置换">#</a> 全局置换</h6>
<ul>
<li>全局置换是指操作系统从<strong>所有当前位于内存的页面</strong>中选择一个页面淘汰，释放出对应的物理块，而不是仅从需要该页的进程的物理块换出。这种置换方法会影响大多数进程的运行，是一种<strong>动态方法</strong></li>
</ul>
<h6 id="局部置换"><a class="anchor" href="#局部置换">#</a> 局部置换</h6>
<ul>
<li>局部置换是指当某进程有页面需要换入到内存时，只能从<strong>该进程目前已在内存的页面</strong>中选择一页淘汰，该置换方法<strong>对其它进程没有影响</strong>。</li>
<li>局部置换与全局置换比较有明显的<strong>缺点</strong>：如果进程在执行期间所需要的内存物理块数发生变化，页面置换发生频繁，即使系统有空闲的物理块，也不可能增加给该进程；另外，如果系统给某进程分配的物理块数太多，系统不会收回，最终会造成内存空间浪费。</li>
</ul>
<h5 id="页面置换与页面分配的关联"><a class="anchor" href="#页面置换与页面分配的关联">#</a> 页面置换与页面分配的关联</h5>
<h6 id="固定分配局部置换"><a class="anchor" href="#固定分配局部置换">#</a> 固定分配局部置换</h6>
<ul>
<li>为每个进程分配<strong>固定数量</strong>的物理块，在进程的整个运行期间都不再改变。当一个进程运行中发生缺页中断时，操作系统只从该进程在内存中的页面中选择一页淘汰。</li>
<li>该策略不足在于：应为每个进程分配多少物理块数难以确定。如果分配给进程的物理块太少，缺页中断率高，进而导致整个多道程序系统运行缓慢；给多了，会使内存中能同时执行的进程数减少，进而造成处理器空闲和其他设备空闲，浪费资源。</li>
</ul>
<h6 id="可变分配全局置换"><a class="anchor" href="#可变分配全局置换">#</a> 可变分配全局置换</h6>
<ul>
<li>先为每一进程<strong>分配必要数量的物理块</strong>，使之可以开始运行，系统中余下的空闲物理块组成一个<strong>空闲物理块队列</strong>，当某一进程在运行中发生缺页时，系统从空闲物理块队列中取出一个空闲块分配给该进程。直到系统拥有的空闲物理块耗尽，才会从内存中选择一页淘汰，该页可以是内存中任一进程的页面。</li>
<li><strong>该策略易于实现</strong>，且可以有效地减少缺页中断率，是采用得较多的一种分配和置换策略。</li>
</ul>
<h6 id="可变分配局部置换"><a class="anchor" href="#可变分配局部置换">#</a> 可变分配局部置换</h6>
<ul>
<li>新进程装入内存时，根据应用类型、程序要求，先分配给一定数目物理块。当产生缺页中断时，系统只能从产生缺页中断的进程的页面中选一个页面淘汰，不能影响其他进程的运行。操作系统要<strong>不时重新评价</strong>进程的物理块分配情况，<strong>增加或减少分配给进程的物理块</strong>以改善系统总的性能。</li>
</ul>
<h4 id="页面置换算法"><a class="anchor" href="#页面置换算法">#</a> 页面置换算法 😎</h4>
<h5 id="缺页率"><a class="anchor" href="#缺页率">#</a> 缺页率</h5>
<ul>
<li>一个进程或一个作业在运行中成功的页面访问次数为 S，即所访问的页面在内存中；不成功的页面访问次数为 F，即访问的页面不在内存，需要缺页中断并调入内存；需要访问的页面的总次数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext>&nbsp;</mtext><mo>=</mo><mtext>&nbsp;</mtext><mi>S</mi><mtext>&nbsp;</mtext><mo>+</mo><mtext>&nbsp;</mtext><mi>F</mi></mrow><annotation encoding="application/x-tex">A&nbsp;=&nbsp;S&nbsp;+&nbsp;F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">&nbsp;</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>。则缺页率 f 为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mtext>&nbsp;</mtext><mo>=</mo><mtext>&nbsp;</mtext><mi>F</mi><mtext>&nbsp;</mtext><mi mathvariant="normal">/</mi><mtext>&nbsp;</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">f&nbsp;=&nbsp;F&nbsp;/&nbsp;A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">&nbsp;/&nbsp;</span><span class="mord mathnormal">A</span></span></span></span></li>
<li>影响缺页率的因素如下：
<ul>
<li>进程分得的<strong>内存物理块数</strong>越多，缺页率越低。</li>
<li>划分的<strong>页面</strong>越大，缺页率越低。</li>
<li>如果<strong>程序局部性</strong>好，则缺页率低。</li>
<li>如果选取的<strong>置换算法</strong>优，则缺页率低。</li>
</ul>
</li>
<li>在进程的内存物理块数和页面大小不能改变的情况下，要减少缺页率，就要考虑选择合适的页面置换算法。</li>
</ul>
<h5 id="先进先出fifo页面置换算法"><a class="anchor" href="#先进先出fifo页面置换算法">#</a> 先进先出（FIFO）页面置换算法</h5>
<ul>
<li>先进先出（Fist In First Out）算法的基本思想：总是选择<strong>最先进入内存</strong>的页面或<strong>驻留时间最长</strong>的页面先淘汰。该算法最早出现，易于实现。</li>
<li>实现：可以将所有页面按照进入内存的次序排成一个<strong>队列</strong>，设置一个替换指针指向队头的一页。当需要进行页面淘汰时，替换指针指向的即为当前最先进入内存的页面，该页被淘汰，然后修改指针指向淘汰页后一个页面即可，调入的新的页面排入队尾。</li>
<li>先进先出页面置换算法<strong>开销低</strong>、<strong>容易编程实现</strong>，<strong>适合于线性顺序特性好</strong>的程序。但是该算法没有考虑到页面的访问频率，很可能刚被换出的页面马上又要被访问，使得<strong>缺页率偏高</strong></li>
<li>为了改善 FIFO 算法，减少缺页率，科学家尝试在进程发生缺页时给进程增加物理块。在实验中，Belady 发现了一个奇怪的现象，该现象也被称为<strong> Belady 异常现象</strong>。即：<strong>当页数在一定范围内时，缺页率反而随分配给进程的物理块数的增加而增加</strong></li>
</ul>
<h5 id="最佳opt页面置换算法"><a class="anchor" href="#最佳opt页面置换算法">#</a> 最佳（OPT）页面置换算法</h5>
<ul>
<li>最佳（optimal）页面置换算法由 Belady 在 1966 年提出，基本思想：在选择页面置换时应该考虑该页面将来使用的情况，<strong>将来最长时间不用的页面被淘汰</strong>。在进程采用固定页面分配的情况下，最佳页面置换算法具有最低的缺页率。</li>
</ul>
<h5 id="最近最少使用lru页面置换算法"><a class="anchor" href="#最近最少使用lru页面置换算法">#</a> 最近最少使用（LRU）页面置换算法</h5>
<ul>
<li>实现方法：系统须维护一个<strong>页面淘汰队列</strong>，该队列中存放当前在内存中的页号，每当访问一页时就调整一次，使队尾总指向最近访问的页，而队列头部就是最近最少用的页，发生缺页中断时总淘汰队列头所指示的页；而执行一次页面访问后，需要从队列中把该页调整到队列尾。</li>
</ul>
<h5 id="时钟clock置换算法"><a class="anchor" href="#时钟clock置换算法">#</a> 时钟（clock）置换算法</h5>
<ul>
<li>时钟置换算法的基本思想是：
<ul>
<li>将内存中所有的页面组织成一个<strong>循环队列</strong>，形成一个类似于时钟表面的环形表，循环队列指针类似于钟的指针，用来指向可能被淘汰的页面，指针开始时指向最先进入内存的页面。</li>
<li>时钟置换算法需要在页表中为每一页增加一个访问位 <code>R</code> 。当页面<strong>首次装入内存</strong>时， <code>R</code>  的初值设置为 “0”。当某个页面被访问过后， <code>R</code>  的值被设置为 “1”。</li>
<li>选择淘汰页面的方法是从指针当前指向的页面位置开始扫描时钟环，如果某个页面页表中的 <code>R</code>  为 “1”，表明该页被访问过，将 <code>R</code>  清 “0”，并跳过该页；如果某个页面页表中的 <code>R</code>  为 “0”，表明该页没有被访问过，该页被淘汰，指针推进一步；如果所有的页面都被访问过，指针绕环一圈，将所有页面的 <code>R</code>  清 “0”，指针回到起始位置，选择该页淘汰，指针推进一步。</li>
</ul>
</li>
<li>为了提高置换效率，在页面置换时，如果被淘汰的页面没有被修改过，则不需写回外存。这样，将页表中的访问位 <code>R</code>  和页表中的修改位 <code>M</code>  配合，产生改进的时钟置换算法。</li>
<li>访问位 <code>R</code>  和修改位 <code>M</code>  的组合有下面四种情况：
<ul>
<li>最近没有被访问（ <code>R&nbsp;=&nbsp;0</code> ），没有被修改（ <code>M&nbsp;=&nbsp;0</code> ）：从指针当前位置开始，选择第一个 <code>R&nbsp;=&nbsp;0</code> ， <code>M&nbsp;=&nbsp;0</code>  的页面淘汰。</li>
<li>最近没有被访问（ <code>R&nbsp;=&nbsp;0</code> ），但是被修改过（ <code>M&nbsp;=&nbsp;1</code> ）：如果没有 <code>R&nbsp;=&nbsp;0</code> ， <code>M&nbsp;=&nbsp;0</code>  的页面，则从开始位置重新开始查找第一个 <code>R&nbsp;=&nbsp;0</code> ， <code>M&nbsp;=&nbsp;1</code>  的页面并淘汰之。</li>
<li>最近被访问（ <code>R&nbsp;=&nbsp;1</code> ），没有被修改（ <code>M&nbsp;=&nbsp;0</code> ）：如果没有 <code>R&nbsp;=&nbsp;0</code> ， <code>M&nbsp;=&nbsp;1</code>  的页面，表示所有的页面 <code>R&nbsp;=&nbsp;1</code> 。在再次回到开始位置时，所有页面的访问位 <code>R</code>  都被清 “0”。从开始位置查找第一个 <code>M&nbsp;=&nbsp;0</code>  的页面并淘汰之，此时不用将淘汰页面 “写” 回外存。</li>
<li>最近被访问（ <code>R&nbsp;=&nbsp;1</code> ），被修改（ <code>M&nbsp;=&nbsp;1</code> ）：当前面三种情况都不存在时才考虑 <code>R&nbsp;=&nbsp;1</code> ， <code>M&nbsp;=&nbsp;1</code>  的情况。</li>
</ul>
</li>
<li>该策略的主要优点是没有被修改过的页面会被淘汰，但不必写回外存，<strong>节省了 I/O 时间</strong>。但是<strong>查找淘汰页面</strong>可能需要<strong>多次扫描时钟</strong>，增加了算法的开销。</li>
</ul>
<h4 id="影响请求页式存储管理性能的因素"><a class="anchor" href="#影响请求页式存储管理性能的因素">#</a> 影响请求页式存储管理性能的因素</h4>
<h5 id="分配给进程的内存块数与缺页率的关系"><a class="anchor" href="#分配给进程的内存块数与缺页率的关系">#</a> 分配给进程的内存块数与缺页率的关系</h5>
<ul>
<li>实验结果表明，对每个进程来说，为其分配进程空间页面数约一半的物理块时，请求页式的效果最好</li>
</ul>
<h5 id="页面大小对系统性能的影响"><a class="anchor" href="#页面大小对系统性能的影响">#</a> 页面大小对系统性能的影响</h5>
<ul>
<li>从页表大小考虑：如果页面较小，页数就要增加，页表也随之扩大，为了控制页表所占的内存空间，应选择较大的页面尺寸。</li>
<li>从内存利用率考虑：内存以块为单位，一般情况下进程的最后一个页面总是装不满一个物理块，会产生内部碎片，为了减少内部碎片，应选择小的页面尺寸。</li>
<li>从读写一个页面所需的时间考虑：作业存放在辅助存储器上，从磁盘读入一个页面的时间包括等待时间（移臂时间 + 旋转时间）和传输时间，通常等待时间远大于传输时间。显然，加大页面的尺寸，有利于提高 I/O 的效率。</li>
</ul>
<blockquote>
<p>页面长度是由 CPU 中的 <code>MMU</code>  规定的，操作系统通过特定寄存器的指示位来指定当前选用的页面长度。</p>
</blockquote>
<h5 id="缺页率对系统性能的影响"><a class="anchor" href="#缺页率对系统性能的影响">#</a> 缺页率对系统性能的影响</h5>
<ul>
<li>用 <code>p</code>  表示缺页率，如果 <code>p&nbsp;=&nbsp;0</code> ，则不缺页；如果 <code>p&nbsp;=&nbsp;1</code> ，则始终缺页。</li>
<li>抖动：由于缺页而引起的一种系统现象，即处理器频繁地处理页面的换出和调入，使得处理器实际处理程序的能力大大减小。“抖动” 现象常在<strong>缺页率非常高</strong>时发生。</li>
<li>用 <code>st</code>  表示缺页处理时间。缺页处理时间包括<strong>从外存取相关页面并将其放入内存的时间</strong>。</li>
<li>用 <code>ma</code>  表示对内存一个页面的访问时间。</li>
<li>用 <code>vt</code>  表示有效访问时间。</li>
<li>在非缺页的情况下， <code>vt&nbsp;=&nbsp;ma</code></li>
<li>在缺页率为 p 的情况下， <code>vt =&nbsp;(1&nbsp;−&nbsp;p)&nbsp;×&nbsp;ma&nbsp;+&nbsp;p&nbsp;×&nbsp;st</code></li>
<li>在任何情况下，缺页处理时间由下面三个主要部分构成：
<ul>
<li>缺页中断服务时间；</li>
<li>读页面时间；</li>
<li>恢复进程时间。</li>
</ul>
</li>
</ul>
<blockquote>
<p>有效访问时间直接正比于缺页率</p>
</blockquote>
<h3 id="请求分段虚拟存储管理"><a class="anchor" href="#请求分段虚拟存储管理">#</a> 请求分段虚拟存储管理</h3>
<h4 id="请求分段虚拟存储管理的基本原理"><a class="anchor" href="#请求分段虚拟存储管理的基本原理">#</a> 请求分段虚拟存储管理的基本原理</h4>
<ul>
<li>请求分段的<strong>基本思想</strong>：将用户程序的所有段首先放在辅助存储器中，当用户程序被调度投入运行时，首先把当前需要的一段或几段装入内存，在执行过程中访问到不在内存的段时再把它们从外存装入。</li>
<li>请求分段的<strong>段表</strong>包括：段号、段长、存取权限、在内存中的起始地址、在外存中的起始地址、是否在内存、修改标志、共享标志和扩充位等。</li>
<li><strong>在程序执行中需要访问某段时</strong>，查段表，若该段在内存，则按段式存储管理进行地址转换得到绝对地址。</li>
<li><strong>若该段不在内存中</strong>，则硬件发出一个缺段中断。操作系统处理这个中断时，先查找内存分配表，找出一个足够大的连续区域容纳该分段。如果找不到足够大的连续区域则检查空闲区的总和，若空闲区总和能满足该分段要求，那么进行适当移动后，再将该段装入内存。若空闲区总和不能满足要求，则可调出一个或几个分段在辅助存储器上，再将该分段装入内存。</li>
<li>在执行过程中，<strong>有些数据段的大小会随输入数据多少而变化</strong>。这就需要在该分段尾部添加新信息，但添加后的段的总长度不应超过硬件允许的每段最大长度。对于这种变化的数据段，当要往其中添加新数据时，由于欲访问的地址超出原有的段长，<strong>硬件首先会产生一个越界中断</strong>。操作系统处理这个中断时，<strong>先去判断该段的 “扩充位” 标志，如可以扩充，则允许增加段的长度</strong>，如该段不允许扩充，那么这个越界中断就表示程序出错。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/53b22a32750b10e3fd6a6582c7620e0979f0843410eb98f0962644d2e21a16b4.png" alt="图 18"></li>
</ul>
<h4 id="请求分段虚拟存储管理的段的共享和保护"><a class="anchor" href="#请求分段虚拟存储管理的段的共享和保护">#</a> 请求分段虚拟存储管理的段的共享和保护</h4>
<ul>
<li>请求分段虚拟存储管理为了实现段的共享，除了原有的进程段表外，还要在系统中建立一张段共享表，每个共享分段占一个表项，每个表项包含两部分内容：
<ul>
<li>第一部分包含共享段名、段长、内存起址、状态位（如在不在内存）、辅存地址、共享进程个数计数器。</li>
<li>第二部分包含共享该段的所有进程名、状态、段号、存取控制位（通常为只读）。</li>
</ul>
</li>
<li>当出现笫一个要使用某个共享段的进程时，操作系统为此共享段分配一块内存，再将共享段装入该区。同时将共享段在内存的<strong>起始地址填入共享段表中对应项的内存始址</strong>处，<strong>共享进程个数计数器加 1，修改状态位为 1（在内存）</strong>，填写使用该共享段的进程的有关信息（进程名、使用共享段的段号、存取控制等）。而进程段表中共享段的表项指向内存共享段表地址。此后，当又有进程要使用该共享段时，仅需直接填写共享段表和进程段表，以及把共享进程个数计数器加 1 就可以了。</li>
<li>当进程<strong>不再使用共享段时，应释放该共享段</strong>，除了在共享段表中删去进程占用项外，还要把共享进程个数计数器减 1。共享进程个数计数器为 0 时，说明已没有进程使用此共享段了，系统需要回收该共享段的物理内存，并把占用表项也取消。</li>
<li>优点：不同进程可以用不同段号使用同一个共享段；由于进程段表中共享段的表项指向内存共享段表地址，所以，每当共享段被移动、调出或再装入时，只要修改共享段表的项目，不必要修改共享该段的每个进程的段表。</li>
<li>由于每个分段在逻辑上是独立的，实现存储保护很方便：
<ul>
<li><strong>越界检查</strong>：在段表寄存器中存放了段长信息，在进程段表中存放了每个段的段长。在存储访问时，首先，把指令逻辑地址中的段号与段表长度进行比较，如果段号等于或大于段表长度，将发出地址越界中断；其次，还需检查段内地址是否大于段长，若是的话将产生地址越界中断，从而确保每个进程只在自己的地址空间内运行。</li>
<li><strong>存取控制检查</strong>：在段表的每个表项中，均设有存取控制字段，用于规定此段的访问方式，通常设置的访问方式有：只读、读写、只执行等。</li>
</ul>
</li>
</ul>
<h4 id="请求段页式虚拟存储管理"><a class="anchor" href="#请求段页式虚拟存储管理">#</a> 请求段页式虚拟存储管理</h4>
<ul>
<li>请求段页式虚拟存储管理是在段页式存储管理的基础上增加了<strong>用以实现虚拟存储的缺页中断机制、缺段中断机制来实现的</strong>。</li>
<li>与传统的段页式存储管理一样，用户的逻辑地址空间被划分为段号、段内页号与页内偏移。但是，<strong>请求段页式管理并没有将一个作业的所有段在作业运行前全部装入内存，只是部分段装入内存</strong>，因此，还需要有<strong>作业表</strong>来记载进入内存的作业段的情况。</li>
</ul>
<h2 id="设备管理"><a class="anchor" href="#设备管理">#</a> 设备管理</h2>
<h3 id="设备管理概述"><a class="anchor" href="#设备管理概述">#</a> 设备管理概述</h3>
<h4 id="设备管理的逻辑结构"><a class="anchor" href="#设备管理的逻辑结构">#</a> 设备管理的逻辑结构</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/901fe817cb19a38408e4a1b8adba6f82e94bf3a78646edb50c24d18859b6ab3a.png" alt="图 19"></p>
<h4 id="设备控制器"><a class="anchor" href="#设备控制器">#</a> 设备控制器</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/300f213852f1044436e0b52e90afbd60b160bc6f82920f71bf5c0248aa4783e4.png" alt="图 20"></p>
<h3 id="设备控制方法"><a class="anchor" href="#设备控制方法">#</a> 设备控制方法 😎</h3>
<h4 id="程序循环查询方式"><a class="anchor" href="#程序循环查询方式">#</a> 程序循环查询方式</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/ffcacc4910ffb7b31b7e6b3ab478514aa9b5aa109f8cfa6d4c2d04eb8511eb3f.png" alt="图 21"></p>
<ul>
<li><strong>CPU 要不断的发送 I/O 测试指令</strong>用以测试设备控制器的<strong>忙 / 闲（busy）标志位</strong>，若设备不忙，则主存与外部设备交换一个字符或一个字。若设备忙，则 I/O 测试指令不断对它进行测试，直到设备空闲为止。</li>
<li>由于 CPU 的速度远高于 I/O 设备的速度，使得 CPU 绝大部分时间都处于等待 I/O 完成的循环测试之中。显然，这对 CPU 是极大的浪费。但是，它的控制简单，<strong>在 CPU 速度慢、要求不高的场合下</strong>常被采用。</li>
</ul>
<h4 id="中断驱动方式"><a class="anchor" href="#中断驱动方式">#</a> 中断驱动方式</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/6b57a5341e4eb717aa8832b23a6f47a11b95515cd947cf75c466328d29bfb165.png" alt="图 22"></p>
<ul>
<li>引入中断机构是为了<strong>消除设备驱动程序不断地轮询控制器状态寄存器的开销</strong>，当 I/O 操作结束后，由设备控制器 “自动地” 通知设备驱动程序</li>
</ul>
<h4 id="直接内存访问方式"><a class="anchor" href="#直接内存访问方式">#</a> 直接内存访问方式</h4>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/80ee133f26a54237b0b1e67aba566779be1d894d6cc7a6cbc578d931a6899e29.png" alt="图 23"></p>
<ul>
<li>数据传输的基本单位是数据块，即每次传送至少一个数据块。</li>
<li>所传送的数据是从设备直接送入内存，或者直接读出内存的。</li>
<li>在传输时 CPU 参与更少，<strong>仅在传送一个或多个数据块的开始和结束时</strong>，才需 CPU 干预，整块数据的传送是在控制器的控制下完成的。</li>
</ul>
<h4 id="通道方式"><a class="anchor" href="#通道方式">#</a> 通道方式</h4>
<ul>
<li>I/O 通道方式是 DMA 方式的发展，它可进一步减少 CPU 的干预，即把对一个数据块的读 (或写) 为单位的干预，减少为对一组数据块的读 (或写) 及有关的控制和管理为单位的干预</li>
<li><strong>有专门用于 I/O 的处理单元</strong>。在进行 I/O 操作时，接受 CPU 的委托，独立地执行自己的通道程序来实现内存与外设之间的数据传输。</li>
<li>使 CPU 从对 I/O 设备的繁忙直接控制中解脱出来，极大地提高了 CPU 与外设并行工作的程度，从而更有效地提高整个系统的资源利用率</li>
</ul>
<h5 id="通道分类"><a class="anchor" href="#通道分类">#</a> 通道分类</h5>
<ul>
<li>字节多路通道</li>
<li>选择通道</li>
<li>成组多路通道</li>
</ul>
<h5 id="通道工作方式"><a class="anchor" href="#通道工作方式">#</a> 通道工作方式</h5>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/d41b9f80516d4be146fd793a33782f8a0c6bcbbcefa560e517c78e9d0e07869f.png" alt="图 24"></p>
<ul>
<li>通道 I/O 操作由两种命令实现控制：CPU 的 I/O 指令和通道本身提供的通道程序。</li>
<li>CPU 的 I/O 指令的功能一般包括有：清除、停止、启动、查询等功能，除了操作码之外，I/O 指令中还有通道地址和设备地址域。I/O 指令属特权指令，只能由操作系统使用。</li>
<li>通道程序一般有读、写、查询、控制和转移等功能</li>
<li>在通道 I/O 工作过程中，CPU 对通道的通信是向通道发出启动、查询和停止通道指令；而通道向 CPU 的通信则采用中断方式向 CPU 汇报。</li>
</ul>
<h3 id="缓冲技术"><a class="anchor" href="#缓冲技术">#</a> 缓冲技术</h3>
<h4 id="缓冲技术的作用"><a class="anchor" href="#缓冲技术的作用">#</a> 缓冲技术的作用</h4>
<ul>
<li>它能改善中央处理器与外围设备之间速度不匹配的矛盾，提高 CPU 和 I/O 设备的并行性。</li>
<li>它能减少 I/O 对 CPU 的中断次数和放宽对 CPU 中断响应时间的要求</li>
<li>缓冲技术还能协调逻辑记录大小与物理记录大小不一致的问题</li>
</ul>
<h4 id="缓冲的分类"><a class="anchor" href="#缓冲的分类">#</a> 缓冲的分类</h4>
<h5 id="单缓冲"><a class="anchor" href="#单缓冲">#</a> 单缓冲</h5>
<ul>
<li>单缓冲指当一个进程发出 I/O 请求时，操作系统便在主存中为之分配一个缓冲区，用来临时存放输入／输出数据。它是操作系统提供的一种简单的缓冲形式。</li>
<li>在数据的输入或者过程中，在某一时刻该缓冲区只能存放输入数据或输出数据，而不能既是输入数据又是输出数据，否则会引起缓冲区中数据的混乱。对缓冲区来说，信息的输入和输出实际上是串行工作的。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/22b455e7398984e05dcd77f79c96b611b2b7641c0ea7daa4f6b5b4f926221d86.png" alt="图 25"></p>
<h5 id="双缓冲"><a class="anchor" href="#双缓冲">#</a> 双缓冲</h5>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/2c45d118c726b5644f32f69a1506982a264b2af5e255608178574efff1de5266.png" alt="图 26"></p>
<ul>
<li>双缓冲指在操作系统中为某一设备设置两个缓冲区，当一个缓冲区中的数据尚未被处理时可使用另一个缓冲区存放从设备读入或读出的数据，以此来进一步提高 CPU 和外设的并行程度。</li>
<li>在输入数据时，首先填满缓冲区 1，操作系统可从缓冲区 1 把数据送到用户进程区，用户进程便可对数据进行加工计算；与此同时，输入设备填充缓冲区 2。</li>
<li>当缓冲区 1 空出后，输入设备再次向缓冲区 1 输入。操作系统又可以把缓冲区 2 的数据传送到用户进程区，用户进程开始加工缓冲区 2 的数据。</li>
<li>这样两个缓冲区交替使用，使 CPU 和 I/O 设备的并行性进一步提高。仅当两个缓冲区都空或者都满，进程还要提取数据或者写入数据时，它才被迫等待</li>
</ul>
<h5 id="多缓冲"><a class="anchor" href="#多缓冲">#</a> 多缓冲</h5>
<h6 id="循环缓冲"><a class="anchor" href="#循环缓冲">#</a> 循环缓冲</h6>
<ul>
<li>为了使缓冲区资源得到充分利用，操作系统从主存区域中分配一组缓冲区，如图，根据用途分为：输入缓冲区组和输出缓冲区组。</li>
<li>每个缓冲区有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，组成了循环缓冲。每个缓冲区的大小可以等于物理记录的大小</li>
<li>这种循环式的多缓冲区是系统的公共资源，并由系统统一分配和管理，可供各个进程共享。为了管理各缓冲区，进行统一调度和管理，操作系统中通常要设立专门的机构来管理它们。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/7d72c3eb4d0253542cb36a0d33f341c7c0cb701b9cb23c697097fe575665bf7f.png" alt="图 27"></p>
<h6 id="缓冲池"><a class="anchor" href="#缓冲池">#</a> 缓冲池</h6>
<ul>
<li>缓冲池由内存中的一组缓冲区构成，各缓冲区之间并不一定采用循环链表的方式进行链接，操作系统与用户进程将轮流地使用各个缓冲区，以改善系统性能。</li>
<li>缓冲池中多个缓冲区可供多个进程使用，既可用于输出又可用于输入，是一种现代操作系统经常采用的一种公用缓冲技术</li>
<li>缓冲池中的缓冲区一般按照内容被组织成三个队列：空闲缓冲区队列 <code>emq</code> 、输入缓冲区队列 <code>inq</code> 、输出缓冲区队列 <code>outq</code> 。</li>
<li>每个缓冲区根据其当前的工作性质不同，分为四种状态：收容输入、提取输入、收容输出、提取输出。</li>
<li>对缓冲池的管理，有两个基本操作 <code>Getbuf</code>  过程和 <code>Putbuf</code>  过程。 <code>Getbuf（type）</code> 用于从 <code>type</code>  所指定的队列的队首摘下一个缓冲区； <code>Putbuf（type，number）</code> 用于将由参数 <code>number</code>  所指示的缓冲区挂在 <code>type</code>  队列上。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/50b83f164f004bf756a2fe93c3b0ab32f8f6a80cd457565aa903d5c460b5b531.png" alt="图 28"></p>
<h3 id="输入输出软件"><a class="anchor" href="#输入输出软件">#</a> 输入输出软件</h3>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/60b59564919b61ef884a2c56d9d540baa2d0369ab4cf4e9eae069b9dc87f8ae9.png" alt="图 29"></p>
<h4 id="中断处理程序"><a class="anchor" href="#中断处理程序">#</a> 中断处理程序</h4>
<ul>
<li>凡是涉及到输入 / 输出设备开始、结束或者异常时，一般都会发生中断信号。</li>
<li>当一个中断信号发生时，若能及时得到相应，则正在运行的进程将被挂起，直到 I/O 操作结束并发出一个中断请求，CPU 响应后便转向中断处理程序，然后解除相应进程的阻塞状态。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/5a44697ee5a58c2994eefd83767df4ddd1fcff1fb87f863a76316c83e719761d.png" alt="图 30"></p>
<h4 id="设备驱动程序"><a class="anchor" href="#设备驱动程序">#</a> 设备驱动程序</h4>
<ul>
<li>所谓设备驱动程序是指驱动物理设备和 DMA 控制器或 I/O 控制等直接进行 I/O 操作的程序集合</li>
<li>不同类型的设备应有不同的设备驱动程序，设备驱动程序主要负责启动指定设备，即负责设置与相关设备有关的寄存器的值，启动设备进行 I/O 操作，指定操作的类型和数据流向等。</li>
</ul>
<h5 id="设备驱动程序的处理过程"><a class="anchor" href="#设备驱动程序的处理过程">#</a> 设备驱动程序的处理过程</h5>
<ol>
<li>接收由 I/O 进程发来的命令和参数，并将命令中的抽象要求转换为具体要求。</li>
<li>检查用户 I/O 请求的合法性，了解 I/O 设备的状态，传递有关参数，设置设备的工作方式</li>
<li>发出 I/O 命令，如果设备空闲，便立即启动 I/O 设备去完成指定的 I/O 操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待</li>
<li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。对于设置有通道的计算机系统，驱动程序还应能够根据用户的 I/O 请求，自动地构成通道程序。</li>
<li>I/O 完成后，由通道（或设备）产生中断信号。CPU 接到中断请求后，如果条件符合（中断优先级高于运行程序的优先级），则响应中断，然后转去执行相应的中断处理程序，唤醒因等待 I/O 完成而睡眠的进程，调度用户进程继续运行</li>
</ol>
<h5 id="设备驱动程序的特点"><a class="anchor" href="#设备驱动程序的特点">#</a> 设备驱动程序的特点</h5>
<ul>
<li>与一般的操作系统程序和应用程序不同，设备驱动程序由于与物理设备有关，具有以下特性：
<ul>
<li>驱动程序指在请求 I/O 的进程与设备控制器之间的一个通信和转换程序。它的主要任务是接受上层软件发来的抽象要求并将设备控制器发来的信号传送给上层</li>
<li>驱动程序与设备控制器和 I/O 设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序。</li>
<li>驱动程序与 I/O 设备所采用的 I/O 控制方式紧密相关</li>
</ul>
</li>
</ul>
<h4 id="设备独立性程序"><a class="anchor" href="#设备独立性程序">#</a> 设备独立性程序</h4>
<ul>
<li>所谓设备独立性，也称为设备无关性，<strong>是指在用户程序中不要直接使用物理设备名（或设备的物理地址），而只能使用逻辑设备名</strong>。</li>
<li>逻辑设备是实际物理设备属性的抽象，它不限于某类具体设备。逻辑设备究竟和哪一个具体的物理设备相对应，还要由系统根据当时的设备忙、闲情况来决定或由系统管理员指定</li>
<li>在应用程序中使用逻辑设备名来请求使用某类设备，而<strong>系统在实际执行时，使用物理设备名</strong>。</li>
<li>系统必须根据对应关系将逻辑设备名转换成物理设备名，进一步找到物理设备的驱动程序地址</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/ba903270f1793acc90523a6b95d84433127c4d5233e06eff18abb42032082052.png" alt="图 31"></p>
<ul>
<li>
<p>引入设备独立性这一概念，使得用户程序可使用逻辑设备名，而不必使用物理设备名，有以下优点：</p>
<ul>
<li>使得设备分配更加灵活，提高了设备的利用率。当多用户多进程请求分配设备时，系统可根据设备当时的忙闲情况，合理调整逻辑设备名与物理设备名之间的对应情况，以保证设备的充分使用。</li>
<li><strong>可以实现 I/O 重定向</strong>。所谓 I/O 重定向是指可以<strong>更换 I/O 操作的设备而不必改变应用程序</strong></li>
</ul>
</li>
<li>
<p>设备驱动程序是一个与硬件（或设备）紧密相关的软件，为了实现设备独立性，就必须在驱动程序之上设置一层与设备无关的软件，其主要功能如下：</p>
<ul>
<li>向用户层软件提供统一接口。</li>
<li>设备无关程序负责将设备名映射到相应的设备驱动程序。</li>
<li>设备保护。</li>
<li>协调不同设备数据块的差异。</li>
<li>差错控制。</li>
</ul>
</li>
</ul>
<h4 id="用户层软件"><a class="anchor" href="#用户层软件">#</a> 用户层软件</h4>
<ul>
<li>用户层的 I/O 软件实际上就是面向设备具体应用的软件，它是 I/O 系统软件的最上层软件</li>
</ul>
<h3 id="设备分配与回收"><a class="anchor" href="#设备分配与回收">#</a> 设备分配与回收</h3>
<h4 id="设备信息描述"><a class="anchor" href="#设备信息描述">#</a> 设备信息描述</h4>
<h5 id="系统设备表sdt"><a class="anchor" href="#系统设备表sdt">#</a> 系统设备表 SDT</h5>
<ul>
<li><strong>系统设备表记录系统中所有设备资源的状态</strong>。在整个系统中设置惟一的系统设备表 <code>SDT</code> ，是系统范围的数据结构，记录了系统中全部设备情况，并为每个设备设置了一个表项。 <code>SDT</code>  的每个表项主要包括：设备类型、设备标识符、指向 <code>DCT</code>  的指针以及驱动程序入口。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/7251293ee702b78bea77f84e87eaa710d321a03e0fb98f5c376310adcb290a2e.png" alt="图 32"></p>
<h5 id="设备控制表dct"><a class="anchor" href="#设备控制表dct">#</a> 设备控制表 DCT</h5>
<ul>
<li>对系统范围内的任何一台设备，操作系统都配置了一张设备控制表 <code>DCT</code> ，用来<strong>记录设备的特性、设备和 I/O 控制器的连接情况以及设备的分配和使用情况</strong>。 <code>DCT</code>  在系统生成时或在该设备和系统连接时创建，但表中的内容则可根据系统执行情况动态修改。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/4fe70af304d3fe9629c3751be685ce146ec64ad9b961761acca3fdf4860419dd.png" alt="图 33"></p>
<h5 id="控制器控制表coct"><a class="anchor" href="#控制器控制表coct">#</a> 控制器控制表 COCT</h5>
<ul>
<li>系统为每个控制器都设置了一个 <code>COCT</code> ，用它来<strong>反映 I/O 控制器的使用情况以及所连接的通道情况</strong></li>
<li>主要包括：控制器标识符、控制器的状态、与控制器相连接的通道表指针、控制器队列的队首指针、控制器队列的队尾指针，各相应项意义与 <code>DCT</code>  类似。</li>
</ul>
<h5 id="通道控制表chct"><a class="anchor" href="#通道控制表chct">#</a> 通道控制表 CHCT</h5>
<ul>
<li>在设置有通道的系统中，操作系统为每个通道都配有一张通道控制表，它与 <code>COCT</code>  类似。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/f193c71c54ea2efb6622392e483679232cde3dde351584cd3b8702b478eaa107.png" alt="图 34"></p>
<h4 id="设备分配策略"><a class="anchor" href="#设备分配策略">#</a> 设备分配策略</h4>
<ul>
<li><strong>独占方式</strong>就是把一台设备<strong>固定地分配给一个用户或进程</strong>，直到它运行结束。这种方式对用户来说是方便的，管理起来也简单，但资源往往造成浪费。因为用户程序或进程运行过程中不会自始至终都使用像打印机这类设备</li>
<li><strong>共享方式</strong>是指设备可以在多个用户（或进程）“<strong>交替</strong>” 使用，即一个进程需要时，便申请它，获得后使用它，用完就释放它。其他进程也如此方式使用。磁盘、磁带就是可共享方式分配、使用的设备。</li>
<li><strong>虚拟方式</strong>：为了提高独占设备的利用率，提高进程并行程度，引入了虚拟设备技术。虚拟设备技术就是利用快速、共享设备（例如磁盘）把慢速、独占设备模拟成为同类物理设备。</li>
</ul>
<h4 id="spooling技术"><a class="anchor" href="#spooling技术">#</a> SPOOLing 技术</h4>
<h5 id="spooling系统的组成"><a class="anchor" href="#spooling系统的组成">#</a> SPOOLing 系统的组成</h5>
<ul>
<li><strong>输入井</strong>模拟假脱机输入，用于收容输入的数据。</li>
<li><strong>输出井</strong>模拟脱机输出，用于收容用户程序的输出数据。</li>
<li><strong>预输入程序</strong>模拟脱机输入时的外围控制机，将输入设备的输入信息送到输入井，当相关进程需要输入数据时，直接从输入井读入到内存中的用户程序区。</li>
<li><strong>缓输出程序</strong>模拟脱机输出时的外围控制机，把用户要求输出的信息从用户程序区送到输出井，待输出设备空闲时，将输出井中的信息送到输出设备上。</li>
<li><strong>井管理程序</strong>负责管理输入井与输出井的协调工作。在进程执行过程中，如果请求启动某台设备的输入或者输出工作，操作系统得到该请求并调出井管理程序，控制从相应输入井读取信息或将信息送至输出井内。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/c747f7307395e01200a29d6255ee004a720d381ccad98d6470d0cee6bfc5ab3c.png" alt="图 35"></p>
<h5 id="共享打印机"><a class="anchor" href="#共享打印机">#</a> 共享打印机</h5>
<ul>
<li>为了实现打印机的虚拟共享，应创建一个特殊的守护进程以及一个特殊的目录 —— <code>SPOOLing</code>  目录。</li>
<li>当用户进程请求打印输出时， <code>SPOOLing</code>  系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程， 而只为它做两件事：
<ul>
<li>由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中。</li>
<li>输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中， 再将该表挂到请求打印队列上。</li>
</ul>
</li>
<li>实际上，当进程把该文件放到 <code>SPOOLing</code>  系统中之后就可以认为打印过程已经完成，虽然打印机还没有进行该文件的打印，因此 <code>SPOOLing</code>  也称为打印的 “假脱机” 过程。</li>
<li>而整个的打印作业由该守护进程进行处理，只有该守护进程能够真正使用打印机设备文件</li>
</ul>
<h5 id="spooling技术的特点"><a class="anchor" href="#spooling技术的特点">#</a> SPOOLing 技术的特点</h5>
<ul>
<li><strong>提高了 I/O 的速度</strong>，缓和了高速的处理器与低速输入输出设备之间的矛盾。</li>
<li><strong>将独占设备改造为共享设备</strong>，提高了设备的利用率。</li>
<li><strong>实现了虚拟设备功能</strong>，将物理的单个设备变换为多个对应的逻辑设备。</li>
</ul>
<h4 id="设备分配算法"><a class="anchor" href="#设备分配算法">#</a> 设备分配算法</h4>
<ul>
<li><strong>先来先服务算法</strong>。系统允许多个进程请求同一个设备，也允许一个进程请求多个设备。当有多个进程对同一设备提出 I/O 请求时，或者是在同一设备上进行多次 I/O 操作时，系统按照提出请求的先后顺序，将对应进程组织成一个设备请求队列。当设备空闲时，设备分配程序总是把此设备首先分配给队首进程</li>
<li><strong>优先级高者优先算法</strong>。首先对有 I/O 的进程按照其优先级的高低进行排列，高优先级进程排在设备队列前面，低优先级进程排在后面。当有一个新进程要加入设备请求队列中时，并不是简单地把它挂在队尾，而是根据进程的优先级插在适当的位置。这样就能保证在该设备空闲时，系统能从 I/O 请求队列的队首取下一个具有最高优先级进程，并将设备分配给它。</li>
</ul>
<h4 id="设备分配"><a class="anchor" href="#设备分配">#</a> 设备分配</h4>
<ul>
<li>当系统中已经具备了设备分配的数据结构，而且在设备分配总原则下确定了一定分配算法后，若某进程提出 I/O 请求，设备分配程序便可进行分配。</li>
<li>设备分配过程是逐步由抽象信息表格到具体物理设备的过程，首先使用了管理逻辑设备信息的系统设备表，继而查找设备控制表，然后通过设备控制器利用通道启动设备，传输信息。<br>
<img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/36ce34cabd7384a5260ea51114ed124354d799f0dd09401180a20dd2de4a8c25.png" alt="图 36"></li>
</ul>
<h4 id="设备回收"><a class="anchor" href="#设备回收">#</a> 设备回收</h4>
<ul>
<li>当某一作业（或进程）使用完设备后，则需 “释放设备”，设备回收过程是设备分配过程的逆过程。</li>
<li>回收时，要请求操作系统依次修改与设备有关的通道控制表、设备控制器控制表、设备控制表和系统设备表，主要是修改其中的状态信息，以使设备能够及时被下一个进程使用。</li>
</ul>
<h2 id="文件系统"><a class="anchor" href="#文件系统">#</a> 文件系统</h2>
<h3 id="文件系统概述"><a class="anchor" href="#文件系统概述">#</a> 文件系统概述</h3>
<h4 id="文件的概念"><a class="anchor" href="#文件的概念">#</a> 文件的概念</h4>
<ul>
<li>在计算机系统中，<strong>文件</strong>是指存储在外部存储介质上的、由文件名标识的一组相关信息的集合。</li>
</ul>
<h4 id="文件系统的概念"><a class="anchor" href="#文件系统的概念">#</a> 文件系统的概念</h4>
<ul>
<li>操作系统中负责管理和存取文件信息的软件机构叫做<strong>文件管理</strong></li>
<li>文件系统：操作系统中与文件管理有关的那部分软件和被管理的文件，以及实现管理所需要的一些数据结构的总体。</li>
<li>文件系统的功能
<ul>
<li>实现文件的 “按名存取” 功能。</li>
<li>实现能够快速定位文件的目录结构 ；考虑如何组织目录文件。</li>
<li>向用户提供一套使用方便、简单的操作命令。</li>
<li>管理磁盘、磁带等组成的文件存储器。</li>
<li>实现逻辑文件到物理文件的转换。</li>
<li>保证文件信息的安全可靠。</li>
<li>便于文件的共享。</li>
</ul>
</li>
<li>常用文件系统举例
<ul>
<li>EXT2：Linux 最为常用的文件系统，设计易于向后兼容，所以新版的文件系统代码无需改动就可以支持已有的文件系统。</li>
<li>NFS：网络文件系统，允许多台计算机之间共享文件系统，易于从网络中的计算机上存取文件。</li>
<li>HPFS：高性能文件系统，是 IBM OS/2 的文件系统。</li>
<li>FAT：经过了 MS-DOS，Windows 3.x，Windows 9x，Windows NT，Windows 2000/XP 和 OS/2 等操作系统的不断改进，它已经发展成为包含 FAT12，FAT16 和 FAT32 的庞大家族。</li>
<li>NTFS：NTFS 是微软为了配合 Windows NT 的推出而设计的文件系统，为系统提供了极大的安全性和可靠性。</li>
</ul>
</li>
</ul>
<h4 id="文件的属性"><a class="anchor" href="#文件的属性">#</a> 文件的属性</h4>
<ul>
<li>一个文件包括文件体和文件属性两个部分：文件体是一系列的记录或字符流，以物理块存放在外存上，也叫文件内容。文件属性是对文件进行说明的信息。</li>
<li>主要属性：
<ul>
<li><strong>文件名称</strong>：文件名称是供用户使用的外部标识，也是文件最基本的属性。</li>
<li><strong>文件物理位置</strong>：具体标明文件在存储介质上所存放的物理位置。</li>
<li><strong>文件拥有者</strong>：通常文件创建者对自己所建的文件拥有一切权限，而对其它用户所建的文件则拥有有限的权限。</li>
<li><strong>文件权限</strong>：通过文件权限，文件拥有者可以为自己的文件赋予各种权限，如可允许自己读写和执行，允许同组的用户读写，而只允许其它用户读。</li>
<li><strong>文件类型</strong>：可以从不同的角度来对文件进行分类，例如普通文件或是设备文件，可执行文件或是文本文件，等等。</li>
<li><strong>文件长度</strong>：长度单位通常是字节。</li>
<li><strong>文件时间</strong>：最初创建时间，最后一次的修改时间，最后一次的执行时间，最后一次的读时间等。</li>
</ul>
</li>
</ul>
<h4 id="文件的分类"><a class="anchor" href="#文件的分类">#</a> 文件的分类</h4>
<ul>
<li>为了有效、方便地组织和管理文件，常按照不同的观点对文件进行分类。常用的几种文件分类方法：
<ul>
<li>按照<strong>文件的逻辑结构的不同</strong>：流式文件和纪录式文件。</li>
<li>按照<strong>用途</strong>：系统文件、库文件和用户文件。</li>
<li>按照<strong>性质</strong>：可以把文件分为普通文件、目录文件和特殊文件。</li>
</ul>
</li>
</ul>
<h4 id="文件的使用"><a class="anchor" href="#文件的使用">#</a> 文件的使用</h4>
<ul>
<li>两类操作接口 ：
<ul>
<li>第一类是与文件有关的操作命令或作业控制语言中与文件有关的 JCL 语句</li>
<li>第二类是提供给用户程序使用的文件类系统调用</li>
</ul>
</li>
<li>主要的系统调用：
<ul>
<li>文件创建</li>
<li>文件删除</li>
<li>文件截断</li>
<li>文件读</li>
<li>文件写</li>
<li>文件的读写定位</li>
<li>文件打开</li>
<li>文件关闭</li>
</ul>
</li>
</ul>
<h3 id="文件的组织"><a class="anchor" href="#文件的组织">#</a> 文件的组织</h3>
<ul>
<li>存储介质：用来存储文件信息的载体，例如，磁带、磁盘和光盘等。</li>
<li>块：存储介质上连续信息所组成的一个区域，也叫做物理记录。
<ul>
<li>文件的内容及相关信息都是以 “块” 为单位存放在外存上的</li>
<li>外存物理空间的分配是以块为单位的。</li>
<li>块也是内存和外存进行信息交换的物理单位，每次总是交换一块或整数块信息。</li>
</ul>
</li>
<li>文件组织：文件中信息的配置和构造方式，同一个文件应该从两个侧面来观察它的文件组织方式：</li>
<li>文件的逻辑结构：从用户的观点出发观察到的文件组织形式，用户可以直接处理，独立于文件的物理特性。</li>
<li>文件的物理结构：逻辑文件在物理存储空间中存放方法和组织关系，又称文件的存储结构</li>
</ul>
<h4 id="文件的逻辑结构"><a class="anchor" href="#文件的逻辑结构">#</a> 文件的逻辑结构 😎</h4>
<h5 id="流式文件"><a class="anchor" href="#流式文件">#</a> 流式文件</h5>
<ul>
<li>流式文件：<strong>文件内的数据不组成记录，只是依次的一串信息集合</strong>，如字节流或字符流，它也可以看成是无结构的或只有一个记录的记录式文件，所以也称作<strong>无结构</strong>文件</li>
<li><strong>字节或字符</strong>是访问流式文件的基本单位，顺序存取时读 / 写指针每次步进 1 个字节或 1 个字符长度。</li>
<li>流式文件举例：<strong>源程序文件</strong>、<strong>可执行文件</strong>和<strong>库函数文件</strong>等</li>
<li>这些类型的文件并不需要分记录</li>
<li>没有结构并非意味着该类型的文件不能有结构，处理该文件的软件可以按照用户定义的结构来操作文件。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/99a2535d58e3c937941fa079b1b688c410a3e72a6d6bf7e07d7b74e635f14f8e.png" alt="图 37"></p>
<h5 id="记录式文件"><a class="anchor" href="#记录式文件">#</a> 记录式文件</h5>
<ul>
<li>记录式文件：<strong>一种有结构的文件，指文件中的数据由若干条定长或不定长的记录构成，每条记录又由若干数据项构成</strong>。</li>
<li><strong>记录</strong>是记录式文件进行存取的基本单位，顺序访问时文件读 / 写指针每次步进一条记录长度。</li>
<li>定长记录文件和不定长记录文件：记录式文件中的所有记录长度一般都相等，也可以不等</li>
<li>纪录式文件中记录之间的组织方式非常重要，设计时要综合考虑很多因素，例如，如何提高检索速度，如何便于记录的增删改等。</li>
</ul>
<h6 id="顺序文件"><a class="anchor" href="#顺序文件">#</a> 顺序文件</h6>
<ul>
<li>顺序文件：<strong>记录之间按某种顺序排列组织所形成的文件</strong></li>
<li>在顺序文件中的记录可以按照不同的顺序进行排列。
<ul>
<li>一种是按照存入的时间先后排序：各记录之间的顺序与记录的关键字或内容无关。（日志文件和各种现场记录文件等场合）；</li>
<li>一种是按照记录中的关键字排序。</li>
</ul>
</li>
<li>顺序文件的存取方式：
<ul>
<li><strong>顺序</strong>存取：只要在系统中分别设置读写指针 <code>Rptr</code>  和 <code>Wptr</code> ，读完或写完一条记录后修改该指针指向下一条记录。</li>
<li><strong>直接</strong>存取：也叫随机存取。主要适用于定长记录的顺序文件（任何记录的位置都很容易通过记录长度计算出来）。</li>
</ul>
</li>
<li>优点：
<ul>
<li>适合大量记录批量存取的场合，此时对顺序文件的存取效率是所有逻辑文件中最高的。</li>
<li>只有顺序文件才能被存储在磁带上</li>
</ul>
</li>
<li>缺点：
<ul>
<li>不适合交互系统中用户要求查找或修改单个记录的情况（但是给出记录位置查找定长记录除外）</li>
<li>增删记录比较困难，因为增加或删除记录后需要重新组织记录的顺序和关键字。</li>
</ul>
</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/d61194c798eb7325e9ec04524e16f47f94e7fabbd4887d1b201d8502ab04afed.png" alt="图 38"></p>
<h6 id="索引文件"><a class="anchor" href="#索引文件">#</a> 索引文件</h6>
<ul>
<li>索引文件：为变长记录的顺序文件再建立一张索引表，对主文件中的每个记录在索引表中都有相应的表项，用于记录该记录的长度以及指向该记录的指针。</li>
<li>索引文件可以根据不同的关键字建立索引，形成包含多个索引表的索引文件。</li>
<li>主要优点：
<ul>
<li>通过建立索引极大地提高了对文件的查找速度</li>
<li>对增加和删除记录也非常方便</li>
</ul>
</li>
<li>主要缺点：存储开销变大，增删记录时还需要修改索引表</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/c0dab39558d308cbc78301acdac50e96e72af0d0b40e3902c7c83ae722ce197f.png" alt="图 39"></p>
<h6 id="索引顺序文件"><a class="anchor" href="#索引顺序文件">#</a> 索引顺序文件</h6>
<ul>
<li><strong>将顺序文件中的多个记录组合成一组，并对每一组记录建立一个索引，通过索引指针指向该记录组中的第一条记录</strong></li>
<li>索引顺序文件是顺序文件和索引文件相结合的产物，结合两者的优点，同时又能有效克服变长记录文件的缺点，而且所付出的代价也小。</li>
<li>查找方法：首先也是利用用户（程序）所提供的关键字，以及某种查找算法去检索索引表，找到该记录所在记录组中第一个记录的表项，从中得到该记录组第一个记录在主文件中的位置。再利用顺序查找法去查找主文件，从中找到所要求的记录。</li>
<li>主要优点：索引表占用空间小，同时查找效率比顺序文件又高，因此在文件记录比较多时采用索引顺序文件比较适合。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/d851540571ea860b67237c6c8422552854818c6ff9c8cc476fca4caa4196558e.png" alt="图 40"></p>
<h4 id="记录的成组与分解"><a class="anchor" href="#记录的成组与分解">#</a> 记录的成组与分解</h4>
<ul>
<li><strong>逻辑记录</strong>：记录式文件的逻辑结构中的每条记录描述（用户看到的），按信息在逻辑上的独立含义划分的单位</li>
<li><strong>物理记录</strong>：即 “块”，存储介质上连续信息所组成的区域，文件的内容及相关信息都是以 “块” 为单位存放在外存上的（外存存放的单位）</li>
<li>当一个物理块包含多个逻辑记录时需要进行<strong>记录的成组和分解</strong></li>
<li><strong>记录的成组</strong>：若干个逻辑记录合并成一组，写入一个块。</li>
<li>每块中的逻辑记录的个数称<strong>块因子</strong>。</li>
<li>成组操作一般先在输出缓冲区内进行，凑满一块后才将缓冲区内的信息写到存储介质上。</li>
<li><strong>记录的分解</strong>：当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离出来的操作叫记录的分解。</li>
<li>文件被打开后，在主存中分配相应的输入输出缓冲区，用于成组和分解。由于容量有限，操作系统限定同时打开的文件个数，以防止文件缓冲区太多而挤占紧张的主存空间。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/7bc34367372096307bcfbc23da741e527134e8b45a19a2e699b19d0eaada2fce.png" alt="图 41"></p>
<h4 id="文件的物理结构"><a class="anchor" href="#文件的物理结构">#</a> 文件的物理结构 😎</h4>
<ul>
<li>文件的物理结构不仅取决于存储介质的存储特性，还与采用的外存分配方式有关。</li>
<li>考察文件的物理结构时应该把文件看作相关物理块的集合以及如何给文件分配所需要的物理块</li>
</ul>
<h5 id="连续文件"><a class="anchor" href="#连续文件">#</a> 连续文件</h5>
<ul>
<li><strong>把一个逻辑上连续的文件信息存放在依次相邻的物理块中的组织形式</strong>。</li>
<li>连续文件是基于磁带设备的最简单的物理结构，也适合其它各种外存设备。</li>
<li>文件物理地址的存储方式：目录项的 “文件物理地址” 字段中，记录该文件第一个记录所在的盘块号和文件长度（以盘块为单位）</li>
<li>优点：在顺序存取时速度较快，非常便于顺序访问。（因为只要在目录中找到顺序文件所在的第一个盘块号，就可以从此开始逐个盘块往下读写。）</li>
<li>应用场合：常用于存放系统文件，如操作系统文件、编译程序文件和其它由系统提供的实用程序文件，因为这类文件往往被从头至尾依次存取</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/6a82b7556fc3330b016f56cb380dc28a2db0696e3cb5f05de3fdc138f57481e5.png" alt="图 42"></p>
<h5 id="链接文件"><a class="anchor" href="#链接文件">#</a> 链接文件</h5>
<ul>
<li>非连续分配：<strong>把一个逻辑上连续的文件分散地存放在不同的物理块中，这些物理块既不要求连续，也不必按规则排列</strong>。</li>
<li>链接分配是非连续分配的一种。</li>
<li>链接文件（链接分配）：通过每个物理块上的链接指针将同属于一个文件的多个离散的盘块链结成一个链表的组织形式，实现了离散分配</li>
<li>优点：
<ul>
<li>能适应文件的动态增长</li>
<li>消除了磁盘的外部碎片</li>
<li>添加、删除和修改记录也更方便。</li>
</ul>
</li>
</ul>
<h6 id="隐式链接"><a class="anchor" href="#隐式链接">#</a> 隐式链接</h6>
<ul>
<li><strong>每个物理块自身存放下一物理块的链接指针</strong></li>
<li>目录项的 “物理地址” 字段中只要保存该文件的起始块号和结束块号的指针</li>
<li>主要缺点：
<ul>
<li>只适合于顺序访问，对随机访问是极其低效</li>
<li>每个物理块上增加了一个链接信息，为信息管理添加了一些麻烦。</li>
<li>通过链接指针将一大批离散的物理块链接起来，可靠性差，只要其中任何一个指针出现问题，都会导致整个文件信息丢失或出错。</li>
</ul>
</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/3fa3bb0f89af677a5d0d0d0a5b3e62344b261f06786b9d3aeb35ce0a67ef16b9.png" alt="图 43"></p>
<h6 id="显式链接"><a class="anchor" href="#显式链接">#</a> 显式链接</h6>
<ul>
<li><strong>把用于链接文件的各物理块指针显式地放在内存的一张表格中，表格的序号是物理块号</strong>，从 0 开始，直到 N-1，N 为整个磁盘的盘块的总数，表格的每个表项中存放链接指针即下一个盘块号。</li>
<li>该表格就是 FAT（12,16,36）文件系统中的 FAT 表</li>
<li>MS-DOS 和 windows 早中期操作系统一直采用的文件系统技术。</li>
<li>在文件的目录项的 “物理地址” 字段中只要保存该文件的起始块号</li>
<li>缺点
<ul>
<li>不支持高效的直接存取，对一个较大的文件进行存取时，须在 FAT 中顺序地查找许多盘块号；</li>
<li>FAT 表本身需要占用较大的内存空间</li>
</ul>
</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/6cd9ff64ecafab2bdb78def2a8532ace6604c2d1a75df3608eee6d8398920b54.png" alt="图 44"></p>
<h5 id="索引分配文件"><a class="anchor" href="#索引分配文件">#</a> 索引分配文件</h5>
<ul>
<li>索引分配结构：<strong>系统为每个文件建立一个索引表，集中记录该文件占用的盘块号</strong>。索引表可以直接存放在文件控制块 <code>FCB</code>  中，但是，大文件的索引表往往很大，所以大多数文件系统让索引表置于单独的物理块中且可驻留在磁盘的任意位置，文件控制块的 “物理地址” 字段只要保存该索引表所在的盘块号（即索引表地址）</li>
<li>无键索引表：索引表记录的是组成指定文件的磁盘块号，这种索引只是盘块号的序列，适用于流式文件；</li>
<li><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/6a70b0503a72b5f62db183198c536b9055e190be0656b204a10ea4b4d8d8d6be.png" alt="图 45"></li>
<li>有键索引表：该索引表的索引表项包含逻辑记录键及其磁盘块号，指出了每条逻辑记录在磁盘上的存放地址，即物理块号，适用于纪录式文件。</li>
<li><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/75a28d4a90b1f5383cb4c83c053ac352cd5b572d66e8808448578f90acead496.png" alt="图 46"></li>
<li>优点
<ul>
<li>实现了离散分配</li>
<li>有利于直接存取</li>
</ul>
</li>
<li>缺点
<ul>
<li>索引表增加了空间开销，</li>
<li>不适合中小型文件，对于中小型文件会有空间的浪费。因为往往一个盘块能存放数百个盘块号，但对于中小型文件，本身通常只占用数个到数十个盘块，甚至更少，但仍须为之分配以索引块。</li>
<li>索引表的查找增加了时间开销。</li>
</ul>
</li>
</ul>
<h5 id="多级索引文件"><a class="anchor" href="#多级索引文件">#</a> 多级索引文件</h5>
<ul>
<li>以上索引文件为一级索引文件：存放文件内容所占物理块号的盘块也称作一级索引块</li>
<li>一级索引存在的问题：当索引表本身占用许多物理块时，在查找某键对应的索引项时，可能依次需交换很多块。若索引表占用 n 块，则平均要交换 (n+1)／２次，才能找到所需记录的物理地址，当 n 很大时，这是很费时间的操作。</li>
<li>解决方法：为了提高大文件的查找速度，可以为这些一级索引块再建立一个索引，称为二级索引，即系统再分配一个盘块记录一级索引块的块号。</li>
<li>如果文件再大，还可以建立三级、四级索引，依次类推。</li>
<li>在 Unix 系统中，为了能兼顾到小、中、大以及特大型文件，采取了混合索引结构。</li>
<li>它在文件控制块的地址部分设置了 13 个地址项，即 <code>iaddr(0)</code> - <code>iaddr(12)</code> ，混合了四种寻址方式：直接寻址、一级索引寻址、二级索引寻址和三级索引寻址。</li>
<li><code>iaddr(0)</code> - <code>iaddr(9)</code>  存放了直接寻址指针，即该指针指向的盘块直接存放了该文件的数据内容，如果文件再大就可以用到第 11、12 和 13 个地址项（ <code>iaddr(10)</code> - <code>iaddr(12)</code> ），分别存放的是一级索引地址、二级索引地址和三级索引地址。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/8593b494853b59aff0b4ca4dac5571cfc730eca8e8904440467d134ca8d8e8b4.png" alt="图 47"></p>
<h5 id="直接文件"><a class="anchor" href="#直接文件">#</a> 直接文件</h5>
<ul>
<li><strong>利用哈希函数直接建立逻辑记录的关键字与其物理地址的对应关系的文件组织形式</strong>。</li>
<li>直接文件只能在直接存取的存储设备（如磁盘）上实现，并且主要用于记录式文件。</li>
<li>优点：
<ul>
<li>记录在介质上不需要按序存放，因为它能根据关键字直接计算出物理地址，所以最适合直接存取；</li>
<li>相对于索引文件，它不需索引，节省了索引存储空间和索引查找时间。</li>
</ul>
</li>
<li>适用场合：直接文件在不能采用顺序组织方法、次序较乱、又需在极短时间内存取的场合下极为适合，例如操作系统目录文件、实时处理文件、存储管理的页表查找、编译程序变量名表等采用直接文件特别有效。</li>
<li>主要缺点：需要解决冲突问题。因为地址的总数和关键字之间不存在一一对应关系。</li>
</ul>
<h4 id="文件的存取方法"><a class="anchor" href="#文件的存取方法">#</a> 文件的存取方法</h4>
<ul>
<li>存取方法：如何存储和检索文件数据的方法，它是操作系统为用户程序提供的使用文件的技术和手段。</li>
<li>存取方法和文件的逻辑结构、物理结构以及存储介质有密切的关系，许多操作系统都提供多种存取方法，而在一些文件处理密集的系统软件中，如数据库管理系统，文件存取的方法就更加丰富。</li>
<li>常用的方法：<strong>顺序存取</strong>，<strong>直接存取</strong>，<strong>按键存取</strong></li>
</ul>
<h4 id="文件存储空间管理"><a class="anchor" href="#文件存储空间管理">#</a> 文件存储空间管理</h4>
<ul>
<li>文件管理的主要功能之一是如何在外部存储介质上为创建或扩充文件而分配空间，为删除文件而回收空间以及对空闲空间的管理。</li>
<li>磁盘可以随机存取的特性非常适合文件系统的实现，因此磁盘是最常用的文件外部存储介质</li>
<li>文件存储空间管理主要涉及两个问题：
<ul>
<li>磁盘空间的分配</li>
<li>磁盘空闲空间的有效管理</li>
</ul>
</li>
</ul>
<h5 id="磁盘空间的分配"><a class="anchor" href="#磁盘空间的分配">#</a> 磁盘空间的分配</h5>
<h6 id="连续分配"><a class="anchor" href="#连续分配">#</a> 连续分配</h6>
<ul>
<li>文件被存放在外存空间连续存储区 (连续的物理块号) 中，在建立文件时，用户必须给出文件大小，然后，查找到能满足的连续存储区供使用，否则文件不能建立，用户进程必须等待。</li>
<li>优点：顺序访问时通常无需移动磁头，文件查找速度快，管理较为简单</li>
<li>缺点：为了获得足够大的连续存储区，需定时进行‘碎片’收集。因而，不适宜于文件频繁动态增长和收缩的情况，用户事先不知道文件长度也无法进行分配</li>
</ul>
<h6 id="非连续分配"><a class="anchor" href="#非连续分配">#</a> 非连续分配</h6>
<ul>
<li>非连续分配是指以物理块（扇区）为单位，按文件动态要求分配物理块，这些物理块不一定要连续，属于同一文件的块按文件记录的逻辑次序用链接指针连接或用索引表指示，即链接分配和索引分配。</li>
<li>优点：辅存空间管理效率高，便于文件动态增长和收缩，访问文件执行速度快，特别是以簇为单位的分配方法已被广泛使用。</li>
</ul>
<h5 id="磁盘空闲空间的管理"><a class="anchor" href="#磁盘空闲空间的管理">#</a> 磁盘空闲空间的管理</h5>
<h6 id="空闲区表法"><a class="anchor" href="#空闲区表法">#</a> 空闲区表法</h6>
<ul>
<li>系统为外存上的所有空闲块建立一张空闲区表，每个表项记录了一个空闲区，主要包括该空闲区的第一个空闲盘块号、该区的空闲盘块和状态等信息，再将所有的空闲区按其起始盘块号递增的次序排列。</li>
</ul>
<h6 id="空闲块链表法"><a class="anchor" href="#空闲块链表法">#</a> 空闲块链表法</h6>
<ul>
<li>空闲块链表法是将所有空闲块连接在一起，组成一个空闲块链表</li>
<li>空闲块链表的一个变种是空闲盘区链，将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）组成一个链表，也适合连续文件的组织形式。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/808411ee1a9a53a6cbbbe4e181e3075e756858214a54ee5ae0332a9fc26891c0.png" alt="图 48"></p>
<h6 id="位示图法"><a class="anchor" href="#位示图法">#</a> 位示图法</h6>
<ul>
<li>空闲空间表还可由位图或位矢量的方法来实现。<strong>每一个磁盘块由 1 位（bit）来表示</strong>。如果该磁盘块是空闲的，这个位就置 0；否则，就置 1</li>
</ul>
<h3 id="文件目录"><a class="anchor" href="#文件目录">#</a> 文件目录</h3>
<h4 id="文件目录的基本概念"><a class="anchor" href="#文件目录的基本概念">#</a> 文件目录的基本概念 😊</h4>
<h5 id="文件控制块"><a class="anchor" href="#文件控制块">#</a> 文件控制块</h5>
<ul>
<li>为了能对文件进行正确的存取，必须<strong>为文件设置用于描述和控制文件的数据结构</strong>，称之为文件控制块（File Control Block， <code>FCB</code> ）。</li>
<li>每当创建一个文件，系统都要为其建立一个 <code>FCB</code> ， <code>FCB</code>  和文件是一一对应的。每个文件有两部分组成：
<ul>
<li><code>FCB</code> （文件属性信息）</li>
<li>文件体（文件内容信息）</li>
</ul>
</li>
<li><code>FCB</code>  一般包括以下文件属性信息：
<ul>
<li><strong>有关文件存取控制的信息</strong>。</li>
<li><strong>有关文件结构的信息</strong>。文件的逻辑结构，如记录类型、记录个数、记录长度、成组因子数等。文件的物理结构，如文件所在设备名，文件物理结构类型，记录存放在外存的相对位置或文件第一块的物理块号，也可指出文件索引的存放位置等。</li>
<li><strong>有关文件使用的信息</strong>。已打开该文件的进程数，文件被修改的情况，文件最大和当前大小等。</li>
<li><strong>有关文件管理的信息</strong>。如文件建立日期、文件最近修改日期、文件访问日期、文件保留期限、记帐信息等</li>
</ul>
</li>
<li><code>FCB</code>  的重要作用：建立文件名与外存空间中的物理地址的对应关系，从而实现 “按名存取”。</li>
<li>主要过程：系统存取文件时，先找到其 <code>FCB</code> ，从 <code>FCB</code>  中再找到文件信息盘块号或首块物理位置等物理地址信息就能存取文件信息。</li>
</ul>
<h5 id="文件目录和目录文件"><a class="anchor" href="#文件目录和目录文件">#</a> 文件目录和目录文件</h5>
<ul>
<li>为了加快文件的查找速度，通常把 <code>FCB</code>  集中起来进行管理，文件控制块的有序集合称为文件目录，即一个文件控制块就是一个文件目录项。</li>
<li>文件目录也是以文件的形式保存在外存上的，这就形成了目录文件。</li>
<li>因此，文件目录的目录项有两种，一种是用于描述子目录（即目录文件）的 <code>FCB</code> ，一种是普通文件的 <code>FCB</code> 。</li>
<li>目录文件与普通文件不同之处：</li>
<li>目录文件永远不会空，它至少包含两个目录项
<ul>
<li>当前目录项 “.”</li>
<li>父目录项 “..”</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：要搜索到某个文件的外存物理地址，必须先从文件的最外层目录逐层搜索匹配比较。文件目录和 <code>FCB</code>  是现实 “按名存取” 的重要数据结构</p>
</blockquote>
<h4 id="目录文件的组织"><a class="anchor" href="#目录文件的组织">#</a> 目录文件的组织 😊</h4>
<h5 id="fcb线性表"><a class="anchor" href="#fcb线性表">#</a>  <code>FCB</code>  线性表</h5>
<ul>
<li>目录文件中直接存放该目录下所有文件和子目录的 <code>FCB</code>  信息，组成了一个 <code>FCB</code>  线性表，即每个目录项记录了该文件或子目录对应的完整 <code>FCB</code>  信息</li>
<li>缺点：这样组织 <code>FCB</code> ，当文件很多时，目录文件本身可能要占用大量的盘块数，使得目录检索的速度很慢。</li>
</ul>
<h5 id="索引节点"><a class="anchor" href="#索引节点">#</a> 索引节点</h5>
<ul>
<li>基本思想：在检索目录文件的过程中，其实只用到了文件名，仅当找到一个目录项（即其中的文件名与指定要查找的文件名相匹配）时，才需从该目录项中读出该文件的物理地址。而其他一些对该文件进行描述的信息，在检索目录时一概不用。显然，这些信息在检索目录时，不需要调入内存。</li>
<li><strong>索引节点</strong>：把<strong>文件目录项中的文件名和其它描述信息分开</strong>，后者单独组成定长的一个数据结构，称为索引节点（ <code>i-node</code>  或 <code>inode</code>  也称 i 节点）</li>
<li><strong>索引节点号</strong>：一个文件系统中的所有文件的索引节点都集中存放在外存上的索引节点区，并对每个索引节点进行编号（i 节点号）。</li>
<li><strong>文件目录项</strong>： 不再是完整的 <code>FCB</code> ，只要存放 14 个字节的文件名和 2 个字节的 i 节点号</li>
<li>优点：通过索引节点的组织方式大大提高了目录的检索速度</li>
<li>外存索引节点存在的问题：由于访问某一文件的过程中，会频繁地涉及到文件的索引节点，不断在内、外存之间引用它，系统消耗很大。</li>
<li>解决方法：<strong>内存（活动）索引节点表</strong>，正在被使用的索引节点信息保存到内存索引节点表。</li>
<li>在系统占用的内存区里专门开辟一张表（例如 100 个表目）每个表目称为一个<strong>内存活动 i 节点</strong>。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/2623ac5d07c5ab2c056e18db27bdd27fcfb8f335478e899a85a538d09fc5bcee.png" alt="图 49"></p>
<blockquote>
<p>检索文件的过程：检索文件时，先从目录文件中找到文件名匹配的目录项，在目录项中找到该文件的索引节点号，根据索引节点号就可以在索引节点区中找到该文件的索引节点，找到了 i 节点，就获得了它所对应的文件的一切必要属性信息。</p>
</blockquote>
<h5 id="哈希表组织"><a class="anchor" href="#哈希表组织">#</a> 哈希表组织</h5>
<ul>
<li>具体实现：目录文件每个目录项中存放一个块号，每个目录项都设一个序号（类似于数组下标），哈希函数以文件名作为自变量计算散列函数的值，以该值作为序号直接定位的目录文件中的目录项，然后在目录项中找到块号，该块号所指的块内就存放了该文件的 <code>FCB</code> 。</li>
<li>具有相同散列值的文件的 <code>FCB</code>  放在一个物理块内，如果相同散列值的文件数目超过一个物理块能存放 <code>FCB</code>  的数目就产生冲突，需要作溢出处理。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/bc08e2175d943e55b7149218ce5bd95017fe10503050ffb5e309acb054e5ca9e.png" alt="图 50"></p>
<blockquote>
<p>该方法可以大幅度地减少目录搜索时间。插入和删除目录项都很简单，只需要考虑两个目录项冲突的情况，即两个文件名返回的数值一样的情形。哈希表的主要难点是选择合适的哈希表长度与适当的哈希函数。</p>
</blockquote>
<h4 id="目录的结构"><a class="anchor" href="#目录的结构">#</a> 目录的结构</h4>
<h5 id="单级目录结构"><a class="anchor" href="#单级目录结构">#</a> 单级目录结构</h5>
<ul>
<li>整个文件系统中仅建立和维护一张总的目录表，系统中所有文件都在该表中占有一项。</li>
<li>优点：实现简单</li>
<li>缺点：
<ul>
<li>不允许文件重名。</li>
<li>文件查找速度慢。</li>
<li>不便于实现文件共享。单级目录结构只适合于单用户操作系统。</li>
</ul>
</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/776904e4cee9ce4527565619ee199d00cfe4bdd0eca51ca3d55effa008428860.png" alt="图 51"></p>
<h5 id="两级目录结构"><a class="anchor" href="#两级目录结构">#</a> 两级目录结构</h5>
<ul>
<li>二级目录可以解决文件重名，即把系统中的目录分为一个主目录（Master File Directory，MFD）和多个次目录（User File Directory，UFD）。</li>
<li>在多用户系统中，一般每个用户都拥有一个属于自己的次目录 UFD，而主目录 MFD 则存储着各个 UFD 的信息，标明各个 UFD 的名称、物理位置等。</li>
<li>当使用文件时，用户必须给出用户名和文件名。系统根据用户名在主目录中找到该用户目录，再根据文件名在用户目录中找到文件的物理地址。</li>
<li>优点：
<ul>
<li>提高了文件检索速度（用户名大大缩小了需要检索的文件数量）</li>
<li>部分地允许文件名重名。</li>
</ul>
</li>
<li>缺点：对同一用户，也不能有两个同名的文件存在，限制了共享；多个用户完全隔离开来不便于实现多个用户协同完成任务。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/939c90485fd239589022880e35d0504db025b44507a4a025c8b5ea24cc716a9c.png" alt="图 53"></p>
<h5 id="多级层次目录"><a class="anchor" href="#多级层次目录">#</a> 多级层次目录</h5>
<ul>
<li>多级层次目录（树形目录）可以明显地提高对目录的检索速度和文件系统的性能。</li>
<li>在多级层次目录结构中，有一个根目录和许多分目录，根目录是唯一的，每一级目录不但可以包含文件，而且还可以包含下一级的分目录，从而形成了树状目录结构</li>
<li>几个概念：
<ul>
<li>路径名（ <code>path name</code> ）</li>
<li>绝对路径（ <code>absolute path name</code> ）</li>
<li>当前目录（ <code>current directory</code> ）</li>
<li>相对路径名（ <code>relative path name</code> ）</li>
</ul>
</li>
<li>优点：
<ul>
<li>既可方便用户查找文件，又可以把不同类型和不同用途的文件分类。</li>
<li>允许文件重名。</li>
<li>利用多级层次结构关系，可以更方便地制定保护文件的存取权限</li>
</ul>
</li>
<li>缺点：不能直接支持文件或目录的共享，因为这种纯树型目录中每个文件只能有一个父目录</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/b4dda8c06a6a058065773cd7e898bf914efd0c851258b5ae95aac1fa698f7eb9.png" alt="图 54"></p>
<h5 id="图状目录结构"><a class="anchor" href="#图状目录结构">#</a> 图状目录结构</h5>
<ul>
<li>有向无环图目录结构：允许一个文件有多个父目录，不同的目录可以以相同或不同的文件名共享同一个文件，形成的目录结构图不会出现环（因为不支持目录共享）</li>
<li><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/f3a646fc894329f14f630d5dd73d7c9ca832bad61b453a3fb0037907de7eb57f.png" alt="图 55"></li>
<li>有环图目录结构：除了允许文件被共享，还支持目录被共享，则目录结构图中就有可能出现环</li>
<li><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/6e6ba091847f1a5d9a2867aefa2434d9526b8f9b78a1b5ee3c94c30c715f0ad3.png" alt="图 56"></li>
</ul>
<h4 id="目录的检索"><a class="anchor" href="#目录的检索">#</a> 目录的检索</h4>
<ul>
<li>在采用树形目录结构的文件系统中，要根据用户提供的文件路径名，从根目录或当前目录开始，逐级查找路径名中的各子目录名，用它们作为索引，逐层搜索各个目录文件，最后找到匹配的文件目录项</li>
</ul>
<h4 id="文件目录操作"><a class="anchor" href="#文件目录操作">#</a> 文件目录操作</h4>
<ul>
<li>创建目录：在外部存储介质中，创建一个目录文件以备存取文件属性信息。</li>
<li>删除目录：从外部存储介质中，删除一个目录文件。只有当目录为空时，才能删除。</li>
<li>改变目录：用户可利用改变目录的命令，通过指定目录的绝对或相对路径名，设置当前目录。</li>
<li>检索目录：首先，系统利用用户提供的文件名，对文件目录进行查询，以找到相应的属性信息；然后，根据这些属性信息，得出文件所在外部存储介质的物理位置；最后，如果需要，可启动磁盘驱动程序，将所需的文件数据读到内存中。</li>
<li>移动目录：允许文件或子目录在不同的父目录之间移动，文件或子目录经移动后，其文件的路径名将随之改变。</li>
<li>链接操作：通过链接操作，让指定文件具有多个父目录，从而实现文件共享。</li>
<li>打开目录：如要使用的目录不在内存中，则需要打开目录，从外存上读入相应的目录文件。</li>
<li>关闭目录：当所用目录使用结束后，应关闭目录以释放内存空间。</li>
</ul>
<h3 id="文件系统调用的实现"><a class="anchor" href="#文件系统调用的实现">#</a> 文件系统调用的实现</h3>
<h4 id="实现系统调用的相关数据结构"><a class="anchor" href="#实现系统调用的相关数据结构">#</a> 实现系统调用的相关数据结构</h4>
<h5 id="用户打开文件表"><a class="anchor" href="#用户打开文件表">#</a> 用户打开文件表</h5>
<ul>
<li>进程 PCB 结构中保留一个 <code>files_struct</code> ，称为用户打开文件表或文件描述符表。表项的序号是文件描述符 <code>fd</code> ，此登记项内登记系统打开文件表的一个入口指针 <code>fp</code> ，通过此系统打开文件表项连接到打开文件的活动 <code>inode</code></li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/0ec519cc98314470a3321145ab3585239e32c45a775de2d54fbd294b95677ead.png" alt="57"></p>
<h5 id="系统打开文件表"><a class="anchor" href="#系统打开文件表">#</a> 系统打开文件表</h5>
<ul>
<li>为解决多用户进程共享文件、父子进程共享文件而设置的系统数据结构 <code>file_struct</code> 。主存专门开辟最多登记 256 项的系统打开文件表区，当打开一个文件时，通过此表项把用户打开文件表的表项与文件活动 <code>inode</code>  连接起来，以实现数据的访问和信息共享</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/09eadbea3b6e1fcb87c36c2ca4dfe621cfd612e7a632ab35e9de666cbba89592.png" alt="图 58"></p>
<h5 id="活动索引节点表"><a class="anchor" href="#活动索引节点表">#</a> 活动索引节点表</h5>
<ul>
<li>由于文件的索引节点中保存的信息非常重要，当系统需要对文件进行各种操作时，都离不开文件系统的索引节点表中指出的文件属性信息。因此，在实现中也将被访问文件在磁盘中的索引节点复制到内存中，构成了活动索引节点表，从而使对文件的访问更加便利和快捷</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/870e1daf91657d8b363a5edacf1d098b1d9920b2298261d9d571c8d800236572.png" alt="图 59"></p>
<h5 id="内存各数据结构之间的关系"><a class="anchor" href="#内存各数据结构之间的关系">#</a> 内存各数据结构之间的关系</h5>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/871dd0a5fa51cb93250873c616a90bc5ec05c2404dbf7e254eb88bb2ef9910d7.png" alt="图 60"></p>
<h4 id="创建文件"><a class="anchor" href="#创建文件">#</a> 创建文件</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><ul>
<li><code>fd=create(“/home/zhao/file1.c”,0775)</code>  执行的具体过程：
<ul>
<li>为新文件 <code>file1.c</code>  分配磁盘 <code>inode</code>  和活动 <code>inode</code> ，并把 <code>inode</code>  号与文件分量名 <code>file1.c</code>  组成新的目录项，记录到该文件目录路径 <code>/home/zhao</code>  的目录文件中。显然，在这一过程中，需要执行目录检索程序。</li>
<li>在新文件所对应的活动 <code>inode</code>  中置初值，包括把存取权限 <code>i_mode</code>  置为 <code>0775</code> ，链接计数 <code>i_count</code>  置为 “1” 等。</li>
<li>为新文件分配用户打开文件表项和系统打开文件表项，置系统打开文件表项的初值，包括在 <code>f_flag</code>  中置 “写” 标志，读写位移 <code>f_offset</code>  清 0，等等；把用户打开文件表项、系统打开文件表项及 <code>file1.c</code>  所对应的活动 <code>inode</code>  用指针连接起来，最后，把文件描述符 <code>fd</code>  返回给调用者。</li>
</ul>
</li>
</ul>
<h4 id="文件的链接-解除链接和删除"><a class="anchor" href="#文件的链接-解除链接和删除">#</a> 文件的链接、解除链接和删除</h4>
<ul>
<li><code>link</code>  和 <code>unlink</code>
<ul>
<li><code>link</code> : 链接文件，实现文件共享， <code>i_nlink+1</code></li>
<li><code>unlink</code> ：删除文件或解除链接， <code>i_nlink-1</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：删除的任务是把指定文件从所在的目录文件中去除，删除时如果没有链接用户（即 <code>i_nlink</code>  为 “1”），还要把文件占用的存储空间释放。</p>
</blockquote>
<h4 id="打开文件"><a class="anchor" href="#打开文件">#</a> 打开文件</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><ul>
<li>打开：文件在使用之前必须先 “打开”，以建立进程与文件之间的联系，而文件描述符唯一地标识了这样一种连接，其任务是把文件的磁盘索引节点复制到主存的活动索引节点表中，同时建立一个独立的读写文件数据结构，即系统打开文件表的一个表项。</li>
<li>实现过程：
<ul>
<li>检查是否有其他进程已经打开该文件，如果有，则活动 <code>inode</code>  表中已有此文件的 <code>inode</code> ，只要把对应的活动 <code>inode</code>  中的 <code>i_count</code>  加 1， <code>i_count</code>  反映了通过不同的系统打开文件表项来共享同一活动 <code>inode</code>  的进程数目，它是以后执行文件关闭操作时，活动 <code>inode</code>  能否被释放的依据。</li>
<li>如果是第一次打开该文件，则检索目录，要求打开的文件应该是已经创建的文件，它应登记在文件目录中，否则会出错。在检索到指定文件之后，就把它的磁盘索引节点复制到活动索引节点表中。</li>
<li>根据参数 <code>flags</code>  所给出的打开方式与活动索引节点中在创建文件时所记录的文件访问权限相比较，如果非法，则这次打开失败。</li>
<li>当 “打开” 合法时，为文件分配用户打开文件表项和系统打开文件表项，并为表项设置初值。通过指针建立这些表项与活动索引节点间的联系。把文件描述符 <code>fd</code> （即用户打开文件表中相应文件表项的序号）返回给调用者。</li>
</ul>
</li>
</ul>
<h4 id="关闭文件"><a class="anchor" href="#关闭文件">#</a> 关闭文件</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><ul>
<li>关闭：活动索引节点表的大小受到容量的限制，这就要求用户一旦不再对文件进行操作时，应立即释放相应的活动索引节点，以便让其他进程使用</li>
<li>实现过程
<ul>
<li>根据 <code>fd</code>  找到用户打开文件表项，再找到系统打开文件表项。释放用户打开文件表项。</li>
<li>把对应系统打开文件表项中的 <code>f_count</code>  减 “1”，如果非 “0”，说明进程族（例如父子进程）中还有进程共享这一表项，不用释放此表项直接返回；否则释放表项，并找到与之连接的活动索引节点。</li>
<li>把活动索引节点中的 <code>i_count</code>  减 “1”，若不为 “0”，表明还有其他用户进程正在使用该文件，不用释放而直接返回，否则在把该活动索引节点中的内容复制回磁盘上的相应索引节点中后，释放该活动索引节点。</li>
</ul>
</li>
<li>关于 <code>f_count</code>  和 <code>i_count</code>  (实现动态共享)
<ul>
<li><code>f_count</code>  反映不同进程通过同一个系统打开文件表项共享一个文件的情况；</li>
<li><code>i_count</code>  反映不同进程通过不同系统打开文件表项共享一个文件的情况。</li>
<li>由于文件的读写位移指针是存放在系统打开文件表项中的，所以前者实现的是使用相同位移指针的动态共享文件方式，主要适合同一进程族中的进程之间，即父子进程之间共享文件；后者实现的是使用不同读写位移指针的动态共享文件方式。</li>
</ul>
</li>
</ul>
<h4 id="读文件"><a class="anchor" href="#读文件">#</a> 读文件</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> nr <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><ul>
<li>实现过程：首先根据 <code>f_flag</code>  中的信息，检查读操作合法性，如果读操作合法，按活动索引节点中 <code>i_addr</code>  指出的文件物理块存放地址，从文件的当前位移量 <code>f_offset</code>  处开始，读出所要求的字节数到块设备缓冲区中，然后再送到 <code>bufp</code>  指向的用户主存区中。</li>
</ul>
<h4 id="写文件"><a class="anchor" href="#写文件">#</a> 写文件</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> nw <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><ul>
<li>其中 <code>fd</code> 、 <code>count</code>  和 <code>nw</code>  的含义类似于 <code>read</code>  中的含义， <code>buf</code>  是信息传送的源地址，即把 <code>buf</code>  所指向的用户数据区中的信息写入文件中。</li>
</ul>
<h4 id="随机存取"><a class="anchor" href="#随机存取">#</a> 随机存取</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fe<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table></figure><ul>
<li>其中，当 <code>whence</code>  值为 0 时，则 <code>f_offset</code>  被置为参数 <code>offset</code>  的值；当 <code>whence</code>  值为 1 是，则 <code>f_offset</code>  被置为文件当前位置值加上 <code>offset</code>  的值</li>
<li>关于 <code>f_offset</code> : 在文件初次 “打开” 时，文件的位移量 <code>f_offset</code>  清空为 0，以后的文件读写操作总是根据 <code>offset</code>  的当前值来顺序地读写文件。</li>
<li>为了支持文件的随机访问，文件系统提供了系统调用 <code>lseek</code> ，允许用户在读写文件之前，事先改变 <code>f_offset</code>  的指向。</li>
</ul>
<h3 id="文件共享"><a class="anchor" href="#文件共享">#</a> 文件共享</h3>
<h4 id="静态共享"><a class="anchor" href="#静态共享">#</a> 静态共享</h4>
<ul>
<li>静态共享：文件或目录的共享关系不管用户是否正在使用系统都存在的共享方式。</li>
<li>文件链接：允许一个文件或目录有多个父目录，实际上仅有一处物理存储</li>
<li>静态共享主要有两种方式实现链接：一种是基于索引节点的方式，一般不适合目录共享，另一种是符号链接共享的方式，适合于文件也适合于目录</li>
</ul>
<h5 id="基于索引节点的链接共享"><a class="anchor" href="#基于索引节点的链接共享">#</a> 基于索引节点的链接共享</h5>
<ul>
<li>通过索引节点实现链接： 多个目录共享一个文件，只要把被共享文件的目录项指向同一个索引节点，即存放相同的索引节点号，被共享的文件可以同名，也可以不同名。</li>
<li>只适合文件共享</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/cd17921e1c4653e6eb6193d6e86eaef4cc706f14cc3098bbf7639e1130ae77c8.png" alt="图 61"></p>
<h5 id="符号链接共享"><a class="anchor" href="#符号链接共享">#</a> 符号链接共享</h5>
<ul>
<li>符号链接：只有原文件的目录项才拥有指向其索引结点的指针，而共享该文件的其他链接文件只有该文件的路径名，并不拥有指向其索引结点的指针，这个保存的路径名也称作符号，所以叫符号链接。</li>
<li>不但可以用于文件共享，也可用于目录共享</li>
<li>符号链接本身是一种只有文件名，不指向 <code>inode</code>  的文件，是一种 <code>link</code>  类型的特殊文件。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/78aeb7348b72971aef4c89739a195aa360894edb1ebebc9663288ce7bb8ab0f4.png" alt="图 62"></p>
<h4 id="动态共享"><a class="anchor" href="#动态共享">#</a> 动态共享</h4>
<ul>
<li>动态共享：就系统中不同的用户进程或同一用户的不同进程并发地访问同一文件。这种共享关系只有当用户进程存在时才可能出现，一旦用户的进程消亡，其共享关系也就自动消失。</li>
<li>用户打开文件表、系统打开文件表和内存活动索引节点表是实现动态文件共享的重要数据结构</li>
<li>根据是否共享读写位移指针，动态共享分为两种方式：共享位移指针的动态共享方式、不共享位移指针的动态共享方式</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/c55a1e533f5c92c81bf8249ea284b831447eeb9cbc535b099a272e54bd8f9726.png" alt="63"></p>
<h3 id="文件系统体系结构"><a class="anchor" href="#文件系统体系结构">#</a> 文件系统体系结构</h3>
<ul>
<li>文件系统的体系结构通常采用分层结构，有以下三部分组成:
<ul>
<li>文件管理层：实现文件的逻辑结构，为用户提供各种文件系统调用，及文件访问权限的设置等工作；</li>
<li>目录管理：负责查找文件描述符，进而找到需要访问的文件，并进行访问权限检查等工作；</li>
<li>磁盘主存映射管理：将文件的逻辑地址转换成磁盘的物理地址，即由逻辑块号找到柱面号、磁道号和扇区号，具体的数据传输操作由设备管理实现。</li>
</ul>
</li>
</ul>
<h4 id="文件系统的层次结构模型"><a class="anchor" href="#文件系统的层次结构模型">#</a> 文件系统的层次结构模型</h4>
<ul>
<li>文件系统接口层：主要用于接收用户对文件的操作命令或系统调用，根据用户对文件的存取要求将其转换为统一格式的文件系统内部调用。</li>
<li>文件目录管理层：根据文件名或文件路径名建立或搜索文件目录，获得文件内部标志和目录中的文件属性。从目录中的文件属性确定访问文件的用户身份，验证存取权限，判定本次文件操作的合法性，实现文件的存取、共享、保护。如果不允许当前用户访问，则发出操作失败信息。</li>
<li>基本文件系统层：根据文件内部标志将文件说明信息调入内存，即打开文件，为访问文件做准备。该层根据文件的逻辑结构和存取方法等信息，把指定的逻辑记录地址变换成相应的物理块地址。对于流式文件，只要把用户指定的逻辑地址按块长计算出相对块号；对纪录式文件，先把记录号转换成逻辑地址，再把逻辑地址转换成相对块号。</li>
<li>物理文件系统层：根据文件在内存中的物理结构信息，将相对块号和块内地址变换成文件存储器的物理块号和块内地址。</li>
<li>设备分配控制层：负责文件存储空间的分配，动态地为文件的写操作申请物理块，实现文件缓冲区的管理。该层根据申请的物理块号生成 I/O 控制系统的地址格式。</li>
<li>输入 / 输出接口层：执行 I/O 操作，为文件分配磁盘等物理介质空间，实现文件信息的存取，与设备管理功能相联系。</li>
</ul>
<p><img loading="lazy" data-src="https://blog.ivansnow02.xyz/blog-img/images/ComputerSystem/09ec42f164cf1ac8e729eaa2c52e2b287df4dab97ddff9adbe2e25642e0a837e.png" alt="图 64"></p>
<h4 id="文件操作的执行过程"><a class="anchor" href="#文件操作的执行过程">#</a> 文件操作的执行过程</h4>
<ul>
<li>根据上面文件系统的层次结构，以<strong>写一个文件</strong>为例简要说明文件写操作发出时，各层是如何工作和相互衔接的。
<ul>
<li>当用户写一个文件时，应用程序首先调用文件系统提供的接口，将写文件的请求转换为统一格式的文件系统内部调用。</li>
<li>文件系统管理根据写文件的文件名和文件路径读内存中相应的目录，修改并更新文件目录。</li>
<li>基本文件系统根据文件内部标志将文件说明信息放入内存，写入内存中的打开文件表，打开文件，为访问文件做准备。</li>
<li>物理文件系统根据写文件的结构和存取方法等逻辑结构信息，把指定的逻辑记录地址变换成相应的物理块地址。对于流式文件，只要把用户指定的逻辑地址按块长计算出相对块号；对记录式文件，先把记录号变换成逻辑地址，再把逻辑地址按块长计算出相对块号。</li>
<li>物理文件系统将相对块号和块内地址变换为文件存储器的物理块号和块内地址。</li>
<li>设备分配控制为文件的写操作申请物理块，实现文件缓冲区的管理。系统根据申请的物理块号生成 I/O 控制系统的地址格式。</li>
<li>输入 / 输出接口执行 I/O 操作，为文件分配磁盘等物理介质空间，并将对磁盘的请求信息传递给磁盘管理。</li>
</ul>
</li>
</ul>
<h4 id="虚拟文件系统"><a class="anchor" href="#虚拟文件系统">#</a> 虚拟文件系统</h4>
<ul>
<li>为了同时支持多种文件系统，不同的操作系统采用不同的技术方案提供了虚拟文件系统。</li>
<li>目标：
<ul>
<li>把多种文件系统纳入统一框架，不同的磁盘分区可包含不同的文件系统，对它们的使用和传统的单一文件系统并无区别；</li>
<li>用户可通过一组系统调用对不同的文件系统及文件进行操作，系统调用可以跨物理介质和跨文件系统执行，如从一个文件系统复制或移动数据到另一个文件系统中，即提供对不同文件系统透明的相互访问；</li>
<li>对网络文件提供完全的支持，访问远程节点上的文件应与访问本地节点的文件一致；</li>
<li>提供对特殊文件系统的支持</li>
</ul>
</li>
<li>虚拟文件系统也称虚拟文件系统系统开关（Virtual File System，VFS），它是内核的一个子系统，提供一个通用文件系统模型，概括所能见到的文件系统的常用功能和行为，处理一切与底层设备管理相关的细节，为应用程序提供标准接口。具体设计时在原有的具体文件系统层次结构上增加应用层、虚拟层和实现层。各层的功能如下：
<ul>
<li>应用层：VFS 模型源于 UNIX 文件系统，使得用户可以直接使用标准 UNIX 文件系统调用来操作文件，无须考虑具体文件系统的特性和物理存储介质，通过 VFS 访问文件系统，才使得不同文件系统之间的协作性和通用性成为可能。</li>
<li>虚拟层：在对具体文件系统的共同特性进行抽象的基础上，形成与具体文件系统的实现无关的虚拟层，并在其上定义与用户的一致性接口。</li>
<li>实现层：使用类似于开关表的技术进行具体文件系统的转接，实现各种文件系统的细节。</li>
</ul>
</li>
</ul>
<div class="tags"><a href="/tags/computer-science/" rel="tag"><i class="ic i-tag"></i>computer science</a><a href="/tags/learning/" rel="tag"><i class="ic i-tag"></i>learning</a></div></div><footer><div class="meta"><span class="icon"><i class="ic i-eye"></i></span><span>此文章已被阅读次数:</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/ComputerSystem/">正在加载...</span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2024-08-05 16:49:38" itemprop="dateModified" datetime="2024-08-05T16:49:38+08:00">2024-08-05</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>Ivan Snow<i class="ic i-at"><em>@</em></i>Snow's Blog</li><li class="link"><strong>本文链接：</strong><a href="https://blog.ivansnow02.xyz/ComputerSystem/" title="操作系统复习">https://blog.ivansnow02.xyz/ComputerSystem/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-organization/" rel="prev" itemprop="url" title="计算机组成原理复习" style="background-image: linear-gradient(to bottom right, #fed1e0, #e799ac);"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>computer science</span><h3>计算机组成原理复习</h3></a></div><div class="item right"><a href="/DataBaseLearning/" rel="next" itemprop="url" title="数据库系统概论概念整理" style="background-image: linear-gradient(to bottom right, #f2f4c1, #c0ac82);"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>computer science</span><h3>数据库系统概论概念整理</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text"> 概论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text"> 操作系统的定义和功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 操作系统的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 操作系统的功能 😊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 操作系统的特征 😎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.2.</span> <span class="toc-text"> 操作系统的发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text"> 操作系统的分类 😊</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 批处理操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 分时操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 实时操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 个人计算机操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 网络操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text"> 分布式操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.7.</span> <span class="toc-text"> 嵌入式操作系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text"> 操作系统的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 程序接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 操作接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text"> 操作系统的设计实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 操作系统设计与开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 操作系统的体系结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text"> 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text"> 程序的执行方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 程序的顺序执行 😊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 程序的并发执行与并行执行 😎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 进程概念的引入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text"> 进程的特征与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 进程的相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 进程状态及转换 😎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97pcb"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 进程控制块 PCB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 进程控制 😊</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">2.3.</span> <span class="toc-text"> 进程的互斥与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E5%92%8C%E5%8D%8F%E4%BD%9C"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 竞争和协作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%97%B6%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 与时间有关的错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 临界资源与临界区 😊</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E7%AE%A1%E7%90%86%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.3.3.1.</span> <span class="toc-text"> 软件方法管理临界区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.3.3.2.</span> <span class="toc-text"> 硬件方式管理临界区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text"> 进程同步机制 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.4.1.</span> <span class="toc-text"> 信号量机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.5.</span> <span class="toc-text"> 进程同步的经典问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.5.1.</span> <span class="toc-text"> 生产者 - 消费者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.5.2.</span> <span class="toc-text"> 读者 - 写者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.5.3.</span> <span class="toc-text"> 哲学家就餐问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.5.4.</span> <span class="toc-text"> 睡眠理发师问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.</span> <span class="toc-text"> 进程通信 😊</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 消息传递通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.1.1.</span> <span class="toc-text"> 直接通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.1.2.</span> <span class="toc-text"> 间接通信</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 共享内存通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.3.</span> <span class="toc-text"> 管道通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">2.5.</span> <span class="toc-text"> 进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 进程调度模型 😎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E9%80%89%E6%8B%A9%E8%AF%84%E4%BB%B7%E5%87%86%E5%88%99"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 调度算法选择 / 评价准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.3.</span> <span class="toc-text"> 调度算法 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1first-come-first-servedfcfs"><span class="toc-number">2.5.3.1.</span> <span class="toc-text"> 先来先服务（First-Come First-Served，FCFS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88shortest-job-firstsjf"><span class="toc-number">2.5.3.2.</span> <span class="toc-text"> 短作业优先（Shortest-Job-First，SJF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88shortest-remaining-time-firstsrtf"><span class="toc-number">2.5.3.3.</span> <span class="toc-text"> 最短剩余时间优先（Shortest Remaining Time First，SRTF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88highest-response-ratio-firsthrrf"><span class="toc-number">2.5.3.4.</span> <span class="toc-text"> 高响应比优先（Highest Response Ratio First，HRRF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E6%9D%83highest-priority-firsthpf"><span class="toc-number">2.5.3.5.</span> <span class="toc-text"> 优先权（Highest-Priority-First，HPF）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%ACround-ribonrr"><span class="toc-number">2.5.3.6.</span> <span class="toc-text"> 时间片轮转（Round-Ribon，RR）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97multilevel-feed-queuemfq"><span class="toc-number">2.5.3.7.</span> <span class="toc-text"> 多级反馈队列（Multilevel-Feed-Queue，MFQ）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9Acpu%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">2.5.4.</span> <span class="toc-text"> 多 CPU 系统中的调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A0%B8cpu%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">2.5.5.</span> <span class="toc-text"> 多核 CPU 中的调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text"> 死锁 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 死锁产生的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 死锁产生的必要条件 😎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="toc-number">2.6.3.</span> <span class="toc-text"> 死锁的避免 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.3.1.</span> <span class="toc-text"> 银行家调度算法 😎</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">2.6.4.</span> <span class="toc-text"> 检测与解除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.</span> <span class="toc-text"> 线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 线程的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 线程与进程的区别与联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.3.</span> <span class="toc-text"> 线程的三种模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.8.</span> <span class="toc-text"> 管程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E7%94%A8%E7%AE%A1%E7%A8%8B%E6%9D%A5%E8%A7%A3%E5%86%B3"><span class="toc-number">2.8.1.</span> <span class="toc-text"> 进程同步的几个经典问题，用管程来解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.8.1.1.</span> <span class="toc-text"> 管程解决生产者 - 消费者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">2.8.1.2.</span> <span class="toc-text"> 管程解决哲学家就餐问题的算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text"> 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text"> 内存管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 计算机存储系统的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 内存管理的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 计算机存储系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.3.1.</span> <span class="toc-text"> 处理器寄存器和高速缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.1.3.2.</span> <span class="toc-text"> 内存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.1.3.3.</span> <span class="toc-text"> 外存储器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 地址的表示与地址转换 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.4.1.</span> <span class="toc-text"> 物理地址空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.4.2.</span> <span class="toc-text"> 逻辑地址空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.4.3.</span> <span class="toc-text"> 地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.1.4.3.1.</span> <span class="toc-text"> 静态重定位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.1.4.3.2.</span> <span class="toc-text"> 动态重定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.5.</span> <span class="toc-text"> 覆盖与交换技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.5.1.</span> <span class="toc-text"> 覆盖技术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.5.2.</span> <span class="toc-text"> 交换技术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.1.5.3.</span> <span class="toc-text"> 覆盖技术和交换技术的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text"> 分区内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 单一连续内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">3.2.1.1.</span> <span class="toc-text"> 单一连续内存管理基本思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">3.2.1.2.</span> <span class="toc-text"> 单一连续内存管理内存的分配与回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.2.1.3.</span> <span class="toc-text"> 单一连续内存管理地址转换与内存保护</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.1.4.</span> <span class="toc-text"> 单一连续内存管理缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 固定分区内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">3.2.2.1.</span> <span class="toc-text"> 固定分区内存管理基本思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">3.2.2.2.</span> <span class="toc-text"> 固定分区内存管理分区的划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.2.2.3.</span> <span class="toc-text"> 固定分区的内存分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.2.2.4.</span> <span class="toc-text"> 固定分区的地址转换与内存保护</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.2.5.</span> <span class="toc-text"> 固定分区分配的优点和缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 可变分区内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">3.2.3.1.</span> <span class="toc-text"> 可变分区内存管理基本思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.2.</span> <span class="toc-text"> 可变分区的内存分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%85%88%E9%80%82%E5%BA%94%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.2.1.</span> <span class="toc-text"> 最先适应分配算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.2.2.</span> <span class="toc-text"> 循环首次适应分配算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E9%80%82%E5%BA%94%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.2.3.</span> <span class="toc-text"> 最优适应分配算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.2.4.</span> <span class="toc-text"> 最坏适应分配算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.2.5.</span> <span class="toc-text"> 快速适应算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">3.2.3.2.6.</span> <span class="toc-text"> 对比分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.2.3.3.</span> <span class="toc-text"> 可变分区的地址转换与内存保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text"> 页式内存管理 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 页式内存管理基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 页式存储管理的内存的分配与回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 页式存储管理的地址转换 😎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text"> 快表 😎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.3.5.</span> <span class="toc-text"> 页的共享和保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.3.6.</span> <span class="toc-text"> 多级页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text"> 段式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 段式存储管理的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 段式存储管理的地址转换和内存保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="toc-number">3.4.3.</span> <span class="toc-text"> 段的共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.4.4.</span> <span class="toc-text"> 分段和分页的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.5.</span> <span class="toc-text"> 段页式存储管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">3.5.</span> <span class="toc-text"> 虚拟存储技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.1.</span> <span class="toc-text"> 程序局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">3.5.2.</span> <span class="toc-text"> 虚拟存储技术的基本思想 😎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text"> 请求分页虚拟存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.1.</span> <span class="toc-text"> 请求分页虚拟存储管理的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">3.6.2.</span> <span class="toc-text"> 请求分页虚拟存储管理的硬件支持</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%9A%84%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.6.2.1.</span> <span class="toc-text"> 请求分页的页表机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-number">3.6.2.2.</span> <span class="toc-text"> 缺页中断机构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">3.6.2.3.</span> <span class="toc-text"> 地址转换机构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.3.</span> <span class="toc-text"> 页面分配策略与页面调度算法 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.3.1.</span> <span class="toc-text"> 页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.3.1.1.</span> <span class="toc-text"> 固定分配方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.3.1.2.</span> <span class="toc-text"> 可变分配方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E7%89%A9%E7%90%86%E5%9D%97%E6%95%B0"><span class="toc-number">3.6.3.1.3.</span> <span class="toc-text"> 进程的最小物理块数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%85%A5%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.3.2.</span> <span class="toc-text"> 页面调入策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A1%B5%E8%B0%83%E5%85%A5"><span class="toc-number">3.6.3.2.1.</span> <span class="toc-text"> 请求页调入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A2%84%E5%85%88%E9%A1%B5%E8%B0%83%E5%85%A5"><span class="toc-number">3.6.3.2.2.</span> <span class="toc-text"> 预先页调入</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.3.3.</span> <span class="toc-text"> 页面置换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.6.3.3.1.</span> <span class="toc-text"> 全局置换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.6.3.3.2.</span> <span class="toc-text"> 局部置换</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E4%B8%8E%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">3.6.3.4.</span> <span class="toc-text"> 页面置换与页面分配的关联</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.6.3.4.1.</span> <span class="toc-text"> 固定分配局部置换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.6.3.4.2.</span> <span class="toc-text"> 可变分配全局置换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.6.3.4.3.</span> <span class="toc-text"> 可变分配局部置换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.4.</span> <span class="toc-text"> 页面置换算法 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87"><span class="toc-number">3.6.4.1.</span> <span class="toc-text"> 缺页率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BAfifo%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.4.2.</span> <span class="toc-text"> 先进先出（FIFO）页面置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3opt%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.4.3.</span> <span class="toc-text"> 最佳（OPT）页面置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8lru%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.4.4.</span> <span class="toc-text"> 最近最少使用（LRU）页面置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%92%9Fclock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.4.5.</span> <span class="toc-text"> 时钟（clock）置换算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E8%AF%B7%E6%B1%82%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">3.6.5.</span> <span class="toc-text"> 影响请求页式存储管理性能的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%BB%99%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E6%95%B0%E4%B8%8E%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.6.5.1.</span> <span class="toc-text"> 分配给进程的内存块数与缺页率的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E5%AF%B9%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.6.5.2.</span> <span class="toc-text"> 页面大小对系统性能的影响</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87%E5%AF%B9%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.6.5.3.</span> <span class="toc-text"> 缺页率对系统性能的影响</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.7.</span> <span class="toc-text"> 请求分段虚拟存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.1.</span> <span class="toc-text"> 请求分段虚拟存储管理的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.7.2.</span> <span class="toc-text"> 请求分段虚拟存储管理的段的共享和保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.7.3.</span> <span class="toc-text"> 请求段页式虚拟存储管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text"> 设备管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 设备管理的逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 设备控制器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text"> 设备控制方法 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 程序循环查询方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 中断驱动方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 直接内存访问方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text"> 通道方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.4.1.</span> <span class="toc-text"> 通道分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.4.2.</span> <span class="toc-text"> 通道工作方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF"><span class="toc-number">4.3.</span> <span class="toc-text"> 缓冲技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 缓冲技术的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 缓冲的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">4.3.2.1.</span> <span class="toc-text"> 单缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">4.3.2.2.</span> <span class="toc-text"> 双缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BC%93%E5%86%B2"><span class="toc-number">4.3.2.3.</span> <span class="toc-text"> 多缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2"><span class="toc-number">4.3.2.3.1.</span> <span class="toc-text"> 循环缓冲</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">4.3.2.3.2.</span> <span class="toc-text"> 缓冲池</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text"> 输入输出软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 中断处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 设备驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.2.1.</span> <span class="toc-text"> 设备驱动程序的处理过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.2.2.</span> <span class="toc-text"> 设备驱动程序的特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 设备独立性程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.4.4.</span> <span class="toc-text"> 用户层软件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">4.5.</span> <span class="toc-text"> 设备分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text"> 设备信息描述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8sdt"><span class="toc-number">4.5.1.1.</span> <span class="toc-text"> 系统设备表 SDT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8dct"><span class="toc-number">4.5.1.2.</span> <span class="toc-text"> 设备控制表 DCT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8coct"><span class="toc-number">4.5.1.3.</span> <span class="toc-text"> 控制器控制表 COCT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8chct"><span class="toc-number">4.5.1.4.</span> <span class="toc-text"> 通道控制表 CHCT</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">4.5.2.</span> <span class="toc-text"> 设备分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spooling%E6%8A%80%E6%9C%AF"><span class="toc-number">4.5.3.</span> <span class="toc-text"> SPOOLing 技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#spooling%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">4.5.3.1.</span> <span class="toc-text"> SPOOLing 系统的组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%89%93%E5%8D%B0%E6%9C%BA"><span class="toc-number">4.5.3.2.</span> <span class="toc-text"> 共享打印机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#spooling%E6%8A%80%E6%9C%AF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.5.3.3.</span> <span class="toc-text"> SPOOLing 技术的特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.4.</span> <span class="toc-text"> 设备分配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="toc-number">4.5.5.</span> <span class="toc-text"> 设备分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%9B%9E%E6%94%B6"><span class="toc-number">4.5.6.</span> <span class="toc-text"> 设备回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text"> 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text"> 文件系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 文件的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 文件系统的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.3.</span> <span class="toc-text"> 文件的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.4.</span> <span class="toc-text"> 文件的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.5.</span> <span class="toc-text"> 文件的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.2.</span> <span class="toc-text"> 文件的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 文件的逻辑结构 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.1.1.</span> <span class="toc-text"> 流式文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.1.2.</span> <span class="toc-text"> 记录式文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.1.2.1.</span> <span class="toc-text"> 顺序文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.1.2.2.</span> <span class="toc-text"> 索引文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.1.2.3.</span> <span class="toc-text"> 索引顺序文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E6%88%90%E7%BB%84%E4%B8%8E%E5%88%86%E8%A7%A3"><span class="toc-number">5.2.2.</span> <span class="toc-text"> 记录的成组与分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.</span> <span class="toc-text"> 文件的物理结构 😎</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.1.</span> <span class="toc-text"> 连续文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.2.</span> <span class="toc-text"> 链接文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.3.2.1.</span> <span class="toc-text"> 隐式链接</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.3.2.2.</span> <span class="toc-text"> 显式链接</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.3.</span> <span class="toc-text"> 索引分配文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.4.</span> <span class="toc-text"> 多级索引文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.5.</span> <span class="toc-text"> 直接文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.4.</span> <span class="toc-text"> 文件的存取方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.5.</span> <span class="toc-text"> 文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-number">5.2.5.1.</span> <span class="toc-text"> 磁盘空间的分配</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">5.2.5.1.1.</span> <span class="toc-text"> 连续分配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">5.2.5.1.2.</span> <span class="toc-text"> 非连续分配</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.5.2.</span> <span class="toc-text"> 磁盘空闲空间的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E5%8C%BA%E8%A1%A8%E6%B3%95"><span class="toc-number">5.2.5.2.1.</span> <span class="toc-text"> 空闲区表法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">5.2.5.2.2.</span> <span class="toc-text"> 空闲块链表法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95"><span class="toc-number">5.2.5.2.3.</span> <span class="toc-text"> 位示图法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">5.3.</span> <span class="toc-text"> 文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 文件目录的基本概念 😊</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">5.3.1.1.</span> <span class="toc-text"> 文件控制块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%92%8C%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6"><span class="toc-number">5.3.1.2.</span> <span class="toc-text"> 文件目录和目录文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 目录文件的组织 😊</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fcb%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">  FCB  线性表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">5.3.2.2.</span> <span class="toc-text"> 索引节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%84%E7%BB%87"><span class="toc-number">5.3.2.3.</span> <span class="toc-text"> 哈希表组织</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.3.</span> <span class="toc-text"> 目录的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.3.1.</span> <span class="toc-text"> 单级目录结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.3.2.</span> <span class="toc-text"> 两级目录结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%9B%AE%E5%BD%95"><span class="toc-number">5.3.3.3.</span> <span class="toc-text"> 多级层次目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%8A%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.3.4.</span> <span class="toc-text"> 图状目录结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E7%B4%A2"><span class="toc-number">5.3.4.</span> <span class="toc-text"> 目录的检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.5.</span> <span class="toc-text"> 文件目录操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.</span> <span class="toc-text"> 文件系统调用的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 实现系统调用的相关数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8"><span class="toc-number">5.4.1.1.</span> <span class="toc-text"> 用户打开文件表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8"><span class="toc-number">5.4.1.2.</span> <span class="toc-text"> 系统打开文件表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E8%A1%A8"><span class="toc-number">5.4.1.3.</span> <span class="toc-text"> 活动索引节点表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%90%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.1.4.</span> <span class="toc-text"> 内存各数据结构之间的关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">5.4.2.</span> <span class="toc-text"> 创建文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%93%BE%E6%8E%A5-%E8%A7%A3%E9%99%A4%E9%93%BE%E6%8E%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">5.4.3.</span> <span class="toc-text"> 文件的链接、解除链接和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">5.4.4.</span> <span class="toc-text"> 打开文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">5.4.5.</span> <span class="toc-text"> 关闭文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">5.4.6.</span> <span class="toc-text"> 读文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">5.4.7.</span> <span class="toc-text"> 写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96"><span class="toc-number">5.4.8.</span> <span class="toc-text"> 随机存取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">5.5.</span> <span class="toc-text"> 文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%85%B1%E4%BA%AB"><span class="toc-number">5.5.1.</span> <span class="toc-text"> 静态共享</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB"><span class="toc-number">5.5.1.1.</span> <span class="toc-text"> 基于索引节点的链接共享</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB"><span class="toc-number">5.5.1.2.</span> <span class="toc-text"> 符号链接共享</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%85%B1%E4%BA%AB"><span class="toc-number">5.5.2.</span> <span class="toc-text"> 动态共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.</span> <span class="toc-text"> 文件系统体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.6.1.</span> <span class="toc-text"> 文件系统的层次结构模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.6.2.</span> <span class="toc-text"> 文件操作的执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.6.3.</span> <span class="toc-text"> 虚拟文件系统</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-organization/" rel="bookmark" title="计算机组成原理复习">计算机组成原理复习</a></li><li class="active"><a href="/ComputerSystem/" rel="bookmark" title="操作系统复习">操作系统复习</a></li><li><a href="/DataBaseLearning/" rel="bookmark" title="数据库系统概论概念整理">数据库系统概论概念整理</a></li><li><a href="/sql-lab/" rel="bookmark" title="SQL代码复习">SQL代码复习</a></li><li><a href="/computer-network/" rel="bookmark" title="计算机网络">计算机网络</a></li><li><a href="/ai-fundamental/" rel="bookmark" title="人工智能基础">人工智能基础</a></li><li><a href="/Compilers/" rel="bookmark" title="编译技术笔记">编译技术笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="Ivan Snow" src="/img/avatar.webp"><p class="name" itemprop="name">Ivan Snow</p><div class="description" itemprop="description">some notes about computer science</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">47</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">22</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/ivansnow02" class="item github" title="https://github.com/ivansnow02"><i class="ic i-github"></i></a><a href="mailto:eone2017@protonmail.com" class="item email" title="mailto:eone2017@protonmail.com"><i class="ic i-envelope"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/links/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/DataBaseLearning/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-organization/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/algorithms/" title="分类于algorithms">algorithms</a></div><span><a href="/AlgorithmIntroduction/">算法导论笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Redis/" title="分类于Redis">Redis</a></div><span><a href="/Redis-Learning-01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Redis的数据类型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/data-structure/" title="分类于data structure">data structure</a></div><span><a href="/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%916-28/">哈夫曼树叶子结点的路径长度与权值的乘积之和</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/data-structure/" title="分类于data structure">data structure</a></div><span><a href="/DataStructureTest02/">数据结构题目02</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/data-structure/" title="分类于data structure">data structure</a></div><span><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0/">数据结构函数复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/data-structure/" title="分类于data structure">data structure</a></div><span><a href="/SPT/">最短路径 Shortest Path</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/trash/" title="分类于trash">trash</a></div><span><a href="/%E4%B9%A0%E8%BF%91%E5%B9%B3%E5%A4%8D%E4%B9%A0/">习近平复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Physics/" title="分类于Physics">Physics</a></div><span><a href="/%E7%89%A9%E7%90%86%E5%A4%8D%E4%B9%A0/">物理复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于computer science">computer science</a></div><span><a href="/computer-network/">计算机网络</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Redis/" title="分类于Redis">Redis</a></div><span><a href="/Redis-Learning-02-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Redis的快速入门</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright">© 2023 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">Ivan Snow @ Code Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">666k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">10:06</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> &amp; Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div><script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script><div id="busuanzi-wrap"><span class="ic i-eye"></span><span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span> | <span class="ic i-user"></span><span id="busuanzi_container_site_uv">本站访客量 <span id="busuanzi_value_site_uv"></span> 次</span></div></div></footer></div><script data-config="" type="text/javascript">var LOCAL = {
    ispost: true,
        path: `ComputerSystem/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: true,
    katex: true,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="undefined/undefined" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0&amp;features=default,fetch" defer=""></script><script src="/js/siteInit.js?v=0.4.14" type="module" fetchpriority="high" defer=""></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script>
    Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/';
  </script>
</body></html>